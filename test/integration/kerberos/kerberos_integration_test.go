//go:build kerberos

// Package kerberos_test provides integration tests for RPCSEC_GSS with a real MIT KDC.
//
// These tests start a MIT Kerberos KDC in Docker, create a realm with real principals,
// and exercise the full RPCSEC_GSS lifecycle (INIT -> DATA -> DESTROY) using real
// Kerberos tokens generated by gokrb5.
//
// Run with: go test -tags=kerberos -v -timeout 5m ./test/integration/kerberos/
// Requires: Docker
package kerberos_test

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"net"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"
	"testing"
	"time"

	"github.com/jcmturner/gokrb5/v8/client"
	krb5config "github.com/jcmturner/gokrb5/v8/config"
	"github.com/jcmturner/gokrb5/v8/crypto"
	"github.com/jcmturner/gokrb5/v8/gssapi"
	"github.com/jcmturner/gokrb5/v8/messages"
	"github.com/jcmturner/gokrb5/v8/types"

	"github.com/marmos91/dittofs/internal/protocol/nfs/rpc/gss"
	"github.com/marmos91/dittofs/pkg/auth/kerberos"
	dconfig "github.com/marmos91/dittofs/pkg/config"
)

const (
	containerName = "dittofs-kdc-test"
	imageName     = "dittofs-kdc-test"
	realm         = "DITTOFS.TEST"
	testUser      = "testuser"
	testPass      = "testpass"
	spnShort      = "nfs/localhost"
	spnFull       = "nfs/localhost@DITTOFS.TEST"
)

// TestRealKDC tests the full RPCSEC_GSS lifecycle with a real MIT KDC in Docker.
func TestRealKDC(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping KDC integration test in short mode")
	}
	if _, err := exec.LookPath("docker"); err != nil {
		t.Skip("docker not found, skipping KDC integration test")
	}

	// Setup KDC in Docker (builds image, starts container, creates principals)
	kdcPort, keytabPath, krb5ConfPath, cleanup := setupKDC(t)
	defer cleanup()

	t.Run("krb5_auth_only_lifecycle", func(t *testing.T) {
		provider, proc := createGSSStack(t, keytabPath, krb5ConfPath)
		defer provider.Close()
		defer proc.Stop()

		// Get real AP-REQ token from the KDC
		gssToken, _ := getRealAPREQ(t, krb5ConfPath, kdcPort)

		// === RPCSEC_GSS_INIT ===
		initCred := encodeCredOrFatal(t, &gss.RPCGSSCredV1{
			GSSProc: gss.RPCGSSInit,
			SeqNum:  0,
			Service: gss.RPCGSSSvcNone,
		})
		initResult := proc.Process(initCred, nil, gssToken)
		if initResult.Err != nil {
			t.Fatalf("INIT failed: %v", initResult.Err)
		}
		if !initResult.IsControl {
			t.Fatal("expected control message for INIT")
		}
		handle, gssMajor := decodeInitRes(t, initResult.GSSReply)
		if gssMajor != gss.GSSComplete {
			t.Fatalf("INIT gss_major=%d, expected GSSComplete (0)", gssMajor)
		}
		t.Logf("INIT succeeded: handle=%x", handle)

		// === RPCSEC_GSS_DATA (auth-only) ===
		procArgs := []byte("GETATTR request args")
		dataCred := encodeCredOrFatal(t, &gss.RPCGSSCredV1{
			GSSProc: gss.RPCGSSData,
			SeqNum:  1,
			Service: gss.RPCGSSSvcNone,
			Handle:  handle,
		})
		dataResult := proc.Process(dataCred, nil, procArgs)
		if dataResult.Err != nil {
			t.Fatalf("DATA failed: %v", dataResult.Err)
		}
		if dataResult.Identity == nil {
			t.Fatal("no identity returned for DATA")
		}
		if !bytes.Equal(dataResult.ProcessedData, procArgs) {
			t.Errorf("data mismatch: got %q, want %q", dataResult.ProcessedData, procArgs)
		}
		t.Logf("DATA authenticated: %s@%s (UID=%d, GID=%d)",
			dataResult.Identity.Username, dataResult.Identity.Domain,
			*dataResult.Identity.UID, *dataResult.Identity.GID)

		// Verify static identity mapping
		if dataResult.Identity.Username != testUser {
			t.Errorf("username: got %q, want %q", dataResult.Identity.Username, testUser)
		}
		if *dataResult.Identity.UID != 1000 {
			t.Errorf("UID: got %d, want 1000", *dataResult.Identity.UID)
		}
		if *dataResult.Identity.GID != 1000 {
			t.Errorf("GID: got %d, want 1000", *dataResult.Identity.GID)
		}

		// === Replay Detection ===
		t.Log("Testing replay detection...")
		replayCred := encodeCredOrFatal(t, &gss.RPCGSSCredV1{
			GSSProc: gss.RPCGSSData,
			SeqNum:  1, // Same seq_num as above â€” must be rejected
			Service: gss.RPCGSSSvcNone,
			Handle:  handle,
		})
		replayResult := proc.Process(replayCred, nil, procArgs)
		if !replayResult.SilentDiscard {
			t.Error("expected silent discard for replay, got normal result")
		}
		t.Log("Replay correctly rejected (silent discard)")

		// === Second DATA with new seq_num ===
		dataCred2 := encodeCredOrFatal(t, &gss.RPCGSSCredV1{
			GSSProc: gss.RPCGSSData,
			SeqNum:  2,
			Service: gss.RPCGSSSvcNone,
			Handle:  handle,
		})
		dataResult2 := proc.Process(dataCred2, nil, []byte("second request"))
		if dataResult2.Err != nil {
			t.Fatalf("second DATA failed: %v", dataResult2.Err)
		}
		t.Log("Second DATA with seq_num=2 succeeded")

		// === RPCSEC_GSS_DESTROY ===
		destroyCred := encodeCredOrFatal(t, &gss.RPCGSSCredV1{
			GSSProc: gss.RPCGSSDestroy,
			SeqNum:  3,
			Service: gss.RPCGSSSvcNone,
			Handle:  handle,
		})
		destroyResult := proc.Process(destroyCred, nil, nil)
		if destroyResult.Err != nil {
			t.Fatalf("DESTROY failed: %v", destroyResult.Err)
		}
		if proc.ContextCount() != 0 {
			t.Errorf("expected 0 contexts after DESTROY, got %d", proc.ContextCount())
		}
		t.Log("DESTROY succeeded, context removed")

		// === Stale handle rejection ===
		staleCred := encodeCredOrFatal(t, &gss.RPCGSSCredV1{
			GSSProc: gss.RPCGSSData,
			SeqNum:  4,
			Service: gss.RPCGSSSvcNone,
			Handle:  handle,
		})
		staleResult := proc.Process(staleCred, nil, procArgs)
		if staleResult.Err == nil {
			t.Fatal("expected error for stale handle")
		}
		t.Logf("Stale handle correctly rejected: %v", staleResult.Err)
	})

	t.Run("krb5i_integrity", func(t *testing.T) {
		provider, proc := createGSSStack(t, keytabPath, krb5ConfPath)
		defer provider.Close()
		defer proc.Stop()

		// Each subtest needs its own AP-REQ (ticket is one-time-use for replay protection)
		gssToken, clientSessionKey := getRealAPREQ(t, krb5ConfPath, kdcPort)

		// INIT with integrity service
		initCred := encodeCredOrFatal(t, &gss.RPCGSSCredV1{
			GSSProc: gss.RPCGSSInit,
			SeqNum:  0,
			Service: gss.RPCGSSSvcIntegrity,
		})
		initResult := proc.Process(initCred, nil, gssToken)
		if initResult.Err != nil {
			t.Fatalf("INIT failed: %v", initResult.Err)
		}
		handle, _ := decodeInitRes(t, initResult.GSSReply)
		t.Logf("krb5i INIT succeeded: handle=%x", handle)

		// Build integrity-wrapped DATA request body (as client/initiator)
		procArgs := []byte("READDIR args with integrity protection")
		seqNum := uint32(1)
		integrityBody := wrapIntegrityAsInitiator(t, clientSessionKey, seqNum, procArgs)

		dataCred := encodeCredOrFatal(t, &gss.RPCGSSCredV1{
			GSSProc: gss.RPCGSSData,
			SeqNum:  seqNum,
			Service: gss.RPCGSSSvcIntegrity,
			Handle:  handle,
		})
		dataResult := proc.Process(dataCred, nil, integrityBody)
		if dataResult.Err != nil {
			t.Fatalf("krb5i DATA failed: %v", dataResult.Err)
		}
		if !bytes.Equal(dataResult.ProcessedData, procArgs) {
			t.Errorf("unwrapped data mismatch: got %q, want %q", dataResult.ProcessedData, procArgs)
		}
		t.Log("krb5i integrity verification passed with real Kerberos session key")

		// Verify reply wrapping works (server -> client direction)
		replyBody := []byte("READDIR response data")
		wrappedReply, err := gss.WrapIntegrity(dataResult.SessionKey, dataResult.SeqNum, replyBody)
		if err != nil {
			t.Fatalf("WrapIntegrity for reply failed: %v", err)
		}
		t.Logf("Server reply wrapped with integrity (%d bytes)", len(wrappedReply))

		// Cleanup
		destroyCred := encodeCredOrFatal(t, &gss.RPCGSSCredV1{
			GSSProc: gss.RPCGSSDestroy,
			SeqNum:  2,
			Service: gss.RPCGSSSvcIntegrity,
			Handle:  handle,
		})
		proc.Process(destroyCred, nil, nil)
	})

	t.Run("krb5p_privacy", func(t *testing.T) {
		provider, proc := createGSSStack(t, keytabPath, krb5ConfPath)
		defer provider.Close()
		defer proc.Stop()

		gssToken, clientSessionKey := getRealAPREQ(t, krb5ConfPath, kdcPort)

		// INIT with privacy service
		initCred := encodeCredOrFatal(t, &gss.RPCGSSCredV1{
			GSSProc: gss.RPCGSSInit,
			SeqNum:  0,
			Service: gss.RPCGSSSvcPrivacy,
		})
		initResult := proc.Process(initCred, nil, gssToken)
		if initResult.Err != nil {
			t.Fatalf("INIT failed: %v", initResult.Err)
		}
		handle, _ := decodeInitRes(t, initResult.GSSReply)
		t.Logf("krb5p INIT succeeded: handle=%x", handle)

		// Build privacy-wrapped DATA request body (as client/initiator)
		procArgs := []byte("WRITE args with privacy protection")
		seqNum := uint32(1)
		privacyBody := wrapPrivacyAsInitiator(t, clientSessionKey, seqNum, procArgs)

		dataCred := encodeCredOrFatal(t, &gss.RPCGSSCredV1{
			GSSProc: gss.RPCGSSData,
			SeqNum:  seqNum,
			Service: gss.RPCGSSSvcPrivacy,
			Handle:  handle,
		})
		dataResult := proc.Process(dataCred, nil, privacyBody)
		if dataResult.Err != nil {
			t.Fatalf("krb5p DATA failed: %v", dataResult.Err)
		}
		if !bytes.Equal(dataResult.ProcessedData, procArgs) {
			t.Errorf("unwrapped data mismatch: got %q, want %q", dataResult.ProcessedData, procArgs)
		}
		t.Log("krb5p privacy verification passed with real Kerberos session key")

		// Verify reply wrapping works (server -> client direction)
		replyBody := []byte("WRITE response data")
		wrappedReply, err := gss.WrapPrivacy(dataResult.SessionKey, dataResult.SeqNum, replyBody)
		if err != nil {
			t.Fatalf("WrapPrivacy for reply failed: %v", err)
		}
		t.Logf("Server reply wrapped with privacy (%d bytes)", len(wrappedReply))

		// Cleanup
		destroyCred := encodeCredOrFatal(t, &gss.RPCGSSCredV1{
			GSSProc: gss.RPCGSSDestroy,
			SeqNum:  2,
			Service: gss.RPCGSSSvcPrivacy,
			Handle:  handle,
		})
		proc.Process(destroyCred, nil, nil)
	})

	t.Run("default_identity_mapping", func(t *testing.T) {
		// Use a mapper without the testuser in the static map
		provider, err := kerberos.NewProvider(&dconfig.KerberosConfig{
			Enabled:          true,
			KeytabPath:       keytabPath,
			ServicePrincipal: spnFull,
			Krb5Conf:         krb5ConfPath,
			MaxClockSkew:     5 * time.Minute,
		})
		if err != nil {
			t.Fatalf("create provider: %v", err)
		}
		defer provider.Close()

		emptyMapping := dconfig.IdentityMappingConfig{
			DefaultUID: 65534,
			DefaultGID: 65534,
		}
		verifier := gss.NewKrb5Verifier(provider)
		mapper := kerberos.NewStaticMapper(&emptyMapping)
		proc := gss.NewGSSProcessor(verifier, mapper, 100, 10*time.Minute)
		defer proc.Stop()

		gssToken, _ := getRealAPREQ(t, krb5ConfPath, kdcPort)

		initCred := encodeCredOrFatal(t, &gss.RPCGSSCredV1{
			GSSProc: gss.RPCGSSInit,
			SeqNum:  0,
			Service: gss.RPCGSSSvcNone,
		})
		initResult := proc.Process(initCred, nil, gssToken)
		if initResult.Err != nil {
			t.Fatalf("INIT failed: %v", initResult.Err)
		}
		handle, _ := decodeInitRes(t, initResult.GSSReply)

		dataCred := encodeCredOrFatal(t, &gss.RPCGSSCredV1{
			GSSProc: gss.RPCGSSData,
			SeqNum:  1,
			Service: gss.RPCGSSSvcNone,
			Handle:  handle,
		})
		dataResult := proc.Process(dataCred, nil, []byte("test"))
		if dataResult.Err != nil {
			t.Fatalf("DATA failed: %v", dataResult.Err)
		}

		// Unknown principal should get default UID/GID (65534/nobody)
		if *dataResult.Identity.UID != 65534 {
			t.Errorf("expected default UID 65534, got %d", *dataResult.Identity.UID)
		}
		if *dataResult.Identity.GID != 65534 {
			t.Errorf("expected default GID 65534, got %d", *dataResult.Identity.GID)
		}
		t.Logf("Unmapped principal correctly got default identity (UID=%d, GID=%d)",
			*dataResult.Identity.UID, *dataResult.Identity.GID)
	})
}

// ============================================================================
// KDC Docker Setup
// ============================================================================

func setupKDC(t *testing.T) (kdcHostPort int, keytabPath string, krb5ConfPath string, cleanup func()) {
	t.Helper()

	tmpDir := t.TempDir()

	// Clean up any previous container
	exec.Command("docker", "rm", "-f", containerName).CombinedOutput()

	// Build Docker image (cached after first run)
	t.Log("Building KDC Docker image...")
	dockerfileDir := findDockerfileDir(t)
	buildCmd := exec.Command("docker", "build", "-t", imageName, dockerfileDir)
	buildCmd.Stdout = os.Stdout
	buildCmd.Stderr = os.Stderr
	if err := buildCmd.Run(); err != nil {
		t.Fatalf("docker build failed: %v", err)
	}

	// Start container with random TCP port mapping.
	// Override entrypoint to sleep so we can set up the KDC manually.
	t.Log("Starting KDC container...")
	runOut, err := exec.Command("docker", "run", "-d",
		"--name", containerName,
		"-p", "0:88/tcp",
		"--entrypoint", "sleep",
		imageName,
		"infinity",
	).CombinedOutput()
	if err != nil {
		t.Fatalf("docker run failed: %v\n%s", err, runOut)
	}

	// Get the randomly assigned host port
	portOut, err := exec.Command("docker", "port", containerName, "88/tcp").Output()
	if err != nil {
		exec.Command("docker", "rm", "-f", containerName).Run()
		t.Fatalf("docker port: %v", err)
	}
	portStr := strings.TrimSpace(string(portOut))
	parts := strings.Split(portStr, ":")
	kdcHostPort, err = strconv.Atoi(parts[len(parts)-1])
	if err != nil {
		exec.Command("docker", "rm", "-f", containerName).Run()
		t.Fatalf("parse port %q: %v", portStr, err)
	}
	t.Logf("KDC mapped to host port %d", kdcHostPort)

	// Write krb5.conf inside container
	containerKrb5Conf := fmt.Sprintf(`[libdefaults]
    default_realm = %s
    dns_lookup_realm = false
    dns_lookup_kdc = false

[realms]
    %s = {
        kdc = localhost
        admin_server = localhost
    }
`, realm, realm)
	dockerExecBash(t, fmt.Sprintf("cat > /etc/krb5.conf << 'ENDCONF'\n%sENDCONF", containerKrb5Conf))

	// Write kdc.conf inside container
	kdcConf := fmt.Sprintf(`[kdcdefaults]
    kdc_ports = 88

[realms]
    %s = {
        database_name = /var/lib/krb5kdc/principal
        admin_keytab = FILE:/etc/krb5kdc/kadm5.keytab
        acl_file = /etc/krb5kdc/kadm5.acl
        key_stash_file = /etc/krb5kdc/stash
        max_life = 10h 0m 0s
        max_renewable_life = 7d 0h 0m 0s
        supported_enctypes = aes256-cts-hmac-sha1-96:normal aes128-cts-hmac-sha1-96:normal
    }
`, realm)
	dockerExecBash(t, fmt.Sprintf("mkdir -p /etc/krb5kdc && cat > /etc/krb5kdc/kdc.conf << 'ENDCONF'\n%sENDCONF", kdcConf))

	// Create Kerberos realm database
	t.Log("Creating Kerberos realm...")
	dockerExecCmd(t, "kdb5_util", "create", "-s", "-r", realm, "-P", "masterpassword")

	// Create test user principal
	t.Log("Creating principals...")
	dockerExecCmd(t, "kadmin.local", "-q", fmt.Sprintf("addprinc -pw %s %s@%s", testPass, testUser, realm))

	// Create NFS service principal
	dockerExecCmd(t, "kadmin.local", "-q", fmt.Sprintf("addprinc -randkey %s", spnFull))

	// Export service keytab
	dockerExecCmd(t, "kadmin.local", "-q", fmt.Sprintf("ktadd -k /tmp/nfs.keytab %s", spnFull))

	// Start KDC daemon in background
	t.Log("Starting KDC daemon...")
	if err := exec.Command("docker", "exec", "-d", containerName, "krb5kdc").Run(); err != nil {
		exec.Command("docker", "rm", "-f", containerName).Run()
		t.Fatalf("start KDC: %v", err)
	}

	// Copy keytab to host
	keytabPath = filepath.Join(tmpDir, "nfs.keytab")
	if out, err := exec.Command("docker", "cp", containerName+":/tmp/nfs.keytab", keytabPath).CombinedOutput(); err != nil {
		exec.Command("docker", "rm", "-f", containerName).Run()
		t.Fatalf("copy keytab: %v\n%s", err, out)
	}

	// Write host-side krb5.conf pointing to mapped port (force TCP)
	krb5ConfPath = filepath.Join(tmpDir, "krb5.conf")
	hostKrb5Conf := fmt.Sprintf(`[libdefaults]
    default_realm = %s
    dns_lookup_realm = false
    dns_lookup_kdc = false
    udp_preference_limit = 1

[realms]
    %s = {
        kdc = 127.0.0.1:%d
    }
`, realm, realm, kdcHostPort)
	if err := os.WriteFile(krb5ConfPath, []byte(hostKrb5Conf), 0644); err != nil {
		exec.Command("docker", "rm", "-f", containerName).Run()
		t.Fatalf("write krb5.conf: %v", err)
	}

	// Wait for KDC to accept TCP connections
	t.Log("Waiting for KDC to be ready...")
	waitForPort(t, kdcHostPort, 30*time.Second)
	t.Log("KDC is ready!")

	cleanup = func() {
		t.Log("Cleaning up KDC container...")
		exec.Command("docker", "rm", "-f", containerName).Run()
	}
	return
}

func findDockerfileDir(t *testing.T) string {
	t.Helper()
	// The Dockerfile is in the same directory as this test file.
	// Go tests run with CWD set to the package directory.
	if _, err := os.Stat("Dockerfile"); err == nil {
		return "."
	}
	// Fallback: try relative to project root
	projectRoot := os.Getenv("DITTOFS_PROJECT_ROOT")
	if projectRoot == "" {
		// Walk up from CWD to find go.mod
		dir, _ := os.Getwd()
		for {
			if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
				projectRoot = dir
				break
			}
			parent := filepath.Dir(dir)
			if parent == dir {
				t.Fatal("cannot find project root (go.mod)")
			}
			dir = parent
		}
	}
	return filepath.Join(projectRoot, "test", "integration", "kerberos")
}

func dockerExecBash(t *testing.T, script string) {
	t.Helper()
	cmd := exec.Command("docker", "exec", containerName, "bash", "-c", script)
	out, err := cmd.CombinedOutput()
	if err != nil {
		exec.Command("docker", "rm", "-f", containerName).Run()
		t.Fatalf("docker exec bash: %v\n%s", err, out)
	}
}

func dockerExecCmd(t *testing.T, args ...string) {
	t.Helper()
	cmdArgs := append([]string{"exec", containerName}, args...)
	cmd := exec.Command("docker", cmdArgs...)
	out, err := cmd.CombinedOutput()
	if err != nil {
		exec.Command("docker", "rm", "-f", containerName).Run()
		t.Fatalf("docker exec %v: %v\n%s", args, err, out)
	}
}

func waitForPort(t *testing.T, port int, timeout time.Duration) {
	t.Helper()
	deadline := time.Now().Add(timeout)
	for time.Now().Before(deadline) {
		conn, err := net.DialTimeout("tcp", fmt.Sprintf("127.0.0.1:%d", port), 500*time.Millisecond)
		if err == nil {
			conn.Close()
			return
		}
		time.Sleep(500 * time.Millisecond)
	}
	t.Fatalf("port %d not ready within %s", port, timeout)
}

// ============================================================================
// GSS Stack Creation
// ============================================================================

func createGSSStack(t *testing.T, keytabPath, krb5ConfPath string) (*kerberos.Provider, *gss.GSSProcessor) {
	t.Helper()

	cfg := &dconfig.KerberosConfig{
		Enabled:          true,
		KeytabPath:       keytabPath,
		ServicePrincipal: spnFull,
		Krb5Conf:         krb5ConfPath,
		MaxClockSkew:     5 * time.Minute,
		ContextTTL:       10 * time.Minute,
		MaxContexts:      100,
		IdentityMapping: dconfig.IdentityMappingConfig{
			Strategy:   "static",
			DefaultUID: 65534,
			DefaultGID: 65534,
			StaticMap: map[string]dconfig.StaticIdentity{
				fmt.Sprintf("%s@%s", testUser, realm): {UID: 1000, GID: 1000, GIDs: []uint32{1000, 100}},
			},
		},
	}

	provider, err := kerberos.NewProvider(cfg)
	if err != nil {
		t.Fatalf("create provider: %v", err)
	}

	verifier := gss.NewKrb5Verifier(provider)
	idMapping := cfg.IdentityMapping
	mapper := kerberos.NewStaticMapper(&idMapping)
	proc := gss.NewGSSProcessor(verifier, mapper, cfg.MaxContexts, cfg.ContextTTL)

	return provider, proc
}

// ============================================================================
// Real Kerberos Token Generation
// ============================================================================

// getRealAPREQ authenticates against the real KDC and builds a GSS-API
// wrapped AP-REQ token suitable for RPCSEC_GSS_INIT.
func getRealAPREQ(t *testing.T, krb5ConfPath string, kdcPort int) (gssToken []byte, sessionKey types.EncryptionKey) {
	t.Helper()

	cfg, err := krb5config.Load(krb5ConfPath)
	if err != nil {
		t.Fatalf("load krb5.conf: %v", err)
	}

	// Create Kerberos client and authenticate (kinit equivalent)
	cl := client.NewWithPassword(testUser, realm, testPass, cfg, client.DisablePAFXFAST(true))
	if err := cl.Login(); err != nil {
		t.Fatalf("kinit failed: %v", err)
	}
	defer cl.Destroy()
	t.Log("Got TGT from KDC")

	// Get service ticket (TGS-REQ equivalent)
	tkt, sessionKey, err := cl.GetServiceTicket(spnShort)
	if err != nil {
		t.Fatalf("get service ticket: %v", err)
	}
	t.Logf("Got service ticket for %s (enctype=%d)", spnShort, sessionKey.KeyType)

	// Build AP-REQ authenticator (no sub-key so both sides use ticket session key)
	auth, err := types.NewAuthenticator(cl.Credentials.Domain(), cl.Credentials.CName())
	if err != nil {
		t.Fatalf("create authenticator: %v", err)
	}

	// Build AP-REQ message
	apReq, err := messages.NewAPReq(tkt, sessionKey, auth)
	if err != nil {
		t.Fatalf("build AP-REQ: %v", err)
	}

	apReqBytes, err := apReq.Marshal()
	if err != nil {
		t.Fatalf("marshal AP-REQ: %v", err)
	}
	t.Logf("Built AP-REQ (%d bytes)", len(apReqBytes))

	// Wrap in GSS-API initial context token
	gssToken = wrapInGSSAPIToken(apReqBytes)
	t.Logf("Wrapped in GSS-API token (%d bytes)", len(gssToken))

	return gssToken, sessionKey
}

// ============================================================================
// GSS-API Token Building
// ============================================================================

// wrapInGSSAPIToken wraps an AP-REQ in a GSS-API initial context token.
//
// Format per RFC 2743 Section 3.1:
//
//	0x60 [length] 0x06 0x09 [KRB5-OID-value] [AP-REQ-bytes]
func wrapInGSSAPIToken(apReqBytes []byte) []byte {
	// KRB5 OID value: 1.2.840.113554.1.2.2
	krb5OIDValue := []byte{0x2a, 0x86, 0x48, 0x86, 0xf7, 0x12, 0x01, 0x02, 0x02}

	// Inner = OID_tag(1) + OID_len(1) + OID_value(9) + AP-REQ
	innerLen := 1 + 1 + len(krb5OIDValue) + len(apReqBytes)

	var buf bytes.Buffer
	buf.WriteByte(0x60) // APPLICATION 0 tag
	writeASN1Length(&buf, innerLen)
	buf.WriteByte(0x06) // OBJECT IDENTIFIER tag
	buf.WriteByte(byte(len(krb5OIDValue)))
	buf.Write(krb5OIDValue)
	buf.Write(apReqBytes)

	return buf.Bytes()
}

func writeASN1Length(buf *bytes.Buffer, length int) {
	if length < 128 {
		buf.WriteByte(byte(length))
		return
	}
	if length < 256 {
		buf.WriteByte(0x81)
		buf.WriteByte(byte(length))
		return
	}
	buf.WriteByte(0x82)
	buf.WriteByte(byte(length >> 8))
	buf.WriteByte(byte(length))
}

// ============================================================================
// RPCSEC_GSS Credential and Response Helpers
// ============================================================================

func encodeCredOrFatal(t *testing.T, cred *gss.RPCGSSCredV1) []byte {
	t.Helper()
	data, err := gss.EncodeGSSCred(cred)
	if err != nil {
		t.Fatalf("encode GSS cred: %v", err)
	}
	return data
}

// decodeInitRes decodes an RPCGSSInitRes to extract the handle and major status.
func decodeInitRes(t *testing.T, gssReply []byte) (handle []byte, gssMajor uint32) {
	t.Helper()
	reader := bytes.NewReader(gssReply)

	// Read handle (XDR opaque: length + data + padding)
	var handleLen uint32
	if err := binary.Read(reader, binary.BigEndian, &handleLen); err != nil {
		t.Fatalf("read handle length: %v", err)
	}
	handle = make([]byte, handleLen)
	if _, err := reader.Read(handle); err != nil {
		t.Fatalf("read handle: %v", err)
	}
	padding := (4 - (handleLen % 4)) % 4
	for range int(padding) {
		reader.ReadByte()
	}

	// Read gss_major
	if err := binary.Read(reader, binary.BigEndian, &gssMajor); err != nil {
		t.Fatalf("read gss_major: %v", err)
	}
	return
}

// ============================================================================
// Integrity/Privacy Wrapping (Client/Initiator Side)
// ============================================================================

// wrapIntegrityAsInitiator builds an rpc_gss_integ_data body as the client would.
func wrapIntegrityAsInitiator(t *testing.T, sessionKey types.EncryptionKey, seqNum uint32, args []byte) []byte {
	t.Helper()

	// databody_integ = XDR(seq_num) + procedure_args
	databodyInteg := make([]byte, 4+len(args))
	binary.BigEndian.PutUint32(databodyInteg[0:4], seqNum)
	copy(databodyInteg[4:], args)

	// MIC as initiator (no SentByAcceptor flag)
	micToken := gssapi.MICToken{
		Flags:     0, // Initiator
		SndSeqNum: uint64(seqNum),
		Payload:   databodyInteg,
	}
	if err := micToken.SetChecksum(sessionKey, gss.KeyUsageInitiatorSign); err != nil {
		t.Fatalf("compute initiator MIC: %v", err)
	}
	micBytes, err := micToken.Marshal()
	if err != nil {
		t.Fatalf("marshal MIC: %v", err)
	}

	// Encode: opaque(databody_integ) + opaque(mic)
	var buf bytes.Buffer
	writeXDROpaque(&buf, databodyInteg)
	writeXDROpaque(&buf, micBytes)
	return buf.Bytes()
}

// wrapPrivacyAsInitiator builds an rpc_gss_priv_data body as the client would.
func wrapPrivacyAsInitiator(t *testing.T, sessionKey types.EncryptionKey, seqNum uint32, args []byte) []byte {
	t.Helper()

	// plaintext = XDR(seq_num) + procedure_args
	plaintext := make([]byte, 4+len(args))
	binary.BigEndian.PutUint32(plaintext[0:4], seqNum)
	copy(plaintext[4:], args)

	encType, err := crypto.GetEtype(sessionKey.KeyType)
	if err != nil {
		t.Fatalf("get encryption type: %v", err)
	}

	wrapToken := gssapi.WrapToken{
		Flags:     0, // Initiator
		EC:        uint16(encType.GetHMACBitLength() / 8),
		RRC:       0,
		SndSeqNum: uint64(seqNum),
		Payload:   plaintext,
	}
	if err := wrapToken.SetCheckSum(sessionKey, gss.KeyUsageInitiatorSeal); err != nil {
		t.Fatalf("compute initiator WrapToken checksum: %v", err)
	}
	wrapTokenBytes, err := wrapToken.Marshal()
	if err != nil {
		t.Fatalf("marshal WrapToken: %v", err)
	}

	// Encode: opaque(wrap_token)
	var buf bytes.Buffer
	writeXDROpaque(&buf, wrapTokenBytes)
	return buf.Bytes()
}

// writeXDROpaque writes an XDR variable-length opaque value.
func writeXDROpaque(buf *bytes.Buffer, data []byte) {
	length := uint32(len(data))
	binary.Write(buf, binary.BigEndian, length)
	buf.Write(data)
	padding := (4 - (length % 4)) % 4
	for range int(padding) {
		buf.WriteByte(0)
	}
}
