package state

import (
	"encoding/hex"
	"fmt"

	"github.com/marmos91/dittofs/internal/adapter/nfs/v4/types"
)

// ============================================================================
// SeqID Validation
// ============================================================================

// SeqIDValidation is the result of validating a seqid against an OpenOwner.
type SeqIDValidation int

const (
	// SeqIDOK indicates the seqid is the expected next value.
	SeqIDOK SeqIDValidation = iota

	// SeqIDReplay indicates the seqid matches the last processed seqid
	// (retransmit -- return cached result).
	SeqIDReplay

	// SeqIDBad indicates the seqid is neither expected nor a replay.
	SeqIDBad
)

// ============================================================================
// OpenOwner
// ============================================================================

// OpenOwner represents an NFSv4 open-owner for state tracking.
// An open-owner is identified by the combination of clientid + owner opaque data.
// Each open-owner has an independent seqid sequence for replay detection.
//
// Per RFC 7530 Section 9.1.7, the server tracks:
//   - The last seqid processed for this owner
//   - The cached result of the last operation (for replay)
//   - Whether the owner has been confirmed via OPEN_CONFIRM
type OpenOwner struct {
	// ClientID is the server-assigned client identifier.
	ClientID uint64

	// OwnerData is the opaque owner identifier from the client.
	OwnerData []byte

	// LastSeqID is the last successfully processed seqid for this owner.
	LastSeqID uint32

	// LastResult is the cached result of the last operation on this owner.
	// Used for replay detection (same seqid returns cached result).
	LastResult *CachedResult

	// Confirmed indicates whether OPEN_CONFIRM has been called for this owner.
	// New owners created by OPEN must be confirmed before the open state is usable.
	Confirmed bool

	// OpenStates tracks all open files for this owner.
	OpenStates []*OpenState

	// ClientRecord is a back-reference to the owning client record.
	ClientRecord *ClientRecord
}

// ValidateSeqID checks whether a seqid is valid for this open-owner.
//
// Per RFC 7530 Section 9.1.7:
//   - Expected = LastSeqID + 1 (with wrap: 0xFFFFFFFF -> 1, not 0)
//   - seqid == expected -> SeqIDOK
//   - seqid == LastSeqID -> SeqIDReplay
//   - else -> SeqIDBad
func (oo *OpenOwner) ValidateSeqID(seqid uint32) SeqIDValidation {
	expected := nextSeqID(oo.LastSeqID)

	if seqid == expected {
		return SeqIDOK
	}
	if seqid == oo.LastSeqID {
		return SeqIDReplay
	}
	return SeqIDBad
}

// ============================================================================
// CachedResult
// ============================================================================

// CachedResult holds the result of the last operation on an open-owner.
// When a replay is detected (same seqid), this cached result is returned
// instead of re-executing the operation.
type CachedResult struct {
	// Status is the NFS4 status code of the cached operation.
	Status uint32

	// Data is the XDR-encoded operation-specific result data.
	Data []byte
}

// ============================================================================
// OpenState
// ============================================================================

// OpenState represents the state of a single open file for an open-owner.
// Created by OPEN, removed by CLOSE.
//
// Per RFC 7530 Section 9.1:
//   - Each OpenState has a unique stateid (generated by the server)
//   - share_access/share_deny accumulate across multiple OPENs on same file
//   - CLOSE removes the OpenState and its stateid
type OpenState struct {
	// Stateid is the server-assigned state identifier for this open.
	Stateid types.Stateid4

	// Owner is the open-owner that created this state.
	Owner *OpenOwner

	// FileHandle is the file handle of the opened file.
	FileHandle []byte

	// ShareAccess is the accumulated share access mode (OR'd across OPENs).
	ShareAccess uint32

	// ShareDeny is the accumulated share deny mode (OR'd across OPENs).
	ShareDeny uint32

	// Confirmed indicates whether OPEN_CONFIRM has been called for this state.
	Confirmed bool

	// LockStates tracks lock stateids derived from this open.
	LockStates []*LockState
}

// ============================================================================
// OpenFileResult
// ============================================================================

// OpenFileResult is the result returned by StateManager.OpenFile.
// It contains everything the OPEN handler needs to build its response.
type OpenFileResult struct {
	// Stateid is the stateid to return to the client.
	Stateid types.Stateid4

	// RFlags is the result flags (OPEN4_RESULT_CONFIRM if new owner).
	RFlags uint32

	// IsReplay indicates this is a replay of a previous operation.
	// When true, CachedStatus and CachedData should be returned directly.
	IsReplay bool

	// CachedStatus is the status from the replayed operation (only if IsReplay).
	CachedStatus uint32

	// CachedData is the XDR data from the replayed operation (only if IsReplay).
	CachedData []byte
}

// ============================================================================
// Owner Key
// ============================================================================

// openOwnerKey is a composite key for looking up open-owners in maps.
// It combines the client ID and hex-encoded owner data for uniqueness.
type openOwnerKey string

// makeOwnerKey creates an openOwnerKey from a client ID and owner data.
func makeOwnerKey(clientID uint64, ownerData []byte) openOwnerKey {
	return openOwnerKey(fmt.Sprintf("%d:%s", clientID, hex.EncodeToString(ownerData)))
}

// ============================================================================
// Helpers
// ============================================================================

// nextSeqID computes the next expected seqid with wrap-around.
// Per RFC 7530, seqid 0xFFFFFFFF wraps to 1 (not 0, since 0 is
// reserved for special stateids).
func nextSeqID(current uint32) uint32 {
	if current == 0xFFFFFFFF {
		return 1
	}
	return current + 1
}
