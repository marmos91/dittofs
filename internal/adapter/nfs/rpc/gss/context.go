package gss

import (
	"context"
	"crypto/rand"
	"sync"
	"time"

	"github.com/jcmturner/gokrb5/v8/types"
	"github.com/marmos91/dittofs/internal/logger"
	"github.com/marmos91/dittofs/pkg/metadata"
)

// ============================================================================
// Context Value Helpers for GSS Identity Propagation
// ============================================================================

// gssIdentityKey is the context key for passing GSS identity through Go context.
// Using a private struct type ensures no collisions with other packages.
type gssIdentityKey struct{}

// ContextWithIdentity returns a new context carrying the GSS-resolved identity.
//
// This is used in the NFS connection handler after GSS DATA processing to
// pass the resolved Unix identity to NFS handlers via context.Value.
//
// Parameters:
//   - ctx: Parent context
//   - id: Resolved identity from GSSProcessor (UID/GID from principal mapping)
//
// Returns:
//   - context.Context: New context with identity attached
func ContextWithIdentity(ctx context.Context, id *metadata.Identity) context.Context {
	return context.WithValue(ctx, gssIdentityKey{}, id)
}

// IdentityFromContext extracts the GSS identity from the context, if present.
//
// Returns nil if no GSS identity was set (e.g., for AUTH_UNIX/AUTH_NULL requests).
//
// Parameters:
//   - ctx: Context to extract identity from
//
// Returns:
//   - *metadata.Identity: The GSS identity, or nil if not set
func IdentityFromContext(ctx context.Context) *metadata.Identity {
	id, _ := ctx.Value(gssIdentityKey{}).(*metadata.Identity)
	return id
}

// gssSessionInfoKey is the context key for passing GSS session info for reply construction.
type gssSessionInfoKey struct{}

// GSSSessionInfo contains per-request GSS state needed for reply construction.
//
// This is stored in the context during GSS DATA processing so the reply
// path can compute the GSS verifier without modifying the sendReply signature.
type GSSSessionInfo struct {
	// SessionKey is the session key from the GSS context.
	SessionKey types.EncryptionKey

	// SeqNum is the sequence number from the credential.
	SeqNum uint32

	// Service is the RPCSEC_GSS service level (none/integrity/privacy).
	// Needed by the reply path to determine which wrapping to apply.
	Service uint32
}

// ContextWithSessionInfo returns a new context carrying GSS session info.
func ContextWithSessionInfo(ctx context.Context, info *GSSSessionInfo) context.Context {
	return context.WithValue(ctx, gssSessionInfoKey{}, info)
}

// SessionInfoFromContext extracts the GSS session info from the context, if present.
func SessionInfoFromContext(ctx context.Context) *GSSSessionInfo {
	info, _ := ctx.Value(gssSessionInfoKey{}).(*GSSSessionInfo)
	return info
}

// GSSContext represents an active RPCSEC_GSS security context.
//
// Each context is created during RPCSEC_GSS_INIT when the client authenticates
// via Kerberos. The context stores the session key (from the decrypted ticket),
// the client principal, and a sequence window for replay detection.
//
// Contexts are stored in the ContextStore and looked up by handle on every
// RPCSEC_GSS_DATA request to validate and unwrap the call.
//
// Thread Safety: The LastUsed field is protected by mu for concurrent updates.
// All other fields are immutable after creation.
type GSSContext struct {
	// Handle is a unique 16-byte identifier generated by the server.
	// The client includes this in subsequent RPCSEC_GSS credentials.
	Handle []byte

	// Principal is the authenticated Kerberos principal name (e.g., "alice").
	Principal string

	// Realm is the Kerberos realm (e.g., "EXAMPLE.COM").
	Realm string

	// SessionKey is the encryption key from the decrypted service ticket.
	// Used for MIC computation (integrity) and wrap/unwrap (privacy).
	SessionKey types.EncryptionKey

	// SeqWindow is the per-context sequence number tracker for replay detection.
	SeqWindow *SeqWindow

	// Service is the protection level negotiated during INIT.
	// One of RPCGSSSvcNone, RPCGSSSvcIntegrity, or RPCGSSSvcPrivacy.
	Service uint32

	// CreatedAt is the time the context was established.
	CreatedAt time.Time

	// LastUsed is the time of the last DATA request on this context.
	// Updated on each successful Lookup for LRU-based eviction.
	LastUsed time.Time

	// mu protects LastUsed updates.
	mu sync.Mutex
}

// Touch updates the LastUsed timestamp to now.
// Thread-safe.
func (c *GSSContext) Touch() {
	c.mu.Lock()
	c.LastUsed = time.Now()
	c.mu.Unlock()
}

// GetLastUsed returns the LastUsed timestamp.
// Thread-safe.
func (c *GSSContext) GetLastUsed() time.Time {
	c.mu.Lock()
	defer c.mu.Unlock()
	return c.LastUsed
}

// generateHandle creates a cryptographically random 16-byte context handle.
func generateHandle() ([]byte, error) {
	handle := make([]byte, 16)
	if _, err := rand.Read(handle); err != nil {
		return nil, err
	}
	return handle, nil
}

// ContextStore is a thread-safe store of active RPCSEC_GSS contexts.
//
// It provides O(1) lookup by handle via sync.Map, TTL-based expiration of
// idle contexts, and LRU eviction when the maximum number of contexts is reached.
//
// The store runs a background cleanup goroutine that periodically removes
// expired contexts (those whose LastUsed exceeds the configured TTL).
//
// CRITICAL ORDERING: Context must be stored BEFORE the INIT reply is sent
// to the client. If the reply arrives before the context is stored, the
// client's first DATA request will fail with "context not found".
// This was a real bug in early NFS-Ganesha versions.
type ContextStore struct {
	contexts      sync.Map
	maxContexts   int
	contextTTL    time.Duration
	cleanupTicker *time.Ticker
	stopCh        chan struct{}
}

// cleanupInterval is the time between TTL cleanup sweeps.
const cleanupInterval = 5 * time.Minute

// NewContextStore creates a new context store and starts the background
// cleanup goroutine.
//
// Parameters:
//   - maxContexts: Maximum number of concurrent contexts. When exceeded,
//     the oldest (LRU) context is evicted to make room. Use 0 for unlimited.
//   - contextTTL: Time after which idle contexts are removed. A context's
//     LastUsed is updated on each DATA request.
//
// Returns:
//   - *ContextStore: Initialized store with background cleanup running
func NewContextStore(maxContexts int, contextTTL time.Duration) *ContextStore {
	cs := &ContextStore{
		maxContexts: maxContexts,
		contextTTL:  contextTTL,
		stopCh:      make(chan struct{}),
	}

	cs.cleanupTicker = time.NewTicker(cleanupInterval)
	go cs.cleanupLoop()

	return cs
}

// Store adds a GSS context to the store.
//
// CRITICAL: This MUST be called BEFORE the INIT reply is sent to the client.
// See ContextStore documentation for rationale.
//
// If the store is at capacity (maxContexts), the oldest context (by LastUsed)
// is evicted first. This ensures the store does not grow unboundedly.
//
// Parameters:
//   - ctx: The context to store (must have a non-nil Handle)
func (cs *ContextStore) Store(ctx *GSSContext) {
	if cs.maxContexts > 0 {
		count := cs.Count()
		if count >= cs.maxContexts {
			cs.evictOldest()
		}
	}

	cs.contexts.Store(string(ctx.Handle), ctx)
}

// Lookup retrieves a GSS context by its handle.
//
// On a successful lookup, the context's LastUsed timestamp is updated
// to support LRU eviction. This is O(1) via sync.Map.
//
// Parameters:
//   - handle: The 16-byte context handle from the RPCSEC_GSS credential
//
// Returns:
//   - *GSSContext: The context if found
//   - bool: true if the context exists, false otherwise
func (cs *ContextStore) Lookup(handle []byte) (*GSSContext, bool) {
	val, ok := cs.contexts.Load(string(handle))
	if !ok {
		return nil, false
	}

	ctx := val.(*GSSContext)
	ctx.Touch()
	return ctx, true
}

// Delete removes a GSS context from the store.
//
// Called when processing RPCSEC_GSS_DESTROY. It is safe to call Delete
// with a handle that does not exist (no-op).
//
// Parameters:
//   - handle: The context handle to remove
func (cs *ContextStore) Delete(handle []byte) {
	cs.contexts.Delete(string(handle))
}

// Count returns the number of active contexts in the store.
//
// This iterates the sync.Map, so it is O(n). Use for metrics and
// capacity checks, not in hot paths.
func (cs *ContextStore) Count() int {
	count := 0
	cs.contexts.Range(func(_, _ interface{}) bool {
		count++
		return true
	})
	return count
}

// Stop stops the background cleanup goroutine and ticker.
//
// Must be called when the GSS processor is shut down to prevent
// goroutine leaks.
func (cs *ContextStore) Stop() {
	close(cs.stopCh)
	cs.cleanupTicker.Stop()
}

// cleanupLoop runs the periodic TTL cleanup.
func (cs *ContextStore) cleanupLoop() {
	for {
		select {
		case <-cs.cleanupTicker.C:
			cs.cleanup()
		case <-cs.stopCh:
			return
		}
	}
}

// cleanup removes contexts whose LastUsed exceeds the TTL.
func (cs *ContextStore) cleanup() {
	now := time.Now()
	cs.contexts.Range(func(key, value interface{}) bool {
		ctx := value.(*GSSContext)
		lastUsed := ctx.GetLastUsed()
		if now.Sub(lastUsed) > cs.contextTTL {
			logger.Debug("GSS context expired",
				"principal", ctx.Principal,
				"realm", ctx.Realm,
				"idle", now.Sub(lastUsed).String(),
			)
			cs.contexts.Delete(key)
		}
		return true
	})
}

// evictOldest removes the context with the oldest LastUsed timestamp.
func (cs *ContextStore) evictOldest() {
	var oldestKey interface{}
	var oldestTime time.Time
	first := true

	cs.contexts.Range(func(key, value interface{}) bool {
		ctx := value.(*GSSContext)
		lastUsed := ctx.GetLastUsed()
		if first || lastUsed.Before(oldestTime) {
			oldestKey = key
			oldestTime = lastUsed
			first = false
		}
		return true
	})

	if oldestKey != nil {
		if val, ok := cs.contexts.Load(oldestKey); ok {
			ctx := val.(*GSSContext)
			logger.Debug("GSS context evicted (max contexts reached)",
				"principal", ctx.Principal,
				"realm", ctx.Realm,
			)
		}
		cs.contexts.Delete(oldestKey)
	}
}
