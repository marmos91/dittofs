---
phase: 26-generic-lock-interface-protocol-leak-purge
plan: 05
type: execute
wave: 3
depends_on:
  - 26-02
  - 26-04
files_modified:
  - pkg/controlplane/runtime/runtime.go
  - pkg/controlplane/runtime/netgroups.go
  - pkg/controlplane/runtime/mounts.go
  - internal/controlplane/api/handlers/clients.go
  - internal/controlplane/api/handlers/grace.go
  - internal/controlplane/api/handlers/netgroups.go
  - internal/controlplane/api/handlers/identity_mappings.go
  - internal/controlplane/api/handlers/adapter_settings.go
  - internal/controlplane/api/router.go
  - pkg/identity/
  - pkg/adapter/nfs/identity.go
autonomous: true
requirements:
  - REF-02

must_haves:
  truths:
    - "Runtime has no NFS-specific fields (mounts, dnsCache, nfsClientProvider, shareChangeCallbacks)"
    - "NFS-specific API handlers (clients.go, grace.go, netgroups.go, identity_mappings.go) moved under NFS adapter scope"
    - "pkg/identity/ dissolved -- generic parts in metadata, NFS Kerberos parts in NFS adapter"
    - "Adapter-scoped settings API exists (/api/adapters/{type}/settings, /api/shares/{id}/adapters/{type}/settings)"
    - "Mount tracking uses unified concept across protocols"
    - "SquashMode, Netgroup matching, DNS cache are NFS-adapter-internal"
  artifacts:
    - path: "pkg/controlplane/runtime/runtime.go"
      provides: "Clean runtime without NFS-specific fields"
    - path: "internal/controlplane/api/handlers/adapter_settings.go"
      provides: "Adapter-scoped settings handlers"
      contains: "adapters/{type}/settings"
    - path: "pkg/adapter/nfs/identity.go"
      provides: "NFS Kerberos identity resolution (from dissolved pkg/identity/)"
      contains: "type IdentityResolver"
  key_links:
    - from: "pkg/controlplane/runtime/runtime.go"
      to: "pkg/adapter/nfs/adapter.go"
      via: "NFS adapter owns mount tracking, not runtime"
      pattern: "RecordMount|RemoveMount"
    - from: "internal/controlplane/api/handlers/adapter_settings.go"
      to: "pkg/controlplane/store/adapter_configs.go"
      via: "Settings handlers use adapter config CRUD from Plan 02"
      pattern: "GetShareAdapterConfig|SetShareAdapterConfig"
---

<objective>
Purge NFS-specific runtime fields, relocate NFS API handlers, dissolve pkg/identity/, and create adapter-scoped settings API.

Purpose: Complete the protocol leak purge by moving all remaining NFS-specific code from generic layers (runtime, API handlers, identity package) to the NFS adapter or adapter-scoped infrastructure. Create the adapter settings API per user-specified URL pattern.

Output: Clean runtime (~950 lines), NFS handlers under adapter scope, dissolved identity package, adapter settings endpoints.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-generic-lock-interface-protocol-leak-purge/26-CONTEXT.md
@.planning/phases/26-generic-lock-interface-protocol-leak-purge/26-RESEARCH.md
@.planning/phases/26-generic-lock-interface-protocol-leak-purge/26-02-SUMMARY.md
@.planning/phases/26-generic-lock-interface-protocol-leak-purge/26-04-SUMMARY.md
@pkg/controlplane/runtime/runtime.go
@pkg/controlplane/runtime/netgroups.go
@internal/controlplane/api/handlers/clients.go
@internal/controlplane/api/handlers/grace.go
@internal/controlplane/api/handlers/netgroups.go
@internal/controlplane/api/handlers/identity_mappings.go
@internal/controlplane/api/router.go
@pkg/identity/
</context>

<tasks>

<task type="auto">
  <name>Task 1: Move NFS-specific runtime fields and implement unified mount tracking</name>
  <files>
    pkg/controlplane/runtime/runtime.go
    pkg/controlplane/runtime/netgroups.go
    pkg/controlplane/runtime/mounts.go
    pkg/adapter/nfs/adapter.go
  </files>
  <action>
    **1. Move NFS-specific fields from Runtime:**
    Remove from `pkg/controlplane/runtime/runtime.go`:
    - `mounts map[string]*MountInfo` field -> move to NFS adapter (NFS-specific mount tracking)
    - `dnsCache` + `dnsCacheOnce` fields -> move to NFS adapter (only used by netgroup DNS resolution)
    - `shareChangeCallbacks` field -> move to NFS adapter (only NFS re-exports trigger this)
    - `nfsClientProvider any` field -> move to NFS adapter (purely NFS state manager reference)

    Remove these methods from Runtime:
    - `RecordMount`, `RemoveMount`, `RemoveAllMounts`, `ListMounts` -> move to NFS adapter
    - `ApplyIdentityMapping` -> move to NFS adapter
    - `SetNFSClientProvider`, `NFSClientProvider` -> move to NFS adapter
    - All netgroup-related methods (DNS cache, netgroup matching) -> move to NFS adapter

    **2. Create unified mount tracking:**
    Per user decision: unified "mounts" concept across both protocols.
    - Create `pkg/controlplane/runtime/mounts.go` with a generic `MountTracker`:
      ```go
      type MountInfo struct {
          ClientAddr   string
          Protocol     string  // "nfs" or "smb"
          ShareName    string
          MountedAt    time.Time
          AdapterData  any     // Protocol-specific details (NFS mount path, SMB session ID, etc.)
      }

      type MountTracker struct {
          mu     sync.RWMutex
          mounts map[string]*MountInfo  // key: protocol:client:share
      }
      ```
    - Runtime exposes `MountTracker` for aggregate view: `runtime.Mounts().List()` returns all mounts across protocols
    - NFS adapter records NFS-specific mounts with NFS details in AdapterData
    - SMB adapter records SMB sessions as "mounts" with session details in AdapterData

    **3. Move netgroups.go to NFS adapter:**
    - Move `pkg/controlplane/runtime/netgroups.go` (200+ lines) to NFS adapter internal
    - DNS cache, netgroup matching, `MatchesNetgroup()` -- all NFS-specific
    - NFS adapter creates this service at startup using `store.(NetgroupStore)` type assertion from Plan 02

    **4. Update all callers of moved Runtime methods:**
    - NFS handlers that call `runtime.RecordMount(...)` -> use NFS adapter's mount tracker (which registers with runtime's unified MountTracker)
    - NFS handlers that call `runtime.ApplyIdentityMapping(...)` -> use NFS adapter's identity resolver
    - API handlers that call `runtime.ListMounts()` -> use runtime.Mounts().List() (generic)
    - SMB handlers that track sessions -> register with runtime's unified MountTracker

    **5. Fix compilation and tests:**
    - `go build ./...` must pass
    - `go test ./pkg/controlplane/runtime/...` must pass
    - `go test ./pkg/adapter/nfs/...` must pass
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs && go build ./pkg/controlplane/runtime/... && go build ./pkg/adapter/nfs/...</automated>
    <manual>Verify runtime.go has no NFS fields. netgroups.go moved to NFS adapter. Unified MountTracker exists.</manual>
  </verify>
  <done>NFS-specific fields removed from Runtime. Unified MountTracker created. Netgroup logic moved to NFS adapter. All callers updated. Compilation passes.</done>
</task>

<task type="auto">
  <name>Task 2: Relocate NFS API handlers and dissolve pkg/identity/</name>
  <files>
    internal/controlplane/api/handlers/clients.go
    internal/controlplane/api/handlers/grace.go
    internal/controlplane/api/handlers/netgroups.go
    internal/controlplane/api/handlers/identity_mappings.go
    internal/controlplane/api/router.go
    pkg/identity/
    pkg/adapter/nfs/identity.go
  </files>
  <action>
    **1. Relocate NFS-specific API handlers:**
    Per user decision: NFS-specific handlers move under NFS adapter scope.

    Move these handlers to NFS adapter-registered routes:
    - `handlers/clients.go` (298 lines) -> NFS adapter registers at `/api/adapters/nfs/clients`
    - `handlers/grace.go` (84 lines) -> NFS adapter registers at `/api/adapters/nfs/grace`
    - `handlers/netgroups.go` (240 lines) -> NFS adapter registers at `/api/adapters/nfs/netgroups`
    - `handlers/identity_mappings.go` (126 lines) -> NFS adapter registers at `/api/adapters/nfs/identity-mappings`

    Approach: NFS adapter provides a `RegisterRoutes(router chi.Router)` method that adds NFS-specific API routes. The main API server calls this for each registered adapter. Handler code stays in internal/controlplane/api/handlers/ or moves to a new `internal/adapter/nfs/api/` package (choose based on import graph simplicity).

    The existing generic API routes (shares, users, groups, etc.) stay in `internal/controlplane/api/`.

    **2. Update API router:**
    In `internal/controlplane/api/router.go`:
    - Remove direct routes for `/api/v1/clients`, `/api/v1/grace`, `/api/v1/netgroups`, `/api/v1/identity-mappings`
    - Add adapter route registration hook: when NFS adapter is loaded, it registers its routes under `/api/v1/adapters/nfs/`
    - Keep mount listing as generic: `/api/v1/mounts` -> uses runtime.Mounts().List()
    - Add per-adapter mount detail routes: `/api/v1/adapters/nfs/mounts` and `/api/v1/adapters/smb/mounts`

    **3. Create adapter-scoped settings API:**
    Per user decision: API pattern is `/api/adapters/{type}/settings` for global defaults, `/api/shares/{id}/adapters/{type}/settings` for per-share overrides.

    Create `internal/controlplane/api/handlers/adapter_settings.go`:
    - `GET /api/v1/adapters/{adapterType}/settings` -> returns adapter's global default config
    - `PUT /api/v1/adapters/{adapterType}/settings` -> updates adapter's global defaults
    - `GET /api/v1/shares/{shareID}/adapters/{adapterType}/settings` -> returns per-share override (from ShareAdapterConfig)
    - `PUT /api/v1/shares/{shareID}/adapters/{adapterType}/settings` -> sets per-share override via `store.SetShareAdapterConfig()`
    - `DELETE /api/v1/shares/{shareID}/adapters/{adapterType}/settings` -> removes per-share override (falls back to defaults)
    - Config validation at API level per user decision. Also validate on startup load (defense in depth).

    **4. Dissolve pkg/identity/:**
    Per user decision: `pkg/identity/` dissolved entirely.
    - Analyze each file:
      - `mapper.go` -- NFS Kerberos principal resolution -> move to `pkg/adapter/nfs/identity.go`
      - `convention.go` -- NFSv4 naming conventions -> move to NFS adapter
      - `table.go` -- identity table lookups -> move to NFS adapter
      - `static.go` -- static identity mappings -> move to NFS adapter
      - `cache.go` -- identity resolution cache -> move to NFS adapter
    - If any truly generic identity logic exists (DittoFS user + UID/GID resolution), keep in `pkg/metadata/` or `pkg/controlplane/`
    - Delete `pkg/identity/` directory after all code relocated
    - Update all imports referencing `pkg/identity/`

    **5. Update dfsctl commands:**
    - `dfsctl client list/evict` -> update API endpoints to `/api/v1/adapters/nfs/clients`
    - `dfsctl netgroup *` -> update API endpoints to `/api/v1/adapters/nfs/netgroups`
    - `dfsctl identity-mapping *` -> update API endpoints to `/api/v1/adapters/nfs/identity-mappings`
    - Add `dfsctl share adapter-config set/get` commands for per-share adapter config
    - Add `dfsctl adapter settings` commands for global adapter defaults

    **6. Run full test suite:**
    - `go test ./...`
    - Fix any failures from moved handlers, dissolved identity package, updated routes
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs && go test ./... 2>&1 | tail -30</automated>
    <manual>Verify pkg/identity/ is gone. NFS handlers under /api/adapters/nfs/. Adapter settings endpoints work.</manual>
  </verify>
  <done>NFS API handlers moved to adapter-scoped routes. pkg/identity/ dissolved (NFS parts in adapter, generic in metadata). Adapter settings API exists. dfsctl commands updated. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 3: Final validation -- full build, test suite, verify all purge targets</name>
  <files></files>
  <action>
    **1. Full compilation check:**
    - `go build ./...` -- zero errors
    - `go vet ./...` -- zero warnings

    **2. Full test suite:**
    - `go test ./...` -- all tests pass
    - `go test -race ./...` -- no data races (especially with concurrent lock operations and break callbacks)

    **3. Verify all Phase 26 success criteria:**
    Run verification grep commands for each success criterion:

    a. `EnhancedLock` renamed to `UnifiedLock`:
       `grep -rn 'type EnhancedLock ' pkg/ internal/ --include='*.go'` -> no results (except deprecated alias)

    b. SMB lock types removed from `pkg/metadata/lock/`:
       `grep -rn 'ShareReservation\b' pkg/metadata/lock/ --include='*.go'` -> no results (only AccessMode)
       `grep -rn 'LeaseInfo\b' pkg/metadata/lock/ --include='*.go'` -> no results (only OpLock)

    c. SMB lease methods removed from MetadataService:
       `grep -rn 'CheckAndBreakLeases\|ReclaimLeaseSMB\|OplockChecker' pkg/metadata/service.go` -> no results

    d. NLM methods moved from MetadataService:
       `grep -rn 'LockFileNLM\|TestLockNLM\|UnlockFileNLM\|CancelBlockingLock' pkg/metadata/service.go` -> no results

    e. GracePeriodManager stays generic:
       `grep -rn 'GracePeriodManager' pkg/metadata/lock/grace.go` -> exists, unchanged

    f. Share model cleaned:
       `grep -rn 'Squash\|AnonymousUID\|GuestEnabled' pkg/controlplane/models/share.go` -> no results

    g. SquashMode, Netgroup removed from generic interfaces:
       `grep -rn 'SquashMode\|Netgroup' pkg/controlplane/store/interface.go` -> no results in main Store interface

    h. NFS API handlers moved:
       `grep -rn 'nfs/v4/state' internal/controlplane/api/handlers/` -> no results (handlers moved)

    i. pkg/identity/ dissolved:
       `ls pkg/identity/` -> directory does not exist or is empty

    j. Centralized conflict detection:
       `grep -rn 'func (ul \*UnifiedLock) ConflictsWith' pkg/metadata/lock/types.go` -> exists

    **4. If any check fails:** fix the issue and re-run verification.
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs && go build ./... && go test ./... 2>&1 | tail -20</automated>
    <manual>All 10 success criteria verified via grep. No protocol leaks remain in generic layers.</manual>
  </verify>
  <done>All Phase 26 success criteria verified. Build passes, all tests pass, no data races. Protocol leak purge complete. Lock types unified. MetadataService, Share model, Store interface, Runtime all clean of protocol-specific code.</done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles cleanly
2. `go test ./...` passes
3. `go test -race ./...` passes (no data races)
4. All 10 Phase 26 success criteria verified via grep (see Task 3 action)
5. `wc -l pkg/metadata/service.go` shows ~550 lines (down from 994)
6. `wc -l pkg/controlplane/runtime/runtime.go` shows ~950 lines (down from 1258)
7. `ls pkg/identity/` shows directory removed or empty
</verification>

<success_criteria>
- Runtime has no NFS-specific fields or methods
- Unified MountTracker provides cross-protocol mount view
- NFS API handlers under /api/v1/adapters/nfs/ scope
- Adapter settings API at /api/adapters/{type}/settings and /api/shares/{id}/adapters/{type}/settings
- pkg/identity/ fully dissolved
- All 10 Phase 26 success criteria from ROADMAP verified
- Full test suite passes including race detection
</success_criteria>

<output>
After completion, create `.planning/phases/26-generic-lock-interface-protocol-leak-purge/26-05-SUMMARY.md`
</output>
