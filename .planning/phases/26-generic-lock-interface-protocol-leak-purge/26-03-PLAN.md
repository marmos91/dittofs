---
phase: 26-generic-lock-interface-protocol-leak-purge
plan: 03
type: execute
wave: 2
depends_on:
  - 26-01
files_modified:
  - pkg/metadata/lock/manager.go
  - pkg/metadata/lock/types.go
  - pkg/metadata/lock/oplock.go
  - pkg/metadata/lock/oplock_break.go
  - pkg/metadata/lock/manager_test.go
  - pkg/metadata/lock/cross_protocol_test.go
autonomous: true
requirements:
  - REF-01

must_haves:
  truths:
    - "LockManager interface exists with unified lock CRUD + grace period + break callback registration"
    - "ConflictsWith() method handles all 4 conflict cases (oplock-oplock, oplock-byterange, byterange-byterange, access mode)"
    - "Break callbacks are typed (OnOpLockBreak, OnByteRangeRevoke, OnAccessConflict)"
    - "GracePeriodManager is part of LockManager interface"
    - "Cross-protocol conflict tests pass with new interface"
    - "Centralized oplock break logic replaces OplockChecker global"
  artifacts:
    - path: "pkg/metadata/lock/manager.go"
      provides: "LockManager interface with all unified methods"
      contains: "type LockManager interface"
    - path: "pkg/metadata/lock/types.go"
      provides: "ConflictsWith method implementing all 4 conflict types"
      contains: "func (ul *UnifiedLock) ConflictsWith"
    - path: "pkg/metadata/lock/oplock_break.go"
      provides: "BreakCallbacks interface with typed methods"
      contains: "type BreakCallbacks interface"
    - path: "pkg/metadata/lock/cross_protocol_test.go"
      provides: "Rewritten cross-protocol conflict tests"
      contains: "TestConflictsWith"
  key_links:
    - from: "pkg/metadata/lock/manager.go"
      to: "pkg/metadata/lock/types.go"
      via: "LockManager methods accept/return UnifiedLock"
      pattern: "AddUnifiedLock.*UnifiedLock"
    - from: "pkg/metadata/lock/manager.go"
      to: "pkg/metadata/lock/oplock_break.go"
      via: "Manager uses BreakCallbacks for notification dispatch"
      pattern: "RegisterBreakCallbacks|BreakCallbacks"
    - from: "pkg/metadata/lock/types.go"
      to: "pkg/metadata/lock/oplock.go"
      via: "ConflictsWith delegates to OpLocksConflict for oplock cases"
      pattern: "OpLocksConflict|opLockConflictsWithByteLock"
---

<objective>
Define the LockManager interface and implement centralized conflict detection with typed break callbacks.

Purpose: Create the unified LockManager interface that both NFS and SMB adapters will use, implement the `ConflictsWith()` method handling all 4 conflict cases, and add typed break callbacks for compile-safe cross-protocol coordination. This replaces the OplockChecker global with centralized break logic.

Output: LockManager interface, ConflictsWith method with all conflict cases, BreakCallbacks typed interface, rewritten cross-protocol conflict tests.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-generic-lock-interface-protocol-leak-purge/26-CONTEXT.md
@.planning/phases/26-generic-lock-interface-protocol-leak-purge/26-RESEARCH.md
@.planning/phases/26-generic-lock-interface-protocol-leak-purge/26-01-SUMMARY.md
@pkg/metadata/lock/types.go
@pkg/metadata/lock/oplock.go
@pkg/metadata/lock/oplock_break.go
@pkg/metadata/lock/manager.go
@pkg/metadata/lock/cross_protocol.go
@pkg/metadata/lock/grace.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define LockManager interface and implement ConflictsWith</name>
  <files>
    pkg/metadata/lock/manager.go
    pkg/metadata/lock/types.go
    pkg/metadata/lock/oplock.go
    pkg/metadata/lock/oplock_break.go
  </files>
  <action>
    **1. Define LockManager interface in manager.go:**
    Per user decision: single interface (not split), includes grace period, includes break callback registration.
    ```go
    type LockManager interface {
        // Unified lock CRUD
        AddUnifiedLock(handleKey string, lock *UnifiedLock) error
        RemoveUnifiedLock(handleKey string, owner LockOwner, offset, length uint64) error
        ListUnifiedLocks(handleKey string) []*UnifiedLock
        RemoveFileUnifiedLocks(handleKey string)
        UpgradeLock(handleKey string, owner LockOwner, offset, length uint64) (*UnifiedLock, error)
        GetUnifiedLock(handleKey string, owner LockOwner, offset, length uint64) (*UnifiedLock, error)

        // Centralized break operations (replaces OplockChecker global)
        CheckAndBreakOpLocksForWrite(handleKey string, excludeOwner *LockOwner) error
        CheckAndBreakOpLocksForRead(handleKey string, excludeOwner *LockOwner) error
        CheckAndBreakOpLocksForDelete(handleKey string, excludeOwner *LockOwner) error

        // Legacy byte-range (backward compat for existing callers)
        Lock(handleKey string, lock FileLock) error
        Unlock(handleKey string, sessionID uint64, offset, length uint64) error
        TestLock(handleKey string, lock FileLock) (*LockConflict, error)
        ListLocks(handleKey string) []FileLock

        // Grace period (per user decision: part of LockManager)
        EnterGracePeriod(expectedClients []string)
        ExitGracePeriod()
        IsOperationAllowed(op Operation) (bool, error)
        MarkReclaimed(clientID string)
        IsInGracePeriod() bool

        // Break callbacks
        RegisterBreakCallbacks(callbacks BreakCallbacks)

        // Connection/cleanup
        RemoveAllLocks(handleKey string)
        RemoveClientLocks(clientID string)
        GetStats() ManagerStats
    }
    ```

    Verify `*Manager` (concrete type) satisfies `LockManager`:
    ```go
    var _ LockManager = (*Manager)(nil)
    ```

    **2. Implement centralized break operations on Manager:**
    Add `CheckAndBreakOpLocksForWrite`, `CheckAndBreakOpLocksForRead`, `CheckAndBreakOpLocksForDelete` methods to `*Manager`. These replace the global `OplockChecker` pattern:
    - Look up all UnifiedLocks for the handle
    - For each lock with an OpLock:
      - For write: if OpLock.State includes Read or Write, initiate break to None (or Read for read-only breaks)
      - For delete: break all oplocks on the handle
      - For read: if OpLock.State includes Write, break to Read
    - Call registered `BreakCallbacks.OnOpLockBreak()` for each break needed
    - Wait for break acknowledgment (use existing scanner/timeout pattern from OpLockBreakScanner)

    **3. Implement full ConflictsWith method:**
    In `types.go`, implement `ConflictsWith()` on `*UnifiedLock` handling all 4 cases per user decision:

    ```go
    func (ul *UnifiedLock) ConflictsWith(other *UnifiedLock) bool {
        // Same owner = no conflict
        if ul.Owner.OwnerID == other.Owner.OwnerID {
            return false
        }

        // Case 1: Access mode conflicts
        if accessModesConflict(ul.AccessMode, other.AccessMode) {
            return true
        }

        // Case 2: OpLock vs OpLock
        if ul.HasOpLock() && other.HasOpLock() {
            return OpLocksConflict(ul.OpLock, other.OpLock)
        }

        // Case 3: OpLock vs byte-range
        if ul.HasOpLock() != other.HasOpLock() {
            return opLockConflictsWithByteLock(ul, other)
        }

        // Case 4: Byte-range vs byte-range
        if !RangesOverlap(ul.Offset, ul.Length, other.Offset, other.Length) {
            return false
        }
        return !(ul.Type == LockTypeShared && other.Type == LockTypeShared)
    }
    ```

    Implement helper `accessModesConflict(a, b AccessMode) bool`:
    - `a` wants read + `b` denies read -> conflict
    - `a` wants write + `b` denies write -> conflict
    - `a` denies read + `b` wants read -> conflict
    - `a` denies write + `b` wants write -> conflict
    - `a` denies delete + `b` wants delete (or vice versa) -> conflict

    **4. Update AddUnifiedLock to use ConflictsWith:**
    In `manager.go`, update `AddUnifiedLock` to call `newLock.ConflictsWith(existing)` instead of the old standalone `IsEnhancedLockConflicting()` function. Remove the standalone function if it still exists.

    **5. Wire BreakCallbacks into Manager:**
    - Add `breakCallbacks []BreakCallbacks` field to Manager
    - Implement `RegisterBreakCallbacks(cb BreakCallbacks)` to append
    - When breaks are triggered (in CheckAndBreakOpLocks* and in AddUnifiedLock conflict path), iterate registered callbacks and dispatch typed events
    - NFS adapter will register `OnOpLockBreak` (for delegation recall)
    - SMB adapter will register all three callbacks
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs && go build ./pkg/metadata/lock/...</automated>
    <manual>Verify LockManager interface exists with all methods. ConflictsWith handles 4 cases. BreakCallbacks dispatched.</manual>
  </verify>
  <done>LockManager interface defined with unified CRUD + grace period + break callbacks. ConflictsWith handles all 4 conflict types. Centralized break operations replace OplockChecker. Manager satisfies LockManager interface.</done>
</task>

<task type="auto">
  <name>Task 2: Rewrite lock tests for new interface and conflict detection</name>
  <files>
    pkg/metadata/lock/manager_test.go
    pkg/metadata/lock/cross_protocol_test.go
    pkg/metadata/lock/oplock_test.go
    pkg/metadata/lock/oplock_break_test.go
  </files>
  <action>
    **1. Rewrite cross_protocol_test.go against new interface:**
    Per user decision: tests rewritten against new LockManager interface, not just renamed.
    - Test `ConflictsWith()` for all 4 cases:
      - OpLock vs OpLock: Read-Read (no conflict), Read-Write (conflict), Write-Write (conflict), Handle combinations
      - OpLock vs byte-range: Write oplock conflicts with any byte-range, Read oplock doesn't conflict with shared byte-range
      - Byte-range vs byte-range: overlapping exclusive (conflict), overlapping shared (no conflict), non-overlapping (no conflict)
      - AccessMode: DenyRead + AccessRead (conflict), DenyWrite + AccessWrite (conflict), DenyDelete (conflict), matching deny+access combos
    - Test `ConflictsWith()` same owner always returns false
    - Test centralized break: `CheckAndBreakOpLocksForWrite` triggers OnOpLockBreak callback
    - Test centralized break: `CheckAndBreakOpLocksForRead` only breaks Write oplocks
    - Test centralized break: `CheckAndBreakOpLocksForDelete` breaks all oplocks
    - Test cross-protocol scenario: NFS delegation (OpLock) broken by SMB write (via CheckAndBreak)

    **2. Rewrite manager_test.go for new API:**
    - Update all `AddEnhancedLock` calls -> `AddUnifiedLock`
    - Update all `RemoveEnhancedLock` calls -> `RemoveUnifiedLock`
    - Update lock construction to use `NewUnifiedLock()` with `OpLock` pointer
    - Test `RegisterBreakCallbacks` + verify callbacks invoked on conflict
    - Test LockManager interface compliance via interface variable

    **3. Update oplock_test.go (was lease_types_test.go):**
    - Rename test functions from `TestLeaseConflict*` -> `TestOpLockConflict*`
    - Update `LeaseInfo{}` construction -> `OpLock{}` with string GroupKey
    - Update `LeaseState*` constants -> `OpLockState` bitmask values
    - Test new union levels: `OpLockReadWrite`, `OpLockReadHandle`, `OpLockReadWriteHandle`

    **4. Update oplock_break_test.go (was lease_break_test.go):**
    - Update `LeaseBreakScanner` -> `OpLockBreakScanner`
    - Update callback types to use `BreakCallbacks` interface
    - Test that typed callbacks are dispatched correctly

    **5. Run full lock package tests:**
    - `go test -v ./pkg/metadata/lock/...`
    - Ensure all tests pass, no flaky tests
    - Verify test coverage for ConflictsWith is comprehensive (all 4 cases)
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs && go test -v ./pkg/metadata/lock/... 2>&1 | tail -40</automated>
    <manual>Verify cross-protocol tests cover all 4 conflict types. Manager tests use new API names.</manual>
  </verify>
  <done>Lock test suite rewritten against new LockManager interface. ConflictsWith tested for all 4 conflict cases. Centralized break operations tested. Cross-protocol scenarios verified. All lock tests pass.</done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles cleanly
2. `go test ./pkg/metadata/lock/...` passes all tests
3. `grep -rn 'type LockManager interface' pkg/metadata/lock/manager.go` confirms interface exists
4. `grep -rn 'func (ul \*UnifiedLock) ConflictsWith' pkg/metadata/lock/types.go` confirms method exists
5. `grep -rn 'OnOpLockBreak\|OnByteRangeRevoke\|OnAccessConflict' pkg/metadata/lock/oplock_break.go` confirms typed callbacks
6. `grep -rn 'CheckAndBreakOpLocksFor' pkg/metadata/lock/manager.go` confirms centralized break methods
7. Cross-protocol tests cover oplock-oplock, oplock-byterange, byterange-byterange, access mode conflicts
</verification>

<success_criteria>
- LockManager interface has unified CRUD + grace period + break callback registration + centralized break ops
- ConflictsWith method on UnifiedLock handles all 4 conflict cases correctly
- BreakCallbacks interface has 3 typed methods (OnOpLockBreak, OnByteRangeRevoke, OnAccessConflict)
- Centralized CheckAndBreakOpLocksFor{Write,Read,Delete} replaces OplockChecker global pattern
- All lock package tests rewritten and passing
- Cross-protocol conflict coverage is comprehensive
</success_criteria>

<output>
After completion, create `.planning/phases/26-generic-lock-interface-protocol-leak-purge/26-03-SUMMARY.md`
</output>
