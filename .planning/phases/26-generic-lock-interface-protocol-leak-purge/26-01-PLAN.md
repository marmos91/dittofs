---
phase: 26-generic-lock-interface-protocol-leak-purge
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/metadata/lock/types.go
  - pkg/metadata/lock/oplock.go
  - pkg/metadata/lock/oplock_break.go
  - pkg/metadata/lock/store.go
  - pkg/metadata/lock/errors.go
  - pkg/metadata/lock/cross_protocol.go
  - pkg/metadata/lock/manager.go
  - pkg/metadata/lock/lease_types.go
  - pkg/metadata/lock/lease_break.go
  - pkg/metadata/lock_exports.go
autonomous: true
requirements:
  - REF-01

must_haves:
  truths:
    - "UnifiedLock is a composed struct embedding OpLock (pointer, nil for byte-range) and AccessMode (bitmask)"
    - "OpLock type replaces LeaseInfo with opaque string GroupKey and OpLockState bitmask (Read/Write/Handle)"
    - "AccessMode replaces ShareReservation as a uint32 bitmask with 5 flags (AccessRead, AccessWrite, DenyRead, DenyWrite, DenyDelete)"
    - "All references to EnhancedLock, LeaseInfo, ShareReservation compile with new names"
    - "Manager uses AddUnifiedLock/RemoveUnifiedLock/ListUnifiedLocks API"
    - "PersistedLock uses new field names (OpLockGroupKey, OpLockState, AccessMode)"
    - "lock_exports.go re-exports all new types for backward compatibility"
  artifacts:
    - path: "pkg/metadata/lock/types.go"
      provides: "UnifiedLock composed struct, AccessMode bitmask, LockOwner"
      contains: "type UnifiedLock struct"
    - path: "pkg/metadata/lock/oplock.go"
      provides: "OpLock type, OpLockState bitmask, conflict helpers"
      contains: "type OpLock struct"
    - path: "pkg/metadata/lock/oplock_break.go"
      provides: "OpLockBreakScanner, break callbacks"
      contains: "type OpLockBreakScanner struct"
    - path: "pkg/metadata/lock/store.go"
      provides: "PersistedLock with new field names, LockQuery.IsOpLock"
      contains: "OpLockGroupKey"
    - path: "pkg/metadata/lock/manager.go"
      provides: "Manager with AddUnifiedLock, RemoveUnifiedLock, ListUnifiedLocks"
      contains: "func (m *Manager) AddUnifiedLock"
    - path: "pkg/metadata/lock_exports.go"
      provides: "Re-exports for new type names"
      contains: "UnifiedLock"
  key_links:
    - from: "pkg/metadata/lock/types.go"
      to: "pkg/metadata/lock/manager.go"
      via: "UnifiedLock used in manager maps and methods"
      pattern: "unifiedLocks.*UnifiedLock"
    - from: "pkg/metadata/lock/oplock.go"
      to: "pkg/metadata/lock/types.go"
      via: "OpLock embedded as pointer in UnifiedLock"
      pattern: "OpLock.*\\*OpLock"
    - from: "pkg/metadata/lock/store.go"
      to: "pkg/metadata/lock/types.go"
      via: "ToPersistedLock/FromPersistedLock conversion"
      pattern: "ToPersistedLock|FromPersistedLock"
---

<objective>
Rename lock types to protocol-agnostic names and restructure as composed types.

Purpose: Transform the lock type system from protocol-coupled names (EnhancedLock, LeaseInfo, ShareReservation) to protocol-agnostic names (UnifiedLock, OpLock, AccessMode) with composed struct design, enabling the rest of Phase 26 to build on clean abstractions.

Output: All lock package types renamed, manager API updated, persistence layer updated, all ~1100 type references across ~70 files compile with new names.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-generic-lock-interface-protocol-leak-purge/26-CONTEXT.md
@.planning/phases/26-generic-lock-interface-protocol-leak-purge/26-RESEARCH.md
@docs/GENERIC_LOCK_INTERFACE_PLAN.md
@pkg/metadata/lock/types.go
@pkg/metadata/lock/lease_types.go
@pkg/metadata/lock/lease_break.go
@pkg/metadata/lock/manager.go
@pkg/metadata/lock/store.go
@pkg/metadata/lock/errors.go
@pkg/metadata/lock/cross_protocol.go
@pkg/metadata/lock_exports.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define new type system (UnifiedLock, OpLock, AccessMode)</name>
  <files>
    pkg/metadata/lock/types.go
    pkg/metadata/lock/oplock.go
    pkg/metadata/lock/oplock_break.go
    pkg/metadata/lock/store.go
    pkg/metadata/lock/errors.go
  </files>
  <action>
    **1. Restructure types.go:**
    - Rename `EnhancedLock` to `UnifiedLock` as a composed struct:
      - Keep: ID, Owner, FileHandle, Offset, Length, Type, AcquiredAt, Blocking, Reclaim
      - Replace `ShareReservation ShareReservation` with `AccessMode AccessMode` (bitmask)
      - Replace all LeaseInfo-related fields with `OpLock *OpLock` (pointer, nil for byte-range)
      - Add `HasOpLock() bool` method
    - Rename `ShareReservation` type to `AccessMode` as `uint32` bitmask:
      - Constants: `AccessRead AccessMode = 0x01`, `AccessWrite = 0x02`, `DenyRead = 0x04`, `DenyWrite = 0x08`, `DenyDelete = 0x10`
      - Add `Has(flag AccessMode) bool` helper method
      - Remove old ShareReservation enum constants (DenyNone, DenyRead, DenyWrite, DenyAll)
    - Rename `IsEnhancedLockConflicting()` standalone function to `ConflictsWith()` method on `*UnifiedLock`
    - Keep `RangesOverlap()` as standalone utility
    - Rename all references within types.go (constructors like `NewEnhancedLock` -> `NewUnifiedLock`)

    **2. Create oplock.go (from lease_types.go):**
    - Rename file `lease_types.go` -> `oplock.go`
    - Rename `LeaseInfo` to `OpLock` struct:
      - `LeaseKey [16]byte` -> `GroupKey string` (opaque, protocol-agnostic)
      - `State LeaseState` -> `State OpLockState` (uint8 bitmask)
      - `Breaking bool`, `BreakToState` -> `BreakTarget OpLockState`, `BreakStarted time.Time` (keep)
      - `Epoch uint32` -> `StateVersion uint32`
      - `Reclaim bool` (keep)
      - Remove `Protocol` field if present (OpLock must be truly opaque per user decision)
    - Rename `LeaseState` constants to `OpLockState`:
      - `LeaseStateNone` -> `OpLockNone`
      - `LeaseStateRead` -> `OpLockRead OpLockState = 0x01`
      - `LeaseStateWrite` -> `OpLockWrite OpLockState = 0x02`
      - `LeaseStateHandle` -> `OpLockHandle OpLockState = 0x04`
      - Add union levels: `OpLockReadWrite = OpLockRead | OpLockWrite`, `OpLockReadHandle = OpLockRead | OpLockHandle`, `OpLockReadWriteHandle = OpLockRead | OpLockWrite | OpLockHandle`
    - Rename `LeasesConflict()` -> `OpLocksConflict()`
    - Rename `LeaseConflictsWithByteRangeLock()` -> `opLockConflictsWithByteLock()` (unexported, called from ConflictsWith)
    - Keep validation functions, update names

    **3. Create oplock_break.go (from lease_break.go):**
    - Rename file `lease_break.go` -> `oplock_break.go`
    - Rename `LeaseBreakScanner` -> `OpLockBreakScanner`
    - Rename `LeaseBreakCallback` -> `OpLockBreakCallback`
    - Define typed `BreakCallbacks` interface:
      ```go
      type BreakCallbacks interface {
          OnOpLockBreak(groupKey string, targetState OpLockState)
          OnByteRangeRevoke(handle FileHandle, offset, length uint64)
          OnAccessConflict(handle FileHandle, conflictingMode AccessMode)
      }
      ```
    - Update scanner to use `BreakCallbacks` interface instead of raw callback function

    **4. Update store.go (PersistedLock field renames):**
    - `ShareReservation int` -> `AccessMode int`
    - `LeaseKey []byte` -> `OpLockGroupKey string`
    - `LeaseState uint8` -> `OpLockState uint8`
    - `LeaseEpoch uint32` -> `OpLockStateVersion uint32`
    - `BreakToState uint8` -> `OpLockBreakTarget uint8`
    - `Breaking bool` -> `OpLockBreaking bool`
    - Add `IsOpLock() bool` method on PersistedLock
    - Rename `LockQuery` field: `IsLease` -> `IsOpLock`
    - Update `ToPersistedLock()` to handle new UnifiedLock -> PersistedLock mapping (including GroupKey string conversion)
    - Update `FromPersistedLock()` to handle new PersistedLock -> UnifiedLock mapping (including AccessMode bitmask conversion from old enum if needed)
    - Update JSON tags: `json:"lease_key"` -> `json:"oplock_group_key"`, etc.

    **5. Update errors.go:**
    - Rename `EnhancedLockConflict` param type and factory function
    - Update any `ShareReservation` or `LeaseInfo` references in error messages

    IMPORTANT: Do NOT delete the old lease_types.go and lease_break.go files yet -- they will be removed after references are updated in Task 2. At this stage, add temporary type aliases in the OLD files pointing to the NEW types to keep compilation working during transition:
    ```go
    // lease_types.go - temporary aliases
    type LeaseInfo = OpLock
    type LeaseState = OpLockState
    // ... etc
    ```
    Similarly for `EnhancedLock = UnifiedLock` and `ShareReservation = AccessMode` in types.go if needed for intermediate compilation.
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs && go build ./pkg/metadata/lock/...</automated>
    <manual>Verify types.go has UnifiedLock composed struct, oplock.go has OpLock type, AccessMode is bitmask</manual>
  </verify>
  <done>UnifiedLock, OpLock, AccessMode types defined with correct structure. PersistedLock fields renamed. Temporary aliases allow compilation.</done>
</task>

<task type="auto">
  <name>Task 2: Mechanical rename across all consumers and update manager API</name>
  <files>
    pkg/metadata/lock/manager.go
    pkg/metadata/lock/cross_protocol.go
    pkg/metadata/lock_exports.go
    pkg/metadata/lock/lease_types.go
    pkg/metadata/lock/lease_break.go
  </files>
  <action>
    **1. Update manager.go:**
    - Rename internal map: `enhancedLocks` -> `unifiedLocks`
    - Rename methods:
      - `AddEnhancedLock` -> `AddUnifiedLock`
      - `RemoveEnhancedLock` -> `RemoveUnifiedLock`
      - `ListEnhancedLocks` -> `ListUnifiedLocks`
      - `GetEnhancedLock` -> `GetUnifiedLock` (if exists)
      - `RemoveAllEnhancedLocks` -> `RemoveFileUnifiedLocks`
    - Update all internal references to use `UnifiedLock`, `OpLock`, `AccessMode`
    - Rename `LeaseBreakScanner` references -> `OpLockBreakScanner`
    - Update `CheckAndBreakLeases*` methods to use OpLock terminology internally

    **2. Update cross_protocol.go:**
    - Update type references from `EnhancedLock` -> `UnifiedLock`
    - Update `LeaseInfo` -> `OpLock` references
    - Update `ShareReservation` -> `AccessMode` references
    - Keep `TranslateToNLMHolder()` and `TranslateSMBConflictReason()` but update param/return types

    **3. Mechanical rename across ALL consumer files (outside lock package):**
    Use `grep -rn` to find every occurrence and update:
    - `EnhancedLock` -> `UnifiedLock` (~460 occurrences across ~71 files)
    - `AddEnhancedLock` -> `AddUnifiedLock`
    - `RemoveEnhancedLock` -> `RemoveUnifiedLock`
    - `ListEnhancedLocks` -> `ListUnifiedLocks`
    - `LeaseInfo` -> `OpLock` (careful: only the lock type, not generic words)
    - `LeaseState` (lock type) -> `OpLockState`
    - `LeaseBreakScanner` -> `OpLockBreakScanner`
    - `LeaseBreakCallback` -> `OpLockBreakCallback`
    - `ShareReservation` -> `AccessMode` (only the lock type)
    - `LeaseKey` (field) -> `GroupKey` or `OpLockGroupKey` depending on context
    - `LeasesConflict` -> `OpLocksConflict`
    - `IsEnhancedLockConflicting` -> replace call sites with `lock.ConflictsWith(other)`
    - `DenyNone`, `DenyRead` (old ShareReservation consts) -> appropriate AccessMode values

    Key consumer files to update:
    - `pkg/adapter/nfs/*.go` (NFS adapter)
    - `pkg/adapter/smb/*.go` (SMB adapter)
    - `internal/protocol/nfs/v3/handlers/*.go`
    - `internal/protocol/nfs/v4/handlers/*.go`
    - `internal/protocol/nfs/v4/state/*.go`
    - `pkg/metadata/service.go`
    - `pkg/metadata/file.go`
    - All test files referencing lock types

    **4. Update lock_exports.go:**
    - Replace all re-exported type aliases to use new names
    - `type EnhancedLock = lock.UnifiedLock` (keep old alias for transition)
    - Add new exports: `type UnifiedLock = lock.UnifiedLock`, `type OpLock = lock.OpLock`, `type AccessMode = lock.AccessMode`, `type OpLockState = lock.OpLockState`, `type OpLockBreakScanner = lock.OpLockBreakScanner`, `type BreakCallbacks = lock.BreakCallbacks`
    - Update function re-exports to use new names

    **5. Remove temporary alias files:**
    - Delete `lease_types.go` (content moved to oplock.go)
    - Delete `lease_break.go` (content moved to oplock_break.go)
    - Delete corresponding test files if they exist (`lease_types_test.go` -> rename to `oplock_test.go`, `lease_break_test.go` -> rename to `oplock_break_test.go`)

    CRITICAL: Use `sed` or similar for bulk renames, but manually verify each file afterward. The compiler will catch missed references -- iterate until `go build ./...` passes.
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs && go build ./... 2>&1 | head -50</automated>
    <manual>Verify no references to old type names remain (grep for EnhancedLock, LeaseInfo as type, ShareReservation)</manual>
  </verify>
  <done>All ~1100 type references updated. Manager uses AddUnifiedLock/RemoveUnifiedLock/ListUnifiedLocks. lock_exports.go re-exports new types. Old lease_types.go and lease_break.go deleted. Project compiles with `go build ./...`.</done>
</task>

<task type="auto">
  <name>Task 3: Run existing test suite and fix failures from rename</name>
  <files>
    pkg/metadata/lock/oplock_test.go
    pkg/metadata/lock/oplock_break_test.go
    pkg/metadata/lock/manager_test.go
    pkg/metadata/lock/store_test.go
    pkg/metadata/lock/cross_protocol_test.go
  </files>
  <action>
    **1. Rename test files:**
    - `lease_types_test.go` -> `oplock_test.go`
    - `lease_break_test.go` -> `oplock_break_test.go`
    - Update all type references in renamed test files

    **2. Fix test failures from type changes:**
    - Update test constructors: `NewEnhancedLock(...)` -> `NewUnifiedLock(...)`
    - Update `LeaseInfo{}` literal construction -> `OpLock{}` with string GroupKey (was [16]byte LeaseKey)
    - Update `ShareReservation` constants in tests -> `AccessMode` bitmask values
    - Update map key access: `enhancedLocks` -> `unifiedLocks`
    - Fix any PersistedLock JSON test fixtures for new field names

    **3. Fix AccessMode migration in FromPersistedLock:**
    - Old ShareReservation was enum (0=None, 1=DenyRead, 2=DenyWrite, 3=DenyAll)
    - New AccessMode is bitmask. Create `migrateShareReservation()` if needed for backward compat in deserialization
    - Or, since this is a clean break (per user decision), just use new bitmask values directly

    **4. Run full test suite:**
    - `go test ./pkg/metadata/lock/...` -- all lock package tests
    - `go test ./pkg/metadata/...` -- broader metadata tests
    - `go test ./pkg/adapter/...` -- adapter tests
    - `go test ./...` -- full project test suite
    - Fix any remaining failures

    IMPORTANT: Tests must pass before committing. If cross-protocol tests fail due to removed standalone `IsEnhancedLockConflicting()`, update call sites to use the method-based `ConflictsWith()` approach.
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs && go test ./... 2>&1 | tail -30</automated>
    <manual>Verify all lock tests pass, no test references old type names</manual>
  </verify>
  <done>All existing tests pass with renamed types. No references to old type names (EnhancedLock, LeaseInfo, ShareReservation) remain in test files. `go test ./...` passes.</done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles with zero errors
2. `go test ./...` passes with zero failures
3. `grep -rn 'EnhancedLock\|LeaseInfo\b' pkg/ internal/ --include='*.go' | grep -v '_test.go' | grep -v 'lock_exports.go'` returns no results (old names gone except backward-compat aliases)
4. `grep -rn 'type UnifiedLock struct' pkg/metadata/lock/types.go` confirms composed struct
5. `grep -rn 'type OpLock struct' pkg/metadata/lock/oplock.go` confirms renamed type
6. `grep -rn 'type AccessMode uint32' pkg/metadata/lock/types.go` confirms bitmask
</verification>

<success_criteria>
- UnifiedLock is a composed struct with *OpLock pointer and AccessMode bitmask
- OpLock replaces LeaseInfo with string GroupKey and OpLockState bitmask
- AccessMode replaces ShareReservation with 5-flag bitmask
- Manager API uses AddUnifiedLock/RemoveUnifiedLock/ListUnifiedLocks
- PersistedLock uses new field names in JSON tags
- lock_exports.go re-exports all new types
- All tests pass, project compiles
</success_criteria>

<output>
After completion, create `.planning/phases/26-generic-lock-interface-protocol-leak-purge/26-01-SUMMARY.md`
</output>
