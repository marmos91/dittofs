---
phase: 03-storage-management
plan: 03
type: execute
wave: 3
depends_on: ["03-01", "03-02"]
files_modified:
  - k8s/dittofs-operator/api/v1alpha1/dittoserver_webhook.go
  - k8s/dittofs-operator/api/v1alpha1/dittoserver_webhook_test.go
  - k8s/dittofs-operator/cmd/main.go
autonomous: false

must_haves:
  truths:
    - "Invalid StorageClass is rejected at CR creation time"
    - "Missing S3 credentials Secret triggers warning (not error)"
    - "Webhook has access to Kubernetes client for validation"
  artifacts:
    - path: "k8s/dittofs-operator/api/v1alpha1/dittoserver_webhook.go"
      provides: "StorageClass and S3 Secret validation"
      contains: "StorageClass"
    - path: "k8s/dittofs-operator/cmd/main.go"
      provides: "Custom webhook setup with client injection"
      contains: "SetupDittoServerWebhookWithManager"
  key_links:
    - from: "dittoserver_webhook.go"
      to: "storagev1.StorageClass"
      via: "client.Get lookup"
      pattern: "storagev1\\.StorageClass"
    - from: "cmd/main.go"
      to: "dittoserver_webhook.go"
      via: "SetupDittoServerWebhookWithManager call"
      pattern: "SetupDittoServerWebhookWithManager"
---

<objective>
Add StorageClass validation and S3 Secret validation to the webhook with client injection

Purpose: Catch configuration errors early by validating that referenced StorageClass exists and warning if S3 credentials Secret is missing. This prevents users from creating DittoServer resources that will fail to provision storage.

Output:
- DittoServerValidator type with client.Client field
- StorageClass existence validation (hard error if not found)
- S3 Secret existence warning (soft warning, not error)
- Custom webhook setup function with client injection
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-storage-management/03-RESEARCH.md
@.planning/phases/03-storage-management/03-01-SUMMARY.md
@.planning/phases/03-storage-management/03-02-SUMMARY.md
@k8s/dittofs-operator/api/v1alpha1/dittoserver_webhook.go
@k8s/dittofs-operator/cmd/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DittoServerValidator with client injection</name>
  <files>k8s/dittofs-operator/api/v1alpha1/dittoserver_webhook.go</files>
  <action>
Restructure the webhook to use a separate validator type with client access:

1. Add imports at the top:
```go
import (
    "context"
    "fmt"

    corev1 "k8s.io/api/core/v1"
    storagev1 "k8s.io/api/storage/v1"
    apierrors "k8s.io/apimachinery/pkg/api/errors"
    "k8s.io/apimachinery/pkg/runtime"
    "k8s.io/apimachinery/pkg/types"
    ctrl "sigs.k8s.io/controller-runtime"
    "sigs.k8s.io/controller-runtime/pkg/client"
    logf "sigs.k8s.io/controller-runtime/pkg/log"
    "sigs.k8s.io/controller-runtime/pkg/webhook"
    "sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)
```

2. Add DittoServerValidator struct (keep existing dittoserverlog):
```go
// DittoServerValidator implements webhook.CustomValidator with cluster client access.
// This enables validation of cluster resources like StorageClass and Secrets.
type DittoServerValidator struct {
    Client client.Client
}

var _ webhook.CustomValidator = &DittoServerValidator{}
```

3. Add new SetupDittoServerWebhookWithManager function (keep existing SetupWebhookWithManager for backward compat):
```go
// SetupDittoServerWebhookWithManager sets up the webhook with client injection for validation.
// This function should be used instead of SetupWebhookWithManager when cluster resource
// validation (StorageClass, Secrets) is needed.
func SetupDittoServerWebhookWithManager(mgr ctrl.Manager) error {
    validator := &DittoServerValidator{
        Client: mgr.GetClient(),
    }
    return ctrl.NewWebhookManagedBy(mgr).
        For(&DittoServer{}).
        WithValidator(validator).
        Complete()
}
```

4. Add validator methods to DittoServerValidator:
```go
// ValidateCreate implements webhook.CustomValidator
func (v *DittoServerValidator) ValidateCreate(ctx context.Context, obj runtime.Object) (admission.Warnings, error) {
    ds := obj.(*DittoServer)
    dittoserverlog.Info("validate create (with client)", "name", ds.Name)
    return v.validateDittoServerWithClient(ctx, ds)
}

// ValidateUpdate implements webhook.CustomValidator
func (v *DittoServerValidator) ValidateUpdate(ctx context.Context, oldObj, newObj runtime.Object) (admission.Warnings, error) {
    ds := newObj.(*DittoServer)
    dittoserverlog.Info("validate update (with client)", "name", ds.Name)
    return v.validateDittoServerWithClient(ctx, ds)
}

// ValidateDelete implements webhook.CustomValidator
func (v *DittoServerValidator) ValidateDelete(ctx context.Context, obj runtime.Object) (admission.Warnings, error) {
    // No validation needed for delete
    return nil, nil
}
```

5. Keep the existing DittoServer methods (ValidateCreate, ValidateUpdate, ValidateDelete, validateDittoServer, validatePorts) as they are for the default webhook path.
  </action>
  <verify>
Run:
```bash
cd k8s/dittofs-operator && go build ./...
grep "DittoServerValidator" api/v1alpha1/dittoserver_webhook.go
grep "SetupDittoServerWebhookWithManager" api/v1alpha1/dittoserver_webhook.go
```
Build should succeed, both DittoServerValidator and SetupDittoServerWebhookWithManager should exist.
  </verify>
  <done>DittoServerValidator struct exists with Client field, SetupDittoServerWebhookWithManager function exists</done>
</task>

<task type="auto">
  <name>Task 2: Implement StorageClass and S3 Secret validation</name>
  <files>k8s/dittofs-operator/api/v1alpha1/dittoserver_webhook.go</files>
  <action>
Add the validateDittoServerWithClient method that performs cluster-aware validation:

```go
// validateDittoServerWithClient performs validation that requires cluster access.
// This includes StorageClass validation and S3 Secret validation.
func (v *DittoServerValidator) validateDittoServerWithClient(ctx context.Context, ds *DittoServer) (admission.Warnings, error) {
    var warnings admission.Warnings

    // First, run all the standard validations (storage required, port conflicts, etc.)
    stdWarnings, err := ds.validateDittoServer()
    if err != nil {
        return stdWarnings, err
    }
    warnings = append(warnings, stdWarnings...)

    // Validate StorageClass if explicitly specified
    if ds.Spec.Storage.StorageClassName != nil && *ds.Spec.Storage.StorageClassName != "" {
        scName := *ds.Spec.Storage.StorageClassName
        storageClass := &storagev1.StorageClass{}
        err := v.Client.Get(ctx, types.NamespacedName{Name: scName}, storageClass)
        if err != nil {
            if apierrors.IsNotFound(err) {
                return warnings, fmt.Errorf("StorageClass %q does not exist in cluster", scName)
            }
            // Transient error - warn but allow (API server might be temporarily unavailable)
            warnings = append(warnings,
                fmt.Sprintf("Could not verify StorageClass %q exists: %v", scName, err))
        }
    }

    // Validate S3 credentials Secret if configured (warning only, not error)
    if ds.Spec.S3 != nil && ds.Spec.S3.CredentialsSecretRef != nil {
        secretName := ds.Spec.S3.CredentialsSecretRef.SecretName
        secret := &corev1.Secret{}
        err := v.Client.Get(ctx, types.NamespacedName{
            Name:      secretName,
            Namespace: ds.Namespace,
        }, secret)
        if err != nil {
            if apierrors.IsNotFound(err) {
                warnings = append(warnings,
                    fmt.Sprintf("S3 credentials Secret %q not found; ensure it exists before DittoFS pod starts", secretName))
            } else {
                warnings = append(warnings,
                    fmt.Sprintf("Could not verify S3 credentials Secret %q: %v", secretName, err))
            }
        } else {
            // Secret exists, validate it has required keys
            ref := ds.Spec.S3.CredentialsSecretRef
            accessKeyIDKey := ref.AccessKeyIDKey
            if accessKeyIDKey == "" {
                accessKeyIDKey = "accessKeyId"
            }
            secretAccessKeyKey := ref.SecretAccessKeyKey
            if secretAccessKeyKey == "" {
                secretAccessKeyKey = "secretAccessKey"
            }

            if _, ok := secret.Data[accessKeyIDKey]; !ok {
                warnings = append(warnings,
                    fmt.Sprintf("S3 credentials Secret %q missing key %q", secretName, accessKeyIDKey))
            }
            if _, ok := secret.Data[secretAccessKeyKey]; !ok {
                warnings = append(warnings,
                    fmt.Sprintf("S3 credentials Secret %q missing key %q", secretName, secretAccessKeyKey))
            }
        }
    }

    return warnings, nil
}
```

This validation:
- First runs all standard validations (existing validateDittoServer)
- Then validates StorageClass exists (hard error if not found)
- Then validates S3 Secret exists and has required keys (warnings only)
  </action>
  <verify>
Run:
```bash
cd k8s/dittofs-operator && go build ./...
grep "StorageClass" api/v1alpha1/dittoserver_webhook.go
grep "S3 credentials Secret" api/v1alpha1/dittoserver_webhook.go
```
Build should succeed, both StorageClass and S3 validation should exist.
  </verify>
  <done>StorageClass validation returns error if not found, S3 Secret validation returns warnings</done>
</task>

<task type="auto">
  <name>Task 3: Update main.go to use new webhook setup</name>
  <files>k8s/dittofs-operator/cmd/main.go</files>
  <action>
In cmd/main.go, replace the webhook setup call to use SetupDittoServerWebhookWithManager:

Find the line that looks like:
```go
if err = (&dittoiov1alpha1.DittoServer{}).SetupWebhookWithManager(mgr); err != nil {
```

Replace it with:
```go
if err = dittoiov1alpha1.SetupDittoServerWebhookWithManager(mgr); err != nil {
```

This switches from the receiver-style method (which doesn't have client access) to the new function that injects the client.
  </action>
  <verify>
Run:
```bash
cd k8s/dittofs-operator && go build ./...
grep "SetupDittoServerWebhookWithManager" cmd/main.go
```
Build should succeed, main.go should use SetupDittoServerWebhookWithManager.
  </verify>
  <done>main.go uses SetupDittoServerWebhookWithManager for client-aware validation</done>
</task>

<task type="auto">
  <name>Task 4: Add webhook validation tests</name>
  <files>k8s/dittofs-operator/api/v1alpha1/dittoserver_webhook_test.go</files>
  <action>
Add tests for the new validation logic. The test file should include:

1. Test for StorageClass validation (mock client returning NotFound)
2. Test for S3 Secret warning (mock client returning NotFound should NOT error)
3. Test for S3 Secret key validation (missing keys should warn)

Add these test cases to the existing test file:

```go
import (
    "context"
    "testing"

    storagev1 "k8s.io/api/storage/v1"
    metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
    "k8s.io/apimachinery/pkg/runtime"
    "sigs.k8s.io/controller-runtime/pkg/client"
    "sigs.k8s.io/controller-runtime/pkg/client/fake"
)

func TestStorageClassValidation(t *testing.T) {
    scheme := runtime.NewScheme()
    _ = storagev1.AddToScheme(scheme)
    _ = AddToScheme(scheme)

    // Create a fake client with no StorageClass
    fakeClient := fake.NewClientBuilder().WithScheme(scheme).Build()

    validator := &DittoServerValidator{Client: fakeClient}

    scName := "nonexistent-sc"
    ds := &DittoServer{
        ObjectMeta: metav1.ObjectMeta{
            Name:      "test-ds",
            Namespace: "default",
        },
        Spec: DittoServerSpec{
            Storage: StorageSpec{
                MetadataSize:     "10Gi",
                CacheSize:        "5Gi",
                StorageClassName: &scName,
            },
        },
    }

    _, err := validator.ValidateCreate(context.Background(), ds)
    if err == nil {
        t.Error("Expected error for nonexistent StorageClass, got nil")
    }
}

func TestS3SecretWarning(t *testing.T) {
    scheme := runtime.NewScheme()
    _ = storagev1.AddToScheme(scheme)
    _ = AddToScheme(scheme)

    // Create a fake client with no Secret
    fakeClient := fake.NewClientBuilder().WithScheme(scheme).Build()

    validator := &DittoServerValidator{Client: fakeClient}

    ds := &DittoServer{
        ObjectMeta: metav1.ObjectMeta{
            Name:      "test-ds",
            Namespace: "default",
        },
        Spec: DittoServerSpec{
            Storage: StorageSpec{
                MetadataSize: "10Gi",
                CacheSize:    "5Gi",
            },
            S3: &S3StoreConfig{
                CredentialsSecretRef: &S3CredentialsSecretRef{
                    SecretName: "nonexistent-secret",
                },
            },
        },
    }

    warnings, err := validator.ValidateCreate(context.Background(), ds)
    if err != nil {
        t.Errorf("S3 Secret not found should warn, not error: %v", err)
    }
    if len(warnings) == 0 {
        t.Error("Expected warning for missing S3 Secret")
    }
}
```

Run tests after adding.
  </action>
  <verify>
Run:
```bash
cd k8s/dittofs-operator && make test
grep "TestStorageClassValidation\|TestS3SecretWarning" api/v1alpha1/dittoserver_webhook_test.go
```
Tests should pass, both test functions should exist.
  </verify>
  <done>Webhook validation tests exist and pass for StorageClass and S3 Secret validation</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete storage management implementation:
1. Cache VolumeClaimTemplate (replaced EmptyDir)
2. S3 credentials Secret reference with env var injection
3. StorageClass validation in webhook
4. S3 Secret validation in webhook (warnings)
5. PVC retention policy (Retain/Retain)
  </what-built>
  <how-to-verify>
1. **Build verification**:
   ```bash
   cd k8s/dittofs-operator && make build
   ```

2. **Test verification**:
   ```bash
   cd k8s/dittofs-operator && make test
   ```

3. **CRD verification**:
   ```bash
   cat k8s/dittofs-operator/config/crd/bases/dittofs.dittofs.com_dittoservers.yaml | grep -A5 "cacheSize"
   cat k8s/dittofs-operator/config/crd/bases/dittofs.dittofs.com_dittoservers.yaml | grep -A20 "s3:"
   ```

4. **Controller verification** (no EmptyDir for cache):
   ```bash
   grep -n "EmptyDir" k8s/dittofs-operator/internal/controller/dittoserver_controller.go
   # Should return no results
   ```

5. **Optional: Local cluster test** (if cluster available):
   ```bash
   # Apply CRD
   kubectl apply -f k8s/dittofs-operator/config/crd/bases/

   # Try to create DittoServer with invalid StorageClass
   cat <<EOF | kubectl apply -f -
   apiVersion: dittofs.dittofs.com/v1alpha1
   kind: DittoServer
   metadata:
     name: test-invalid-sc
   spec:
     storage:
       metadataSize: "10Gi"
       cacheSize: "5Gi"
       storageClassName: "nonexistent-class"
   EOF
   # Should fail validation with "StorageClass does not exist"
   ```
  </how-to-verify>
  <resume-signal>Type "approved" if all checks pass, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Build and test**:
```bash
cd k8s/dittofs-operator && make build test
```
Both must succeed.

2. **Webhook client injection**:
```bash
grep "SetupDittoServerWebhookWithManager" k8s/dittofs-operator/cmd/main.go
grep "Client client.Client" k8s/dittofs-operator/api/v1alpha1/dittoserver_webhook.go
```
Both should exist.

3. **StorageClass validation**:
```bash
grep "StorageClass.*does not exist" k8s/dittofs-operator/api/v1alpha1/dittoserver_webhook.go
```
Error message should exist.

4. **S3 Secret warning**:
```bash
grep "S3 credentials Secret.*not found" k8s/dittofs-operator/api/v1alpha1/dittoserver_webhook.go
```
Warning message should exist.
</verification>

<success_criteria>
- DittoServerValidator struct exists with Client field
- SetupDittoServerWebhookWithManager function exists and is used in main.go
- StorageClass validation returns error if StorageClass not found
- S3 Secret validation returns warning (not error) if Secret not found
- S3 Secret key validation warns if required keys missing
- All webhook tests pass
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/03-storage-management/03-03-SUMMARY.md` using summary template.
</output>
