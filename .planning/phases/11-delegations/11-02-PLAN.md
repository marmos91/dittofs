---
phase: 11-delegations
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - internal/protocol/nfs/v4/state/callback.go
  - internal/protocol/nfs/v4/state/callback_test.go
autonomous: true

must_haves:
  truths:
    - "Server can parse NFSv4 universal address (uaddr) to host:port for TCP connection"
    - "Server can encode CB_COMPOUND containing CB_RECALL and send over TCP"
    - "Server can send CB_NULL to verify callback path is operational"
    - "Callback respects timeout and handles connection failures gracefully"
  artifacts:
    - path: "internal/protocol/nfs/v4/state/callback.go"
      provides: "ParseUniversalAddr, SendCBRecall, SendCBNull, CB_COMPOUND encoding"
      min_lines: 150
    - path: "internal/protocol/nfs/v4/state/callback_test.go"
      provides: "Unit tests for callback client"
      min_lines: 200
  key_links:
    - from: "internal/protocol/nfs/v4/state/callback.go"
      to: "internal/protocol/nlm/callback/client.go"
      via: "Reuses buildRPCCallMessage and addRecordMark patterns"
      pattern: "buildRPCCallMessage|addRecordMark"
    - from: "internal/protocol/nfs/v4/state/callback.go"
      to: "internal/protocol/nfs/v4/state/client.go"
      via: "Uses CallbackInfo struct for program number and address"
      pattern: "CallbackInfo"
---

<objective>
Implement the NFSv4 callback RPC client for sending CB_COMPOUND messages to clients.

Purpose: The callback client is the communication channel for delegation recall. When the server needs to recall a delegation, it sends a CB_COMPOUND message containing CB_RECALL to the client. This plan builds the callback infrastructure: universal address parsing, CB_COMPOUND/CB_RECALL XDR encoding, TCP connection management, and CB_NULL for path verification.

Output: callback.go with ParseUniversalAddr, SendCBRecall, SendCBNull, and supporting encode/decode functions. Comprehensive tests.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-delegations/11-RESEARCH.md
@.planning/phases/11-delegations/11-01-SUMMARY.md
@internal/protocol/nlm/callback/client.go
@internal/protocol/nfs/v4/state/client.go
@internal/protocol/nfs/v4/state/delegation.go
@internal/protocol/nfs/v4/types/constants.go
@internal/protocol/nfs/rpc/types.go
@internal/protocol/xdr/xdr.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Universal address parsing and CB_COMPOUND encoding</name>
  <files>
    internal/protocol/nfs/v4/state/callback.go
  </files>
  <action>
Create `internal/protocol/nfs/v4/state/callback.go` with the following functions. Follow the NLM callback client pattern from `internal/protocol/nlm/callback/client.go` closely.

1. **Constants:**
   ```go
   const (
       CBCallbackTimeout = 5 * time.Second  // Total timeout for callback operations
       rpcVersion        = 2                 // RPC version per RFC 5531
   )
   ```

2. **ParseUniversalAddr(netid, uaddr string) (string, int, error):**
   - For netid "tcp" (IPv4): uaddr format is "h1.h2.h3.h4.p1.p2"
     - Split from the RIGHT: last two dot-separated components are port bytes
     - host = everything before the last two dots
     - port = p1*256 + p2
     - Example: "10.1.3.7.2.15" -> host "10.1.3.7", port 527
   - For netid "tcp6" (IPv6): uaddr format is "h1:h2::h3.p1.p2"
     - Same logic: last two dot components are port bytes, rest is IPv6 host
     - Example: "fe80::1.2.15" -> host "fe80::1", port 527
   - Validate p1 and p2 are in range 0-255
   - Return clear error messages for malformed addresses
   - Use strings.LastIndex to parse from the right (handle IPv6 colons correctly)

3. **encodeCBCompound(callbackIdent uint32, ops []byte) []byte:**
   - Encodes CB_COMPOUND4args:
     - tag: empty utf8str_cs (WriteXDROpaque with empty bytes)
     - minorversion: uint32 = 0
     - callback_ident: uint32 (from SETCLIENTID)
     - argarray: the pre-encoded operations
   - Returns the complete args bytes

4. **encodeCBRecallOp(stateid *types.Stateid4, truncate bool, fh []byte) []byte:**
   - Encodes one nfs_cb_argop4 for CB_RECALL:
     - argop: uint32 = OP_CB_RECALL (4)
     - stateid4: encode via types.EncodeStateid4
     - truncate: bool as uint32 (0 or 1)
     - fh: nfs_fh4 as XDR opaque
   - Returns the encoded operation bytes

5. **encodeCBNullOp() []byte:**
   - Encodes the CB_NULL operation for path testing
   - Actually CB_NULL is procedure 0, not an operation in CB_COMPOUND
   - CB_NULL is sent as its own RPC call (procedure 0, no args, no result)
   - So this should be a separate path

6. **buildCBRPCCallMessage(xid, prog, vers, proc uint32, args []byte) ([]byte, error):**
   - Copy the pattern from NLM callback's buildRPCCallMessage exactly
   - XID, MsgType=CALL(0), RPCVersion=2, Program, Version, Procedure
   - AUTH_NULL credentials and verifier (flavor=0, length=0)
   - Procedure arguments appended

7. **addRecordMark(msg []byte, lastFragment bool) []byte:**
   - Copy from NLM callback directly (same RPC record marking)

8. **readAndValidateCBReply(conn net.Conn) error:**
   - Read 4-byte fragment header
   - Parse fragment length (mask off high bit)
   - Read fragment body
   - Parse RPC reply: skip XID(4) + msgType(4) + reply_stat(4)
   - Check accept_stat (position depends on verifier): if not 0 (SUCCESS), return error
   - For CB_COMPOUND: parse nfsstat4 from the response body to check for NFS4_OK
   - On any parse error, return error (don't panic)

9. **SendCBRecall(ctx context.Context, callback CallbackInfo, stateid *types.Stateid4, truncate bool, fh []byte) error:**
   - Parse universal address: `ParseUniversalAddr(callback.NetID, callback.Addr)`
   - Create TCP connection with timeout: `net.Dialer.DialContext(ctx, "tcp", host:port)`
   - Set deadline from context on connection
   - Encode CB_RECALL operation, wrap in CB_COMPOUND args
   - Build RPC CALL message (program=callback.Program, version=1, procedure=CB_PROC_COMPOUND=1)
   - Add record mark, write to connection
   - Read and validate reply
   - Close connection (deferred)
   - Return nil on success, wrapped error on failure

10. **SendCBNull(ctx context.Context, callback CallbackInfo) error:**
    - Parse universal address
    - Create TCP connection with timeout
    - Build RPC CALL message (program=callback.Program, version=1, procedure=CB_PROC_NULL=0, no args)
    - Add record mark, write to connection
    - Read and discard reply (same as NLM pattern)
    - Return nil on success, error on failure

Use `context.WithTimeout` with `CBCallbackTimeout` for both SendCBRecall and SendCBNull, matching the NLM pattern of 5s total timeout encompassing dial + I/O.
  </action>
  <verify>
    `cd /Users/marmos91/Projects/dittofs && go build ./internal/protocol/nfs/v4/state/` compiles cleanly.
    `go vet ./internal/protocol/nfs/v4/state/` passes.
  </verify>
  <done>
    callback.go exists with ParseUniversalAddr, SendCBRecall, SendCBNull, CB_COMPOUND encoding, and RPC message building. All functions follow the NLM callback pattern.
  </done>
</task>

<task type="auto">
  <name>Task 2: Callback client tests</name>
  <files>
    internal/protocol/nfs/v4/state/callback_test.go
  </files>
  <action>
Create `internal/protocol/nfs/v4/state/callback_test.go` with comprehensive tests:

**ParseUniversalAddr tests:**
- `TestParseUniversalAddr_IPv4`: "10.1.3.7.2.15" -> host "10.1.3.7", port 527
- `TestParseUniversalAddr_IPv4_HighPort`: "192.168.1.1.31.144" -> host "192.168.1.1", port 8080
- `TestParseUniversalAddr_IPv4_LowPort`: "127.0.0.1.0.111" -> host "127.0.0.1", port 111
- `TestParseUniversalAddr_IPv6`: "fe80::1.2.15" -> host "fe80::1", port 527
- `TestParseUniversalAddr_IPv6_Loopback`: "::1.0.111" -> host "::1", port 111
- `TestParseUniversalAddr_NoDots`: "invalid" -> error
- `TestParseUniversalAddr_OneDot`: "invalid.1" -> error (need at least host + 2 port components)
- `TestParseUniversalAddr_BadPortP1`: "10.1.3.7.abc.15" -> error
- `TestParseUniversalAddr_BadPortP2`: "10.1.3.7.2.xyz" -> error
- `TestParseUniversalAddr_PortOutOfRange`: "10.1.3.7.256.1" -> error (p1 > 255)

**CB_COMPOUND encoding tests:**
- `TestEncodeCBRecallOp`: encode a CB_RECALL op, verify wire format matches expected bytes
  - Verify OP_CB_RECALL (4) at start
  - Verify stateid4 encoded correctly (seqid + other)
  - Verify truncate bool
  - Verify file handle as XDR opaque
- `TestEncodeCBCompound`: encode full CB_COMPOUND args, verify tag + minorversion + callback_ident + array count + operations

**RPC message building tests:**
- `TestBuildCBRPCCallMessage`: build a message, verify XID, msg type, RPC version, program, version, procedure, AUTH_NULL cred/verf, args
- `TestAddRecordMark`: verify 4-byte header with last fragment bit and correct length

**Integration-style tests using a mock TCP server:**
- `TestSendCBRecall_Success`: start a goroutine listening on TCP, accept connection, read the CB_COMPOUND call, send a valid RPC reply with NFS4_OK, verify SendCBRecall returns nil
- `TestSendCBRecall_ConnectionRefused`: use unreachable address, verify error returned
- `TestSendCBRecall_Timeout`: start a listener that accepts but never responds, use short context timeout, verify error
- `TestSendCBNull_Success`: start mock server, verify CB_NULL call received and SendCBNull returns nil
- `TestSendCBNull_ConnectionRefused`: verify error on unreachable address

For mock TCP servers: use `net.Listen("tcp", "127.0.0.1:0")` to get a random port, run accept/respond in a goroutine. Build minimal valid RPC REPLY messages (XID echo, reply_stat=MSG_ACCEPTED, accept_stat=SUCCESS, plus CB_COMPOUND4res with NFS4_OK).

Run all tests with `-race` flag.
  </action>
  <verify>
    `cd /Users/marmos91/Projects/dittofs && go test -race -v ./internal/protocol/nfs/v4/state/ -run TestParse` passes all ParseUniversalAddr tests.
    `go test -race -v ./internal/protocol/nfs/v4/state/ -run TestEncode` passes encoding tests.
    `go test -race -v ./internal/protocol/nfs/v4/state/ -run TestSendCB` passes integration tests.
    `go test -race ./internal/protocol/nfs/v4/state/` passes all state tests.
  </verify>
  <done>
    15+ callback tests pass with race detection. ParseUniversalAddr handles IPv4, IPv6, edge cases. CB_COMPOUND encoding verified at byte level. SendCBRecall and SendCBNull tested with mock TCP servers including success, connection refused, and timeout scenarios.
  </done>
</task>

</tasks>

<verification>
1. `go build ./internal/protocol/nfs/v4/...` compiles without errors
2. `go test -race ./internal/protocol/nfs/v4/state/` passes all tests (delegation + callback)
3. `go vet ./internal/protocol/nfs/v4/...` reports no issues
4. ParseUniversalAddr correctly handles IPv4 and IPv6 universal addresses
5. CB_COMPOUND with CB_RECALL encodes correctly per RFC 7530 wire format
6. SendCBRecall successfully delivers callback to mock server
</verification>

<success_criteria>
- ParseUniversalAddr handles IPv4 "h1.h2.h3.h4.p1.p2" and IPv6 "h1::h2.p1.p2" formats
- CB_COMPOUND encoding includes tag, minorversion, callback_ident, and operation array
- CB_RECALL encoding includes stateid4, truncate bool, and file handle
- SendCBRecall creates TCP connection, sends framed RPC CALL, reads reply
- SendCBNull verifies callback path with lightweight RPC call
- All tests pass with -race
</success_criteria>

<output>
After completion, create `.planning/phases/11-delegations/11-02-SUMMARY.md`
</output>
