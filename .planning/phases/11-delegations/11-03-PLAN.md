---
phase: 11-delegations
plan: 03
type: execute
wave: 3
depends_on: ["11-01", "11-02"]
files_modified:
  - internal/protocol/nfs/v4/handlers/open.go
  - internal/protocol/nfs/v4/handlers/delegpurge.go
  - internal/protocol/nfs/v4/handlers/handler.go
  - internal/protocol/nfs/v4/state/manager.go
  - internal/protocol/nfs/v4/state/delegation.go
  - internal/protocol/nfs/v4/handlers/delegation_test.go
autonomous: true

must_haves:
  truths:
    - "OPEN grants read delegation when client has exclusive read access and callback path is up"
    - "OPEN grants write delegation when client has exclusive write access and callback path is up"
    - "OPEN with conflicting access triggers async CB_RECALL and returns NFS4ERR_DELAY"
    - "CLAIM_DELEGATE_CUR opens a file using an existing delegation stateid"
    - "DELEGPURGE purges all delegations for a client (or returns NFS4ERR_NOTSUPP)"
    - "No delegation granted when another client has opens on the same file"
    - "No delegation granted when callback address is empty"
  artifacts:
    - path: "internal/protocol/nfs/v4/handlers/open.go"
      provides: "Delegation conflict detection, grant decision, CLAIM_DELEGATE_CUR/PREV handling"
      min_lines: 50
    - path: "internal/protocol/nfs/v4/handlers/delegpurge.go"
      provides: "DELEGPURGE handler"
      min_lines: 20
    - path: "internal/protocol/nfs/v4/state/manager.go"
      provides: "ShouldGrantDelegation, RecallDelegation, CheckDelegationConflict methods"
      min_lines: 60
    - path: "internal/protocol/nfs/v4/handlers/delegation_test.go"
      provides: "Integration tests for delegation grant, recall, conflict"
      min_lines: 250
  key_links:
    - from: "internal/protocol/nfs/v4/handlers/open.go"
      to: "internal/protocol/nfs/v4/state/manager.go"
      via: "CheckDelegationConflict and ShouldGrantDelegation calls"
      pattern: "CheckDelegationConflict|ShouldGrantDelegation"
    - from: "internal/protocol/nfs/v4/state/manager.go"
      to: "internal/protocol/nfs/v4/state/callback.go"
      via: "RecallDelegation calls SendCBRecall asynchronously"
      pattern: "SendCBRecall"
    - from: "internal/protocol/nfs/v4/handlers/open.go"
      to: "internal/protocol/nfs/v4/state/delegation.go"
      via: "encodeDelegation encodes open_delegation4 in OPEN response"
      pattern: "encodeDelegation"
---

<objective>
Integrate delegation conflict detection and grant logic into the OPEN handler, implement CLAIM_DELEGATE_CUR/PREV support, and add the DELEGPURGE handler.

Purpose: This is the integration plan that wires delegations into the OPEN flow. After this plan, the server will grant read/write delegations when appropriate, detect conflicts and trigger CB_RECALL when a second client opens a delegated file, and handle CLAIM_DELEGATE_CUR opens. This connects the delegation state (Plan 11-01) and callback channel (Plan 11-02) into the main protocol flow.

Output: Modified OPEN handler with delegation grant/conflict logic, encodeDelegation helper, CLAIM_DELEGATE_CUR/PREV handlers, DELEGPURGE handler, ShouldGrantDelegation and RecallDelegation methods on StateManager, comprehensive integration tests.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-delegations/11-RESEARCH.md
@.planning/phases/11-delegations/11-01-SUMMARY.md
@.planning/phases/11-delegations/11-02-SUMMARY.md
@internal/protocol/nfs/v4/handlers/open.go
@internal/protocol/nfs/v4/handlers/handler.go
@internal/protocol/nfs/v4/state/manager.go
@internal/protocol/nfs/v4/state/delegation.go
@internal/protocol/nfs/v4/state/callback.go
@internal/protocol/nfs/v4/state/client.go
@internal/protocol/nfs/v4/types/constants.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: StateManager delegation grant, conflict detection, and recall methods</name>
  <files>
    internal/protocol/nfs/v4/state/manager.go
    internal/protocol/nfs/v4/state/delegation.go
  </files>
  <action>
Add the following methods to StateManager and supporting types to delegation.go.

1. **ShouldGrantDelegation(clientID uint64, fileHandle []byte, shareAccess uint32) (delegType uint32, grant bool):**
   - Acquires sm.mu.RLock (read lock sufficient for checking)
   - Check 1: Verify client exists and has a non-empty callback address (Callback.Addr != "")
     - If no callback info, return OPEN_DELEGATE_NONE, false
   - Check 2: Count opens on this file by OTHER clients via countOpensOnFile (from Plan 11-01)
     - If other clients have opens, return OPEN_DELEGATE_NONE, false (conflict imminent)
   - Check 3: Check for existing delegations on this file via delegByFile
     - If delegations exist from OTHER clients, return OPEN_DELEGATE_NONE, false
     - If same client already has a delegation, return OPEN_DELEGATE_NONE, false (avoid double-grant)
   - Check 4: Grant decision based on shareAccess:
     - If shareAccess includes OPEN4_SHARE_ACCESS_WRITE (bit 1): return OPEN_DELEGATE_WRITE, true
     - Otherwise: return OPEN_DELEGATE_READ, true
   - NOTE: This is the simple policy per research recommendation. No heuristics yet.

2. **CheckDelegationConflict(fileHandle []byte, clientID uint64, shareAccess uint32) (conflict bool, err error):**
   - Acquires sm.mu.Lock (write lock -- may need to mark RecallSent)
   - Look up delegByFile[string(fileHandle)]
   - For each delegation:
     - If delegation.ClientID == clientID: skip (same client, no conflict)
     - If delegation is already Revoked: skip
     - If delegation.DelegType == OPEN_DELEGATE_WRITE: any access by another client is a conflict
     - If delegation.DelegType == OPEN_DELEGATE_READ and shareAccess includes WRITE: conflict
     - If delegation.DelegType == OPEN_DELEGATE_READ and shareAccess is READ-only: no conflict (multiple readers allowed)
   - On conflict:
     - Mark delegation.RecallSent = true, delegation.RecallTime = time.Now()
     - Launch async goroutine: go sm.sendRecall(delegation) (non-blocking per Pitfall 2)
     - Return true, nil
   - No conflict: return false, nil

3. **sendRecall(deleg *DelegationState) (private method):**
   - Look up client record under sm.mu.RLock to get CallbackInfo
   - Release lock before network call (critical: do NOT hold lock during TCP)
   - Call SendCBRecall(context.Background(), callback, &deleg.Stateid, false, deleg.FileHandle)
   - If error: log at WARN level "CB_RECALL failed", mark deleg as needing revocation timer (Plan 11-04)
   - If success: log at DEBUG level "CB_RECALL sent successfully"

4. **Add encodeDelegation function to delegation.go:**
   - `func EncodeDelegation(buf *bytes.Buffer, deleg *DelegationState)` (exported, used by handlers)
   - If deleg == nil: write OPEN_DELEGATE_NONE (uint32 = 0) and return
   - Write deleg.DelegType (OPEN_DELEGATE_READ or OPEN_DELEGATE_WRITE)
   - Encode stateid4 via types.EncodeStateid4
   - Write recall: bool (uint32 = 0, not being recalled at grant time)
   - If OPEN_DELEGATE_WRITE: encode nfs_space_limit4 (NFS_LIMIT_SIZE=1, filesize=0xFFFFFFFFFFFFFFFF for unlimited)
   - Encode nfsace4: type=ACE4_ACCESS_ALLOWED_ACE_TYPE(0), flag=0
     - For READ: access_mask=ACE4_GENERIC_READ(0x00120081)
     - For WRITE: access_mask=ACE4_GENERIC_READ|ACE4_GENERIC_WRITE (0x001601BF per research)
     - who="EVERYONE@"

5. **ValidateDelegationStateid(stateid *types.Stateid4) (*DelegationState, error):**
   - Look up delegation by stateid.Other in delegByOther
   - Validate boot epoch
   - Return the DelegationState or appropriate error
   - Used by CLAIM_DELEGATE_CUR to verify the provided delegation stateid
  </action>
  <verify>
    `cd /Users/marmos91/Projects/dittofs && go build ./internal/protocol/nfs/v4/...` compiles cleanly.
    `go vet ./internal/protocol/nfs/v4/state/` passes.
  </verify>
  <done>
    ShouldGrantDelegation checks callback path, existing opens, and existing delegations before granting. CheckDelegationConflict detects conflicts and triggers async CB_RECALL without holding the lock during TCP. sendRecall delivers CB_RECALL via callback channel. EncodeDelegation produces correct open_delegation4 wire format with ACE. ValidateDelegationStateid validates delegation stateids for CLAIM_DELEGATE_CUR.
  </done>
</task>

<task type="auto">
  <name>Task 2: OPEN handler delegation integration, CLAIM_DELEGATE_CUR/PREV, DELEGPURGE handler, tests</name>
  <files>
    internal/protocol/nfs/v4/handlers/open.go
    internal/protocol/nfs/v4/handlers/delegpurge.go
    internal/protocol/nfs/v4/handlers/handler.go
    internal/protocol/nfs/v4/handlers/delegation_test.go
  </files>
  <action>
1. **Modify handleOpenClaimNull in open.go:**
   - After the OpenFile call succeeds and before encoding the result, add delegation conflict check and grant logic:
   ```
   // Check delegation conflicts (another client's delegation on this file)
   conflict, _ := h.StateManager.CheckDelegationConflict([]byte(fileHandle), clientID, shareAccess)
   if conflict {
       // A conflicting delegation exists -- recall has been triggered asynchronously.
       // Return NFS4ERR_DELAY so the client retries after the delegation holder returns it.
       return &types.CompoundResult{
           Status: types.NFS4ERR_DELAY,
           OpCode: types.OP_OPEN,
           Data:   encodeStatusOnly(types.NFS4ERR_DELAY),
       }
   }
   ```
   - IMPORTANT: The conflict check must happen AFTER OpenFile succeeds (state is created) but BEFORE encoding the response. If NFS4ERR_DELAY is returned, the open state should be cleaned up (call StateManager.CloseFile to roll back).
   - Actually, better approach per RFC: check for delegation conflict BEFORE calling OpenFile. If conflict, return NFS4ERR_DELAY without creating state. The client will retry the entire OPEN.

   - After conflict check passes, try to grant a delegation:
   ```
   delegType, shouldGrant := h.StateManager.ShouldGrantDelegation(clientID, []byte(fileHandle), shareAccess)
   var deleg *state.DelegationState
   if shouldGrant {
       deleg = h.StateManager.GrantDelegation(clientID, []byte(fileHandle), delegType)
   }
   ```
   - Pass the delegation to encodeOpenResult (needs signature change).

2. **Modify encodeOpenResult in open.go:**
   - Change signature to accept an optional `*state.DelegationState` parameter.
   - Replace the hardcoded `OPEN_DELEGATE_NONE` encoding with a call to `state.EncodeDelegation(buf, deleg)`.
   - When deleg is nil, EncodeDelegation writes OPEN_DELEGATE_NONE (same as current behavior).
   - Update all callers of encodeOpenResult:
     - handleOpenClaimNull: passes the delegation (or nil if not granted)
     - handleOpenClaimPrevious: passes nil for now (delegation reclaim uses different path)

3. **Implement CLAIM_DELEGATE_CUR in open.go:**
   - Replace the current CLAIM_DELEGATE_CUR case (which returns NFS4ERR_NOTSUPP) with a real handler.
   - CLAIM_DELEGATE_CUR args: stateid4 (delegation stateid) + component4 (filename)
   - Decode both args from reader
   - Validate the delegation stateid via StateManager.ValidateDelegationStateid
   - If invalid: return appropriate NFS4 error
   - If valid: proceed like CLAIM_NULL (lookup file, open, etc.) but skip delegation grant (client already has one) and skip conflict check (client is the delegation holder)
   - Create a new helper `handleOpenClaimDelegateCur` that reuses the CLAIM_NULL logic but with these differences

4. **Implement CLAIM_DELEGATE_PREV in open.go:**
   - Replace the current CLAIM_DELEGATE_PREV case (which returns NFS4ERR_NOTSUPP).
   - CLAIM_DELEGATE_PREV args: component4 (filename)
   - This is for reclaiming delegations after server restart during grace period.
   - For now, return NFS4ERR_NOTSUPP (matching DELEGPURGE). Full implementation requires persistent delegation state which is out of scope for Phase 11.
   - Must still consume the component4 arg from reader to prevent XDR desync.

5. **Create handlers/delegpurge.go:**
   - `handleDelegPurge(ctx *types.CompoundContext, reader io.Reader) *types.CompoundResult`
   - Decode DELEGPURGE4args: clientid4 (uint64)
   - Return NFS4ERR_NOTSUPP per research recommendation (paired with CLAIM_DELEGATE_PREV support level).
   - Since we don't support CLAIM_DELEGATE_PREV, DELEGPURGE is also not supported per RFC 7530 Section 16.7: "If DELEGPURGE is not supported, it SHOULD return NFS4ERR_NOTSUPP".

6. **Register new handlers in handler.go:**
   - Add `h.opDispatchTable[types.OP_DELEGPURGE] = h.handleDelegPurge` in the "Delegation operations" section

7. **Create handlers/delegation_test.go** with integration tests:
   - `TestOpen_GrantsReadDelegation`: Set up StateManager with one confirmed client with callback info. OPEN a file with READ access. Verify OPEN response includes OPEN_DELEGATE_READ with valid delegation stateid (type tag 0x03). Decode the full open_delegation4 from response and verify stateid, recall=false, ACE permissions.
   - `TestOpen_GrantsWriteDelegation`: Same setup, OPEN with WRITE access. Verify OPEN_DELEGATE_WRITE in response with space_limit.
   - `TestOpen_NoDelegation_NoCallback`: Client with empty callback address. OPEN a file. Verify OPEN_DELEGATE_NONE in response.
   - `TestOpen_NoDelegation_OtherClientHasOpens`: Two clients, first opens a file. Second client opens same file. Verify second client gets OPEN_DELEGATE_NONE.
   - `TestOpen_ConflictDetection_WriteDelegation`: Client A has write delegation. Client B opens same file. Verify Client B gets NFS4ERR_DELAY.
   - `TestOpen_ConflictDetection_ReadDelegWriteAccess`: Client A has read delegation. Client B opens same file with WRITE access. Verify NFS4ERR_DELAY.
   - `TestOpen_NoConflict_ReadDelegReadAccess`: Client A has read delegation. Client B opens same file with READ-only access. Verify no conflict (both can read).
   - `TestOpen_ClaimDelegateCur`: Client has delegation, opens file with CLAIM_DELEGATE_CUR providing delegation stateid. Verify success.
   - `TestOpen_ClaimDelegatePrev_NotSupported`: Verify NFS4ERR_NOTSUPP.
   - `TestDelegPurge_NotSupported`: Verify NFS4ERR_NOTSUPP and clientid consumed from args.

   For tests that need real OPEN to work, use the same test patterns from existing handler tests: create a Handler with mock runtime or nil runtime (pseudo-fs only tests), set up StateManager state directly, and verify response bytes.

   For conflict detection tests that involve CB_RECALL, use a mock TCP listener (from 11-02 pattern) or just verify the state-level behavior without actual TCP.

Run all tests with `-race` flag.
  </action>
  <verify>
    `cd /Users/marmos91/Projects/dittofs && go test -race -v ./internal/protocol/nfs/v4/handlers/ -run TestOpen_Grant` passes delegation grant tests.
    `go test -race -v ./internal/protocol/nfs/v4/handlers/ -run TestOpen_Conflict` passes conflict detection tests.
    `go test -race -v ./internal/protocol/nfs/v4/handlers/ -run TestDelegPurge` passes DELEGPURGE test.
    `go test -race ./internal/protocol/nfs/v4/handlers/` passes all handler tests.
    `go test -race ./internal/protocol/nfs/v4/...` passes all v4 tests.
  </verify>
  <done>
    OPEN handler grants read/write delegations based on ShouldGrantDelegation policy. Delegation conflict check triggers async CB_RECALL and returns NFS4ERR_DELAY. CLAIM_DELEGATE_CUR validates delegation stateid and opens file. CLAIM_DELEGATE_PREV returns NFS4ERR_NOTSUPP. DELEGPURGE returns NFS4ERR_NOTSUPP. 10+ integration tests pass with race detection covering grant, no-grant, conflict, and claim scenarios.
  </done>
</task>

</tasks>

<verification>
1. `go build ./internal/protocol/nfs/v4/...` compiles without errors
2. `go test -race ./internal/protocol/nfs/v4/state/` passes all state tests
3. `go test -race ./internal/protocol/nfs/v4/handlers/` passes all handler tests
4. `go vet ./internal/protocol/nfs/v4/...` reports no issues
5. OPEN with solo client access grants delegation (verified in tests)
6. OPEN with conflicting delegation returns NFS4ERR_DELAY (verified in tests)
7. CB_RECALL is triggered asynchronously without holding StateManager lock
8. DELEGPURGE returns NFS4ERR_NOTSUPP (verified in tests)
</verification>

<success_criteria>
- OPEN grants OPEN_DELEGATE_READ when client has exclusive read access and callback path is available
- OPEN grants OPEN_DELEGATE_WRITE when client has exclusive write access and callback path is available
- OPEN returns OPEN_DELEGATE_NONE when other clients have opens or callback path is down
- Conflicting OPEN triggers async CB_RECALL and returns NFS4ERR_DELAY to second client
- CLAIM_DELEGATE_CUR opens file using existing delegation stateid
- DELEGPURGE returns NFS4ERR_NOTSUPP
- All tests pass with -race
</success_criteria>

<output>
After completion, create `.planning/phases/11-delegations/11-03-SUMMARY.md`
</output>
