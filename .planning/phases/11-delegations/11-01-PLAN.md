---
phase: 11-delegations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/protocol/nfs/v4/state/delegation.go
  - internal/protocol/nfs/v4/state/delegation_test.go
  - internal/protocol/nfs/v4/state/manager.go
  - internal/protocol/nfs/v4/handlers/delegreturn.go
  - internal/protocol/nfs/v4/handlers/handler.go
  - internal/protocol/nfs/v4/types/constants.go
autonomous: true

must_haves:
  truths:
    - "Delegation state can be created and tracked per (clientID, fileHandle)"
    - "Delegation stateids use type tag 0x03 and are unique across server restarts"
    - "DELEGRETURN removes delegation state and returns NFS4_OK"
    - "Lease expiry cleans up all delegations for the expired client"
    - "Double DELEGRETURN is idempotent (NFS4_OK on already-returned)"
  artifacts:
    - path: "internal/protocol/nfs/v4/state/delegation.go"
      provides: "DelegationState struct, delegation maps, GrantDelegation, ReturnDelegation methods"
      min_lines: 80
    - path: "internal/protocol/nfs/v4/state/delegation_test.go"
      provides: "Unit tests for delegation state lifecycle"
      min_lines: 150
    - path: "internal/protocol/nfs/v4/handlers/delegreturn.go"
      provides: "DELEGRETURN handler"
      min_lines: 30
  key_links:
    - from: "internal/protocol/nfs/v4/state/delegation.go"
      to: "internal/protocol/nfs/v4/state/manager.go"
      via: "delegByOther and delegByFile maps added to StateManager"
      pattern: "delegByOther|delegByFile"
    - from: "internal/protocol/nfs/v4/handlers/delegreturn.go"
      to: "internal/protocol/nfs/v4/state/manager.go"
      via: "StateManager.ReturnDelegation call"
      pattern: "ReturnDelegation"
    - from: "internal/protocol/nfs/v4/state/manager.go"
      to: "internal/protocol/nfs/v4/state/delegation.go"
      via: "onLeaseExpired delegation cleanup cascade"
      pattern: "delegByOther|delegByFile"
---

<objective>
Implement delegation state tracking in StateManager and the DELEGRETURN handler.

Purpose: Establish the data model and lifecycle for NFSv4 delegations. This plan creates the DelegationState type, adds delegation maps to StateManager, implements GrantDelegation/ReturnDelegation methods, adds delegation cleanup to lease expiry, and registers the DELEGRETURN handler.

Output: DelegationState type, StateManager delegation maps and methods, DELEGRETURN handler, delegation cleanup in onLeaseExpired, unit tests.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-delegations/11-RESEARCH.md
@internal/protocol/nfs/v4/state/manager.go
@internal/protocol/nfs/v4/state/client.go
@internal/protocol/nfs/v4/state/stateid.go
@internal/protocol/nfs/v4/state/openowner.go
@internal/protocol/nfs/v4/handlers/handler.go
@internal/protocol/nfs/v4/handlers/stubs.go
@internal/protocol/nfs/v4/types/constants.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: DelegationState type and StateManager delegation methods</name>
  <files>
    internal/protocol/nfs/v4/state/delegation.go
    internal/protocol/nfs/v4/state/manager.go
    internal/protocol/nfs/v4/types/constants.go
  </files>
  <action>
Create `internal/protocol/nfs/v4/state/delegation.go` with:

1. **DelegationState struct:**
   ```go
   type DelegationState struct {
       Stateid    types.Stateid4
       ClientID   uint64
       FileHandle []byte
       DelegType  uint32  // OPEN_DELEGATE_READ or OPEN_DELEGATE_WRITE
       RecallSent bool
       RecallTime time.Time
       Revoked    bool
   }
   ```

2. **Add two new maps to StateManager** in `manager.go`:
   - `delegByOther map[[types.NFS4_OTHER_SIZE]byte]*DelegationState` -- primary lookup by stateid other
   - `delegByFile map[string][]*DelegationState` -- conflict detection by file handle (string key)
   - Initialize both in `NewStateManager`

3. **GrantDelegation method on StateManager:**
   - Takes clientID, fileHandle []byte, delegType uint32
   - Generates stateid via `sm.generateStateidOther(StateTypeDeleg)` (0x03 already defined)
   - Creates DelegationState, stores in both maps
   - Returns the DelegationState (caller uses for response encoding)
   - Caller must NOT hold sm.mu (method acquires it)

4. **ReturnDelegation method on StateManager:**
   - Takes *types.Stateid4
   - Looks up by stateid.Other in delegByOther
   - Validates boot epoch via isCurrentEpoch
   - Removes from both delegByOther and delegByFile
   - Returns nil on success
   - If not found: check isCurrentEpoch for stale vs bad stateid errors
   - If already returned/revoked: return NFS4_OK (idempotent, per Pitfall 3 from research)

5. **GetDelegationsForFile method on StateManager:**
   - Takes fileHandle []byte, returns []*DelegationState
   - Read-lock lookup in delegByFile (used by conflict detection in Plan 11-03)

6. **CountOpensOnFile helper** (private, caller holds sm.mu):
   - Iterates openStateByOther, counts opens on the given file handle that belong to clients OTHER than the specified clientID
   - Used later for grant decisions

7. **Modify onLeaseExpired in manager.go:**
   - After the existing lock/open cleanup loop, add delegation cleanup:
   - Iterate delegByOther, find all entries where ClientID matches the expired client
   - Delete from delegByOther and from delegByFile (remove from the slice)
   - Log at INFO level: "delegation revoked on lease expiry"

8. **Add constants to types/constants.go** (only if missing):
   ```go
   // Callback operation numbers
   OP_CB_GETATTR  uint32 = 3
   OP_CB_RECALL   uint32 = 4

   // Callback program
   NFS4_CALLBACK_VERSION uint32 = 1
   CB_PROC_NULL          uint32 = 0
   CB_PROC_COMPOUND      uint32 = 1

   // ACE constants for delegation permissions
   ACE4_ACCESS_ALLOWED_ACE_TYPE uint32 = 0
   ACE4_GENERIC_READ            uint32 = 0x00120081
   ACE4_GENERIC_WRITE           uint32 = 0x00160106

   // Space limit
   NFS_LIMIT_SIZE   uint32 = 1
   NFS_LIMIT_BLOCKS uint32 = 2
   ```

9. **Add ErrGrace and ErrNoGrace error references** if needed by delegation grant check (already exist from Phase 9).

The pattern follows the existing OpenState and LockState lifecycle in StateManager. Use the same single RWMutex (sm.mu) for thread safety.
  </action>
  <verify>
    `cd /Users/marmos91/Projects/dittofs && go build ./internal/protocol/nfs/v4/...` compiles cleanly.
    `go vet ./internal/protocol/nfs/v4/state/` passes.
  </verify>
  <done>
    DelegationState type defined with all fields. StateManager has delegByOther and delegByFile maps initialized. GrantDelegation creates and stores delegation state with type-0x03 stateids. ReturnDelegation removes delegation state idempotently. GetDelegationsForFile returns delegations for a file. onLeaseExpired cleans up delegations for expired clients. New callback and ACE constants added.
  </done>
</task>

<task type="auto">
  <name>Task 2: DELEGRETURN handler and unit tests</name>
  <files>
    internal/protocol/nfs/v4/handlers/delegreturn.go
    internal/protocol/nfs/v4/handlers/handler.go
    internal/protocol/nfs/v4/state/delegation_test.go
  </files>
  <action>
1. **Create `handlers/delegreturn.go`:**
   - `handleDelegReturn(ctx *types.CompoundContext, reader io.Reader) *types.CompoundResult`
   - Require current filehandle (RequireCurrentFH)
   - Decode DELEGRETURN4args: `stateid4` via `types.DecodeStateid4(reader)`
   - Call `h.StateManager.ReturnDelegation(stateid)`
   - On error: map via `mapOpenStateError` and return error result
   - On success: return NFS4_OK status-only response
   - Follow exact pattern of existing handlers (handleClose, handleReleaseLockOwner)

2. **Register in `handler.go`:**
   - Add `h.opDispatchTable[types.OP_DELEGRETURN] = h.handleDelegReturn` in NewHandler
   - Place it in the "Lock operations" or a new "Delegation operations" section comment

3. **Create `state/delegation_test.go`** with comprehensive tests:
   - `TestGrantDelegation_Read`: grant read delegation, verify stateid has type tag 0x03, verify stored in both maps
   - `TestGrantDelegation_Write`: grant write delegation, verify stored correctly
   - `TestReturnDelegation_Success`: grant then return, verify maps are empty
   - `TestReturnDelegation_NotFound`: return with unknown stateid, verify appropriate error
   - `TestReturnDelegation_StaleStateid`: return with stale epoch, verify NFS4ERR_STALE_STATEID
   - `TestReturnDelegation_Idempotent`: return same delegation twice, second should succeed (NFS4_OK)
   - `TestGetDelegationsForFile`: grant multiple delegations on same file, verify all returned
   - `TestGetDelegationsForFile_Empty`: query file with no delegations, verify empty
   - `TestLeaseExpiry_CleansDelegations`: set up client with delegation, expire lease, verify delegation removed from both maps
   - `TestLeaseExpiry_MultipleClients`: multiple clients with delegations, expire one, verify only that client's delegations removed
   - `TestCountOpensOnFile`: create open states on a file, verify count excludes requesting client
   - `TestDelegationStateidTypeTag`: verify generated delegation stateids have byte[0] == 0x03

   Use the same test patterns as existing tests in state/ (create StateManager with short lease, manipulate state, assert).

4. **Add DELEGRETURN handler test** (can be in delegation_test.go or a handlers test file):
   - Test DELEGRETURN with valid delegation stateid -> NFS4_OK
   - Test DELEGRETURN with bad stateid -> NFS4ERR_BAD_STATEID
   - Test DELEGRETURN after delegation already returned -> NFS4_OK (idempotent)

Run all tests with `-race` flag.
  </action>
  <verify>
    `cd /Users/marmos91/Projects/dittofs && go test -race -v ./internal/protocol/nfs/v4/state/ -run TestDelegation` passes all delegation tests.
    `go test -race -v ./internal/protocol/nfs/v4/state/ -run TestLeaseExpiry` passes lease expiry delegation cleanup test.
    `go test -race ./internal/protocol/nfs/v4/handlers/` passes (including new DELEGRETURN tests).
    `go test -race ./internal/protocol/nfs/v4/...` passes all v4 tests.
  </verify>
  <done>
    DELEGRETURN handler registered and working. 12+ delegation tests pass with race detection. Grant, return, idempotent return, stale stateid, lease expiry cleanup all verified. Delegation stateid type tag is 0x03.
  </done>
</task>

</tasks>

<verification>
1. `go build ./internal/protocol/nfs/v4/...` compiles without errors
2. `go test -race ./internal/protocol/nfs/v4/state/` passes all tests including new delegation tests
3. `go test -race ./internal/protocol/nfs/v4/handlers/` passes all tests including DELEGRETURN
4. `go vet ./internal/protocol/nfs/v4/...` reports no issues
5. Delegation stateids have type tag 0x03 (verified in tests)
6. Lease expiry cleans up delegation state (verified in tests)
</verification>

<success_criteria>
- DelegationState type and StateManager maps exist and are thread-safe
- GrantDelegation creates delegation state with type-0x03 stateids
- ReturnDelegation removes state idempotently
- DELEGRETURN handler registered in dispatch table and tested
- Lease expiry cascading cleanup includes delegations
- All tests pass with -race
</success_criteria>

<output>
After completion, create `.planning/phases/11-delegations/11-01-SUMMARY.md`
</output>
