---
phase: 06-nfsv4-protocol-foundation
plan: 03
type: execute
wave: 3
depends_on: ["06-02"]
files_modified:
  - internal/protocol/nfs/v4/handlers/putfh.go
  - internal/protocol/nfs/v4/handlers/putrootfh.go
  - internal/protocol/nfs/v4/handlers/putpubfh.go
  - internal/protocol/nfs/v4/handlers/getfh.go
  - internal/protocol/nfs/v4/handlers/savefh.go
  - internal/protocol/nfs/v4/handlers/restorefh.go
  - internal/protocol/nfs/v4/handlers/lookup.go
  - internal/protocol/nfs/v4/handlers/lookupp.go
  - internal/protocol/nfs/v4/handlers/getattr.go
  - internal/protocol/nfs/v4/handlers/readdir.go
  - internal/protocol/nfs/v4/handlers/access.go
  - internal/protocol/nfs/v4/handlers/illegal.go
  - internal/protocol/nfs/v4/handlers/setclientid.go
  - internal/protocol/nfs/v4/handlers/handler.go
  - internal/protocol/nfs/v4/handlers/ops_test.go
autonomous: true

must_haves:
  truths:
    - "PUTFH sets current filehandle from client-provided opaque handle"
    - "PUTROOTFH sets current filehandle to pseudo-fs root"
    - "PUTPUBFH sets current filehandle to pseudo-fs root (same as PUTROOTFH)"
    - "GETFH returns the current filehandle"
    - "SAVEFH saves current filehandle to saved slot"
    - "RESTOREFH restores saved filehandle to current slot"
    - "LOOKUP traverses pseudo-fs by name, setting current FH to child"
    - "LOOKUP on export junction transitions from pseudo-fs to real share root handle"
    - "LOOKUPP navigates to parent directory"
    - "GETATTR returns requested attributes for pseudo-fs nodes"
    - "READDIR lists children of pseudo-fs directory nodes"
    - "ACCESS returns full access mask for pseudo-fs directories"
    - "ILLEGAL returns NFS4ERR_OP_ILLEGAL"
    - "SETCLIENTID stub returns NFS4_OK with generated client ID"
    - "Operations requiring current FH return NFS4ERR_NOFILEHANDLE when none set"
  artifacts:
    - path: "internal/protocol/nfs/v4/handlers/putfh.go"
      provides: "PUTFH operation handler"
      contains: "handlePutFH"
    - path: "internal/protocol/nfs/v4/handlers/lookup.go"
      provides: "LOOKUP operation with pseudo-fs awareness"
      contains: "handleLookup"
    - path: "internal/protocol/nfs/v4/handlers/getattr.go"
      provides: "GETATTR operation for pseudo-fs nodes"
      contains: "handleGetAttr"
    - path: "internal/protocol/nfs/v4/handlers/readdir.go"
      provides: "READDIR operation for pseudo-fs directories"
      contains: "handleReadDir"
    - path: "internal/protocol/nfs/v4/handlers/setclientid.go"
      provides: "SETCLIENTID/SETCLIENTID_CONFIRM stubs"
      contains: "handleSetClientID"
    - path: "internal/protocol/nfs/v4/handlers/ops_test.go"
      provides: "Unit tests for all operation handlers"
      contains: "TestPutRootFH"
  key_links:
    - from: "internal/protocol/nfs/v4/handlers/lookup.go"
      to: "internal/protocol/nfs/v4/pseudofs/"
      via: "PseudoFS.LookupChild for pseudo-fs traversal"
      pattern: "PseudoFS.*LookupChild"
    - from: "internal/protocol/nfs/v4/handlers/getattr.go"
      to: "internal/protocol/nfs/v4/attrs/"
      via: "EncodePseudoFSAttrs for attribute encoding"
      pattern: "attrs\\.EncodePseudoFSAttrs"
    - from: "internal/protocol/nfs/v4/handlers/handler.go"
      to: "all handler files"
      via: "dispatch table registration in NewHandler"
      pattern: "OP_.*handlePut|handleLookup|handleGetAttr"
---

<objective>
Implement all Phase 6 NFSv4 operation handlers: filehandle management (PUTFH, PUTROOTFH, PUTPUBFH, GETFH, SAVEFH, RESTOREFH), pseudo-fs traversal (LOOKUP, LOOKUPP, GETATTR, READDIR, ACCESS), protocol operations (ILLEGAL), and client setup stubs (SETCLIENTID, SETCLIENTID_CONFIRM).

Purpose: Complete the NFSv4 skeleton so that an NFSv4 client can perform basic namespace browsing (mount root, list exports, traverse into pseudo-fs). Real file operations (READ, WRITE, CREATE, etc.) remain NFS4ERR_NOTSUPP for Phase 7.
Output: 14 handler files registered in the COMPOUND dispatch table, with comprehensive unit tests.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-nfsv4-protocol-foundation/06-RESEARCH.md
@.planning/phases/06-nfsv4-protocol-foundation/06-CONTEXT.md
@.planning/phases/06-nfsv4-protocol-foundation/06-01-SUMMARY.md
@.planning/phases/06-nfsv4-protocol-foundation/06-02-SUMMARY.md
@internal/protocol/nfs/v4/types/
@internal/protocol/nfs/v4/attrs/
@internal/protocol/nfs/v4/pseudofs/
@internal/protocol/nfs/v4/handlers/handler.go
@internal/protocol/nfs/v4/handlers/compound.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Filehandle and pseudo-fs traversal operation handlers</name>
  <files>
    internal/protocol/nfs/v4/handlers/putfh.go
    internal/protocol/nfs/v4/handlers/putrootfh.go
    internal/protocol/nfs/v4/handlers/putpubfh.go
    internal/protocol/nfs/v4/handlers/getfh.go
    internal/protocol/nfs/v4/handlers/savefh.go
    internal/protocol/nfs/v4/handlers/restorefh.go
    internal/protocol/nfs/v4/handlers/lookup.go
    internal/protocol/nfs/v4/handlers/lookupp.go
    internal/protocol/nfs/v4/handlers/getattr.go
    internal/protocol/nfs/v4/handlers/readdir.go
    internal/protocol/nfs/v4/handlers/access.go
    internal/protocol/nfs/v4/handlers/illegal.go
    internal/protocol/nfs/v4/handlers/setclientid.go
    internal/protocol/nfs/v4/handlers/handler.go
  </files>
  <action>
    Create one handler per file, each implementing the `OpHandler` signature: `func(ctx *types.CompoundContext, reader io.Reader) *types.CompoundResult`. Each handler reads its own args from the reader and returns an XDR-encoded result in CompoundResult.Data.

    All handlers that need a current filehandle must call `types.RequireCurrentFH(ctx)` first and return NFS4ERR_NOFILEHANDLE if not set.

    **putfh.go** — `handlePutFH`:
    - Read opaque filehandle from reader (XDR opaque: uint32 length + bytes + padding)
    - Validate handle length <= NFS4_FHSIZE (128 bytes)
    - Set `ctx.CurrentFH = handle`
    - Encode result: status only (uint32 NFS4_OK)

    **putrootfh.go** — `handlePutRootFH`:
    - No args to read
    - Set `ctx.CurrentFH = h.PseudoFS.GetRootHandle()`
    - Encode result: status only (uint32 NFS4_OK)

    **putpubfh.go** — `handlePutPubFH`:
    - Same as PUTROOTFH per locked decision "PUTPUBFH = PUTROOTFH = pseudo-fs root"
    - Set `ctx.CurrentFH = h.PseudoFS.GetRootHandle()`
    - Encode result: status only

    **getfh.go** — `handleGetFH`:
    - Requires current FH
    - No args to read
    - Encode result: status (NFS4_OK) + current filehandle as XDR opaque

    **savefh.go** — `handleSaveFH`:
    - Requires current FH
    - No args to read
    - Set `ctx.SavedFH = copy of ctx.CurrentFH` (make a copy to avoid aliasing)
    - Encode result: status only

    **restorefh.go** — `handleRestoreFH`:
    - Check saved FH: if nil, return NFS4ERR_RESTOREFH
    - Set `ctx.CurrentFH = copy of ctx.SavedFH`
    - Encode result: status only

    **lookup.go** — `handleLookup`:
    - Requires current FH
    - Read component name from reader (XDR string: uint32 length + bytes + padding)
    - Validate filename with `types.ValidateUTF8Filename(name)`, return error code if invalid
    - Check if current FH is a pseudo-fs handle (`pseudofs.IsPseudoFSHandle`):
      - If yes: look up name in pseudo-fs via `h.PseudoFS.LookupChild(node, name)`
        - If child found and child.IsExport: get real share root handle from runtime.GetShareRootHandle(ctx.Context, child.ShareName). Set `ctx.CurrentFH = realHandle`. This is the "junction crossing" — transitioning from pseudo-fs to real share.
        - If child found and NOT IsExport: set `ctx.CurrentFH = child.Handle` (stay in pseudo-fs)
        - If child not found: return NFS4ERR_NOENT
      - If no (real handle): For Phase 6, return NFS4ERR_NOTSUPP (real LOOKUP implemented in Phase 7)
    - Encode result: status only (NFS4_OK or error)

    **lookupp.go** — `handleLookupP`:
    - Requires current FH
    - No args to read
    - Check if current FH is pseudo-fs handle:
      - If yes: look up parent via `h.PseudoFS.LookupParent(node)`. Set `ctx.CurrentFH = parent.Handle`
      - If no: For Phase 6, return NFS4ERR_NOTSUPP
    - Encode result: status only

    **getattr.go** — `handleGetAttr`:
    - Requires current FH
    - Read requested attrs bitmap from reader using `attrs.DecodeBitmap4`
    - Check if current FH is pseudo-fs handle:
      - If yes: look up node, encode attributes using `attrs.EncodePseudoFSAttrs(buf, requested, node)`. Encode result: status (NFS4_OK) + response bitmap + attr values as opaque data.
      - If no: For Phase 6, return NFS4ERR_NOTSUPP (real GETATTR in Phase 7)
    - GETATTR response XDR format: status(uint32) + bitmap4(attrmask) + opaque(attrvals)

    **readdir.go** — `handleReadDir`:
    - Requires current FH
    - Read args: cookie (uint64), cookieverf (8 bytes), dircount (uint32), maxcount (uint32), attr_request bitmap
    - Check if current FH is pseudo-fs handle:
      - If yes: list children via `h.PseudoFS.ListChildren(node)`
      - For each child, encode an `entry4`: cookie (uint64, use child index+1 as cookie), name (XDR string), attrs (encode requested attrs for child)
      - Cookie=0 means start from beginning. Skip entries with cookie <= requested cookie.
      - Set EOF=true (pseudo-fs directories are always fully enumerable)
      - Encode cookieverf as 8 zero bytes (pseudo-fs doesn't need verification)
      - Encode result: status + cookieverf + dirlist4 (entries + eof bool)
      - If no: For Phase 6, return NFS4ERR_NOTSUPP
    - Respect maxcount limit: stop encoding entries if encoded size approaches maxcount

    **access.go** — `handleAccess`:
    - Requires current FH
    - Read access bits from reader (uint32 bitmask: ACCESS4_READ=0x01, ACCESS4_LOOKUP=0x02, ACCESS4_MODIFY=0x04, ACCESS4_EXTEND=0x08, ACCESS4_DELETE=0x10, ACCESS4_EXECUTE=0x20)
    - For pseudo-fs handles: grant all requested access bits (pseudo-fs directories are always accessible)
    - For real handles: For Phase 6, return NFS4ERR_NOTSUPP
    - Encode result: status + supported (same as requested) + access (same as requested)

    **illegal.go** — `handleIllegal`:
    - No args to read (skip any remaining data for this op — actually ILLEGAL has no args per RFC)
    - Encode result: status NFS4ERR_OP_ILLEGAL
    - This is used for truly unknown opcodes as well

    **setclientid.go** — `handleSetClientID` and `handleSetClientIDConfirm`:
    - `handleSetClientID`:
      - Read args: client verifier (8 bytes), client id (XDR string = nfs_client_id4), callback program/netid/addr (cb_client4), callback_ident (uint32)
      - For Phase 6 stub: Generate a simple client ID (e.g., atomic counter) and verifier (8 random bytes or timestamp)
      - Encode result: status NFS4_OK + clientid (uint64) + setclientid_confirm verifier (8 bytes)
      - Log at DEBUG: "SETCLIENTID stub: accepted client %s, assigned ID %d"
    - `handleSetClientIDConfirm`:
      - Read args: clientid (uint64), setclientid_confirm verifier (8 bytes)
      - For Phase 6 stub: Always return NFS4_OK (no validation)
      - Encode result: status NFS4_OK only
      - Log at DEBUG: "SETCLIENTID_CONFIRM stub: confirmed client ID %d"
    - Both stubs are minimal placeholders. Phase 9 implements proper state management.

    **handler.go** modifications:
    - In `NewHandler`, register all implemented handlers in the dispatch table:
      ```
      OP_PUTFH -> h.handlePutFH
      OP_PUTROOTFH -> h.handlePutRootFH
      OP_PUTPUBFH -> h.handlePutPubFH
      OP_GETFH -> h.handleGetFH
      OP_SAVEFH -> h.handleSaveFH
      OP_RESTOREFH -> h.handleRestoreFH
      OP_LOOKUP -> h.handleLookup
      OP_LOOKUPP -> h.handleLookupP
      OP_GETATTR -> h.handleGetAttr
      OP_READDIR -> h.handleReadDir
      OP_ACCESS -> h.handleAccess
      OP_ILLEGAL -> h.handleIllegal
      OP_SETCLIENTID -> h.handleSetClientID
      OP_SETCLIENTID_CONFIRM -> h.handleSetClientIDConfirm
      ```
    - All other operation numbers remain mapped to the default notSuppHandler
  </action>
  <verify>
    cd /Users/marmos91/Projects/dittofs && go build ./...
    go vet ./internal/protocol/nfs/v4/...
  </verify>
  <done>
    All 14 operation handlers implemented and registered in dispatch table. Handlers correctly read their XDR args, manipulate CompoundContext, and return encoded results.
  </done>
</task>

<task type="auto">
  <name>Task 2: Comprehensive unit tests for all operation handlers</name>
  <files>
    internal/protocol/nfs/v4/handlers/ops_test.go
  </files>
  <action>
    Create comprehensive unit tests for all operation handlers. Build test helpers that construct minimal encoded COMPOUND4args for specific operation sequences.

    **ops_test.go:**

    Test helpers:
    - `newTestHandler() *Handler` — creates Handler with a PseudoFS built from shares ["/export", "/data/archive"]. Use a nil runtime or minimal mock since pseudo-fs operations don't need runtime (except LOOKUP junction crossing which needs GetShareRootHandle — mock this or skip those tests that need it).
    - `encodeCompound(tag string, ops ...encodedOp) []byte` — builds COMPOUND4args bytes
    - `encodedOp` type with helpers: `encodePutRootFH()`, `encodeGetFH()`, `encodePutFH(handle []byte)`, `encodeSaveFH()`, `encodeRestoreFH()`, `encodeLookup(name string)`, `encodeLookupP()`, `encodeGetAttr(bits ...uint32)`, `encodeReadDir(cookie uint64, maxcount uint32, bits ...uint32)`, `encodeAccess(mask uint32)`, `encodeIllegal()`
    - `decodeCompoundResponse(data []byte) *types.Compound4Response` — decodes response for assertions

    Test cases:

    **PUTROOTFH + GETFH** (basic compound):
    - Encode: [PUTROOTFH, GETFH]
    - Assert: 2 results, both NFS4_OK
    - Assert: GETFH result contains pseudo-fs root handle (starts with "pseudofs:")

    **PUTPUBFH == PUTROOTFH**:
    - Encode: [PUTPUBFH, GETFH]
    - Assert: returned handle == root handle from [PUTROOTFH, GETFH]

    **PUTFH with valid handle**:
    - Encode: [PUTFH(pseudoFSRootHandle), GETFH]
    - Assert: GETFH returns the same handle

    **PUTFH with oversized handle** (>128 bytes):
    - Encode: [PUTFH(130-byte handle)]
    - Assert: NFS4ERR_BADHANDLE

    **GETFH without current FH** (no PUTFH first):
    - Encode: [GETFH]
    - Assert: NFS4ERR_NOFILEHANDLE

    **SAVEFH + RESTOREFH**:
    - Encode: [PUTROOTFH, SAVEFH, LOOKUP("export"), RESTOREFH, GETFH]
    - Assert: GETFH returns root handle (restored from saved)

    **RESTOREFH without saved FH**:
    - Encode: [PUTROOTFH, RESTOREFH]
    - Assert: NFS4ERR_RESTOREFH

    **LOOKUP on pseudo-fs root**:
    - Encode: [PUTROOTFH, LOOKUP("export"), GETFH]
    - Assert: NFS4_OK, GETFH returns handle for /export node

    **LOOKUP nonexistent name**:
    - Encode: [PUTROOTFH, LOOKUP("nonexistent")]
    - Assert: NFS4ERR_NOENT

    **LOOKUP with invalid UTF-8**:
    - Encode: [PUTROOTFH, LOOKUP(string([]byte{0xFF, 0xFE}))]
    - Assert: NFS4ERR_BADCHAR

    **LOOKUP stops compound on error**:
    - Encode: [PUTROOTFH, LOOKUP("nonexistent"), GETFH]
    - Assert: 2 results (PUTROOTFH OK + LOOKUP NOENT), GETFH not executed

    **LOOKUPP from child to root**:
    - Encode: [PUTROOTFH, LOOKUP("export"), LOOKUPP, GETFH]
    - Assert: GETFH returns root handle

    **LOOKUPP from root stays at root**:
    - Encode: [PUTROOTFH, LOOKUPP, GETFH]
    - Assert: GETFH returns root handle (root's parent is root)

    **GETATTR on pseudo-fs root**:
    - Encode: [PUTROOTFH, GETATTR(FATTR4_TYPE, FATTR4_FSID)]
    - Assert: NFS4_OK, response contains TYPE=NF4DIR, FSID={0,1}

    **GETATTR with no bits requested**:
    - Encode: [PUTROOTFH, GETATTR(empty bitmap)]
    - Assert: NFS4_OK, empty response bitmap, no attr data

    **READDIR on pseudo-fs root**:
    - Encode: [PUTROOTFH, READDIR(cookie=0, maxcount=4096, FATTR4_TYPE)]
    - Assert: NFS4_OK, entries include "export" and "data", EOF=true

    **ACCESS on pseudo-fs**:
    - Encode: [PUTROOTFH, ACCESS(0x3F)]  (all bits)
    - Assert: NFS4_OK, supported=0x3F, access=0x3F

    **ILLEGAL operation**:
    - Encode: [ILLEGAL]
    - Assert: NFS4ERR_OP_ILLEGAL

    **End-to-end compound: browse pseudo-fs**:
    - Encode: [PUTROOTFH, GETATTR(TYPE), LOOKUP("data"), GETATTR(TYPE), LOOKUP("archive"), GETFH]
    - Assert: 6 results all NFS4_OK, navigated through pseudo-fs tree
  </action>
  <verify>
    cd /Users/marmos91/Projects/dittofs && go test ./internal/protocol/nfs/v4/handlers/... -v -race
    go test ./internal/protocol/nfs/v4/... -v -race
    go test ./... -count=1 2>&1 | tail -5
  </verify>
  <done>
    All operation handler tests pass. COMPOUND sequences correctly navigate the pseudo-fs. Error cases (no FH, bad name, invalid UTF-8, nonexistent entries) return correct NFS4 error codes. Stop-on-error behavior verified. No regressions in existing tests.
  </done>
</task>

</tasks>

<verification>
- `go test ./internal/protocol/nfs/v4/... -v -race` passes all tests
- `go vet ./internal/protocol/nfs/v4/...` reports no issues
- `go build ./...` succeeds (entire project compiles)
- `go test ./... -count=1` passes (no regressions)
- COMPOUND sequence [PUTROOTFH, LOOKUP("export"), GETATTR(TYPE), READDIR] returns correct results
- Operations without current FH return NFS4ERR_NOFILEHANDLE
- SETCLIENTID stubs return NFS4_OK
</verification>

<success_criteria>
1. All 14 operation handlers registered in COMPOUND dispatch table
2. PUTROOTFH/PUTPUBFH set current FH to pseudo-fs root
3. LOOKUP traverses pseudo-fs tree, handles export junctions
4. GETATTR returns correct attributes for pseudo-fs nodes
5. READDIR lists pseudo-fs children with attributes
6. SAVEFH/RESTOREFH correctly save and restore filehandle state
7. NFS4ERR_NOFILEHANDLE returned when operations need but lack current FH
8. UTF-8 validation rejects bad filenames in LOOKUP
9. SETCLIENTID stubs allow client ID establishment
10. Full pseudo-fs browsing works end-to-end via COMPOUND sequences
</success_criteria>

<output>
After completion, create `.planning/phases/06-nfsv4-protocol-foundation/06-03-SUMMARY.md`
</output>
