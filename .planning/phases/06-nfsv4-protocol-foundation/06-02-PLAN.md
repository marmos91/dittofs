---
phase: 06-nfsv4-protocol-foundation
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - internal/protocol/nfs/v4/pseudofs/pseudofs.go
  - internal/protocol/nfs/v4/pseudofs/pseudofs_test.go
  - internal/protocol/nfs/v4/handlers/handler.go
  - internal/protocol/nfs/v4/handlers/compound.go
  - internal/protocol/nfs/v4/handlers/compound_test.go
  - internal/protocol/nfs/v4/handlers/context.go
  - internal/protocol/nfs/v4/handlers/null.go
  - internal/protocol/nfs/dispatch.go
  - pkg/adapter/nfs/nfs_connection.go
  - internal/protocol/nfs/rpc/constants.go
autonomous: true

must_haves:
  truths:
    - "COMPOUND operations execute sequentially, stopping on first error"
    - "COMPOUND response includes results up to and including the failed operation"
    - "Tag field echoed byte-for-byte in response"
    - "Minor version != 0 returns NFS4ERR_MINOR_VERS_MISMATCH"
    - "COMPOUND op count > 128 returns NFS4ERR_RESOURCE"
    - "Pseudo-filesystem presents all runtime shares under unified root"
    - "Pseudo-fs handles are distinguishable from real file handles"
    - "Adding/removing shares dynamically updates pseudo-fs"
    - "NFSv4 RPC calls routed to v4 handlers via version field"
    - "NFSv3 continues to work unchanged alongside NFSv4"
    - "NLM/NSM/MOUNT programs remain active regardless of NFS version"
  artifacts:
    - path: "internal/protocol/nfs/v4/pseudofs/pseudofs.go"
      provides: "PseudoFS tree, node management, handle generation"
      contains: "PseudoFS"
    - path: "internal/protocol/nfs/v4/handlers/handler.go"
      provides: "V4 Handler struct with PseudoFS and Runtime dependencies"
      contains: "Handler"
    - path: "internal/protocol/nfs/v4/handlers/compound.go"
      provides: "COMPOUND dispatcher loop with sequential op execution"
      contains: "ProcessCompound"
    - path: "internal/protocol/nfs/v4/handlers/null.go"
      provides: "NFSv4 NULL procedure handler"
      contains: "HandleNull"
    - path: "pkg/adapter/nfs/nfs_connection.go"
      provides: "Version routing for NFS v3 vs v4"
      contains: "handleNFSv4Procedure"
  key_links:
    - from: "pkg/adapter/nfs/nfs_connection.go"
      to: "internal/protocol/nfs/v4/handlers/"
      via: "handleNFSv4Procedure dispatches to v4 handler"
      pattern: "handleNFSv4Procedure"
    - from: "internal/protocol/nfs/v4/handlers/compound.go"
      to: "internal/protocol/nfs/v4/types/"
      via: "imports CompoundContext, CompoundResult, error codes"
      pattern: "types\\.NFS4"
    - from: "internal/protocol/nfs/v4/handlers/handler.go"
      to: "internal/protocol/nfs/v4/pseudofs/"
      via: "Handler holds PseudoFS reference"
      pattern: "PseudoFS"
---

<objective>
Build the COMPOUND dispatcher, pseudo-filesystem, version routing, and NULL handler.

Purpose: This is the core runtime machinery of NFSv4. After this plan, the server accepts NFSv4 COMPOUND RPCs, dispatches operations sequentially with shared filehandle context, and presents a virtual namespace via the pseudo-filesystem. Individual operation handlers (PUTFH, LOOKUP, GETATTR, etc.) are added in Plan 03.
Output: Working COMPOUND dispatcher with pseudo-fs and version routing. Unimplemented ops return NFS4ERR_NOTSUPP.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-nfsv4-protocol-foundation/06-RESEARCH.md
@.planning/phases/06-nfsv4-protocol-foundation/06-CONTEXT.md
@.planning/phases/06-nfsv4-protocol-foundation/06-01-SUMMARY.md
@internal/protocol/nfs/dispatch.go
@pkg/adapter/nfs/nfs_connection.go
@internal/protocol/nfs/rpc/constants.go
@internal/protocol/nfs/v3/handlers/doc.go
@internal/protocol/nfs/v3/handlers/nfs_context.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Pseudo-filesystem implementation</name>
  <files>
    internal/protocol/nfs/v4/pseudofs/pseudofs.go
    internal/protocol/nfs/v4/pseudofs/pseudofs_test.go
  </files>
  <action>
    Create package `internal/protocol/nfs/v4/pseudofs/` implementing the virtual namespace tree.

    **pseudofs.go:**

    - `PseudoFS` struct with:
      - `mu sync.RWMutex` for thread safety
      - `root *PseudoNode` (root of the tree)
      - `handles map[string][]byte` (path -> handle mapping)
      - `byHandle map[string]*PseudoNode` (hex-encoded handle -> node, for reverse lookup)
      - `nextID uint64` (monotonic counter for handle generation)

    - `PseudoNode` struct with:
      - `Name string` (node name, e.g., "export")
      - `Path string` (full path, e.g., "/export")
      - `Handle []byte` (unique handle for this node)
      - `Children map[string]*PseudoNode`
      - `IsExport bool` (true if this is a junction to a real share)
      - `ShareName string` (share name if IsExport, for routing to metadata service)
      - `Parent *PseudoNode` (parent reference for LOOKUPP)
      - `ChangeID uint64` (monotonic, bumped on child changes)
      - `FileID uint64` (stable file ID for GETATTR)

    - Handle format: `pseudoFSHandlePrefix = "pseudofs:"`. Handle = `"pseudofs:" + path`. If total length > 128 bytes (NFS4_FHSIZE), hash the path portion with SHA-256 and use hex-encoded first 16 bytes of hash.

    - `New() *PseudoFS` — creates empty pseudo-fs with root node at path "/" with handle "pseudofs:/"

    - `IsPseudoFSHandle(handle []byte) bool` — returns true if handle starts with "pseudofs:" prefix

    - `GetRootHandle() []byte` — returns root node handle

    - `LookupByHandle(handle []byte) (*PseudoNode, bool)` — looks up node by handle (uses byHandle map with hex-encoded key)

    - `LookupChild(parent *PseudoNode, name string) (*PseudoNode, bool)` — looks up child by name in parent's children map

    - `LookupParent(node *PseudoNode) (*PseudoNode, bool)` — returns parent node (root's parent is root itself per NFSv4 spec)

    - `Rebuild(shares []string)` — rebuilds the pseudo-fs tree from a list of share paths:
      1. Lock mu exclusively
      2. Keep root node (preserve root handle for stability)
      3. Clear all non-root nodes from handles and byHandle maps
      4. For each share path, create intermediate directory nodes and the export node
      5. Example: share "/data/archive" creates nodes for "/", "/data" (intermediate), "/data/archive" (IsExport=true)
      6. Reuse existing handles for nodes that still exist (handle stability across rebuilds)
      7. Bump root's ChangeID

    - `ListChildren(node *PseudoNode) []*PseudoNode` — returns sorted list of children (read-locked)

    - `GetNodeCount() int` — returns total number of nodes (for testing/debugging)

    - Implement `attrs.PseudoFSAttrSource` interface on `PseudoNode`:
      - `GetHandle() []byte` returns Handle
      - `GetFSID() (uint64, uint64)` returns (0, 1) for all pseudo-fs nodes (per research recommendation)
      - `GetFileID() uint64` returns FileID
      - `GetChangeID() uint64` returns ChangeID
      - `GetType() uint32` returns NF4DIR (all pseudo-fs nodes are directories)

    **pseudofs_test.go:**
    - Test New() creates root with correct handle
    - Test IsPseudoFSHandle true for pseudo-fs handles, false for "shareName:uuid" format
    - Test Rebuild with single share "/export" creates root + export node
    - Test Rebuild with nested share "/data/archive" creates root + "data" intermediate + "data/archive" export
    - Test Rebuild with multiple shares creates all nodes
    - Test Rebuild preserves root handle across rebuilds
    - Test LookupByHandle returns correct node
    - Test LookupChild finds child, returns false for nonexistent
    - Test LookupParent returns parent, root's parent is root
    - Test ListChildren returns sorted list
    - Test handle stability: rebuild with same shares produces same handles
    - Test export node has IsExport=true, intermediate has IsExport=false
    - Test handles fit within NFS4_FHSIZE (128 bytes) even for long paths
  </action>
  <verify>
    cd /Users/marmos91/Projects/dittofs && go test ./internal/protocol/nfs/v4/pseudofs/... -v -race
  </verify>
  <done>
    Pseudo-filesystem correctly builds a virtual namespace tree from share paths, generates distinguishable handles with "pseudofs:" prefix, supports dynamic rebuilds, and passes all tests including race detection.
  </done>
</task>

<task type="auto">
  <name>Task 2: COMPOUND dispatcher, Handler struct, version routing, and NULL handler</name>
  <files>
    internal/protocol/nfs/v4/handlers/handler.go
    internal/protocol/nfs/v4/handlers/compound.go
    internal/protocol/nfs/v4/handlers/compound_test.go
    internal/protocol/nfs/v4/handlers/context.go
    internal/protocol/nfs/v4/handlers/null.go
    internal/protocol/nfs/dispatch.go
    pkg/adapter/nfs/nfs_connection.go
    internal/protocol/nfs/rpc/constants.go
  </files>
  <action>
    Create the COMPOUND dispatcher and integrate NFSv4 into the existing NFS adapter.

    **internal/protocol/nfs/v4/handlers/handler.go:**
    - `Handler` struct with:
      - `Registry *runtime.Runtime` (same pattern as v3 Handler)
      - `PseudoFS *pseudofs.PseudoFS` (pseudo-filesystem reference)
      - `opDispatchTable map[uint32]OpHandler` (map of operation number -> handler func)
    - `OpHandler` type: `func(ctx *types.CompoundContext, reader io.Reader) *types.CompoundResult`
    - `NewHandler(registry *runtime.Runtime, pfs *pseudofs.PseudoFS) *Handler` — creates handler and initializes dispatch table with all operation numbers. For Phase 6, most ops map to a default handler that returns NFS4ERR_NOTSUPP. The implemented ops are:
      - `OP_ILLEGAL` -> handleIllegal (returns NFS4ERR_OP_ILLEGAL)
      - All others -> notSuppHandler (returns NFS4ERR_NOTSUPP with the correct OpCode)
      Note: Plan 03 will register PUTFH, PUTROOTFH, etc. into this table.
    - `notSuppHandler(opCode uint32) *types.CompoundResult` — returns CompoundResult with Status=NFS4ERR_NOTSUPP, OpCode=given opcode, Data=XDR-encoded status-only response

    **internal/protocol/nfs/v4/handlers/compound.go:**
    - `func (h *Handler) ProcessCompound(compoundCtx *types.CompoundContext, data []byte) ([]byte, error)` — the main COMPOUND dispatcher:
      1. Decode COMPOUND4args from data using an `io.Reader` (bytes.NewReader):
         - Read tag as XDR opaque (variable-length bytes)
         - Read minorversion as uint32
         - Read numOps as uint32
      2. Validate minor version: if != 0, return COMPOUND4res with Status=NFS4ERR_MINOR_VERS_MISMATCH, echoed tag, empty results array
      3. Validate op count: if > MaxCompoundOps (128), return with Status=NFS4ERR_RESOURCE
      4. Sequential dispatch loop:
         - For each op, read the opcode (uint32) from reader
         - Look up in opDispatchTable. If not found, use handleIllegal
         - Call handler with CompoundContext + remaining reader
         - Append result to results slice
         - If result.Status != NFS4_OK, break (stop on first error per RFC 7530 Section 16.2.3)
         - Check context cancellation between ops
      5. Encode COMPOUND4res to bytes.Buffer:
         - Write status (last operation's status, or NFS4_OK if all succeeded)
         - Write tag (echoed from request as-is)
         - Write results count
         - For each result: write opcode, then write result.Data
      6. Return encoded bytes

    - XDR decoding approach: The COMPOUND args contain tag + minorversion + numOps, then each op is opcode followed by op-specific args. Since ops are processed sequentially, the reader cursor advances naturally. Each op handler reads its own args from the reader and returns its XDR-encoded result. This "streaming" approach avoids pre-parsing all ops.

    **internal/protocol/nfs/v4/handlers/compound_test.go:**
    - Test empty COMPOUND (0 ops): returns NFS4_OK with empty results
    - Test minor version mismatch (minorversion=1): returns NFS4ERR_MINOR_VERS_MISMATCH with echoed tag, 0 results
    - Test tag echo: arbitrary bytes echoed back unchanged (including non-UTF-8)
    - Test single ILLEGAL op: returns NFS4ERR_OP_ILLEGAL in results
    - Test unknown opcode (e.g., 99999): treated as ILLEGAL, returns NFS4ERR_OP_ILLEGAL
    - Test multiple ops stop on first error: 3 ops where op 2 fails, only 2 results in response
    - Test op count limit exceeded (129 ops): returns NFS4ERR_RESOURCE
    - Helper function to build encoded COMPOUND4args for testing

    **internal/protocol/nfs/v4/handlers/context.go:**
    - `ExtractV4HandlerContext(ctx context.Context, call *rpc.RPCCallMessage, clientAddr string) *types.CompoundContext` — creates CompoundContext from RPC call. Extracts AUTH_UNIX credentials same as v3's ExtractHandlerContext but populates CompoundContext fields. CurrentFH and SavedFH start as nil.

    **internal/protocol/nfs/v4/handlers/null.go:**
    - `func (h *Handler) HandleNull(data []byte) ([]byte, error)` — NFSv4 NULL procedure (procedure 0). Returns empty reply body (same as v3 NULL). This is NOT a COMPOUND operation; it's a separate RPC procedure.

    **internal/protocol/nfs/dispatch.go** modifications:
    - Add import for v4 handlers package (aliased as `nfs4`)
    - Update comment on `ProgramNFS` comment to note it handles both v3 and v4
    - No new dispatch table for v4 (COMPOUND handles its own internal dispatch)

    **pkg/adapter/nfs/nfs_connection.go** modifications:
    - Add `v4Handler *nfs4.Handler` field to `NFSConnection` struct (or to the server struct that creates connections — follow the pattern of how v3 Handler is stored)
    - In `handleRPCCall`, update the `case rpc.ProgramNFS:` block:
      ```
      case rpc.ProgramNFS:
          switch call.Version {
          case rpc.NFSVersion3:
              replyData, err = c.handleNFSProcedure(ctx, call, procedureData, clientAddr)
          case rpc.NFSVersion4:
              replyData, err = c.handleNFSv4Procedure(ctx, call, procedureData, clientAddr)
          default:
              return c.handleUnsupportedVersion(call, rpc.NFSVersion3, "NFS", clientAddr)
          }
      ```
    - Remove the macOS kernel bug workaround in `handleUnsupportedVersion` that closes connection for NFSv4 (per research: remove when v4 is enabled). The workaround should now only trigger if v4 is explicitly disabled via version range config. For now (Phase 6), v4 is always enabled per locked decision "Both v3 and v4 active simultaneously by default", so remove the workaround entirely and send PROG_MISMATCH for truly unsupported versions.
    - Add `handleNFSv4Procedure` method:
      1. Extract CompoundContext via `nfs4.ExtractV4HandlerContext(ctx, call, clientAddr)`
      2. If `call.Procedure == types.NFSPROC4_NULL`: call v4Handler.HandleNull, return
      3. If `call.Procedure == types.NFSPROC4_COMPOUND`: call v4Handler.ProcessCompound with CompoundContext + procedureData, return
      4. Otherwise: return RPC PROC_UNAVAIL error (NFSv4 only has 2 procedures)
    - Log at INFO level the first time a client uses v4 (use sync.Once or atomic bool to log only once per server lifetime). The locked decision says: "Log at INFO level the first time a client uses v3 or v4, subsequent calls at DEBUG". Add this for both v3 and v4 paths.
    - The v4 Handler needs to be initialized somewhere. Follow the existing pattern: look at how the v3 handler and mount handler are created in the NFS adapter. The v4 Handler should be created in the NFS adapter's initialization (likely in nfs_adapter.go) with the PseudoFS. The PseudoFS should be rebuilt whenever shares change. For Phase 6, initialize PseudoFS with current shares at adapter startup and add a TODO comment for dynamic rebuild on share changes.

    **internal/protocol/nfs/rpc/constants.go** modifications:
    - Update the NFSVersion4 comment to remove "DittoFS does not support NFSv4" and replace with "DittoFS supports NFSv4.0 (RFC 7530). Used for version routing in dispatch."
  </action>
  <verify>
    cd /Users/marmos91/Projects/dittofs && go test ./internal/protocol/nfs/v4/handlers/... -v
    go test ./internal/protocol/nfs/v4/pseudofs/... -v
    go vet ./internal/protocol/nfs/v4/...
    go build ./...
  </verify>
  <done>
    COMPOUND dispatcher correctly processes NFSv4 RPCs: sequential operation execution, stop-on-error, tag echo, minor version validation, op count limiting. NFSv4 calls route to v4 handler via version field in RPC. NULL procedure works. Unimplemented ops return NFS4ERR_NOTSUPP. Pseudo-fs initialized at adapter startup. NFSv3 continues to work unchanged. All tests pass.
  </done>
</task>

</tasks>

<verification>
- `go test ./internal/protocol/nfs/v4/... -v -race` passes all tests
- `go vet ./internal/protocol/nfs/v4/...` reports no issues
- `go build ./...` succeeds (entire project compiles)
- `go test ./... -count=1` passes (no regressions in existing tests)
- NFSv3 code path unchanged (dispatch still works for version=3)
</verification>

<success_criteria>
1. COMPOUND processes 0+ operations sequentially, stopping on first error
2. COMPOUND response includes correct number of results (up to and including failure)
3. Tag echoed byte-for-byte (verified by test with non-UTF-8 bytes)
4. Minor version 1 or 2 returns NFS4ERR_MINOR_VERS_MISMATCH
5. Op count > 128 returns NFS4ERR_RESOURCE
6. Unknown opcodes return NFS4ERR_OP_ILLEGAL
7. Pseudo-fs creates correct tree from share paths with distinguishable handles
8. Version routing sends v3 to v3 handlers, v4 to v4 handlers
9. No regressions in existing v3 tests
</success_criteria>

<output>
After completion, create `.planning/phases/06-nfsv4-protocol-foundation/06-02-SUMMARY.md`
</output>
