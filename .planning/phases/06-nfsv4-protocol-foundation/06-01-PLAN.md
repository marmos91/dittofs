---
phase: 06-nfsv4-protocol-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/protocol/nfs/v4/types/constants.go
  - internal/protocol/nfs/v4/types/types.go
  - internal/protocol/nfs/v4/types/errors.go
  - internal/protocol/nfs/v4/types/constants_test.go
  - internal/protocol/nfs/v4/attrs/bitmap.go
  - internal/protocol/nfs/v4/attrs/bitmap_test.go
  - internal/protocol/nfs/v4/attrs/encode.go
  - internal/protocol/nfs/v4/attrs/encode_test.go
autonomous: true

must_haves:
  truths:
    - "All 40 NFSv4 operation numbers defined as constants"
    - "All 48+ NFSv4 error codes defined with correct values"
    - "Internal metadata errors map to NFSv4 error codes"
    - "Bitmap4 variable-length encode/decode works for 0, 1, 2, 3+ words"
    - "UTF-8 filename validation rejects invalid UTF-8, null bytes, slashes, and overlength names"
    - "FATTR4 mandatory attribute bit numbers defined"
  artifacts:
    - path: "internal/protocol/nfs/v4/types/constants.go"
      provides: "NFSv4 operation numbers, error codes, procedure numbers"
      contains: "NFS4_OK"
    - path: "internal/protocol/nfs/v4/types/types.go"
      provides: "CompoundContext, CompoundResult, Compound4Args, Compound4Response, RawOp, V4ClientState structs"
      contains: "CompoundContext"
    - path: "internal/protocol/nfs/v4/types/errors.go"
      provides: "MapMetadataErrorToNFS4 function, ValidateUTF8Filename function"
      contains: "MapMetadataErrorToNFS4"
    - path: "internal/protocol/nfs/v4/attrs/bitmap.go"
      provides: "Bitmap4 encode/decode/set/check helpers"
      contains: "EncodeBitmap4"
    - path: "internal/protocol/nfs/v4/attrs/encode.go"
      provides: "FATTR4 attribute constants and encoding for pseudo-fs attributes"
      contains: "FATTR4_TYPE"
  key_links:
    - from: "internal/protocol/nfs/v4/types/errors.go"
      to: "pkg/metadata"
      via: "import metadata errors"
      pattern: "metadata\\.Err"
---

<objective>
Define all NFSv4 XDR types, constants, error codes, attribute definitions, and bitmap helpers.

Purpose: Provide the foundational type system that the COMPOUND dispatcher (Plan 02) and operation handlers (Plan 03) build on. This is a pure data-definition plan with no runtime behavior changes.
Output: Two new packages (`v4/types/` and `v4/attrs/`) with comprehensive constants, structures, and helpers.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-nfsv4-protocol-foundation/06-RESEARCH.md
@.planning/phases/06-nfsv4-protocol-foundation/06-CONTEXT.md
@internal/protocol/nfs/types/constants.go
@internal/protocol/nfs/v3/handlers/nfs_context.go
@internal/protocol/nfs/dispatch.go
@internal/protocol/xdr/
@pkg/metadata/errors.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: NFSv4 types package (constants, types, error mapping, UTF-8 validation)</name>
  <files>
    internal/protocol/nfs/v4/types/constants.go
    internal/protocol/nfs/v4/types/types.go
    internal/protocol/nfs/v4/types/errors.go
    internal/protocol/nfs/v4/types/constants_test.go
  </files>
  <action>
    Create package `internal/protocol/nfs/v4/types/` with three files:

    **constants.go** — Define all NFSv4 constants per RFC 7530/7531:
    - RPC procedure numbers: `NFSPROC4_NULL = 0`, `NFSPROC4_COMPOUND = 1`
    - All 40 NFSv4 operation numbers (OP_ACCESS=3 through OP_RELEASE_LOCKOWNER=39, OP_ILLEGAL=10044). Use exact values from research.
    - `NFS4_FHSIZE = 128` (max file handle size)
    - `NFS4_MINOR_VERSION_0 = 0`
    - `MaxCompoundOps = 128` (COMPOUND op count limit per Claude's discretion in CONTEXT.md)
    - File type constants: `NF4REG=1, NF4DIR=2, NF4BLK=3, NF4CHR=4, NF4LNK=5, NF4SOCK=6, NF4FIFO=7, NF4ATTRDIR=8, NF4NAMEDATTR=9`
    - All 48+ NFSv4 error codes with exact values from research (NFS4_OK=0 through NFS4ERR_CB_PATH_DOWN=10048). Include every code listed in the research.
    - `FH4_PERSISTENT = 0x00` and `FH4_VOLATILE_ANY = 0x01` for fh_expire_type

    **types.go** — Define XDR structures:
    - `RawOp` struct: `OpCode uint32` (args decoded lazily by each handler)
    - `Compound4Args` struct: `Tag []byte, MinorVersion uint32, Ops []RawOp`
    - `CompoundResult` struct: `Status uint32, OpCode uint32, Data []byte` (encoded result of one op)
    - `Compound4Response` struct: `Status uint32, Tag []byte, Results []CompoundResult`
    - `CompoundContext` struct (mutable, passed by pointer):
      - `CurrentFH []byte` (current filehandle, nil = no FH set)
      - `SavedFH []byte` (saved filehandle for SAVEFH/RESTOREFH)
      - `ClientAddr string`
      - `AuthFlavor uint32`
      - `UID *uint32, GID *uint32, GIDs []uint32`
      - `Context context.Context` (Go context for cancellation)
      - `ClientState *V4ClientState` (placeholder for Phase 9)
    - `V4ClientState` struct (minimal placeholder): `ClientAddr string` only
    - `FSID4` struct: `Major uint64, Minor uint64`
    - `NFS4Time` struct: `Seconds int64, Nseconds uint32`
    - Helper: `RequireCurrentFH(ctx *CompoundContext) uint32` — returns NFS4_OK if CurrentFH is not nil, NFS4ERR_NOFILEHANDLE otherwise
    - Helper: `RequireSavedFH(ctx *CompoundContext) uint32` — returns NFS4_OK if SavedFH is not nil, NFS4ERR_RESTOREFH otherwise

    **errors.go** — Error mapping and UTF-8 validation:
    - `MapMetadataErrorToNFS4(err error) uint32` — maps internal `metadata` errors to NFS4 status codes. Use the mapping table from research (ErrNotFound->NFS4ERR_NOENT, ErrAccessDenied->NFS4ERR_ACCESS, ErrPermissionDenied->NFS4ERR_PERM, ErrAlreadyExists->NFS4ERR_EXIST, ErrNotEmpty->NFS4ERR_NOTEMPTY, ErrIsDirectory->NFS4ERR_ISDIR, ErrNotDirectory->NFS4ERR_NOTDIR, ErrInvalidArgument->NFS4ERR_INVAL, ErrNoSpace->NFS4ERR_NOSPC, ErrQuotaExceeded->NFS4ERR_DQUOT, ErrReadOnly->NFS4ERR_ROFS, ErrNotSupported->NFS4ERR_NOTSUPP, ErrStaleHandle->NFS4ERR_STALE, ErrInvalidHandle->NFS4ERR_BADHANDLE, ErrNameTooLong->NFS4ERR_NAMETOOLONG, ErrLocked->NFS4ERR_LOCKED, ErrDeadlock->NFS4ERR_DEADLOCK, ErrGracePeriod->NFS4ERR_GRACE, ErrIOError->NFS4ERR_IO, default->NFS4ERR_SERVERFAULT). Use `errors.As` to match `*metadata.StoreError` if applicable, otherwise check for known sentinel errors from `pkg/metadata/errors/`.
    - `ValidateUTF8Filename(name string) uint32` — returns NFS4_OK if valid, otherwise: empty->NFS4ERR_INVAL, invalid UTF-8->NFS4ERR_BADCHAR, contains null byte->NFS4ERR_BADCHAR, contains '/'->NFS4ERR_BADNAME, length>255->NFS4ERR_NAMETOOLONG. Use `unicode/utf8.ValidString()` and `strings.ContainsRune`.

    **constants_test.go** — Unit tests:
    - Test that key error codes have correct values (NFS4_OK==0, NFS4ERR_NOENT==2, NFS4ERR_NOTSUPP==10004, NFS4ERR_NOFILEHANDLE==10020, NFS4ERR_MINOR_VERS_MISMATCH==10021)
    - Test RequireCurrentFH with nil and non-nil FH
    - Test RequireSavedFH with nil and non-nil FH
    - Test MapMetadataErrorToNFS4 for ErrNotFound, ErrAccessDenied, ErrStaleHandle, unknown error
    - Test ValidateUTF8Filename: valid name, empty, invalid UTF-8 bytes, null byte, contains '/', too long (256 chars), exactly 255 chars (OK)
  </action>
  <verify>
    cd /Users/marmos91/Projects/dittofs && go test ./internal/protocol/nfs/v4/types/... -v
    go vet ./internal/protocol/nfs/v4/types/...
  </verify>
  <done>
    All NFSv4 operation numbers, error codes, and core structs defined. Error mapping function correctly maps metadata errors to NFS4 status codes. UTF-8 validation rejects invalid filenames. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Bitmap4 attribute helpers and FATTR4 definitions</name>
  <files>
    internal/protocol/nfs/v4/attrs/bitmap.go
    internal/protocol/nfs/v4/attrs/bitmap_test.go
    internal/protocol/nfs/v4/attrs/encode.go
    internal/protocol/nfs/v4/attrs/encode_test.go
  </files>
  <action>
    Create package `internal/protocol/nfs/v4/attrs/` with bitmap and attribute helpers:

    **bitmap.go** — Variable-length bitmap4 operations:
    - `EncodeBitmap4(buf *bytes.Buffer, bitmap []uint32) error` — writes word count then each word as uint32 via the shared `internal/protocol/xdr/` package
    - `DecodeBitmap4(reader io.Reader) ([]uint32, error)` — reads word count (reject if >8 to prevent abuse), then each word. Use `internal/protocol/xdr/` DecodeUint32.
    - `IsBitSet(bitmap []uint32, bit uint32) bool` — checks if specific bit is set. Handles word index > len(bitmap) gracefully (returns false).
    - `SetBit(bitmap *[]uint32, bit uint32)` — sets a bit, extending the slice if needed. Takes pointer to slice so it can grow.
    - `ClearBit(bitmap []uint32, bit uint32)` — clears a bit (no-op if word doesn't exist)
    - `Intersect(request, supported []uint32) []uint32` — AND of two bitmaps, returns only bits present in both. Result length = min of both lengths.

    **bitmap_test.go** — Comprehensive tests:
    - Empty bitmap (0 words) encode/decode roundtrip
    - Single word bitmap encode/decode
    - Multi-word (3+ words) encode/decode
    - IsBitSet for bit in range, out of range, boundary cases (bit 31, bit 32, bit 63)
    - SetBit extends slice when needed (e.g., setting bit 64 on a 1-word bitmap grows to 3 words)
    - Intersect of overlapping and disjoint bitmaps
    - DecodeBitmap4 rejects numWords > 8

    **encode.go** — FATTR4 attribute constants and encoding:
    - Define all mandatory FATTR4 attribute bit numbers per RFC 7530:
      - `FATTR4_SUPPORTED_ATTRS = 0`
      - `FATTR4_TYPE = 1`
      - `FATTR4_FH_EXPIRE_TYPE = 2`
      - `FATTR4_CHANGE = 3`
      - `FATTR4_SIZE = 4`
      - `FATTR4_LINK_SUPPORT = 5`
      - `FATTR4_SYMLINK_SUPPORT = 6`
      - `FATTR4_NAMED_ATTR = 7`
      - `FATTR4_FSID = 8`
      - `FATTR4_UNIQUE_HANDLES = 9`
      - `FATTR4_LEASE_TIME = 10`
      - `FATTR4_RDATTR_ERROR = 11`
      - `FATTR4_FILEHANDLE = 19`
      - Also define recommended attributes used for pseudo-fs: `FATTR4_MODE = 33`, `FATTR4_NUMLINKS = 35`, `FATTR4_OWNER = 36`, `FATTR4_OWNER_GROUP = 37`, `FATTR4_SPACE_USED = 45`, `FATTR4_TIME_ACCESS = 47`, `FATTR4_TIME_MODIFY = 53`, `FATTR4_MOUNTED_ON_FILEID = 55`, `FATTR4_FILEID = 20`
    - `SupportedAttrs() []uint32` — returns bitmap of all attributes this server supports (the mandatory ones above)
    - `EncodePseudoFSAttrs(buf *bytes.Buffer, requested []uint32, node PseudoFSAttrSource) error` — encodes only the requested attributes that are supported. Writes the response bitmap first (intersection of requested and supported), then the attr values as opaque data per RFC 7530 Section 3.3.10 ordering.
    - `PseudoFSAttrSource` interface: `GetHandle() []byte`, `GetFSID() (uint64, uint64)`, `GetFileID() uint64`, `GetChangeID() uint64`, `GetType() uint32` — pseudo-fs nodes implement this for attribute encoding.
    - For each attribute, encode as: SUPPORTED_ATTRS->bitmap4, TYPE->uint32, FH_EXPIRE_TYPE->uint32(FH4_PERSISTENT), CHANGE->uint64, SIZE->uint64(0 for dirs), LINK_SUPPORT->uint32(1=true), SYMLINK_SUPPORT->uint32(1=true), NAMED_ATTR->uint32(0=false), FSID->two uint64s, UNIQUE_HANDLES->uint32(1=true), LEASE_TIME->uint32(90 seconds default), RDATTR_ERROR->uint32(NFS4_OK), FILEHANDLE->opaque, MODE->uint32(0755 for dirs), NUMLINKS->uint32(2 for dirs), FILEID->uint64

    **encode_test.go** — Attribute encoding tests:
    - Test SupportedAttrs returns non-empty bitmap with expected bits set
    - Test EncodePseudoFSAttrs with empty request bitmap returns empty response
    - Test EncodePseudoFSAttrs with TYPE requested returns correct NF4DIR value
    - Test EncodePseudoFSAttrs with FSID requested returns correct major/minor
    - Test EncodePseudoFSAttrs with unsupported bit requested: bit not set in response bitmap, no value encoded for it
  </action>
  <verify>
    cd /Users/marmos91/Projects/dittofs && go test ./internal/protocol/nfs/v4/attrs/... -v
    go vet ./internal/protocol/nfs/v4/attrs/...
  </verify>
  <done>
    Bitmap4 helpers correctly encode/decode variable-length bitmaps. FATTR4 attribute constants defined. EncodePseudoFSAttrs correctly encodes only requested+supported attributes. All tests pass.
  </done>
</task>

</tasks>

<verification>
- `go test ./internal/protocol/nfs/v4/... -v` passes all tests
- `go vet ./internal/protocol/nfs/v4/...` reports no issues
- `go build ./...` succeeds (packages compile without errors)
- No changes to existing v3 code or adapter code
</verification>

<success_criteria>
1. All 40 NFSv4 operation constants match RFC 7530 values
2. All 48+ error codes match RFC 7530 Section 13 values
3. MapMetadataErrorToNFS4 correctly maps at least 15 internal error types
4. ValidateUTF8Filename correctly handles all edge cases (empty, invalid UTF-8, null, slash, overlength)
5. Bitmap4 encode/decode roundtrips correctly for 0-4+ word bitmaps
6. FATTR4 mandatory attribute bits defined with correct bit numbers
7. EncodePseudoFSAttrs returns only requested+supported attributes
</success_criteria>

<output>
After completion, create `.planning/phases/06-nfsv4-protocol-foundation/06-01-SUMMARY.md`
</output>
