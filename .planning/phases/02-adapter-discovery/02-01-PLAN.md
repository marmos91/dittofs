---
phase: 02-adapter-discovery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - k8s/dittofs-operator/api/v1alpha1/dittoserver_types.go
  - k8s/dittofs-operator/api/v1alpha1/dittoserver_types_builder.go
  - k8s/dittofs-operator/internal/controller/dittofs_client.go
  - k8s/dittofs-operator/internal/controller/adapter_reconciler.go
  - k8s/dittofs-operator/internal/controller/adapter_reconciler_test.go
  - k8s/dittofs-operator/internal/controller/dittoserver_controller.go
autonomous: true

must_haves:
  truths:
    - "Operator polls GET /api/v1/adapters at the interval specified in spec.adapterDiscovery.pollingInterval (defaulting to 30s)"
    - "Changing spec.adapterDiscovery.pollingInterval in the CRD takes effect on the very next reconcile without operator restart"
    - "When the DittoFS API returns an error, the operator preserves existing adapter state and does not modify or delete any Services"
    - "Adapter polling only runs when the Authenticated condition is True"
    - "The minimum RequeueAfter from auth and adapter sub-reconcilers drives the reconcile cadence"
  artifacts:
    - path: "k8s/dittofs-operator/api/v1alpha1/dittoserver_types.go"
      provides: "AdapterDiscoverySpec struct with PollingInterval field"
      contains: "AdapterDiscoverySpec"
    - path: "k8s/dittofs-operator/internal/controller/dittofs_client.go"
      provides: "ListAdapters method and AdapterInfo type"
      contains: "func (c *DittoFSClient) ListAdapters"
    - path: "k8s/dittofs-operator/internal/controller/adapter_reconciler.go"
      provides: "reconcileAdapters, getPollingInterval, getLastKnownAdapters, getAuthenticatedClient"
      contains: "func (r *DittoServerReconciler) reconcileAdapters"
    - path: "k8s/dittofs-operator/internal/controller/adapter_reconciler_test.go"
      provides: "Tests for adapter reconciler success, API error, empty response, unauthenticated"
      min_lines: 100
    - path: "k8s/dittofs-operator/internal/controller/dittoserver_controller.go"
      provides: "Adapter reconciler integrated after auth with min-RequeueAfter logic"
      contains: "reconcileAdapters"
  key_links:
    - from: "k8s/dittofs-operator/internal/controller/adapter_reconciler.go"
      to: "k8s/dittofs-operator/internal/controller/dittofs_client.go"
      via: "ListAdapters() call in reconcileAdapters"
      pattern: "ListAdapters\\(\\)"
    - from: "k8s/dittofs-operator/internal/controller/dittoserver_controller.go"
      to: "k8s/dittofs-operator/internal/controller/adapter_reconciler.go"
      via: "r.reconcileAdapters() called from Reconcile after auth"
      pattern: "r\\.reconcileAdapters"
    - from: "k8s/dittofs-operator/internal/controller/adapter_reconciler.go"
      to: "k8s/dittofs-operator/api/v1alpha1/dittoserver_types.go"
      via: "getPollingInterval reads spec.AdapterDiscovery.PollingInterval"
      pattern: "AdapterDiscovery"
---

<objective>
Implement adapter discovery polling: extend the CRD with a configurable polling interval, add ListAdapters to the DittoFS client, create an adapter reconciler that polls the API and stores results in memory, and integrate it into the main reconcile loop with minimum-RequeueAfter logic.

Purpose: This is the data-gathering foundation for Phase 3. Without adapter discovery, the operator cannot know which Services to create/remove. This phase makes the operator aware of runtime adapter state.

Output: CRD spec field, DittoFSClient.ListAdapters(), adapter_reconciler.go with safety guards, integration into Reconcile loop, and comprehensive tests.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-adapter-discovery/02-RESEARCH.md
@.planning/phases/01-auth-foundation/01-02-SUMMARY.md

# Key source files to reference during implementation:
@k8s/dittofs-operator/api/v1alpha1/dittoserver_types.go
@k8s/dittofs-operator/api/v1alpha1/dittoserver_types_builder.go
@k8s/dittofs-operator/api/v1alpha1/helpers.go
@k8s/dittofs-operator/internal/controller/dittofs_client.go
@k8s/dittofs-operator/internal/controller/auth_reconciler.go
@k8s/dittofs-operator/internal/controller/auth_reconciler_test.go
@k8s/dittofs-operator/internal/controller/dittoserver_controller.go
@k8s/dittofs-operator/utils/conditions/conditions.go
@internal/controlplane/api/handlers/adapters.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CRD spec field, builder option, and ListAdapters to DittoFSClient</name>
  <files>
    k8s/dittofs-operator/api/v1alpha1/dittoserver_types.go
    k8s/dittofs-operator/api/v1alpha1/dittoserver_types_builder.go
    k8s/dittofs-operator/internal/controller/dittofs_client.go
  </files>
  <action>
**1. Add AdapterDiscoverySpec to CRD types** (`dittoserver_types.go`):

Add a new struct after the existing `IdentityConfig` section:

```go
// AdapterDiscoverySpec configures how the operator discovers protocol adapters.
type AdapterDiscoverySpec struct {
    // PollingInterval is how often the operator polls the adapter list API.
    // Supports Go duration strings (e.g., "30s", "1m", "5m").
    // +kubebuilder:default="30s"
    // +optional
    PollingInterval string `json:"pollingInterval,omitempty"`
}
```

Add to `DittoServerSpec` struct (after the `Identity` field):

```go
// AdapterDiscovery configures adapter discovery polling
// +optional
AdapterDiscovery *AdapterDiscoverySpec `json:"adapterDiscovery,omitempty"`
```

**2. Add builder option** (`dittoserver_types_builder.go`):

Add after `WithIdentity`:

```go
// WithAdapterDiscovery sets the AdapterDiscovery of a DittoServerSpec
func WithAdapterDiscovery(ad *AdapterDiscoverySpec) func(*DittoServerSpec) {
    return func(obj *DittoServerSpec) {
        obj.AdapterDiscovery = ad
    }
}
```

**3. Add AdapterInfo type and ListAdapters method** (`dittofs_client.go`):

Add `AdapterInfo` struct (minimal -- only fields the operator needs) and `ListAdapters` method at the bottom of the file:

```go
// AdapterInfo represents an adapter returned by the DittoFS API.
// Only fields needed by the operator are included.
type AdapterInfo struct {
    Type    string `json:"type"`
    Enabled bool   `json:"enabled"`
    Running bool   `json:"running"`
    Port    int    `json:"port"`
}

// ListAdapters calls GET /api/v1/adapters and returns the adapter list.
func (c *DittoFSClient) ListAdapters() ([]AdapterInfo, error) {
    var adapters []AdapterInfo
    if err := c.do(http.MethodGet, "/api/v1/adapters", nil, &adapters); err != nil {
        return nil, err
    }
    return adapters, nil
}
```

Note on `AdapterInfo`: The server's `AdapterResponse` includes `id`, `config`, `created_at`, `updated_at` but the operator only needs `type`, `enabled`, `running`, `port`. Go's JSON decoder silently ignores unknown fields, so this subset struct works directly against the full API response. Do NOT include `ID` -- the research initially included it but it is not needed by the operator, and the research note says "minimal struct -- only the fields the operator needs."

**Commit this task as:** `feat(02-01): add adapter discovery CRD field and ListAdapters client method`
  </action>
  <verify>
Run `go build ./...` from `k8s/dittofs-operator/` to verify compilation. Run `go vet ./...` to catch issues. Verify the `AdapterDiscoverySpec` struct exists in types, the builder option exists, and `ListAdapters` method exists on `DittoFSClient`.
  </verify>
  <done>
AdapterDiscoverySpec struct exists in CRD types with PollingInterval field defaulting to "30s". WithAdapterDiscovery builder option available. DittoFSClient has ListAdapters() returning []AdapterInfo. All code compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement adapter reconciler with safety guards, integrate into Reconcile loop, and add tests</name>
  <files>
    k8s/dittofs-operator/internal/controller/adapter_reconciler.go
    k8s/dittofs-operator/internal/controller/adapter_reconciler_test.go
    k8s/dittofs-operator/internal/controller/dittoserver_controller.go
  </files>
  <action>
**1. Create `adapter_reconciler.go`** following the same sub-reconciler pattern as `auth_reconciler.go`:

Add the file with:

```go
package controller

import (
    "context"
    "fmt"
    "sync"
    "time"

    dittoiov1alpha1 "github.com/marmos91/dittofs/k8s/dittofs-operator/api/v1alpha1"
    "github.com/marmos91/dittofs/k8s/dittofs-operator/utils/conditions"
    corev1 "k8s.io/api/core/v1"
    ctrl "sigs.k8s.io/controller-runtime"
    "sigs.k8s.io/controller-runtime/pkg/client"
    logf "sigs.k8s.io/controller-runtime/pkg/log"
)

const defaultPollingInterval = 30 * time.Second
```

**Add fields to `DittoServerReconciler`** in `dittoserver_controller.go`:

Add these fields to the struct definition:

```go
// adaptersMu protects lastKnownAdapters for concurrent reconcile safety.
adaptersMu sync.RWMutex
// lastKnownAdapters stores the last successful adapter poll result per CR.
// Key is namespace/name of the DittoServer CR.
lastKnownAdapters map[string][]AdapterInfo
```

**Implement in `adapter_reconciler.go`:**

- `getPollingInterval(ds *dittoiov1alpha1.DittoServer) time.Duration` -- reads `spec.AdapterDiscovery.PollingInterval`, parses with `time.ParseDuration`, falls back to `defaultPollingInterval` if nil/empty/invalid/non-positive. IMPORTANT: Read fresh from the spec every time, never cache the value.

- `getAuthenticatedClient(ctx context.Context, ds *dittoiov1alpha1.DittoServer) (*DittoFSClient, error)` -- reads the operator credentials Secret (name from `ds.GetOperatorCredentialsSecretName()`), extracts `access-token` and `server-url`, creates a `NewDittoFSClient` with the server URL, calls `SetToken` with the access token, returns the client. Return error if Secret not found or missing keys.

- `reconcileAdapters(ctx context.Context, dittoServer *dittoiov1alpha1.DittoServer) (ctrl.Result, error)` -- the main method:
  1. Get polling interval from CRD spec
  2. Call `getAuthenticatedClient` -- on error, log and return `ctrl.Result{RequeueAfter: pollingInterval}, nil` (preserve state, don't error)
  3. Call `client.ListAdapters()` -- on error, log "Adapter polling failed, preserving existing state" at Info level and return `ctrl.Result{RequeueAfter: pollingInterval}, nil` (DISC-03: never act on failed response)
  4. On success: call `r.setLastKnownAdapters(dittoServer, adapters)` to store the result
  5. Log at V(1) level: adapter count and next poll time
  6. Return `ctrl.Result{RequeueAfter: pollingInterval}, nil`

- `setLastKnownAdapters(ds *dittoiov1alpha1.DittoServer, adapters []AdapterInfo)`:
  - Write-lock `r.adaptersMu`
  - Lazy-init `r.lastKnownAdapters` map if nil
  - Key: `ds.Namespace + "/" + ds.Name`
  - Store `adapters` (even if empty -- empty is valid state per research)

- `getLastKnownAdapters(ds *dittoiov1alpha1.DittoServer) []AdapterInfo`:
  - Read-lock `r.adaptersMu`
  - Return `nil` if map is nil or key missing (no successful poll yet)
  - This method is for Phase 3 consumption.

**2. Integrate into main Reconcile loop** (`dittoserver_controller.go`):

Replace the current auth reconciliation block (lines ~253-267) with:

```go
// Auth reconciliation: only when StatefulSet has at least one ready replica
if statefulSet.Status.ReadyReplicas >= 1 {
    authResult, authErr := r.reconcileAuth(ctx, dittoServer)
    if authErr != nil {
        logger.Error(authErr, "Auth reconciliation failed")
        r.Recorder.Eventf(dittoServer, corev1.EventTypeWarning, "AuthFailed",
            "Failed to authenticate with DittoFS API: %v", authErr)
        // Don't return error -- auth failure should not block infrastructure reconciliation
        // The Authenticated condition will reflect the failure
    }

    // Adapter discovery: only if authenticated
    var adapterResult ctrl.Result
    if conditions.IsConditionTrue(dittoServer.Status.Conditions, conditions.ConditionAuthenticated) {
        adapterResult, _ = r.reconcileAdapters(ctx, dittoServer)
    }

    // Use minimum RequeueAfter from all sub-reconcilers
    result := mergeRequeueAfter(authResult, adapterResult)
    if result.RequeueAfter > 0 || result.Requeue {
        return result, nil
    }
}
```

Add the `mergeRequeueAfter` helper function in `dittoserver_controller.go`:

```go
// mergeRequeueAfter returns a Result with the minimum positive RequeueAfter
// from the given results. This ensures the fastest-cycling sub-reconciler
// drives the reconcile cadence.
func mergeRequeueAfter(results ...ctrl.Result) ctrl.Result {
    var minResult ctrl.Result
    for _, r := range results {
        if r.Requeue {
            minResult.Requeue = true
        }
        if r.RequeueAfter > 0 {
            if minResult.RequeueAfter == 0 || r.RequeueAfter < minResult.RequeueAfter {
                minResult.RequeueAfter = r.RequeueAfter
            }
        }
    }
    return minResult
}
```

IMPORTANT: The `conditions.IsConditionTrue` check reads from the `dittoServer` that was fetched at the start of Reconcile. However, `setAuthCondition` in the auth reconciler does its own `Status().Update()` on a re-fetched copy. This means `dittoServer.Status.Conditions` might be stale. To handle this correctly, **re-fetch the DittoServer** after auth reconciliation to get the updated condition state:

```go
// Re-fetch to get updated conditions after auth reconciliation
if err := r.Get(ctx, req.NamespacedName, dittoServer); err != nil {
    return ctrl.Result{}, client.IgnoreNotFound(err)
}
```

Place this re-fetch after the auth reconciliation block and before the adapter polling condition check.

**3. Create `adapter_reconciler_test.go`** with these test cases:

Use the same patterns from `auth_reconciler_test.go` (reuse `newTestDittoServer`, `setupAuthReconciler`, `mockDittoFSServer`):

- **TestReconcileAdapters_Success**: Create DS, operator credentials Secret, mock server returning 2 adapters (nfs + smb). Verify `result.RequeueAfter == 30s`, `getLastKnownAdapters` returns 2 adapters with correct types/ports.

- **TestReconcileAdapters_APIError_PreservesState**: Pre-populate `lastKnownAdapters` with 2 adapters. Mock server returns 500. Verify `getLastKnownAdapters` still has the original 2 adapters (DISC-03).

- **TestReconcileAdapters_EmptyResponse_StoresEmpty**: Mock server returns empty array `[]`. Verify `getLastKnownAdapters` returns empty slice (not nil). This confirms empty is stored as valid state.

- **TestReconcileAdapters_NoCredentials_PreservesState**: No credentials Secret exists. Verify reconcileAdapters returns RequeueAfter without error and does not panic.

- **TestReconcileAdapters_CustomPollingInterval**: Set `spec.adapterDiscovery.pollingInterval: "1m"`. Verify `result.RequeueAfter == 60s`.

- **TestGetPollingInterval_Default**: No AdapterDiscovery set. Verify returns 30s.

- **TestGetPollingInterval_Custom**: Set "45s". Verify returns 45s.

- **TestGetPollingInterval_Invalid**: Set "invalid". Verify returns 30s (default).

- **TestMergeRequeueAfter**: Test mergeRequeueAfter with various combinations: (0, 30s) -> 30s; (12m, 30s) -> 30s; (30s, 0) -> 30s; (0, 0) -> 0.

For the test that pre-populates lastKnownAdapters, directly set `r.lastKnownAdapters` on the reconciler before calling `reconcileAdapters` since the field is on the struct.

**Commit this task as:** `feat(02-01): implement adapter reconciler with polling, safety guards, and tests`
  </action>
  <verify>
Run from `k8s/dittofs-operator/`:
- `go build ./...` -- must compile
- `go vet ./...` -- must pass
- `go test ./...` -- all tests must pass (both new adapter tests and existing auth/controller tests)

Verify specific test names pass:
- `go test -v ./internal/controller/ -run TestReconcileAdapters`
- `go test -v ./internal/controller/ -run TestGetPollingInterval`
- `go test -v ./internal/controller/ -run TestMergeRequeueAfter`
  </verify>
  <done>
adapter_reconciler.go exists with reconcileAdapters, getPollingInterval, getAuthenticatedClient, setLastKnownAdapters, getLastKnownAdapters. DittoServerReconciler has adaptersMu and lastKnownAdapters fields. Reconcile loop calls reconcileAdapters after auth when Authenticated=True with min-RequeueAfter merge. All 9+ adapter reconciler tests pass. All existing auth and controller tests pass. DISC-03 safety: API error preserves lastKnownAdapters.
  </done>
</task>

</tasks>

<verification>
From `k8s/dittofs-operator/`:

1. `go build ./...` -- operator compiles
2. `go vet ./...` -- no issues
3. `go test ./...` -- ALL tests pass (auth + adapter + controller)
4. `go test -v ./internal/controller/ -run TestReconcileAdapters` -- adapter tests pass
5. `go test -v ./internal/controller/ -run TestGetPollingInterval` -- interval parsing tests pass
6. `go test -v ./internal/controller/ -run TestMergeRequeueAfter` -- merge logic tests pass
7. Grep for `reconcileAdapters` in dittoserver_controller.go confirms integration
8. Grep for `IsConditionTrue.*ConditionAuthenticated` before reconcileAdapters confirms auth guard
9. Grep for `mergeRequeueAfter` confirms min-result logic exists
</verification>

<success_criteria>
- AdapterDiscoverySpec with PollingInterval field exists in CRD types
- DittoFSClient.ListAdapters() returns []AdapterInfo
- adapter_reconciler.go implements polling with DISC-03 safety (never deletes on error)
- Polling interval is read from CRD spec on every reconcile (never cached)
- Adapter polling only runs when Authenticated condition is True
- Minimum RequeueAfter from auth and adapter reconcilers drives the reconcile cadence
- All tests pass including both new adapter tests and existing auth/controller tests
</success_criteria>

<output>
After completion, create `.planning/phases/02-adapter-discovery/02-01-SUMMARY.md`
</output>
