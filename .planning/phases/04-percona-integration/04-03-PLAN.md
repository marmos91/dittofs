---
phase: 04-percona-integration
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - k8s/dittofs-operator/api/v1alpha1/dittoserver_webhook.go
  - k8s/dittofs-operator/api/v1alpha1/dittoserver_webhook_test.go
  - k8s/dittofs-operator/config/samples/dittofs_v1alpha1_dittoserver_percona.yaml
  - k8s/dittofs-operator/internal/controller/dittoserver_controller_test.go
autonomous: false

must_haves:
  truths:
    - "Webhook rejects DittoServer with Percona enabled if PerconaPGCluster CRD not installed"
    - "Webhook warns if both PostgresSecretRef and Percona enabled"
    - "Sample Percona CR exists for testing"
    - "Operator works correctly with Percona integration"
  artifacts:
    - path: "k8s/dittofs-operator/api/v1alpha1/dittoserver_webhook.go"
      provides: "Percona CRD validation"
      contains: "perconapgclusters"
    - path: "k8s/dittofs-operator/config/samples/dittofs_v1alpha1_dittoserver_percona.yaml"
      provides: "Sample Percona-enabled CR"
      contains: "percona:"
  key_links:
    - from: "dittoserver_webhook.go"
      to: "PerconaPGCluster CRD"
      via: "RESTMapper check"
      pattern: "pgv2\\.percona\\.com"
---

<objective>
Add Percona CRD validation webhook, sample CRs, tests, and human verification of the complete integration.

Purpose: Ensure the operator properly validates Percona configuration (CRD must exist, handle precedence with PostgresSecretRef), provides sample CRs for users, and the complete integration works end-to-end.

Output: Webhook validation for Percona CRD, sample Percona-enabled CR, unit tests, human verification checkpoint.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-percona-integration/04-CONTEXT.md
@.planning/phases/04-percona-integration/04-RESEARCH.md
@.planning/phases/04-percona-integration/04-01-SUMMARY.md
@.planning/phases/04-percona-integration/04-02-SUMMARY.md
@k8s/dittofs-operator/api/v1alpha1/dittoserver_webhook.go
@k8s/dittofs-operator/api/v1alpha1/dittoserver_webhook_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Percona CRD validation to webhook</name>
  <files>
    k8s/dittofs-operator/api/v1alpha1/dittoserver_webhook.go
  </files>
  <action>
Update the webhook validation in dittoserver_webhook.go to:
1. Check if PerconaPGCluster CRD exists when Percona is enabled
2. Warn if both Percona and PostgresSecretRef are set (Percona wins per CONTEXT.md)

In validateDittoServerWithClient function, add after S3 validation:
```go
// Validate Percona configuration
if ds.Spec.Percona != nil && ds.Spec.Percona.Enabled {
    // Check if PerconaPGCluster CRD is installed
    gvk := schema.GroupVersionKind{
        Group:   "pgv2.percona.com",
        Version: "v2",
        Kind:    "PerconaPGCluster",
    }
    _, err := v.Client.RESTMapper().RESTMapping(gvk.GroupKind(), gvk.Version)
    if err != nil {
        return warnings, fmt.Errorf("Percona PostgreSQL Operator CRD not installed; install pg-operator first or disable percona.enabled")
    }

    // Warn if both Percona and PostgresSecretRef are set
    if ds.Spec.Database != nil && ds.Spec.Database.PostgresSecretRef != nil {
        warnings = append(warnings,
            "Both percona.enabled and database.postgresSecretRef are set; Percona-managed PostgreSQL will be used (PostgresSecretRef ignored)")
    }

    // Validate Percona StorageClass if specified
    if ds.Spec.Percona.StorageClassName != nil && *ds.Spec.Percona.StorageClassName != "" {
        scName := *ds.Spec.Percona.StorageClassName
        storageClass := &storagev1.StorageClass{}
        err := v.Client.Get(ctx, types.NamespacedName{Name: scName}, storageClass)
        if err != nil {
            if apierrors.IsNotFound(err) {
                return warnings, fmt.Errorf("Percona StorageClass %q does not exist in cluster", scName)
            }
            warnings = append(warnings,
                fmt.Sprintf("Could not verify Percona StorageClass %q exists: %v", scName, err))
        }
    }

    // Validate backup configuration if enabled
    if ds.Spec.Percona.Backup != nil && ds.Spec.Percona.Backup.Enabled {
        backup := ds.Spec.Percona.Backup

        // Bucket is required if backup enabled
        if backup.Bucket == "" {
            return warnings, fmt.Errorf("percona.backup.bucket is required when backup is enabled")
        }

        // Endpoint is required for S3-compatible storage
        if backup.Endpoint == "" {
            return warnings, fmt.Errorf("percona.backup.endpoint is required when backup is enabled")
        }

        // Warn if credentials secret not specified
        if backup.CredentialsSecretRef == nil {
            warnings = append(warnings,
                "percona.backup.credentialsSecretRef not set; pgBackRest may fail to authenticate with S3")
        } else {
            // Check if credentials secret exists (warning only)
            secret := &corev1.Secret{}
            err := v.Client.Get(ctx, types.NamespacedName{
                Name:      backup.CredentialsSecretRef.Name,
                Namespace: ds.Namespace,
            }, secret)
            if err != nil {
                if apierrors.IsNotFound(err) {
                    warnings = append(warnings,
                        fmt.Sprintf("pgBackRest credentials Secret %q not found; ensure it exists before PostgreSQL starts", backup.CredentialsSecretRef.Name))
                }
            }
        }
    }
}
```

Add import for schema:
```go
import (
    "k8s.io/apimachinery/pkg/runtime/schema"
)
```
  </action>
  <verify>
```bash
cd k8s/dittofs-operator
go build ./api/v1alpha1/...
grep -q "PerconaPGCluster CRD not installed" api/v1alpha1/dittoserver_webhook.go
grep -q "Percona-managed PostgreSQL will be used" api/v1alpha1/dittoserver_webhook.go
```
  </verify>
  <done>Webhook validates Percona CRD exists, warns on precedence conflict, validates backup config</done>
</task>

<task type="auto">
  <name>Task 2: Add sample Percona CR and update tests</name>
  <files>
    k8s/dittofs-operator/config/samples/dittofs_v1alpha1_dittoserver_percona.yaml
    k8s/dittofs-operator/api/v1alpha1/dittoserver_webhook_test.go
    k8s/dittofs-operator/internal/controller/dittoserver_controller_test.go
  </files>
  <action>
1. Create sample Percona-enabled CR:

**config/samples/dittofs_v1alpha1_dittoserver_percona.yaml**:
```yaml
# DittoServer with Percona PostgreSQL integration
# Prerequisites:
# 1. Percona Operator installed: helm install pg-operator percona/pg-operator
# 2. StorageClass available (or use cluster default)
apiVersion: dittofs.dittofs.com/v1alpha1
kind: DittoServer
metadata:
  name: dittofs-percona
  labels:
    app.kubernetes.io/name: dittofs
    app.kubernetes.io/instance: dittofs-percona
spec:
  image: marmos91c/dittofs:latest
  replicas: 1

  # Storage for DittoFS internal data
  storage:
    metadataSize: "10Gi"
    contentSize: "50Gi"
    cacheSize: "5Gi"
    # storageClassName: "fast-ssd"  # Optional, uses default if not set

  # Percona PostgreSQL for control plane metadata
  percona:
    enabled: true
    replicas: 1
    storageSize: "10Gi"
    # storageClassName: "fast-ssd"  # Can differ from DittoFS storage
    databaseName: "dittofs"
    # Backup configuration (optional)
    # backup:
    #   enabled: true
    #   bucket: "my-backups"
    #   endpoint: "https://s3.cubbit.eu"
    #   region: "eu-west-1"
    #   credentialsSecretRef:
    #     name: pgbackrest-s3-creds

  # REST API configuration
  controlPlane:
    port: 8080

  # Identity configuration
  identity:
    type: memory
    jwt:
      secretRef:
        name: dittofs-percona-jwt
        key: secret
      accessTokenDuration: "15m"
      refreshTokenDuration: "168h"

  # Service configuration
  service:
    type: LoadBalancer
---
# JWT Secret for API authentication
apiVersion: v1
kind: Secret
metadata:
  name: dittofs-percona-jwt
type: Opaque
stringData:
  secret: "change-this-to-a-secure-random-string-at-least-32-chars"
```

2. Add webhook tests for Percona validation:

In dittoserver_webhook_test.go, add tests for Percona validation. Note: These tests may need to mock the RESTMapper or be skipped if running without a cluster. Add tests that don't require cluster access:

```go
// Add to existing test file

func TestPerconaPrecedenceWarning(t *testing.T) {
    ds := &DittoServer{
        ObjectMeta: metav1.ObjectMeta{
            Name:      "test-percona-precedence",
            Namespace: "default",
        },
        Spec: DittoServerSpec{
            Storage: StorageSpec{
                MetadataSize: "10Gi",
                CacheSize:    "5Gi",
            },
            Percona: &PerconaConfig{
                Enabled: true,
            },
            Database: &DatabaseConfig{
                PostgresSecretRef: &corev1.SecretKeySelector{
                    LocalObjectReference: corev1.LocalObjectReference{
                        Name: "external-postgres",
                    },
                    Key: "connection-string",
                },
            },
        },
    }

    // The basic validation (without client) should not produce warnings
    // Full validation with client would warn about precedence
    warnings, err := ds.validateDittoServer()
    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }
    // Basic validation doesn't check Percona/Postgres precedence (needs client)
    _ = warnings
}

func TestPerconaBackupRequiredFields(t *testing.T) {
    ds := &DittoServer{
        ObjectMeta: metav1.ObjectMeta{
            Name:      "test-percona-backup",
            Namespace: "default",
        },
        Spec: DittoServerSpec{
            Storage: StorageSpec{
                MetadataSize: "10Gi",
                CacheSize:    "5Gi",
            },
            Percona: &PerconaConfig{
                Enabled: true,
                Backup: &PerconaBackupConfig{
                    Enabled: true,
                    // Missing bucket and endpoint
                },
            },
        },
    }

    // Basic validation passes (backup validation needs client for full check)
    warnings, err := ds.validateDittoServer()
    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }
    _ = warnings
}
```

3. Run tests to verify:
```bash
cd k8s/dittofs-operator
make test
```
  </action>
  <verify>
```bash
cd k8s/dittofs-operator
ls -la config/samples/dittofs_v1alpha1_dittoserver_percona.yaml
make test
```
  </verify>
  <done>Sample Percona CR created, webhook tests added, all tests pass</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Percona PostgreSQL integration for DittoFS operator:
1. CRD types: PerconaConfig, PerconaBackupConfig
2. Percona API scheme registration
3. RBAC for PerconaPGCluster management
4. reconcilePerconaPGCluster with owner reference
5. Init container for PostgreSQL readiness (wait-for-postgres)
6. DATABASE_URL injection from Percona Secret
7. Webhook validation for Percona CRD existence
8. Sample Percona-enabled CR
  </what-built>
  <how-to-verify>
**Option A: Local verification (no cluster required)**

1. Build and test the operator:
```bash
cd k8s/dittofs-operator
make test
make build
```

2. Verify manifests generated correctly:
```bash
# Check RBAC includes PerconaPGCluster
cat config/rbac/role.yaml | grep -A10 "perconapgclusters"

# Check CRD has Percona fields
cat config/crd/bases/dittofs.dittofs.com_dittoservers.yaml | grep -A30 "percona:"
```

3. Review sample CR is valid YAML:
```bash
cat config/samples/dittofs_v1alpha1_dittoserver_percona.yaml
```

**Option B: Cluster verification (requires Kubernetes cluster)**

Prerequisites:
1. Kubernetes cluster available (kind, minikube, or remote)
2. Percona Operator installed:
```bash
helm repo add percona https://percona.github.io/percona-helm-charts/
helm install pg-operator percona/pg-operator --namespace percona --create-namespace
```

Test flow:
1. Install CRDs: `make install`
2. Apply sample without Percona: `kubectl apply -f config/samples/dittofs_v1alpha1_dittoserver.yaml`
3. Verify it works
4. Apply Percona sample: `kubectl apply -f config/samples/dittofs_v1alpha1_dittoserver_percona.yaml`
5. Watch for PerconaPGCluster creation: `kubectl get perconapgclusters`
6. Watch DittoFS status: `kubectl get dittoservers -w`

**Expected behavior:**
- Without Percona Operator: Webhook rejects CR with "CRD not installed" error
- With Percona Operator: PerconaPGCluster created with owner reference
- Pod has init container waiting for PostgreSQL
- Pod has DATABASE_URL env var from Percona Secret
  </how-to-verify>
  <resume-signal>Type "approved" if tests pass and manifests look correct, or describe issues</resume-signal>
</task>

</tasks>

<verification>
After completing all tasks:
1. `make test` passes
2. Webhook validates Percona CRD existence
3. Sample Percona CR exists and is valid YAML
4. RBAC role includes perconapgclusters permissions
5. CRD schema includes percona field with all subfields
</verification>

<success_criteria>
- Webhook rejects DittoServer with Percona enabled if CRD not installed
- Webhook warns when both Percona and PostgresSecretRef are set
- Sample Percona CR demonstrates the integration
- All tests pass
- Human verified the complete integration works
</success_criteria>

<output>
After completion, create `.planning/phases/04-percona-integration/04-03-SUMMARY.md`
</output>
