---
phase: 04-percona-integration
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - k8s/dittofs-operator/internal/controller/dittoserver_controller.go
  - k8s/dittofs-operator/internal/controller/config/config.go
  - k8s/dittofs-operator/pkg/percona/percona.go
  - k8s/dittofs-operator/pkg/percona/status.go
autonomous: true

must_haves:
  truths:
    - "Operator creates PerconaPGCluster when Percona is enabled"
    - "PerconaPGCluster is owned by DittoServer (deleted when DittoServer deleted)"
    - "DittoFS pod has init container waiting for PostgreSQL readiness"
    - "DATABASE_URL environment variable injected from Percona Secret"
  artifacts:
    - path: "k8s/dittofs-operator/pkg/percona/percona.go"
      provides: "PerconaPGCluster spec building"
      contains: "BuildPerconaPGClusterSpec"
    - path: "k8s/dittofs-operator/internal/controller/dittoserver_controller.go"
      provides: "reconcilePerconaPGCluster function"
      contains: "func.*reconcilePerconaPGCluster"
  key_links:
    - from: "dittoserver_controller.go"
      to: "pkg/percona/percona.go"
      via: "import and call"
      pattern: "percona\\.Build"
    - from: "StatefulSet"
      to: "Percona Secret"
      via: "DATABASE_URL env var"
      pattern: "DATABASE_URL.*secretKeyRef"
---

<objective>
Implement PerconaPGCluster reconciliation, init container for PostgreSQL readiness, and DATABASE_URL wiring.

Purpose: When a user enables Percona integration, the operator should auto-create a PerconaPGCluster CR (owned by DittoServer), wait for PostgreSQL to be ready before starting DittoFS, and inject the connection string as DATABASE_URL.

Output: pkg/percona package with PerconaPGCluster spec building, reconcilePerconaPGCluster function, init container configuration, DATABASE_URL injection.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-percona-integration/04-CONTEXT.md
@.planning/phases/04-percona-integration/04-RESEARCH.md
@.planning/phases/04-percona-integration/04-01-SUMMARY.md
@k8s/dittofs-operator/internal/controller/dittoserver_controller.go
@k8s/dittofs-operator/internal/controller/config/config.go
@k8s/dittofs-operator/api/v1alpha1/dittoserver_types.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pkg/percona package with spec building</name>
  <files>
    k8s/dittofs-operator/pkg/percona/percona.go
    k8s/dittofs-operator/pkg/percona/status.go
  </files>
  <action>
Create new package `pkg/percona/` with two files:

**percona.go** - PerconaPGCluster spec building:
```go
package percona

import (
    corev1 "k8s.io/api/core/v1"
    "k8s.io/apimachinery/pkg/api/resource"

    dittoiov1alpha1 "github.com/marmos91/dittofs/k8s/dittofs-operator/api/v1alpha1"
    pgv2 "github.com/percona/percona-postgresql-operator/pkg/apis/pgv2.percona.com/v2"
)

const (
    // PerconaAPIVersion is the API version for PerconaPGCluster
    PerconaAPIVersion = "2.8.0"
    // PostgresVersion is the PostgreSQL version to use
    PostgresVersion = 16
    // DefaultStorageSize is the default storage size for PostgreSQL
    DefaultStorageSize = "10Gi"
    // DefaultDatabaseName is the default database name
    DefaultDatabaseName = "dittofs"
    // DittoFSUser is the PostgreSQL user for DittoFS
    DittoFSUser = "dittofs"
)

// ClusterName returns the PerconaPGCluster name for a DittoServer
func ClusterName(dsName string) string {
    return dsName + "-postgres"
}

// SecretName returns the Percona user credentials Secret name
func SecretName(dsName string) string {
    return ClusterName(dsName) + "-pguser-" + DittoFSUser
}

// BuildPerconaPGClusterSpec creates the PerconaPGCluster spec from DittoServer config
func BuildPerconaPGClusterSpec(ds *dittoiov1alpha1.DittoServer) pgv2.PerconaPGClusterSpec {
    cfg := ds.Spec.Percona
    if cfg == nil {
        return pgv2.PerconaPGClusterSpec{}
    }

    replicas := int32(1)
    if cfg.Replicas != nil {
        replicas = *cfg.Replicas
    }

    storageSize := DefaultStorageSize
    if cfg.StorageSize != "" {
        storageSize = cfg.StorageSize
    }

    dbName := DefaultDatabaseName
    if cfg.DatabaseName != "" {
        dbName = cfg.DatabaseName
    }

    spec := pgv2.PerconaPGClusterSpec{
        CRVersion:       PerconaAPIVersion,
        PostgresVersion: PostgresVersion,
        InstanceSets: []pgv2.PGInstanceSetSpec{
            {
                Name:     "instance1",
                Replicas: &replicas,
                DataVolumeClaimSpec: corev1.PersistentVolumeClaimSpec{
                    AccessModes: []corev1.PersistentVolumeAccessMode{
                        corev1.ReadWriteOnce,
                    },
                    Resources: corev1.VolumeResourceRequirements{
                        Requests: corev1.ResourceList{
                            corev1.ResourceStorage: resource.MustParse(storageSize),
                        },
                    },
                },
            },
        },
        Users: []pgv2.PGUserSpec{
            {
                Name:      pgv2.PGUserName(DittoFSUser),
                Databases: []pgv2.PGDatabaseName{pgv2.PGDatabaseName(dbName)},
            },
        },
    }

    // Set storage class if specified
    if cfg.StorageClassName != nil {
        spec.InstanceSets[0].DataVolumeClaimSpec.StorageClassName = cfg.StorageClassName
    }

    // Configure backups if enabled
    if cfg.Backup != nil && cfg.Backup.Enabled {
        spec.Backups = buildBackupsSpec(ds.Name, cfg.Backup)
    }

    return spec
}

// buildBackupsSpec creates the pgBackRest backup configuration
func buildBackupsSpec(dsName string, backup *dittoiov1alpha1.PerconaBackupConfig) pgv2.Backups {
    if backup == nil || !backup.Enabled {
        return pgv2.Backups{}
    }

    // Default schedules
    fullSchedule := "0 2 * * *"   // Daily at 2am
    incrSchedule := "0 * * * *"   // Hourly
    region := "eu-west-1"

    if backup.FullSchedule != "" {
        fullSchedule = backup.FullSchedule
    }
    if backup.IncrSchedule != "" {
        incrSchedule = backup.IncrSchedule
    }
    if backup.Region != "" {
        region = backup.Region
    }

    backups := pgv2.Backups{
        PGBackRest: pgv2.PGBackRestArchive{
            Global: map[string]string{
                "repo1-path":              "/pgbackrest/" + dsName + "/repo1",
                "repo1-s3-uri-style":      "path",
                "repo1-storage-verify-tls": "y",
            },
            Repos: []pgv2.PGBackRestRepo{
                {
                    Name: "repo1",
                    S3: &pgv2.RepoS3{
                        Bucket:   backup.Bucket,
                        Endpoint: backup.Endpoint,
                        Region:   region,
                    },
                    BackupSchedules: &pgv2.PGBackRestBackupSchedules{
                        Full:        &fullSchedule,
                        Incremental: &incrSchedule,
                    },
                },
            },
        },
    }

    // Add credentials secret reference if provided
    if backup.CredentialsSecretRef != nil {
        backups.PGBackRest.Configuration = []corev1.VolumeProjection{
            {
                Secret: &corev1.SecretProjection{
                    LocalObjectReference: *backup.CredentialsSecretRef,
                },
            },
        }
    }

    return backups
}
```

**status.go** - Status helpers:
```go
package percona

import (
    pgv2 "github.com/percona/percona-postgresql-operator/pkg/apis/pgv2.percona.com/v2"
)

// IsReady checks if the PerconaPGCluster is ready
func IsReady(cluster *pgv2.PerconaPGCluster) bool {
    return cluster.Status.State == pgv2.AppStateReady
}

// GetState returns the current state of the PerconaPGCluster
func GetState(cluster *pgv2.PerconaPGCluster) string {
    return string(cluster.Status.State)
}
```

Note: The exact Percona API types (field names, struct names) should match what's in the imported package. Verify against the Percona v2 API during implementation. The research indicates:
- `InstanceSets` (not `Instances`)
- `PGUserSpec` with `Name` and `Databases` fields
- Status has `State` field with values like `AppStateReady`

Adjust field names based on actual API if different.
  </action>
  <verify>
```bash
cd k8s/dittofs-operator
go build ./pkg/percona/...
ls -la pkg/percona/
```
  </verify>
  <done>pkg/percona package created with BuildPerconaPGClusterSpec and status helpers</done>
</task>

<task type="auto">
  <name>Task 2: Implement reconcilePerconaPGCluster in controller</name>
  <files>
    k8s/dittofs-operator/internal/controller/dittoserver_controller.go
  </files>
  <action>
Add PerconaPGCluster reconciliation to the controller.

1. Add import for percona package:
```go
import (
    // ... existing imports ...
    "github.com/marmos91/dittofs/k8s/dittofs-operator/pkg/percona"
    pgv2 "github.com/percona/percona-postgresql-operator/pkg/apis/pgv2.percona.com/v2"
)
```

2. Add reconcilePerconaPGCluster call in Reconcile function (before reconcileStatefulSet):
```go
// In Reconcile function, after reconcileMetricsService:

// Reconcile PerconaPGCluster if Percona is enabled
if err := r.reconcilePerconaPGCluster(ctx, dittoServer); err != nil {
    logger.Error(err, "Failed to reconcile PerconaPGCluster")
    return ctrl.Result{}, err
}

// Check if Percona is enabled but not ready - block StatefulSet creation
if dittoServer.Spec.Percona != nil && dittoServer.Spec.Percona.Enabled {
    pgCluster := &pgv2.PerconaPGCluster{}
    err := r.Get(ctx, client.ObjectKey{
        Namespace: dittoServer.Namespace,
        Name:      percona.ClusterName(dittoServer.Name),
    }, pgCluster)
    if err != nil {
        logger.Info("Waiting for PerconaPGCluster to be created")
        return ctrl.Result{RequeueAfter: 10 * time.Second}, nil
    }
    if !percona.IsReady(pgCluster) {
        logger.Info("Waiting for PerconaPGCluster to be ready", "state", percona.GetState(pgCluster))
        return ctrl.Result{RequeueAfter: 10 * time.Second}, nil
    }
}
```

3. Implement reconcilePerconaPGCluster function:
```go
// reconcilePerconaPGCluster creates/updates the PerconaPGCluster CR if Percona is enabled.
// The PerconaPGCluster is owned by DittoServer and will be deleted when DittoServer is deleted.
// Per CONTEXT.md decision: operator doesn't reconcile user modifications (no drift reconciliation).
func (r *DittoServerReconciler) reconcilePerconaPGCluster(ctx context.Context, dittoServer *dittoiov1alpha1.DittoServer) error {
    // Skip if Percona is not enabled
    if dittoServer.Spec.Percona == nil || !dittoServer.Spec.Percona.Enabled {
        return nil
    }

    logger := logf.FromContext(ctx)
    clusterName := percona.ClusterName(dittoServer.Name)

    pgCluster := &pgv2.PerconaPGCluster{}
    err := r.Get(ctx, client.ObjectKey{
        Namespace: dittoServer.Namespace,
        Name:      clusterName,
    }, pgCluster)

    if err != nil && !apierrors.IsNotFound(err) {
        return fmt.Errorf("failed to get PerconaPGCluster: %w", err)
    }

    // Create if doesn't exist
    if apierrors.IsNotFound(err) {
        logger.Info("Creating PerconaPGCluster", "name", clusterName)

        pgCluster = &pgv2.PerconaPGCluster{
            ObjectMeta: metav1.ObjectMeta{
                Name:      clusterName,
                Namespace: dittoServer.Namespace,
            },
            Spec: percona.BuildPerconaPGClusterSpec(dittoServer),
        }

        // Set owner reference so it's deleted when DittoServer is deleted
        if err := controllerutil.SetControllerReference(dittoServer, pgCluster, r.Scheme); err != nil {
            return fmt.Errorf("failed to set owner reference: %w", err)
        }

        if err := r.Create(ctx, pgCluster); err != nil {
            return fmt.Errorf("failed to create PerconaPGCluster: %w", err)
        }

        logger.Info("Created PerconaPGCluster", "name", clusterName)
        return nil
    }

    // PerconaPGCluster exists - do NOT update (no drift reconciliation per CONTEXT.md)
    // Users can modify it directly if needed
    logger.V(1).Info("PerconaPGCluster already exists, skipping update", "name", clusterName)
    return nil
}
```

4. Add import for apierrors and time:
```go
import (
    "time"
    apierrors "k8s.io/apimachinery/pkg/api/errors"
)
```
  </action>
  <verify>
```bash
cd k8s/dittofs-operator
go build ./...
grep -q "reconcilePerconaPGCluster" internal/controller/dittoserver_controller.go
grep -q "percona.ClusterName" internal/controller/dittoserver_controller.go
```
  </verify>
  <done>reconcilePerconaPGCluster implemented, controller blocks StatefulSet until PostgreSQL ready</done>
</task>

<task type="auto">
  <name>Task 3: Add init container and DATABASE_URL wiring</name>
  <files>
    k8s/dittofs-operator/internal/controller/dittoserver_controller.go
    k8s/dittofs-operator/internal/controller/config/config.go
  </files>
  <action>
1. Add buildPostgresInitContainer function in dittoserver_controller.go:
```go
// buildPostgresInitContainer creates an init container that waits for PostgreSQL to be ready.
// Uses pg_isready with full auth check (connects as dittofs user to dittofs database).
func buildPostgresInitContainer(dsName string) corev1.Container {
    secretName := percona.SecretName(dsName)

    return corev1.Container{
        Name:  "wait-for-postgres",
        Image: "postgres:16-alpine",
        Command: []string{
            "/bin/sh",
            "-c",
            `echo "Waiting for PostgreSQL at $PGHOST:$PGPORT..."
timeout=300
elapsed=0
while ! pg_isready -h "$PGHOST" -p "$PGPORT" -U "$PGUSER" -d "$PGDATABASE" -t 5; do
  echo "PostgreSQL not ready, waiting... ($elapsed/$timeout seconds)"
  sleep 2
  elapsed=$((elapsed + 2))
  if [ $elapsed -ge $timeout ]; then
    echo "Timeout waiting for PostgreSQL"
    exit 1
  fi
done
echo "PostgreSQL is ready!"`,
        },
        Env: []corev1.EnvVar{
            {
                Name: "PGHOST",
                ValueFrom: &corev1.EnvVarSource{
                    SecretKeyRef: &corev1.SecretKeySelector{
                        LocalObjectReference: corev1.LocalObjectReference{Name: secretName},
                        Key:                  "host",
                    },
                },
            },
            {
                Name: "PGPORT",
                ValueFrom: &corev1.EnvVarSource{
                    SecretKeyRef: &corev1.SecretKeySelector{
                        LocalObjectReference: corev1.LocalObjectReference{Name: secretName},
                        Key:                  "port",
                    },
                },
            },
            {
                Name: "PGUSER",
                ValueFrom: &corev1.EnvVarSource{
                    SecretKeyRef: &corev1.SecretKeySelector{
                        LocalObjectReference: corev1.LocalObjectReference{Name: secretName},
                        Key:                  "user",
                    },
                },
            },
            {
                Name: "PGPASSWORD",
                ValueFrom: &corev1.EnvVarSource{
                    SecretKeyRef: &corev1.SecretKeySelector{
                        LocalObjectReference: corev1.LocalObjectReference{Name: secretName},
                        Key:                  "password",
                    },
                },
            },
            {
                Name: "PGDATABASE",
                ValueFrom: &corev1.EnvVarSource{
                    SecretKeyRef: &corev1.SecretKeySelector{
                        LocalObjectReference: corev1.LocalObjectReference{Name: secretName},
                        Key:                  "dbname",
                    },
                },
            },
        },
    }
}
```

2. Add buildPostgresEnvVars function:
```go
// buildPostgresEnvVars creates the DATABASE_URL env var from Percona Secret.
// Uses the 'uri' key which contains the full connection string.
func buildPostgresEnvVars(dsName string) []corev1.EnvVar {
    secretName := percona.SecretName(dsName)

    return []corev1.EnvVar{
        {
            Name: "DATABASE_URL",
            ValueFrom: &corev1.EnvVarSource{
                SecretKeyRef: &corev1.SecretKeySelector{
                    LocalObjectReference: corev1.LocalObjectReference{Name: secretName},
                    Key:                  "uri",
                },
            },
        },
    }
}
```

3. Update reconcileStatefulSet to add init container and DATABASE_URL when Percona enabled:

In the StatefulSet spec building section, add init containers:
```go
// Build init containers
var initContainers []corev1.Container
if dittoServer.Spec.Percona != nil && dittoServer.Spec.Percona.Enabled {
    initContainers = append(initContainers, buildPostgresInitContainer(dittoServer.Name))
}
```

Add to PodSpec:
```go
Spec: corev1.PodSpec{
    SecurityContext: getPodSecurityContext(dittoServer),
    InitContainers:  initContainers,  // Add this line
    Containers: []corev1.Container{
        // ... existing container spec
    },
```

Update container Env to include DATABASE_URL:
```go
// Merge env vars
envVars := buildS3EnvVars(dittoServer.Spec.S3)
if dittoServer.Spec.Percona != nil && dittoServer.Spec.Percona.Enabled {
    envVars = append(envVars, buildPostgresEnvVars(dittoServer.Name)...)
}

// In container spec:
Env: envVars,
```

4. Update collectSecretData to include Percona secret in hash:
```go
// Percona PostgreSQL credentials secret (if Percona enabled)
if dittoServer.Spec.Percona != nil && dittoServer.Spec.Percona.Enabled {
    secretName := percona.SecretName(dittoServer.Name)
    secret := &corev1.Secret{}
    if err := r.Get(ctx, client.ObjectKey{
        Namespace: dittoServer.Namespace,
        Name:      secretName,
    }, secret); err == nil {
        // Include uri key for hash (credential changes should restart pod)
        if data, ok := secret.Data["uri"]; ok {
            secrets["percona:uri"] = data
        }
    }
    // Note: Don't error if secret doesn't exist yet - Percona operator creates it
}
```
  </action>
  <verify>
```bash
cd k8s/dittofs-operator
go build ./...
grep -q "buildPostgresInitContainer" internal/controller/dittoserver_controller.go
grep -q "DATABASE_URL" internal/controller/dittoserver_controller.go
grep -q "wait-for-postgres" internal/controller/dittoserver_controller.go
```
  </verify>
  <done>Init container added for PostgreSQL readiness, DATABASE_URL injected, Percona secret included in hash</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `go build ./...` succeeds in k8s/dittofs-operator/
2. pkg/percona/ package exists with percona.go and status.go
3. reconcilePerconaPGCluster function exists in controller
4. Init container "wait-for-postgres" configured when Percona enabled
5. DATABASE_URL env var added when Percona enabled
6. Percona Secret included in config hash
</verification>

<success_criteria>
- pkg/percona package builds with BuildPerconaPGClusterSpec and IsReady helpers
- reconcilePerconaPGCluster creates PerconaPGCluster with owner reference
- Controller blocks StatefulSet creation until PerconaPGCluster is ready
- Init container waits up to 5 minutes for PostgreSQL using pg_isready
- DATABASE_URL environment variable references Percona Secret 'uri' key
- Percona Secret changes trigger pod restart (included in config hash)
</success_criteria>

<output>
After completion, create `.planning/phases/04-percona-integration/04-02-SUMMARY.md`
</output>
