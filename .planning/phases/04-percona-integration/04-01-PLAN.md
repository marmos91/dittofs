---
phase: 04-percona-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - k8s/dittofs-operator/api/v1alpha1/dittoserver_types.go
  - k8s/dittofs-operator/api/v1alpha1/zz_generated.deepcopy.go
  - k8s/dittofs-operator/cmd/main.go
  - k8s/dittofs-operator/go.mod
  - k8s/dittofs-operator/go.sum
  - k8s/dittofs-operator/internal/controller/dittoserver_controller.go
  - k8s/dittofs-operator/config/rbac/role.yaml
autonomous: true

must_haves:
  truths:
    - "PerconaConfig and PerconaBackupConfig types are defined in CRD"
    - "Percona API types are importable and scheme is registered"
    - "RBAC allows operator to manage PerconaPGCluster resources"
  artifacts:
    - path: "k8s/dittofs-operator/api/v1alpha1/dittoserver_types.go"
      provides: "PerconaConfig, PerconaBackupConfig types"
      contains: "type PerconaConfig struct"
    - path: "k8s/dittofs-operator/cmd/main.go"
      provides: "Percona scheme registration"
      contains: "pgv2.AddToScheme"
    - path: "k8s/dittofs-operator/internal/controller/dittoserver_controller.go"
      provides: "RBAC markers for PerconaPGCluster"
      contains: "pgv2.percona.com"
  key_links:
    - from: "cmd/main.go"
      to: "Percona API types"
      via: "scheme registration"
      pattern: "utilruntime\\.Must.*pgv2"
    - from: "dittoserver_controller.go"
      to: "PerconaPGCluster"
      via: "RBAC markers"
      pattern: "kubebuilder:rbac.*perconapgclusters"
---

<objective>
Add Percona PostgreSQL integration types and foundation to the DittoFS operator.

Purpose: Enable the operator to create and manage PerconaPGCluster resources for PostgreSQL metadata store. This is the foundation for auto-creating PostgreSQL clusters when users enable Percona integration.

Output: CRD types for Percona configuration, Percona API scheme registration, RBAC permissions for PerconaPGCluster resources.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-percona-integration/04-CONTEXT.md
@.planning/phases/04-percona-integration/04-RESEARCH.md
@k8s/dittofs-operator/api/v1alpha1/dittoserver_types.go
@k8s/dittofs-operator/cmd/main.go
@k8s/dittofs-operator/internal/controller/dittoserver_controller.go
@k8s/dittofs-operator/go.mod
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Percona CRD types and import API</name>
  <files>
    k8s/dittofs-operator/api/v1alpha1/dittoserver_types.go
    k8s/dittofs-operator/go.mod
    k8s/dittofs-operator/go.sum
  </files>
  <action>
Add Percona-related types to dittoserver_types.go:

1. Add `PerconaConfig` struct to `DittoServerSpec`:
```go
// Percona configures auto-creation of PerconaPGCluster for PostgreSQL metadata store
// +optional
Percona *PerconaConfig `json:"percona,omitempty"`
```

2. Define `PerconaConfig` type:
```go
// PerconaConfig configures auto-creation of PerconaPGCluster
type PerconaConfig struct {
    // Enabled triggers auto-creation of PerconaPGCluster
    // +kubebuilder:default=false
    Enabled bool `json:"enabled,omitempty"`

    // Replicas for PostgreSQL instances
    // +kubebuilder:default=1
    // +kubebuilder:validation:Minimum=1
    // +kubebuilder:validation:Maximum=5
    // +optional
    Replicas *int32 `json:"replicas,omitempty"`

    // StorageSize for PostgreSQL data volume
    // +kubebuilder:default="10Gi"
    // +optional
    StorageSize string `json:"storageSize,omitempty"`

    // StorageClassName for PostgreSQL PVCs (may differ from DittoFS storage)
    // +optional
    StorageClassName *string `json:"storageClassName,omitempty"`

    // DatabaseName for DittoFS control plane
    // +kubebuilder:default="dittofs"
    // +optional
    DatabaseName string `json:"databaseName,omitempty"`

    // Backup configures pgBackRest S3 backups (optional)
    // +optional
    Backup *PerconaBackupConfig `json:"backup,omitempty"`
}
```

3. Define `PerconaBackupConfig` type:
```go
// PerconaBackupConfig configures pgBackRest S3 backups for PostgreSQL
type PerconaBackupConfig struct {
    // Enabled activates backup configuration
    // +kubebuilder:default=false
    Enabled bool `json:"enabled,omitempty"`

    // CredentialsSecretRef references Secret with S3 credentials for pgBackRest
    // Secret must contain keys matching pgBackRest s3.conf format
    // +optional
    CredentialsSecretRef *corev1.LocalObjectReference `json:"credentialsSecretRef,omitempty"`

    // Bucket name for backups
    // +optional
    Bucket string `json:"bucket,omitempty"`

    // Endpoint for S3-compatible storage (e.g., https://s3.cubbit.eu)
    // +optional
    Endpoint string `json:"endpoint,omitempty"`

    // Region for S3 bucket
    // +kubebuilder:default="eu-west-1"
    // +optional
    Region string `json:"region,omitempty"`

    // FullSchedule cron expression for full backups
    // +kubebuilder:default="0 2 * * *"
    // +optional
    FullSchedule string `json:"fullSchedule,omitempty"`

    // IncrSchedule cron expression for incremental backups
    // +kubebuilder:default="0 * * * *"
    // +optional
    IncrSchedule string `json:"incrSchedule,omitempty"`

    // RetentionDays for backup retention
    // +kubebuilder:default=7
    // +kubebuilder:validation:Minimum=1
    // +optional
    RetentionDays *int32 `json:"retentionDays,omitempty"`
}
```

4. Add Percona operator dependency to go.mod:
```bash
cd k8s/dittofs-operator
go get github.com/percona/percona-postgresql-operator/pkg/apis/pgv2.percona.com/v2@latest
go mod tidy
```

Note: The import path is `github.com/percona/percona-postgresql-operator/pkg/apis/pgv2.percona.com/v2` (confirmed in research).
  </action>
  <verify>
```bash
cd k8s/dittofs-operator
go build ./...
grep -q "PerconaConfig" api/v1alpha1/dittoserver_types.go
grep -q "PerconaBackupConfig" api/v1alpha1/dittoserver_types.go
grep -q "percona-postgresql-operator" go.mod
```
  </verify>
  <done>PerconaConfig and PerconaBackupConfig types defined, Percona operator dependency added, code compiles</done>
</task>

<task type="auto">
  <name>Task 2: Register Percona scheme and add RBAC</name>
  <files>
    k8s/dittofs-operator/cmd/main.go
    k8s/dittofs-operator/internal/controller/dittoserver_controller.go
    k8s/dittofs-operator/api/v1alpha1/zz_generated.deepcopy.go
  </files>
  <action>
1. In cmd/main.go, register Percona scheme:

Add import:
```go
pgv2 "github.com/percona/percona-postgresql-operator/pkg/apis/pgv2.percona.com/v2"
```

In init() function, add scheme registration:
```go
utilruntime.Must(pgv2.AddToScheme(scheme))
```

2. In internal/controller/dittoserver_controller.go, add RBAC markers:

Add after existing RBAC markers (before Reconcile function):
```go
// +kubebuilder:rbac:groups=pgv2.percona.com,resources=perconapgclusters,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=pgv2.percona.com,resources=perconapgclusters/status,verbs=get
```

3. Update SetupWithManager to watch owned PerconaPGCluster resources:

Add import at top:
```go
pgv2 "github.com/percona/percona-postgresql-operator/pkg/apis/pgv2.percona.com/v2"
```

Update SetupWithManager function:
```go
func (r *DittoServerReconciler) SetupWithManager(mgr ctrl.Manager) error {
    return ctrl.NewControllerManagedBy(mgr).
        For(&dittoiov1alpha1.DittoServer{}).
        Owns(&appsv1.StatefulSet{}).
        Owns(&corev1.Service{}).
        Owns(&corev1.ConfigMap{}).
        Owns(&pgv2.PerconaPGCluster{}).  // Watch owned PerconaPGCluster
        Named("dittoserver").
        Complete(r)
}
```

4. Run make generate and make manifests to regenerate files:
```bash
cd k8s/dittofs-operator
make generate
make manifests
```
  </action>
  <verify>
```bash
cd k8s/dittofs-operator
grep -q "pgv2.AddToScheme" cmd/main.go
grep -q "perconapgclusters" internal/controller/dittoserver_controller.go
grep -q "PerconaPGCluster" internal/controller/dittoserver_controller.go
cat config/rbac/role.yaml | grep -A5 "perconapgclusters"
make build
```
  </verify>
  <done>Percona scheme registered in main.go, RBAC markers added, controller watches PerconaPGCluster, manifests regenerated</done>
</task>

<task type="auto">
  <name>Task 3: Run tests and verify build</name>
  <files>
    k8s/dittofs-operator/api/v1alpha1/zz_generated.deepcopy.go
  </files>
  <action>
1. Ensure deepcopy functions are generated for new types:
```bash
cd k8s/dittofs-operator
make generate
```

2. Run all tests to verify nothing is broken:
```bash
cd k8s/dittofs-operator
make test
```

3. Build the operator binary:
```bash
cd k8s/dittofs-operator
make build
```

4. Verify the CRD schema is updated (optional - check if Percona fields appear):
```bash
cat k8s/dittofs-operator/config/crd/bases/dittofs.dittofs.com_dittoservers.yaml | grep -A20 "percona:"
```

If tests fail due to Percona API import issues (e.g., missing CRD in test cluster), add build tag or mock. The goal is that the operator compiles and existing functionality still works.
  </action>
  <verify>
```bash
cd k8s/dittofs-operator
make test
echo $?  # Should be 0
make build
ls -la bin/manager
```
  </verify>
  <done>All tests pass, operator builds successfully, deepcopy generated for new types</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `make test` passes in k8s/dittofs-operator/
2. `make build` produces bin/manager
3. go.mod includes percona-postgresql-operator dependency
4. config/rbac/role.yaml includes perconapgclusters permissions
5. CRD schema includes percona field
</verification>

<success_criteria>
- PerconaConfig and PerconaBackupConfig types defined in CRD
- Percona API types importable (pgv2.PerconaPGCluster compiles)
- Scheme registration in main.go
- RBAC markers grant permissions for PerconaPGCluster CRUD
- Controller watches owned PerconaPGCluster resources
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-percona-integration/04-01-SUMMARY.md`
</output>
