---
phase: 34-key-derivation-and-signing
plan: 02
type: execute
wave: 2
depends_on: [34-01]
files_modified:
  - internal/adapter/smb/session/crypto_state.go
  - internal/adapter/smb/session/session.go
  - internal/adapter/smb/types/negotiate_context.go
  - internal/adapter/smb/types/constants.go
  - internal/adapter/smb/v2/handlers/negotiate.go
  - internal/adapter/smb/v2/handlers/negotiate_test.go
  - internal/adapter/smb/v2/handlers/session_setup.go
  - internal/adapter/smb/v2/handlers/context.go
  - internal/adapter/smb/crypto_state.go
  - internal/adapter/smb/framing.go
  - internal/adapter/smb/compound.go
  - internal/adapter/smb/response.go
  - internal/adapter/smb/signing/signing.go
  - pkg/controlplane/models/adapter_settings.go
  - test/smb-conformance/smbtorture/run.sh
  - test/smb-conformance/smbtorture/KNOWN_FAILURES.md
autonomous: true
requirements: [KDF-01, KDF-02, KDF-03, SIGN-01, SIGN-02, SIGN-03]

must_haves:
  truths:
    - "SMB 3.0/3.0.2 sessions derive all 4 keys via SP800-108 KDF with constant label/context"
    - "SMB 3.1.1 sessions derive keys using preauth integrity hash as KDF context"
    - "All SMB 3.x signed messages use AES-128-CMAC (or GMAC if negotiated)"
    - "SMB 2.x signing path continues to use HMAC-SHA256 unchanged"
    - "SIGNING_CAPABILITIES negotiate context is parsed from clients and server responds with selected algorithm"
    - "SessionCryptoState replaces SessionSigningState as the signing abstraction on Session"
    - "Key material is zeroized on session destroy"
    - "Signing algorithm preference is configurable via adapter settings"
  artifacts:
    - path: "internal/adapter/smb/session/crypto_state.go"
      provides: "SessionCryptoState with DeriveAllKeys and Destroy"
      exports: ["SessionCryptoState", "DeriveAllKeys"]
    - path: "internal/adapter/smb/types/negotiate_context.go"
      provides: "SigningCaps type with Encode/Decode"
      contains: "SigningCaps"
    - path: "internal/adapter/smb/types/constants.go"
      provides: "NegCtxSigningCaps constant and signing algorithm IDs"
      contains: "NegCtxSigningCaps"
    - path: "internal/adapter/smb/v2/handlers/negotiate.go"
      provides: "SIGNING_CAPABILITIES context handling in processNegotiateContexts"
      contains: "NegCtxSigningCaps"
    - path: "internal/adapter/smb/v2/handlers/session_setup.go"
      provides: "3.x KDF code path in configureSessionSigningWithKey"
      contains: "DeriveAllKeys"
  key_links:
    - from: "internal/adapter/smb/v2/handlers/session_setup.go"
      to: "internal/adapter/smb/session/crypto_state.go"
      via: "DeriveAllKeys call during session setup"
      pattern: "DeriveAllKeys"
    - from: "internal/adapter/smb/session/crypto_state.go"
      to: "internal/adapter/smb/kdf/kdf.go"
      via: "KDF calls for each key purpose"
      pattern: "kdf\\.DeriveKey"
    - from: "internal/adapter/smb/session/crypto_state.go"
      to: "internal/adapter/smb/signing/signer.go"
      via: "NewSigner factory creates dialect-appropriate Signer"
      pattern: "signing\\.NewSigner"
    - from: "internal/adapter/smb/framing.go"
      to: "internal/adapter/smb/session/session.go"
      via: "Session.CryptoState.Signer for signing/verification"
      pattern: "CryptoState"
    - from: "internal/adapter/smb/v2/handlers/negotiate.go"
      to: "internal/adapter/smb/types/negotiate_context.go"
      via: "SIGNING_CAPABILITIES context parsing and response building"
      pattern: "SigningCaps"
---

<objective>
Wire the KDF and Signer implementations (from Plan 01) into the SMB session lifecycle: create SessionCryptoState, add SIGNING_CAPABILITIES negotiate context, integrate KDF into session setup for 3.x, migrate framing/compound to use the new Signer interface, and update the smbtorture test suite.

Purpose: Completes Phase 34 by connecting the cryptographic primitives to the SMB protocol flow. After this plan, Windows/macOS/Linux clients negotiating SMB 3.x will have their sessions use AES-CMAC/GMAC signing with properly derived keys.

Output: SessionCryptoState on Session, SIGNING_CAPABILITIES context in negotiate, 3.x KDF in session_setup, framing uses Signer interface, smbtorture signing suites added.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-key-derivation-and-signing/34-CONTEXT.md
@.planning/phases/34-key-derivation-and-signing/34-RESEARCH.md
@.planning/phases/34-key-derivation-and-signing/34-01-SUMMARY.md

<interfaces>
<!-- Contracts from Plan 01 that this plan consumes -->

From internal/adapter/smb/kdf/kdf.go (created in Plan 01):
```go
type KeyPurpose uint8
const (
    SigningKeyPurpose    KeyPurpose = iota
    EncryptionKeyPurpose
    DecryptionKeyPurpose
    ApplicationKeyPurpose
)
func DeriveKey(ki, label, context []byte, keyLenBits uint32) []byte
func LabelAndContext(purpose KeyPurpose, dialect types.Dialect, preauthHash [64]byte) (label, context []byte)
```

From internal/adapter/smb/signing/signer.go (created in Plan 01):
```go
type Signer interface {
    Sign(message []byte) [16]byte
    Verify(message []byte) bool
}
const (
    SigningAlgHMACSHA256 uint16 = 0x0000
    SigningAlgAESCMAC    uint16 = 0x0001
    SigningAlgAESGMAC    uint16 = 0x0002
)
func NewSigner(dialect types.Dialect, signingAlgorithmId uint16, key []byte) Signer
func SignMessage(signer Signer, message []byte)
```

From internal/adapter/smb/signing/signing.go (modified in Plan 01):
```go
type SigningConfig struct { Enabled, Required bool }
type SessionSigningState struct {
    Signer          Signer  // Changed from *SigningKey in Plan 01
    SigningRequired  bool
    SigningEnabled   bool
}
```

From internal/adapter/smb/session/session.go:
```go
type Session struct {
    SessionID  uint64
    IsGuest    bool
    Signing    *signing.SessionSigningState
    // ...
}
func (s *Session) SetSigningKey(sessionKey []byte)
func (s *Session) EnableSigning(required bool)
func (s *Session) ShouldSign() bool
func (s *Session) SignMessage(message []byte)
func (s *Session) VerifyMessage(message []byte) bool
```

From internal/adapter/smb/crypto_state.go:
```go
type ConnectionCryptoState struct {
    Dialect           types.Dialect
    CipherId          uint16
    SigningAlgorithmId uint16
    // ... preauth hash, negotiate params
}
func (cs *ConnectionCryptoState) GetPreauthHash() [64]byte
func (cs *ConnectionCryptoState) GetDialect() types.Dialect
```

From internal/adapter/smb/v2/handlers/context.go:
```go
type CryptoState interface {
    SetDialect(d types.Dialect)
    GetDialect() types.Dialect
    SetCipherId(id uint16)
    // ... 14 more methods
}
type SMBHandlerContext struct {
    ConnCryptoState CryptoState
    // ...
}
```

From internal/adapter/smb/types/constants.go:
```go
const (
    NegCtxPreauthIntegrity uint16 = 0x0001
    NegCtxEncryptionCaps   uint16 = 0x0002
    NegCtxNetnameContextID uint16 = 0x0005
)
```

From pkg/controlplane/models/adapter_settings.go:
```go
type SMBAdapterSettings struct {
    // ...
    BlockedOperations string `gorm:"type:text" json:"-"`
    // Need to add: SigningAlgorithmPreference
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: SessionCryptoState, SIGNING_CAPABILITIES, and negotiate context wiring</name>
  <files>internal/adapter/smb/session/crypto_state.go, internal/adapter/smb/session/session.go, internal/adapter/smb/types/negotiate_context.go, internal/adapter/smb/types/constants.go, internal/adapter/smb/v2/handlers/context.go, internal/adapter/smb/crypto_state.go, internal/adapter/smb/v2/handlers/negotiate.go, internal/adapter/smb/v2/handlers/negotiate_test.go, pkg/controlplane/models/adapter_settings.go, internal/adapter/smb/signing/signing.go</files>
  <action>
**1. Create `internal/adapter/smb/session/crypto_state.go`:**
- Define `SessionCryptoState` struct per CONTEXT.md locked decisions:
  ```go
  type SessionCryptoState struct {
      Signer         signing.Signer  // Signs/verifies messages (HMAC, CMAC, or GMAC)
      SigningKey      []byte          // Raw signing key bytes
      EncryptionKey  []byte          // For Phase 35
      DecryptionKey  []byte          // For Phase 35
      ApplicationKey []byte          // For higher-layer protocols
      SigningEnabled  bool
      SigningRequired bool
  }
  ```
- Implement `DeriveAllKeys(sessionKey []byte, dialect types.Dialect, preauthHash [64]byte, cipherId uint16, signingAlgId uint16) *SessionCryptoState`:
  - If dialect < Dialect0300: create HMACSigner directly from sessionKey (no KDF), only set SigningKey (no encryption/decryption/application keys for 2.x).
  - If dialect >= Dialect0300: derive all 4 keys via `kdf.LabelAndContext` + `kdf.DeriveKey`. Encryption/decryption key length is 256 for AES-256 ciphers, 128 otherwise. Signing key is always 128-bit. Create Signer via `signing.NewSigner(dialect, signingAlgId, signingKeyBytes)`.
- Implement `Destroy()` method that zeros all key material (SigningKey, EncryptionKey, DecryptionKey, ApplicationKey byte slices).
- Implement `ShouldSign() bool` — returns `SigningEnabled && Signer != nil`.
- Implement `ShouldVerify() bool` — same logic as ShouldSign.

**2. Modify `internal/adapter/smb/session/session.go`:**
- Replace `Signing *signing.SessionSigningState` with `CryptoState *SessionCryptoState`.
- Remove import of `signing` package.
- Update `NewSession` and `NewSessionWithUser` to initialize `CryptoState: &SessionCryptoState{}` instead of `Signing: signing.NewSessionSigningState()`.
- Update `SetSigningKey(sessionKey []byte)` to create `CryptoState` with HMACSigner: `s.CryptoState = DeriveAllKeys(sessionKey, types.Dialect0202, [64]byte{}, 0, signing.SigningAlgHMACSHA256)` — this preserves 2.x behavior when called from the old path.
- Update `EnableSigning(required bool)` to set `s.CryptoState.SigningEnabled = true; s.CryptoState.SigningRequired = required`.
- Update `ShouldSign()` to return `s.CryptoState != nil && s.CryptoState.ShouldSign()`.
- Update `ShouldVerify()` similarly.
- Update `SignMessage(message []byte)` to call `signing.SignMessage(s.CryptoState.Signer, message)` when ShouldSign.
- Update `VerifyMessage(message []byte) bool` to call `s.CryptoState.Signer.Verify(message)` when ShouldVerify.
- Add `SetCryptoState(cs *SessionCryptoState)` method for Plan 02 session_setup integration.

**3. Add SIGNING_CAPABILITIES to negotiate context types:**

In `internal/adapter/smb/types/constants.go`, add:
```go
NegCtxSigningCaps uint16 = 0x0008
```

In `internal/adapter/smb/types/negotiate_context.go`, add:
```go
type SigningCaps struct {
    SigningAlgorithms []uint16
}
func (s SigningCaps) Encode() []byte  // CipherCount(2) + algorithms(count*2)
func DecodeSigningCaps(data []byte) (SigningCaps, error)
```
Follow the exact same pattern as `EncryptionCaps` (it's structurally identical).

**4. Add `SetSigningAlgorithmId` and `GetSigningAlgorithmId` to CryptoState interface and ConnectionCryptoState:**

In `internal/adapter/smb/v2/handlers/context.go`, add to `CryptoState` interface:
```go
SetSigningAlgorithmId(id uint16)
GetSigningAlgorithmId() uint16
GetCipherId() uint16
GetPreauthHash() [64]byte
```

In `internal/adapter/smb/crypto_state.go`, implement these methods on `ConnectionCryptoState` (SetSigningAlgorithmId already has the field; add getter and GetCipherId/GetPreauthHash).

**5. Wire SIGNING_CAPABILITIES into negotiate handler:**

In `internal/adapter/smb/v2/handlers/negotiate.go`, in `processNegotiateContexts()`:
- Add a case for `types.NegCtxSigningCaps`: parse client's offered signing algorithms via `DecodeSigningCaps`.
- Select the best algorithm by intersecting with server's preference order. The preference order should come from the Handler's settings. Add a `SigningAlgorithmPreference []uint16` field to Handler (set from adapter settings during creation). Default: `[SigningAlgAESGMAC, SigningAlgAESCMAC, SigningAlgHMACSHA256]`.
- When 3.1.1 client omits SIGNING_CAPABILITIES: default to AES-128-CMAC per MS-SMB2 spec.
- Store selected algorithm on CryptoState: `ctx.ConnCryptoState.SetSigningAlgorithmId(selectedAlg)`.
- Build response SIGNING_CAPABILITIES context with only the selected algorithm.

**6. Add `SigningAlgorithmPreference` to adapter settings:**

In `pkg/controlplane/models/adapter_settings.go`, add to `SMBAdapterSettings`:
```go
SigningAlgorithmPreference string `gorm:"type:text" json:"signing_algorithm_preference"`
```
Add `GetSigningAlgorithmPreference() []string` and `SetSigningAlgorithmPreference(prefs []string)` methods following the `BlockedOperations` pattern (JSON array stored as text).

In `NewDefaultSMBSettings`, set default to `["AES-128-GMAC","AES-128-CMAC","HMAC-SHA256"]`.

**7. Update negotiate_test.go:**
- Update `mockCryptoState` with `SetSigningAlgorithmId`/`GetSigningAlgorithmId`/`GetCipherId`/`GetPreauthHash` methods.
- Add test: client sends SIGNING_CAPABILITIES with [GMAC, CMAC], server selects GMAC (preferred).
- Add test: client sends SIGNING_CAPABILITIES with [CMAC] only, server selects CMAC.
- Add test: 3.1.1 client omits SIGNING_CAPABILITIES, server defaults to CMAC.

**8. Clean up old signing.go:**
After session.go no longer imports `SessionSigningState`, remove it from `signing/signing.go`. Keep `SigningConfig` and `DefaultSigningConfig` (still used by Handler). The `SessionSigningState` type can be fully removed since `session.Session` now uses `SessionCryptoState` directly.
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs-phase-30 && go build ./... && go test ./internal/adapter/smb/session/ ./internal/adapter/smb/types/ ./internal/adapter/smb/v2/handlers/ -v -count=1 -run "Test(Negotiate|SigningCaps|CryptoState)" 2>&1 | head -100</automated>
  </verify>
  <done>SessionCryptoState replaces SessionSigningState on Session. SIGNING_CAPABILITIES parsed from clients and responded to. CryptoState interface extended with signing algorithm and preauth hash methods. Negotiate handler selects best signing algorithm. Full project compiles. All existing negotiate tests pass plus new signing caps tests.</done>
</task>

<task type="auto">
  <name>Task 2: Session setup KDF integration, framing migration, and smbtorture update</name>
  <files>internal/adapter/smb/v2/handlers/session_setup.go, internal/adapter/smb/framing.go, internal/adapter/smb/compound.go, internal/adapter/smb/response.go, test/smb-conformance/smbtorture/run.sh, test/smb-conformance/smbtorture/KNOWN_FAILURES.md</files>
  <action>
**1. Integrate KDF into session_setup.go:**

Modify `configureSessionSigningWithKey`:
- Add a per-session preauth hash snapshot: before key derivation for 3.1.1, capture `ctx.ConnCryptoState.GetPreauthHash()` as the KDF context. Per MS-SMB2, this must be the hash value AFTER processing the final SESSION_SETUP request but BEFORE the response. The current preauth hash tracking in `ConnectionCryptoState` already has this value at the point `configureSessionSigningWithKey` is called (the dispatch hooks update it with the request, but not yet the response).
- Read dialect from `ctx.ConnCryptoState.GetDialect()`. Note: ctx here is the SMBHandlerContext — the ConnCryptoState is available since it was populated during NEGOTIATE. If ConnCryptoState is nil (legacy 2.x path), treat as 2.x.
- Read CipherId from `ctx.ConnCryptoState.GetCipherId()` (needed for encryption key length).
- Read SigningAlgorithmId from `ctx.ConnCryptoState.GetSigningAlgorithmId()`.
- If dialect >= Dialect0300:
  ```go
  preauthHash := ctx.ConnCryptoState.GetPreauthHash()
  cryptoState := session.DeriveAllKeys(sessionKey, dialect, preauthHash, cipherId, signingAlgId)
  cryptoState.SigningEnabled = true
  cryptoState.SigningRequired = h.SigningConfig.Required
  sess.SetCryptoState(cryptoState)
  ```
- If dialect < Dialect0300: keep existing path — `sess.SetSigningKey(sessionKey)` + `sess.EnableSigning(required)`.
- IMPORTANT: The `configureSessionSigningWithKey` function currently takes `(sess *session.Session, sessionKey []byte)`. Add `ctx *SMBHandlerContext` as a parameter so it can access ConnCryptoState. Update all callers (there are 1-2 call sites in session_setup.go).

**2. Update framing.go:**

In `sessionSigningVerifier.VerifyRequest()`:
- Replace `sess.Signing != nil && sess.Signing.SigningRequired` with `sess.CryptoState != nil && sess.CryptoState.SigningRequired`.
- Replace `sess.VerifyMessage(verifyBytes)` — this already delegates to CryptoState after Task 1 changes, so just verify it works.
- Replace `sess.Signing != nil && sess.Signing.SigningKey != nil` debug check with `sess.CryptoState != nil && sess.CryptoState.Signer != nil`.

**3. Update compound.go:**

In the compound request signature verification:
- Replace `sess.Signing != nil && sess.Signing.SigningRequired` with `sess.CryptoState != nil && sess.CryptoState.SigningRequired`.
- Replace `sess.VerifyMessage(verifyBytes)` (already delegates properly).

**4. Update response.go:**

In `SendMessage()` or similar:
- Replace `sess.ShouldSign()` / `sess.SignMessage()` — these already delegate to CryptoState after Task 1 changes. Verify no direct references to `sess.Signing` remain.

**5. Verify all references to old `Signing` field are gone:**

After all changes, grep for `sess.Signing` or `.Signing.` in:
- framing.go
- compound.go
- response.go
- session_setup.go
There should be zero references to the old `Signing` field. All should use `CryptoState`.

**6. Update smbtorture test suite:**

In `test/smb-conformance/smbtorture/run.sh`:
- Add `smb2.signing` sub-suite to the list of suites to run (if not already present).
- Add `smb2.session` sub-suite if not already present (covers session signing).
- Follow the existing pattern of running sub-suites individually and prefixing test names with sed.

In `test/smb-conformance/smbtorture/KNOWN_FAILURES.md`:
- Add any signing-related tests that are expected to fail (e.g., tests requiring encryption which is Phase 35, or Kerberos which is Phase 36).
- This will be a baseline update — run smbtorture first, observe results, then update accordingly. If smbtorture cannot be run in this context, add a TODO comment indicating the baseline needs updating after Phase 34 execution.

**7. Final verification:**
- `go build ./...` must succeed
- `go test ./...` must pass (all unit tests)
- `go vet ./...` must pass
- Grep for any remaining `SessionSigningState` references outside of signing/signing.go — should be zero
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs-phase-30 && go build ./... && go test ./... -count=1 2>&1 | tail -30</automated>
  </verify>
  <done>3.x sessions derive all 4 keys via KDF during session setup. Framing, compound, and response use CryptoState.Signer for all dialects. No references to old SessionSigningState remain outside signing package. smbtorture run.sh updated with signing suites. Full project builds and all tests pass.</done>
</task>

</tasks>

<verification>
1. `go build ./...` — full project compiles with zero errors
2. `go test ./...` — all unit tests pass (kdf, signing, session, handlers, types)
3. `go vet ./...` — no issues
4. `grep -rn 'SessionSigningState' internal/ pkg/ --include='*.go' | grep -v '_test.go' | grep -v 'signing.go'` — zero matches (old type fully removed from non-signing files)
5. `grep -rn 'sess\.Signing\b' internal/ --include='*.go' | grep -v '_test.go'` — zero matches (all migrated to CryptoState)
6. KDF test vectors: `go test ./internal/adapter/smb/kdf/ -v` — MS-SMB2 vectors pass
7. CMAC test vectors: `go test ./internal/adapter/smb/signing/ -v -run CMAC` — RFC 4493 vectors pass
</verification>

<success_criteria>
- SMB 3.0/3.0.2 sessions derive keys with constant label/context strings (KDF-01, KDF-02)
- SMB 3.1.1 sessions derive keys using preauth integrity hash as KDF context (KDF-03)
- AES-128-CMAC used for 3.x signing by default (SIGN-01)
- AES-128-GMAC available when negotiated via SIGNING_CAPABILITIES (SIGN-02)
- Signing algorithm abstraction dispatches by dialect: HMAC for 2.x, CMAC for 3.0+, GMAC for 3.1.1 when negotiated (SIGN-03)
- Full project compiles, all tests pass, no regression in existing 2.x signing
</success_criteria>

<output>
After completion, create `.planning/phases/34-key-derivation-and-signing/34-02-SUMMARY.md`
</output>
