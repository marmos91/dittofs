---
phase: 34-key-derivation-and-signing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/adapter/smb/kdf/kdf.go
  - internal/adapter/smb/kdf/kdf_test.go
  - internal/adapter/smb/signing/signer.go
  - internal/adapter/smb/signing/hmac_signer.go
  - internal/adapter/smb/signing/hmac_signer_test.go
  - internal/adapter/smb/signing/cmac_signer.go
  - internal/adapter/smb/signing/cmac_signer_test.go
  - internal/adapter/smb/signing/gmac_signer.go
  - internal/adapter/smb/signing/gmac_signer_test.go
  - internal/adapter/smb/signing/signing.go
autonomous: true
requirements: [KDF-01, KDF-02, KDF-03, SIGN-01, SIGN-02, SIGN-03]

must_haves:
  truths:
    - "SP800-108 Counter Mode KDF derives correct keys for all SMB 3.x dialects, validated by MS-SMB2 test vectors"
    - "AES-128-CMAC produces correct MACs, validated by all 4 RFC 4493 test vectors"
    - "AES-128-GMAC produces correct authentication tags using GCM with empty plaintext and message as AAD"
    - "HMAC-SHA256 signing continues to work unchanged (no regression for 2.x)"
    - "Signer factory dispatches to correct implementation based on dialect and signing algorithm ID"
    - "KDF uses correct label/context strings for SMB 3.0/3.0.2 (constant) vs 3.1.1 (preauth hash)"
  artifacts:
    - path: "internal/adapter/smb/kdf/kdf.go"
      provides: "SP800-108 KDF with KeyPurpose enum and dialect-aware label/context"
      exports: ["DeriveKey", "KeyPurpose", "SigningKeyPurpose", "EncryptionKeyPurpose", "DecryptionKeyPurpose", "ApplicationKeyPurpose", "LabelAndContext"]
    - path: "internal/adapter/smb/kdf/kdf_test.go"
      provides: "MS-SMB2 spec test vectors for SMB 3.0 and 3.1.1"
      min_lines: 50
    - path: "internal/adapter/smb/signing/signer.go"
      provides: "Signer interface, NewSigner factory, SignMessage helper"
      exports: ["Signer", "NewSigner", "SignMessage"]
    - path: "internal/adapter/smb/signing/cmac_signer.go"
      provides: "AES-128-CMAC implementation per RFC 4493"
      exports: ["CMACsigner"]
    - path: "internal/adapter/smb/signing/gmac_signer.go"
      provides: "AES-128-GMAC implementation via GCM with empty plaintext"
      exports: ["GMACSigner"]
    - path: "internal/adapter/smb/signing/hmac_signer.go"
      provides: "HMACSigner refactored from existing SigningKey"
      exports: ["HMACSigner"]
  key_links:
    - from: "internal/adapter/smb/kdf/kdf.go"
      to: "crypto/hmac + crypto/sha256"
      via: "SP800-108 counter mode PRF"
      pattern: "hmac\\.New\\(sha256\\.New"
    - from: "internal/adapter/smb/signing/signer.go"
      to: "internal/adapter/smb/signing/{hmac,cmac,gmac}_signer.go"
      via: "NewSigner factory dispatch"
      pattern: "func NewSigner"
    - from: "internal/adapter/smb/signing/cmac_signer.go"
      to: "crypto/aes"
      via: "AES block cipher for CBC-MAC"
      pattern: "aes\\.NewCipher"
---

<objective>
Implement the SP800-108 Counter Mode KDF package and refactor the signing package with a polymorphic Signer interface supporting HMAC-SHA256, AES-128-CMAC, and AES-128-GMAC.

Purpose: Provides the cryptographic foundation (key derivation and message signing) that Phase 34 Plan 02 wires into session setup, negotiate contexts, and framing. All algorithms are validated against official test vectors.

Output: New `kdf/` package, refactored `signing/` package with `Signer` interface and three implementations, comprehensive test coverage.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-key-derivation-and-signing/34-CONTEXT.md
@.planning/phases/34-key-derivation-and-signing/34-RESEARCH.md
@.planning/phases/33-smb3-dialect-negotiation-preauth-integrity/33-03-SUMMARY.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From internal/adapter/smb/types/constants.go:
```go
type Dialect uint16
const (
    Dialect0202 Dialect = 0x0202  // SMB 2.0.2
    Dialect0210 Dialect = 0x0210  // SMB 2.1
    Dialect0300 Dialect = 0x0300  // SMB 3.0
    Dialect0302 Dialect = 0x0302  // SMB 3.0.2
    Dialect0311 Dialect = 0x0311  // SMB 3.1.1
)
const (
    CipherAES128CCM uint16 = 0x0001
    CipherAES128GCM uint16 = 0x0002
    CipherAES256CCM uint16 = 0x0003
    CipherAES256GCM uint16 = 0x0004
)
```

From internal/adapter/smb/signing/signing.go (to be refactored):
```go
const (
    SignatureOffset = 48
    SignatureSize   = 16
    KeySize         = 16
    SMB2HeaderSize  = 64
)
type SigningKey struct { key [KeySize]byte }
func NewSigningKey(sessionKey []byte) *SigningKey
func (sk *SigningKey) Sign(message []byte) [SignatureSize]byte
func (sk *SigningKey) Verify(message []byte) bool
func (sk *SigningKey) SignMessage(message []byte) // sets flags + signs in place
type SigningConfig struct { Enabled, Required bool }
type SessionSigningState struct { SigningKey *SigningKey; SigningRequired, SigningEnabled bool }
```

From internal/adapter/smb/crypto_state.go:
```go
type ConnectionCryptoState struct {
    Dialect           types.Dialect
    CipherId          uint16
    SigningAlgorithmId uint16
    // ... other fields, preauth hash chain
}
func (cs *ConnectionCryptoState) GetPreauthHash() [64]byte
func (cs *ConnectionCryptoState) GetDialect() types.Dialect
```
</interfaces>
</context>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: SP800-108 KDF package with test vectors</name>
  <files>internal/adapter/smb/kdf/kdf.go, internal/adapter/smb/kdf/kdf_test.go</files>
  <behavior>
    - DeriveKey with SMB 3.0 signing label/context produces key matching MS-SMB2 test vector: SessionKey=0x7CD451825D0450D235424E44BA6E78CC -> SigningKey=0x0B7E9C5CAC36C0F6EA9AB275298CEDCE
    - DeriveKey with SMB 3.1.1 signing label+preauthHash produces key matching MS-SMB2 test vector: SessionKey=0x270E1BA896585EEB7AF3472D3B4C75A7, PreauthHash=known -> SigningKey=0x73FE7A9A77BEF0BDE49C650D8CCB5F76
    - LabelAndContext for all 4 key purposes returns correct label/context for 3.0 vs 3.1.1
    - Signing key is always 128-bit regardless of cipher; encryption/decryption key length is 256-bit when AES-256 cipher negotiated
    - KeyPurpose enum has 4 values: Signing, Encryption, Decryption, Application
  </behavior>
  <action>
Create `internal/adapter/smb/kdf/kdf.go`:
1. Define `KeyPurpose` type (uint8) with 4 constants: `SigningKeyPurpose`, `EncryptionKeyPurpose`, `DecryptionKeyPurpose`, `ApplicationKeyPurpose`.
2. Implement `DeriveKey(ki, label, context []byte, keyLenBits uint32) []byte` — SP800-108 Counter Mode with HMAC-SHA256 PRF. Single iteration (counter=1), r=32 bits. Wire format: `counter(4BE) || label || 0x00 || context || L(4BE)`. Return first keyLenBits/8 bytes of HMAC output.
3. Implement `LabelAndContext(purpose KeyPurpose, dialect types.Dialect, preauthHash [64]byte) (label, context []byte)` that returns the correct label/context per MS-SMB2:
   - SMB 3.0/3.0.2: constant strings (signing=`"SMB2AESCMAC\0"/"SmbSign\0"`, encryption=`"SMB2AESCCM\0"/"ServerIn \0"` (note trailing space), decryption=`"SMB2AESCCM\0"/"ServerOut\0"`, application=`"SMB2APP\0"/"SmbRpc\0"`)
   - SMB 3.1.1: different labels with preauth hash as context (signing=`"SMBSigningKey\0"/preauthHash`, encryption=`"SMBC2SCipherKey\0"/preauthHash`, decryption=`"SMBS2CCipherKey\0"/preauthHash`, application=`"SMBAppKey\0"/preauthHash`)
4. All label strings include their null terminator as part of the label (these are byte literals, not Go strings).

Create `internal/adapter/smb/kdf/kdf_test.go`:
1. Test DeriveKey against MS-SMB2 spec test vectors for SMB 3.0 signing key derivation.
2. Test DeriveKey against MS-SMB2 spec test vectors for SMB 3.1.1 signing key derivation with preauth hash.
3. Test LabelAndContext returns correct label/context for all 4 purposes x 2 dialect groups (3.0 and 3.1.1).
4. Test that signing key length is always 128-bit, encryption/decryption key length varies with cipher.

Use only Go stdlib: `crypto/hmac`, `crypto/sha256`, `encoding/binary`. Import `types.Dialect` from `internal/adapter/smb/types`.
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs-phase-30 && go test ./internal/adapter/smb/kdf/ -v -count=1</automated>
  </verify>
  <done>KDF produces correct keys for all MS-SMB2 test vectors. LabelAndContext returns correct strings for all 4 purposes across both dialect groups.</done>
</task>

<task type="auto" tdd="true">
  <name>Task 2: Signer interface with HMAC, CMAC, and GMAC implementations</name>
  <files>internal/adapter/smb/signing/signer.go, internal/adapter/smb/signing/hmac_signer.go, internal/adapter/smb/signing/hmac_signer_test.go, internal/adapter/smb/signing/cmac_signer.go, internal/adapter/smb/signing/cmac_signer_test.go, internal/adapter/smb/signing/gmac_signer.go, internal/adapter/smb/signing/gmac_signer_test.go, internal/adapter/smb/signing/signing.go</files>
  <behavior>
    - HMACSigner.Sign produces identical output to existing SigningKey.Sign for the same input
    - HMACSigner.Verify returns true for correctly signed messages, false otherwise
    - CMACsigner.Sign with key 2b7e151628aed2a6abf7158809cf4f3c and empty message produces bb1d6929e95937287fa37d129b756746
    - CMACsigner.Sign with key 2b7e151628aed2a6abf7158809cf4f3c and 16-byte message produces 070a16b46b4d4144f79bdd9dd04a287c
    - CMACsigner.Sign with key 2b7e151628aed2a6abf7158809cf4f3c and 40-byte message produces dfa66747de9ae63030ca32611497c827
    - CMACsigner.Sign with key 2b7e151628aed2a6abf7158809cf4f3c and 64-byte message produces 51f0bebf7e3b9d92fc49741779363cfe
    - GMACSigner.Sign extracts MessageId from header bytes 28-35, zero-pads to 12-byte nonce, uses empty plaintext with message as AAD
    - GMACSigner.Verify returns true for correctly tagged messages
    - NewSigner(Dialect0202, 0) returns HMACSigner
    - NewSigner(Dialect0300, SigningAlgAESCMAC) returns CMACsigner
    - NewSigner(Dialect0311, SigningAlgAESGMAC) returns GMACSigner
    - NewSigner(Dialect0311, SigningAlgAESCMAC) returns CMACsigner (3.1.1 without GMAC negotiation)
    - SignMessage helper sets SMB2_FLAGS_SIGNED flag and writes computed signature to bytes 48-63
  </behavior>
  <action>
**Create `internal/adapter/smb/signing/signer.go`:**
1. Define `Signer` interface with `Sign(message []byte) [16]byte` and `Verify(message []byte) bool`.
2. Define signing algorithm ID constants: `SigningAlgHMACSHA256 uint16 = 0x0000`, `SigningAlgAESCMAC uint16 = 0x0001`, `SigningAlgAESGMAC uint16 = 0x0002`.
3. Implement `NewSigner(dialect types.Dialect, signingAlgorithmId uint16, key []byte) Signer` factory:
   - If dialect < Dialect0300: return `NewHMACSigner(key)`
   - If signingAlgorithmId == SigningAlgAESGMAC: return `NewGMACSigner(key)`
   - Otherwise (3.0/3.0.2 or 3.1.1 without GMAC): return `NewCMACSigner(key)`
4. Implement standalone `SignMessage(signer Signer, message []byte)` helper: sets SMB2_FLAGS_SIGNED (bit 3 of flags at offset 16), zeros signature field, calls signer.Sign(), writes signature to bytes 48-63. This replaces the old `SigningKey.SignMessage` protocol concern.

**Create `internal/adapter/smb/signing/hmac_signer.go`:**
1. Define `HMACSigner` struct holding a `[16]byte` key.
2. `NewHMACSigner(sessionKey []byte) *HMACSigner` — pad/truncate key to 16 bytes (same logic as existing `NewSigningKey`). Return nil if empty key.
3. `Sign(message []byte) [16]byte` — copy message, zero bytes 48-63, compute HMAC-SHA256, return first 16 bytes. Identical logic to existing `SigningKey.Sign`.
4. `Verify(message []byte) bool` — extract signature from bytes 48-63, compute expected via Sign, constant-time compare with `hmac.Equal`.
5. `IsValid() bool` — returns true if key is non-zero.

**Create `internal/adapter/smb/signing/cmac_signer.go`:**
1. Define `CMACsigner` struct holding an `[16]byte` key plus cached subkeys K1, K2.
2. `NewCMACSigner(key []byte) *CMACsigner` — store key, eagerly compute K1/K2 via `generateSubkeys`.
3. `generateSubkeys(key []byte) (k1, k2 [16]byte)` — per RFC 4493 Section 2.3: AES-encrypt zero block to get L, shift-left for K1 (XOR 0x87 if MSB set), shift-left K1 for K2.
4. `Sign(message []byte) [16]byte` — per RFC 4493 Section 2.4: copy message, zero bytes 48-63, split into 16-byte blocks, XOR last block with K1 (complete) or K2 (padded with 10*), CBC-MAC all blocks.
5. `Verify(message []byte) bool` — extract expected, compute, `subtle.ConstantTimeCompare`.
6. Helper `shiftLeft(src, dst []byte)` for 1-bit left shift of byte slice.

**Create `internal/adapter/smb/signing/gmac_signer.go`:**
1. Define `GMACSigner` struct holding `[16]byte` key.
2. `NewGMACSigner(key []byte) *GMACSigner`.
3. `Sign(message []byte) [16]byte` — copy message, zero bytes 48-63, extract MessageId (8 bytes at offset 28-35) into 12-byte nonce (zero-padded), create AES cipher + GCM, `gcm.Seal(nil, nonce, nil, msgCopy)` produces 16-byte tag.
4. `Verify(message []byte) bool` — extract tag from bytes 48-63, compute expected via Sign (with tag zeroed), constant-time compare.

**Refactor `internal/adapter/smb/signing/signing.go`:**
1. Remove `SigningKey` struct and all its methods (`NewSigningKey`, `IsValid`, `Sign`, `Verify`, `SignMessage`) — replaced by `HMACSigner`.
2. Remove `SessionSigningState` struct and methods — will be replaced by `SessionCryptoState` in Plan 02.
3. Keep `SigningConfig`, `DefaultSigningConfig`, `NewSessionSigningState` temporarily — they will be migrated in Plan 02. Actually: keep `SigningConfig` and `DefaultSigningConfig` (still used by Handler). Keep `SessionSigningState` temporarily BUT change its `SigningKey *SigningKey` field to `Signer Signer`. Update `ShouldSign`, `ShouldVerify`, `SetSessionKey` accordingly. This minimizes blast radius: Plan 02 can replace `SessionSigningState` with `SessionCryptoState` without breaking the build between plans.
4. Keep constants (`SignatureOffset`, `SignatureSize`, `KeySize`, `SMB2HeaderSize`) — move to `signer.go` if desired.

IMPORTANT: The refactoring of `signing.go` MUST keep the session.go import chain working. `session.Session.Signing` is type `*SessionSigningState` — update its `SigningKey` field to `Signer Signer` and adjust `SetSessionKey` to create an `HMACSigner`. All existing callers (`session.go:SetSigningKey`, `session.go:SignMessage`, `session.go:VerifyMessage`, `framing.go`, `compound.go`) MUST continue to compile and work.

**Create test files:**
- `hmac_signer_test.go`: Test Sign/Verify with known vectors (port existing signing_test.go if it exists). Test NewHMACSigner with empty/short/long keys.
- `cmac_signer_test.go`: All 4 RFC 4493 test vectors (empty, 16-byte, 40-byte, 64-byte messages with key 2b7e...4f3c). Test Verify with valid and tampered messages.
- `gmac_signer_test.go`: Test Sign/Verify with a known key and crafted SMB2-like message with MessageId at offset 28. Test nonce construction (8-byte MessageId padded to 12 bytes). Test Verify with tampered message.

Use only Go stdlib: `crypto/aes`, `cipher`, `crypto/hmac`, `crypto/sha256`, `crypto/subtle`.
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs-phase-30 && go test ./internal/adapter/smb/signing/ -v -count=1 && go build ./...</automated>
  </verify>
  <done>All 4 RFC 4493 CMAC test vectors pass. HMAC signer produces same output as old SigningKey. GMAC signer produces correct tags. NewSigner factory dispatches correctly for all dialect/algorithm combinations. Full project builds with no compilation errors. SessionSigningState uses Signer interface internally.</done>
</task>

</tasks>

<verification>
1. `go test ./internal/adapter/smb/kdf/ -v` — all KDF test vectors pass
2. `go test ./internal/adapter/smb/signing/ -v` — all signer tests pass (HMAC, CMAC, GMAC)
3. `go build ./...` — full project compiles (session.go, framing.go, compound.go all work with refactored signing)
4. `go vet ./internal/adapter/smb/kdf/ ./internal/adapter/smb/signing/` — no issues
</verification>

<success_criteria>
- SP800-108 KDF produces correct keys matching MS-SMB2 test vectors for both SMB 3.0 and 3.1.1
- AES-CMAC passes all 4 RFC 4493 test vectors
- AES-GMAC signs and verifies with correct nonce construction
- Signer factory dispatches correctly: HMAC for 2.x, CMAC for 3.0+, GMAC for 3.1.1 when negotiated
- Full project compiles and all existing tests pass (no regression)
</success_criteria>

<output>
After completion, create `.planning/phases/34-key-derivation-and-signing/34-01-SUMMARY.md`
</output>
