---
phase: 03-dynamic-services-ports
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - k8s/dittofs-operator/api/v1alpha1/dittoserver_types.go
  - k8s/dittofs-operator/api/v1alpha1/dittoserver_types_builder.go
  - k8s/dittofs-operator/internal/controller/service_reconciler.go
  - k8s/dittofs-operator/internal/controller/service_reconciler_test.go
  - k8s/dittofs-operator/internal/controller/dittoserver_controller.go
autonomous: true

must_haves:
  truths:
    - "When an adapter is enabled+running, a dedicated LoadBalancer Service exists exposing that adapter's port"
    - "When an adapter is stopped or removed, its corresponding Service is deleted within one reconcile cycle"
    - "Adapter Services are owned by the DittoServer CR and are garbage-collected on CR deletion"
    - "Adapter Service type and annotations are configurable via CRD spec"
    - "K8s events are emitted for adapter Service create/delete/update lifecycle"
    - "Static Services (headless, file, API, metrics) are never touched by the adapter service reconciler"
    - "If no successful adapter poll has occurred yet (nil), service reconciliation is skipped entirely"
  artifacts:
    - path: "k8s/dittofs-operator/api/v1alpha1/dittoserver_types.go"
      provides: "AdapterServiceConfig type and field on DittoServerSpec"
      contains: "AdapterServiceConfig"
    - path: "k8s/dittofs-operator/internal/controller/service_reconciler.go"
      provides: "Adapter Service lifecycle: create, delete, update, diff logic"
      min_lines: 80
    - path: "k8s/dittofs-operator/internal/controller/service_reconciler_test.go"
      provides: "Tests for Service create, delete, update, nil safety, static Service safety"
      min_lines: 100
  key_links:
    - from: "k8s/dittofs-operator/internal/controller/service_reconciler.go"
      to: "k8s/dittofs-operator/internal/controller/adapter_reconciler.go"
      via: "getLastKnownAdapters()"
      pattern: "getLastKnownAdapters"
    - from: "k8s/dittofs-operator/internal/controller/service_reconciler.go"
      to: "k8s/dittofs-operator/pkg/resources/service.go"
      via: "ServiceBuilder fluent API"
      pattern: "resources\\.NewServiceBuilder"
    - from: "k8s/dittofs-operator/internal/controller/dittoserver_controller.go"
      to: "k8s/dittofs-operator/internal/controller/service_reconciler.go"
      via: "reconcileAdapterServices call in Reconcile loop"
      pattern: "reconcileAdapterServices"
---

<objective>
Implement per-adapter K8s Service lifecycle management. The operator creates a dedicated LoadBalancer Service for each enabled+running adapter discovered via Phase 2 polling, deletes Services for stopped/removed adapters, and updates Services if an adapter's port changes. Services are label-identified, owner-referenced, and configurable via CRD spec.

Purpose: Dynamically expose only running protocol adapters through dedicated K8s Services, eliminating manual resource management and reducing attack surface.
Output: service_reconciler.go with full create/delete/update diff logic, CRD extension for AdapterServiceConfig, integration into Reconcile loop, and tests.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-dynamic-services-ports/03-RESEARCH.md
@.planning/phases/02-adapter-discovery/02-01-SUMMARY.md

@k8s/dittofs-operator/api/v1alpha1/dittoserver_types.go
@k8s/dittofs-operator/api/v1alpha1/dittoserver_types_builder.go
@k8s/dittofs-operator/internal/controller/dittoserver_controller.go
@k8s/dittofs-operator/internal/controller/adapter_reconciler.go
@k8s/dittofs-operator/internal/controller/dittofs_client.go
@k8s/dittofs-operator/pkg/resources/service.go
@k8s/dittofs-operator/utils/conditions/conditions.go
@k8s/dittofs-operator/internal/controller/adapter_reconciler_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add AdapterServiceConfig to CRD spec and builder</name>
  <files>
    k8s/dittofs-operator/api/v1alpha1/dittoserver_types.go
    k8s/dittofs-operator/api/v1alpha1/dittoserver_types_builder.go
  </files>
  <action>
In dittoserver_types.go:

1. Add `AdapterServiceConfig` struct AFTER the existing `AdapterDiscoverySpec` struct:
```go
// AdapterServiceConfig configures dynamically created per-adapter Services.
type AdapterServiceConfig struct {
    // Type of Service to create for each adapter (LoadBalancer, NodePort, ClusterIP).
    // +kubebuilder:default="LoadBalancer"
    // +kubebuilder:validation:Enum=ClusterIP;NodePort;LoadBalancer
    // +optional
    Type string `json:"type,omitempty"`

    // Annotations to apply to adapter Services (e.g., cloud LB configuration).
    // +optional
    Annotations map[string]string `json:"annotations,omitempty"`
}
```

2. Add field to `DittoServerSpec` after the `AdapterDiscovery` field:
```go
// AdapterServices configures dynamically created per-adapter Services.
// +optional
AdapterServices *AdapterServiceConfig `json:"adapterServices,omitempty"`
```

In dittoserver_types_builder.go:

3. Add builder option following the existing pattern (e.g., WithAdapterDiscovery):
```go
// WithAdapterServices sets the AdapterServices of a DittoServerSpec
func WithAdapterServices(as *AdapterServiceConfig) func(*DittoServerSpec) {
    return func(obj *DittoServerSpec) {
        obj.AdapterServices = as
    }
}
```
  </action>
  <verify>
Run `go build ./...` from `k8s/dittofs-operator/` -- must compile with no errors.
Run `go vet ./...` from `k8s/dittofs-operator/` -- must pass.
  </verify>
  <done>
AdapterServiceConfig type exists in dittoserver_types.go with Type (enum-validated) and Annotations fields. DittoServerSpec has AdapterServices field. Builder has WithAdapterServices option. All compile cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement service reconciler and integrate into controller</name>
  <files>
    k8s/dittofs-operator/internal/controller/service_reconciler.go
    k8s/dittofs-operator/internal/controller/dittoserver_controller.go
  </files>
  <action>
Create `service_reconciler.go` in `internal/controller/` with the following:

**Constants and helpers:**
```go
const (
    adapterServiceLabel = "dittofs.io/adapter-service"
    adapterTypeLabel    = "dittofs.io/adapter-type"
)

func adapterServiceName(crName, adapterType string) string
func adapterServiceLabels(crName, adapterType string) map[string]string  // include "app", "instance", adapterServiceLabel, adapterTypeLabel
func getAdapterServiceType(ds) corev1.ServiceType  // reads from spec.adapterServices.type, defaults to LoadBalancer
func getAdapterServiceAnnotations(ds) map[string]string  // reads from spec.adapterServices.annotations, returns nil if unset
```

**Main reconciliation function:**
`reconcileAdapterServices(ctx, dittoServer) error` on DittoServerReconciler:
1. Call `r.getLastKnownAdapters(dittoServer)` -- if nil, skip entirely (no poll yet, DISC-03 safety)
2. Build desired set: `map[string]AdapterInfo` for adapters where `Enabled && Running`
3. List existing adapter Services using `client.MatchingLabels{adapterServiceLabel: "true", "instance": dittoServer.Name}` in the CR namespace
4. Build actual set: `map[string]*corev1.Service` keyed by `adapterTypeLabel` value
5. For each desired adapter NOT in actual: call `r.createAdapterService`
6. For each actual Service whose adapter IS in desired: call `r.updateAdapterServiceIfNeeded` (port change detection)
7. For each actual Service NOT in desired: call `r.deleteAdapterService`
8. Return nil on success, wrap errors with context

**createAdapterService(ctx, ds, adapterType string, info AdapterInfo) error:**
- Use `resources.NewServiceBuilder(adapterServiceName(ds.Name, adapterType), ds.Namespace)` with labels from `adapterServiceLabels`, selector `{"app": "dittofs-server", "instance": ds.Name}`, type from `getAdapterServiceType`, annotations from `getAdapterServiceAnnotations`, and a single TCP port named after the adapter type with port from `info.Port`
- Set controller reference via `controllerutil.SetControllerReference(ds, svc, r.Scheme)` for garbage collection
- Call `r.Create(ctx, svc)` -- if `IsAlreadyExists`, fall through to update path
- Emit event: `r.Recorder.Eventf(ds, corev1.EventTypeNormal, "AdapterServiceCreated", "Created %s Service %s for adapter %s (port %d)", svcType, svc.Name, adapterType, info.Port)`

**updateAdapterServiceIfNeeded(ctx, ds, existing *corev1.Service, info AdapterInfo) error:**
- Check if current port matches `info.Port` -- if yes, return nil (no-op)
- Re-fetch fresh copy via `r.Get` for optimistic locking
- Update port and targetPort in the fresh copy's Spec.Ports
- Also update Service type and annotations in case CRD spec changed (use `getAdapterServiceType` and `getAdapterServiceAnnotations`)
- Call `r.Update(ctx, fresh)` wrapped in `retryOnConflict`
- Emit event for port change: `r.Recorder.Eventf(ds, corev1.EventTypeNormal, "AdapterServiceUpdated", ...)`

**deleteAdapterService(ctx, ds, svc *corev1.Service, adapterType string) error:**
- Call `r.Delete(ctx, svc)` -- if `IsNotFound`, return nil (already deleted)
- Emit event: `r.Recorder.Eventf(ds, corev1.EventTypeNormal, "AdapterServiceDeleted", ...)`

**In dittoserver_controller.go:**
In the Reconcile method, after the `r.reconcileAdapters(ctx, dittoServer)` call (line ~279), add:
```go
// Service reconciliation: sync adapter Services based on discovered state
if err := r.reconcileAdapterServices(ctx, dittoServer); err != nil {
    logger.Error(err, "Failed to reconcile adapter services")
    r.Recorder.Eventf(dittoServer, corev1.EventTypeWarning, "AdapterServiceFailed",
        "Failed to reconcile adapter services: %v", err)
    // Don't block reconciliation -- adapter services are best-effort
}
```

Place this call inside the same `if conditions.IsConditionTrue(...)` block, AFTER the adapter discovery call. The service reconciler depends on `getLastKnownAdapters()` which is populated by `reconcileAdapters()`.

Also add the `adapterResult` into the `mergeRequeueAfter` call alongside the existing results.

IMPORTANT: Do NOT touch any static Service reconciliation methods (reconcileHeadlessService, reconcileFileService, reconcileAPIService, reconcileMetricsService). The adapter service reconciler ONLY manages Services with the `dittofs.io/adapter-service=true` label.
  </action>
  <verify>
Run `go build ./...` from `k8s/dittofs-operator/` -- must compile.
Run `go vet ./...` from `k8s/dittofs-operator/` -- must pass.
Verify `reconcileAdapterServices` is called in the Reconcile loop by grepping: `grep -n "reconcileAdapterServices" k8s/dittofs-operator/internal/controller/dittoserver_controller.go` should find the call.
  </verify>
  <done>
service_reconciler.go exists with reconcileAdapterServices, createAdapterService, updateAdapterServiceIfNeeded, deleteAdapterService. Controller calls reconcileAdapterServices after adapter polling. All static Services remain untouched.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add comprehensive tests for service reconciler</name>
  <files>
    k8s/dittofs-operator/internal/controller/service_reconciler_test.go
  </files>
  <action>
Create `service_reconciler_test.go` in `internal/controller/` using the existing test patterns from `adapter_reconciler_test.go` and `auth_reconciler_test.go`. Use `setupAuthReconciler` or equivalent test helper that provides a reconciler with a fake client.

Tests to implement (use standard Go testing, table-driven where appropriate):

1. **TestReconcileAdapterServices_NilAdapters_Skips**: No successful poll (nil). Verify no Services created, no Services deleted, no error returned. Pre-create a static -file Service to verify it is NOT deleted.

2. **TestReconcileAdapterServices_EmptyAdapters_DeletesOrphans**: Empty adapter list (legitimate). Pre-create an adapter Service with `dittofs.io/adapter-service=true` label. Verify it gets deleted.

3. **TestReconcileAdapterServices_CreateServices**: Set lastKnownAdapters with NFS (enabled+running, port 12049) and SMB (enabled+running, port 12445). Verify two adapter Services are created with correct names (`{cr-name}-adapter-nfs`, `{cr-name}-adapter-smb`), correct ports, correct labels, correct owner reference.

4. **TestReconcileAdapterServices_DeleteStoppedAdapter**: Pre-create NFS adapter Service. Set lastKnownAdapters to empty (all adapters removed). Verify NFS Service is deleted.

5. **TestReconcileAdapterServices_UpdatePortChange**: Pre-create NFS adapter Service with port 12049. Set lastKnownAdapters with NFS port changed to 2049. Verify Service is updated with new port.

6. **TestReconcileAdapterServices_StaticServicesUntouched**: Pre-create static Services (headless, file, API, metrics) WITHOUT the adapter-service label. Set lastKnownAdapters to empty. Verify static Services are NOT deleted.

7. **TestReconcileAdapterServices_OnlyEnabledRunning**: Set lastKnownAdapters with NFS (enabled+running) and SMB (enabled but NOT running). Verify only NFS Service is created. SMB should have no Service.

8. **TestReconcileAdapterServices_CustomServiceType**: Set `spec.adapterServices.type = "NodePort"`. Verify created Service has type NodePort instead of default LoadBalancer.

9. **TestReconcileAdapterServices_CustomAnnotations**: Set `spec.adapterServices.annotations = {"service.beta.kubernetes.io/aws-load-balancer-type": "nlb"}`. Verify created Service has the annotation.

10. **TestGetAdapterServiceType_Default**: No adapterServices spec. Verify returns LoadBalancer.

11. **TestGetAdapterServiceType_Custom**: adapterServices.type = "ClusterIP". Verify returns ClusterIP.

For each test that creates/deletes Services, use the fake client to verify the Service state after reconciliation by listing Services with the adapter label selector.

For owner reference verification, check that the created Service has an OwnerReference with the DittoServer CR's UID.

For event verification, use a `record.FakeRecorder` (already used in existing tests) and check that expected events are emitted.
  </action>
  <verify>
Run `go test ./internal/controller/ -run TestReconcileAdapterServices -v` from `k8s/dittofs-operator/` -- all tests must pass.
Run `go test ./internal/controller/ -run TestGetAdapterServiceType -v` from `k8s/dittofs-operator/` -- all tests must pass.
Run `go test ./... -count=1` from `k8s/dittofs-operator/` -- all existing tests still pass.
  </verify>
  <done>
All 11 test cases pass. Service creation, deletion, update, nil safety, static Service safety, configurability, and event emission are verified. No existing tests broken.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` passes from k8s/dittofs-operator/
2. `go vet ./...` passes from k8s/dittofs-operator/
3. `go test ./... -count=1` passes from k8s/dittofs-operator/ (all existing + new tests)
4. AdapterServiceConfig type exists in CRD types with Type and Annotations fields
5. service_reconciler.go implements desired-vs-actual diff with label-based identification
6. Static Services are never touched by adapter service reconciler (tested explicitly)
7. reconcileAdapterServices is called in the Reconcile loop after adapter polling
8. Adapter Services have owner references to DittoServer CR
</verification>

<success_criteria>
- Running adapters get dedicated Services created (SRVC-01, SRVC-02)
- Stopped/removed adapters have their Services deleted (SRVC-03)
- Services are owned by DittoServer CR for GC (SRVC-04)
- Service type is configurable via CRD spec (SRVC-06)
- Service annotations are configurable via CRD spec (SRVC-07)
- K8s events emitted for lifecycle changes (SRVC-08)
- All tests pass including 11 new service reconciler tests
</success_criteria>

<output>
After completion, create `.planning/phases/03-dynamic-services-ports/03-01-SUMMARY.md`
</output>
