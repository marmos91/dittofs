---
phase: 03-dynamic-services-ports
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - k8s/dittofs-operator/internal/controller/service_reconciler.go
  - k8s/dittofs-operator/internal/controller/service_reconciler_test.go
autonomous: true

must_haves:
  truths:
    - "StatefulSet container ports include dynamic adapter ports matching the set of active adapters"
    - "Dynamic adapter ports use 'adapter-{type}' naming to avoid collision with static port names"
    - "StatefulSet is only updated when container ports actually change (no unnecessary rolling restarts)"
    - "When an adapter stops, its container port is removed from the StatefulSet"
    - "Static container ports (api, metrics, nfs, smb) are preserved unchanged"
  artifacts:
    - path: "k8s/dittofs-operator/internal/controller/service_reconciler.go"
      provides: "reconcileContainerPorts function for StatefulSet port management"
      contains: "reconcileContainerPorts"
    - path: "k8s/dittofs-operator/internal/controller/service_reconciler_test.go"
      provides: "Tests for container port reconciliation"
      contains: "TestReconcileContainerPorts"
  key_links:
    - from: "k8s/dittofs-operator/internal/controller/service_reconciler.go"
      to: "StatefulSet PodTemplateSpec"
      via: "container port patching"
      pattern: "Containers\\[0\\]\\.Ports"
    - from: "k8s/dittofs-operator/internal/controller/service_reconciler.go"
      to: "k8s/dittofs-operator/internal/controller/dittoserver_controller.go"
      via: "called from reconcileAdapterServices after Service diff"
      pattern: "reconcileContainerPorts"
---

<objective>
Implement StatefulSet container port reconciliation so that dynamic adapter ports are added/removed from the DittoFS pod's port list based on active adapters. This ensures monitoring tools, service meshes, and `kubectl port-forward` see accurate port declarations.

Purpose: Container ports accurately reflect running adapters for operational tooling, CNI plugins, and service mesh sidecars.
Output: reconcileContainerPorts function added to service_reconciler.go, called at the end of reconcileAdapterServices, with tests for add/remove/no-op/collision-avoidance.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-dynamic-services-ports/03-RESEARCH.md
@.planning/phases/03-dynamic-services-ports/03-01-SUMMARY.md

@k8s/dittofs-operator/internal/controller/service_reconciler.go
@k8s/dittofs-operator/internal/controller/service_reconciler_test.go
@k8s/dittofs-operator/internal/controller/dittoserver_controller.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement container port reconciliation and integrate</name>
  <files>
    k8s/dittofs-operator/internal/controller/service_reconciler.go
  </files>
  <action>
Add the following to `service_reconciler.go`:

**reconcileContainerPorts(ctx, ds, activeAdapters map[string]AdapterInfo) error:**
1. Get the StatefulSet via `r.Get(ctx, client.ObjectKey{Namespace: ds.Namespace, Name: ds.Name}, statefulSet)`
2. If StatefulSet not found or has no containers, return nil (StatefulSet may not exist yet on first reconcile)
3. Build desired dynamic adapter ports: for each adapter in `activeAdapters`, create `corev1.ContainerPort{Name: fmt.Sprintf("adapter-%s", adapterType), ContainerPort: int32(info.Port), Protocol: corev1.ProtocolTCP}`. The `adapter-` prefix avoids collision with static port names like "nfs", "smb", "api", "metrics"
4. Get current container ports from `statefulSet.Spec.Template.Spec.Containers[0].Ports`
5. Separate current ports into static (those NOT prefixed with "adapter-") and dynamic (those prefixed with "adapter-")
6. Build final desired ports: static ports (preserved as-is from current) + new dynamic adapter ports
7. Sort both current and desired port lists by Name for deterministic comparison using `sort.Slice`
8. Compare using a `portsEqual` helper that checks Name, ContainerPort, and Protocol for each port
9. If ports are equal, return nil (no update needed -- avoids unnecessary rolling restarts, see Pitfall 4 from research)
10. Update `statefulSet.Spec.Template.Spec.Containers[0].Ports = desiredPorts` and call `r.Update(ctx, statefulSet)` wrapped in `retryOnConflict`
11. Return error on failure

**portsEqual(a, b []corev1.ContainerPort) bool:**
- Return false if lengths differ
- Compare element-by-element after sorting: Name, ContainerPort, Protocol must all match
- Return true if all match

**Integration:**
At the end of `reconcileAdapterServices`, after the create/delete/update diff loop, add:
```go
return r.reconcileContainerPorts(ctx, dittoServer, desired)
```
Where `desired` is the `map[string]AdapterInfo` of enabled+running adapters already computed in the function.

IMPORTANT: Do NOT modify `buildContainerPorts()` in dittoserver_controller.go. Static ports (nfs, smb, api, metrics) continue to be set during StatefulSet creation. The service reconciler adds/removes ONLY `adapter-{type}` prefixed ports. During Phase 3, both static "nfs" and dynamic "adapter-nfs" ports may coexist (Phase 4 removes the static ones). This is acceptable per the research's transition note.

IMPORTANT: Do NOT update VolumeClaimTemplates (they are immutable). Only update PodTemplateSpec.
  </action>
  <verify>
Run `go build ./...` from `k8s/dittofs-operator/` -- must compile.
Run `go vet ./...` from `k8s/dittofs-operator/` -- must pass.
Verify `reconcileContainerPorts` is called by grepping: `grep -n "reconcileContainerPorts" k8s/dittofs-operator/internal/controller/service_reconciler.go` should show both the function definition and the call site.
  </verify>
  <done>
reconcileContainerPorts function exists, uses adapter- prefix for dynamic port names, preserves static ports, compares before updating (no unnecessary restarts), and is called at the end of reconcileAdapterServices.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for container port reconciliation</name>
  <files>
    k8s/dittofs-operator/internal/controller/service_reconciler_test.go
  </files>
  <action>
Add the following tests to `service_reconciler_test.go`:

1. **TestReconcileContainerPorts_AddsAdapterPorts**: Create a StatefulSet with static ports (nfs:12049, api:8080). Set activeAdapters with NFS (port 12049). Verify that `adapter-nfs` port is added alongside the static ports. Both "nfs" (static) and "adapter-nfs" (dynamic) should exist (Phase 3 coexistence).

2. **TestReconcileContainerPorts_RemovesStoppedAdapterPorts**: Create a StatefulSet with static ports AND an existing `adapter-smb:12445` port. Set activeAdapters to only NFS (no SMB). Verify `adapter-smb` port is removed, `adapter-nfs` is added, and static ports are preserved.

3. **TestReconcileContainerPorts_NoChange_NoUpdate**: Create a StatefulSet with static ports AND `adapter-nfs:12049`. Set activeAdapters to NFS (port 12049). Verify the StatefulSet is NOT updated (portsEqual returns true). This can be verified by checking that the StatefulSet's ResourceVersion hasn't changed, or by checking the Update wasn't called (use a tracking wrapper or compare generation).

4. **TestReconcileContainerPorts_StatefulSetNotFound**: Call reconcileContainerPorts when no StatefulSet exists. Verify no error (graceful skip).

5. **TestReconcileContainerPorts_StaticPortsPreserved**: Create a StatefulSet with static ports (nfs, smb, api, metrics). Set activeAdapters to empty map. Verify only dynamic ports (adapter-*) are removed, all static ports are preserved. Since there are no adapter-* ports to begin with, the StatefulSet should not be updated.

6. **TestPortsEqual**: Table-driven test for the portsEqual helper:
   - Same ports in same order: true
   - Same ports in different order: true (sort handles this)
   - Different lengths: false
   - Same length but different port numbers: false
   - Empty slices: true

For creating test StatefulSets, use a helper that creates a minimal StatefulSet with the DittoServer name, in the correct namespace, with the specified container ports on a single "dittofs" container. Register the StatefulSet with the fake client before calling the reconciler.
  </action>
  <verify>
Run `go test ./internal/controller/ -run TestReconcileContainerPorts -v` from `k8s/dittofs-operator/` -- all tests must pass.
Run `go test ./internal/controller/ -run TestPortsEqual -v` from `k8s/dittofs-operator/` -- all tests must pass.
Run `go test ./... -count=1` from `k8s/dittofs-operator/` -- all existing + new tests pass.
  </verify>
  <done>
All 6 container port tests pass. Static ports are preserved. Dynamic adapter ports are correctly added/removed. No unnecessary StatefulSet updates. All existing tests still pass.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` passes from k8s/dittofs-operator/
2. `go vet ./...` passes from k8s/dittofs-operator/
3. `go test ./... -count=1` passes from k8s/dittofs-operator/ (all existing + new tests)
4. reconcileContainerPorts is called from reconcileAdapterServices
5. Dynamic ports use `adapter-{type}` naming convention
6. Static ports are never modified by the container port reconciler
7. No unnecessary StatefulSet updates when ports haven't changed
</verification>

<success_criteria>
- StatefulSet container ports match active adapters (SRVC-05)
- Dynamic ports use adapter- prefix to avoid name collision with static ports
- No unnecessary rolling restarts (portsEqual comparison before update)
- All 6+ new tests pass
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-dynamic-services-ports/03-02-SUMMARY.md`
</output>
