---
phase: 14-control-plane-v2-0
plan: 04
type: execute
wave: 3
depends_on: ["14-02", "14-03"]
files_modified:
  - pkg/adapter/nfs/nfs_adapter.go
  - pkg/adapter/nfs/connection.go
  - pkg/adapter/smb/adapter.go
  - pkg/adapter/smb/config.go
  - internal/protocol/nfs/dispatch.go
  - internal/protocol/nfs/v4/handlers/handler.go
  - internal/protocol/nfs/v4/handlers/compound.go
  - internal/protocol/nfs/v4/state/manager.go
autonomous: true

must_haves:
  truths:
    - "NFS adapter uses live settings from SettingsWatcher for new connections"
    - "Per-share security policy enforced at mount/connection time"
    - "Operation blocklist checked in COMPOUND dispatcher (NFS4ERR_NOTSUPP for blocked ops)"
    - "SMB adapter uses live settings from SettingsWatcher"
    - "SMB encryption toggle logs 'not yet implemented' when enabled"
    - "Delegation grant respects delegations_enabled setting"
    - "Share with require_kerberos=true rejects AUTH_SYS connections"
    - "Existing connections are grandfathered when policy tightens"
  artifacts:
    - path: "pkg/adapter/nfs/nfs_adapter.go"
      provides: "NFS adapter consuming live settings"
      contains: "GetNFSSettings"
    - path: "internal/protocol/nfs/v4/handlers/compound.go"
      provides: "Operation blocklist enforcement in COMPOUND"
      contains: "blocked"
  key_links:
    - from: "pkg/adapter/nfs/nfs_adapter.go"
      to: "pkg/controlplane/runtime/settings_watcher.go"
      via: "Reading live settings on new connection"
      pattern: "GetNFSSettings"
    - from: "internal/protocol/nfs/v4/handlers/compound.go"
      to: "pkg/controlplane/models/adapter_settings.go"
      via: "Blocked operations list"
      pattern: "BlockedOperations"
---

<objective>
Wire adapter settings and security policy enforcement into NFS and SMB adapters.

Purpose: Make the control plane settings actually affect adapter behavior at runtime. Settings from the watcher drive connection limits, timeouts, delegation policy, and operation blocklists. Share security policy controls auth flavor acceptance.
Output: Adapters consume live settings, enforce per-share security, and respect operation blocklists.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-control-plane-v2-0/14-CONTEXT.md
@.planning/phases/14-control-plane-v2-0/14-RESEARCH.md
@.planning/phases/14-control-plane-v2-0/14-01-SUMMARY.md
@.planning/phases/14-control-plane-v2-0/14-02-SUMMARY.md
@.planning/phases/14-control-plane-v2-0/14-03-SUMMARY.md
@pkg/adapter/nfs/nfs_adapter.go
@internal/protocol/nfs/dispatch.go
@internal/protocol/nfs/v4/handlers/handler.go
@internal/protocol/nfs/v4/handlers/compound.go
@internal/protocol/nfs/v4/state/manager.go
@pkg/adapter/smb/adapter.go
@pkg/adapter/smb/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: NFS Adapter Settings Enforcement</name>
  <files>
    pkg/adapter/nfs/nfs_adapter.go
    pkg/adapter/nfs/connection.go
    internal/protocol/nfs/dispatch.go
    internal/protocol/nfs/v4/handlers/handler.go
    internal/protocol/nfs/v4/handlers/compound.go
    internal/protocol/nfs/v4/state/manager.go
  </files>
  <action>
**1. NFS Adapter - Settings Consumption** (`nfs_adapter.go`):

In the NFS adapter's connection accept loop (or wherever new connections are handled), read settings from the runtime's SettingsWatcher:
```go
settings := rt.GetNFSSettings()
if settings != nil {
    // Apply to this connection's context
    // max_connections check: count active connections, reject if over limit (0 = unlimited)
    // max_clients check: similar
}
```

For each new connection:
- Check max_connections from settings. If settings.MaxConnections > 0 and current connection count >= MaxConnections, close the connection immediately with a log message.
- Pass settings snapshot to the connection handler so it's used for the lifetime of that connection (grandfathering per locked decision).

Settings that affect StateManager:
- LeaseTime: Update the StateManager's lease duration. Add a `SetLeaseTime(seconds int)` method to StateManager or use the existing `attrs.SetLeaseTime` package-level setter (already exists from Phase 9).
- GracePeriod: Similar -- the grace period timer duration should come from settings.
- DelegationRecallTimeout, CallbackTimeout: Pass to delegation/callback code.

**2. Operation Blocklist Enforcement** (`compound.go`):

In the COMPOUND dispatcher, before dispatching each operation, check if the operation is in the blocklist:
- The Handler struct should have a method `IsOperationBlocked(opNum uint32) bool` that checks both adapter-level and share-level blocklists.
- The adapter-level blocklist comes from NFSAdapterSettings.BlockedOperations.
- The share-level blocklist comes from the share's BlockedOperations field (resolved via the file handle's share).
- If blocked, return NFS4ERR_NOTSUPP for that operation (per locked decision).

Add a field to the v4 Handler: `blockedOps map[uint32]bool` populated from settings on construction or update.
Add a method to refresh blocked ops when settings change.

For per-share blocklist: the share is known after PUTFH resolves a file handle. Store the share's blocked ops on the CompoundContext and check in the dispatch loop after each op resolution.

**3. Security Policy Enforcement** (`dispatch.go` or NFS adapter level):

When a client mounts/connects:
- Look up the share's security policy (AllowAuthSys, RequireKerberos, MinKerberosLevel)
- For NFS connections using AUTH_SYS (auth flavor 1):
  - If share has `AllowAuthSys=false`, reject the mount with NFS3ERR_PERM or NFS4ERR_WRONGSEC
  - If share has `RequireKerberos=true`, reject AUTH_SYS connections with NFS3ERR_PERM or SECINFO response
- For RPCSEC_GSS connections:
  - If share has `MinKerberosLevel="krb5i"` but client uses krb5, reject
  - Kerberos level hierarchy: krb5 < krb5i < krb5p

The enforcement point should be in the mount handler (for NFSv3) and the COMPOUND handler after PUTFH (for NFSv4, when the share is resolved).

Implementation approach: Add a `checkSecurityPolicy(shareName, authFlavor, gssService)` method to the handler/dispatcher that returns NFS error if policy violated. Call it after resolving which share the operation targets.

Per locked decision: Existing connections are grandfathered. The policy check happens on NEW connections/operations, not retroactively.

**4. Delegation Policy** (`state/manager.go`):

In `ShouldGrantDelegation()`:
- Check `delegationsEnabled` flag (from settings)
- If false, never grant delegations (return OPEN_DELEGATE_NONE)
- Add a `SetDelegationsEnabled(enabled bool)` method to StateManager

**5. Netgroup Access Check** (NFS adapter mount handler):

In the mount procedure handler:
- After resolving the share, call `runtime.CheckNetgroupAccess(ctx, shareName, clientIP)`
- If returns false, reject mount with NFS3ERR_ACCES / NFS4ERR_PERM
- Per locked decision: empty allowlist = allow all
  </action>
  <verify>
`go build ./pkg/adapter/nfs/...` compiles.
`go build ./internal/protocol/nfs/...` compiles.
`go test ./internal/protocol/nfs/... -count=1 -race` passes (existing tests).
`go vet ./pkg/adapter/nfs/... ./internal/protocol/nfs/...` passes.
  </verify>
  <done>
NFS adapter reads live settings for new connections. Operation blocklist enforced in COMPOUND (NFS4ERR_NOTSUPP). Security policy checked on mount/PUTFH. Delegation grant respects delegations_enabled. Netgroup IP check on mount. Max connections enforced.
  </done>
</task>

<task type="auto">
  <name>Task 2: SMB Adapter Settings Enforcement</name>
  <files>
    pkg/adapter/smb/adapter.go
    pkg/adapter/smb/config.go
  </files>
  <action>
**1. SMB Adapter - Settings Consumption** (`adapter.go` or `config.go`):

Similar to NFS adapter:
- On new connection, read settings from `rt.GetSMBSettings()`
- Check max_connections limit
- Apply session_timeout, oplock_break_timeout to connection handler
- Dialect negotiation: check client's requested dialect against min_dialect/max_dialect from settings. Reject if client only supports dialects outside the configured range.

**2. Enable Encryption Stub**:
- When settings have `EnableEncryption=true`, log at INFO level: "SMB encryption requested but not yet implemented -- connections will proceed without encryption"
- Per locked decision: config knob present, logs warning, ready for future SMB3 encryption

**3. Operation Blocklist**:
- SMB doesn't have the same per-operation blocklist granularity as NFS, but the framework should support it.
- If share has blocked_operations that map to SMB operations (like "READ", "WRITE"), enforce them in the SMB handler.
- For now, document the mapping but only enforce NFS operations in blocklist. SMB blocklist is a pass-through that logs and ignores unsupported operation names.

**4. Security Policy for SMB**:
- share.AllowAuthSys maps to SMB anonymous/guest access control
- share.RequireKerberos maps to requiring SPNEGO/Kerberos for SMB
- For now, log security policy at session setup and enforce AllowAuthSys (if false, reject SMB sessions without Kerberos auth)
- SMB already has guest access control per share -- integrate with the new AllowAuthSys flag

**5. Netgroup Access Check**:
- In SMB session setup or tree connect, call `runtime.CheckNetgroupAccess(ctx, shareName, clientIP)`
- Same behavior as NFS: reject if not in allowed netgroup
  </action>
  <verify>
`go build ./pkg/adapter/smb/...` compiles.
`go vet ./pkg/adapter/smb/...` passes.
  </verify>
  <done>
SMB adapter reads live settings. Dialect range enforced. Encryption stub logs warning. Security policy enforced on session setup. Netgroup IP check on tree connect. Max connections enforced.
  </done>
</task>

</tasks>

<verification>
- `go build ./...` compiles (full project)
- `go test ./internal/protocol/nfs/... -count=1 -race` passes
- `go test ./pkg/adapter/... -count=1` passes
- Operation blocklist returns NFS4ERR_NOTSUPP for blocked ops
- Security policy rejects unauthorized auth flavors
</verification>

<success_criteria>
Both NFS and SMB adapters consume live settings from the SettingsWatcher. Operation blocklists enforced. Security policy (auth flavor, Kerberos requirement) enforced at connection/mount time. Delegation policy respects settings. Netgroup IP access control active.
</success_criteria>

<output>
After completion, create `.planning/phases/14-control-plane-v2-0/14-04-SUMMARY.md`
</output>
