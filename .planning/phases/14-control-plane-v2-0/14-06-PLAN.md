---
phase: 14-control-plane-v2-0
plan: 06
type: execute
wave: 3
depends_on: ["14-02", "14-03"]
files_modified:
  - internal/controlplane/api/handlers/adapter_settings_test.go
  - internal/controlplane/api/handlers/netgroups_test.go
  - pkg/controlplane/store/adapter_settings_test.go
  - pkg/controlplane/store/netgroups_test.go
  - pkg/controlplane/runtime/settings_watcher_test.go
  - pkg/controlplane/runtime/netgroups_test.go
autonomous: true

must_haves:
  truths:
    - "Adapter settings CRUD operations have unit tests"
    - "Settings validation returns per-field errors"
    - "PATCH applies partial updates correctly (unchanged fields preserved)"
    - "PUT replaces all fields (missing fields get defaults)"
    - "Reset restores defaults for all or specific settings"
    - "Netgroup CRUD operations have unit tests"
    - "Netgroup member validation rejects invalid IPs/CIDRs"
    - "Netgroup deletion blocked when referenced by shares"
    - "Settings watcher detects version changes"
    - "Netgroup access checker matches IPs, CIDRs, and hostnames"
    - "DNS cache TTL works correctly"
  artifacts:
    - path: "pkg/controlplane/store/adapter_settings_test.go"
      provides: "Store-level adapter settings tests"
      contains: "TestNFSAdapterSettings"
    - path: "internal/controlplane/api/handlers/adapter_settings_test.go"
      provides: "API handler tests for adapter settings"
      contains: "TestPatchNFSSettings"
    - path: "pkg/controlplane/runtime/settings_watcher_test.go"
      provides: "Settings watcher unit tests"
      contains: "TestSettingsWatcher"
  key_links:
    - from: "internal/controlplane/api/handlers/adapter_settings_test.go"
      to: "internal/controlplane/api/handlers/adapter_settings.go"
      via: "Handler unit tests"
      pattern: "TestPatch"
    - from: "pkg/controlplane/store/adapter_settings_test.go"
      to: "pkg/controlplane/store/adapter_settings.go"
      via: "Store integration tests"
      pattern: "TestNFS"
---

<objective>
Add comprehensive unit and integration tests for the data layer, API handlers, settings watcher, and netgroup access checking.

Purpose: Ensure all control plane v2.0 functionality is tested before E2E testing in Plan 07. Catch regressions in store operations, validation logic, and runtime behavior.
Output: Test files covering store CRUD, handler validation/PATCH/PUT semantics, watcher polling, and netgroup IP matching.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-control-plane-v2-0/14-CONTEXT.md
@.planning/phases/14-control-plane-v2-0/14-01-SUMMARY.md
@.planning/phases/14-control-plane-v2-0/14-02-SUMMARY.md
@.planning/phases/14-control-plane-v2-0/14-03-SUMMARY.md
@internal/controlplane/api/handlers/auth_test.go
@internal/controlplane/api/handlers/groups_test.go
@pkg/controlplane/store/gorm.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Store and Handler Tests</name>
  <files>
    pkg/controlplane/store/adapter_settings_test.go
    pkg/controlplane/store/netgroups_test.go
    internal/controlplane/api/handlers/adapter_settings_test.go
    internal/controlplane/api/handlers/netgroups_test.go
  </files>
  <action>
Follow existing test patterns from the codebase. Store tests use `//go:build integration` and SQLite in-memory. Handler tests use httptest.

**1. `store/adapter_settings_test.go`**:
- TestEnsureAdapterSettings_CreatesDefaults: Create NFS adapter, call EnsureAdapterSettings, verify default settings created
- TestGetNFSAdapterSettings_ReturnsDefaults: Verify all default values match model constants
- TestUpdateNFSAdapterSettings_IncrementsVersion: Update settings, verify version incremented
- TestUpdateNFSAdapterSettings_PreservesUnchanged: Update only lease_time, verify other fields unchanged
- TestResetNFSAdapterSettings_RestoresDefaults: Modify settings, reset, verify defaults
- TestGetSMBAdapterSettings: Same pattern for SMB
- TestEnsureAdapterSettings_Idempotent: Call twice, verify no duplicate settings

**2. `store/netgroups_test.go`**:
- TestCreateNetgroup: Create, verify ID generated, name stored
- TestCreateNetgroup_DuplicateName: Attempt duplicate, verify ErrDuplicateNetgroup
- TestDeleteNetgroup: Create, delete, verify gone
- TestDeleteNetgroup_InUse: Create netgroup, create share referencing it, attempt delete, verify ErrNetgroupInUse
- TestAddNetgroupMember_IP: Add IP member, verify stored
- TestAddNetgroupMember_CIDR: Add CIDR member
- TestAddNetgroupMember_Hostname: Add hostname member
- TestRemoveNetgroupMember: Add then remove
- TestGetNetgroupMembers: Add multiple, list, verify all returned
- TestGetNetgroup_WithMembers: Verify preloading works

**3. `handlers/adapter_settings_test.go`**:
- TestGetNFSSettings_OK: GET returns 200 with all fields
- TestGetNFSSettings_NotFound: No adapter -> 404
- TestGetNFSDefaults: Verify defaults endpoint returns ranges
- TestPatchNFSSettings_PartialUpdate: PATCH with only lease_time, verify others unchanged
- TestPatchNFSSettings_ValidationError: Send lease_time=5 (below min), verify 422 with per-field errors
- TestPatchNFSSettings_Force: Same invalid value with ?force=true, verify 200 (bypasses validation)
- TestPatchNFSSettings_DryRun: Send update with ?dry_run=true, verify 200 response but DB unchanged
- TestPutNFSSettings_FullReplace: PUT with all fields, verify all updated
- TestResetNFSSettings_All: Reset, verify defaults
- TestResetNFSSettings_Specific: Reset specific setting
- TestSettingsAuditLog: Verify INFO log emitted on update (if testable)

**4. `handlers/netgroups_test.go`**:
- TestCreateNetgroup_OK: POST returns 201 with netgroup
- TestCreateNetgroup_Duplicate: Verify 409
- TestListNetgroups: Create multiple, list, verify all returned
- TestGetNetgroup: Get by name with members
- TestDeleteNetgroup_OK: Delete returns 204
- TestDeleteNetgroup_InUse: Verify 409 Conflict
- TestAddMember_IP: Add IP member, verify 201
- TestAddMember_InvalidType: Invalid type -> 400
- TestAddMember_InvalidCIDR: Bad CIDR -> 400
- TestRemoveMember_OK: Remove returns 204

Follow the exact httptest patterns from `groups_test.go` and `auth_test.go`.
  </action>
  <verify>
`go test ./pkg/controlplane/store/... -count=1 -race` passes.
`go test ./internal/controlplane/api/handlers/... -count=1 -race` passes.
  </verify>
  <done>
30+ tests covering: store CRUD for settings/netgroups, handler validation (per-field errors), PATCH vs PUT semantics, force/dry_run, netgroup lifecycle including in-use protection.
  </done>
</task>

<task type="auto">
  <name>Task 2: Runtime Tests (Settings Watcher + Netgroup Access)</name>
  <files>
    pkg/controlplane/runtime/settings_watcher_test.go
    pkg/controlplane/runtime/netgroups_test.go
  </files>
  <action>
**1. `settings_watcher_test.go`**:

Use a real SQLite in-memory store for integration-style tests.

- TestSettingsWatcher_LoadInitial: Create adapter + settings, load initial, verify cached settings match
- TestSettingsWatcher_DetectsChange: Load initial, update settings in DB (increment version), trigger poll manually (or use short interval), verify cached settings updated
- TestSettingsWatcher_NoChangeNoUpdate: Load initial, poll without DB change, verify no unnecessary update
- TestSettingsWatcher_AtomicSwap: Verify that GetNFSSettings returns a consistent snapshot (no partial reads). Use concurrent goroutines reading while updating to test thread safety.
- TestSettingsWatcher_StopClean: Start watcher, stop, verify goroutine exits cleanly
- TestSettingsWatcher_DBError: Simulate DB error during poll, verify watcher continues (doesn't crash), old settings preserved

The test can use a short poll interval (50ms) for fast testing. Create a helper that sets up store + adapter + settings.

**2. `netgroups_test.go`** (runtime package):

Test the CheckNetgroupAccess function and DNS caching.

- TestCheckNetgroupAccess_NoNetgroup_AllowAll: Share with no netgroup -> returns true
- TestCheckNetgroupAccess_IPMatch: Netgroup has IP "192.168.1.100", client is 192.168.1.100 -> true
- TestCheckNetgroupAccess_IPNoMatch: Different IP -> false
- TestCheckNetgroupAccess_CIDRMatch: Netgroup has "10.0.0.0/8", client is 10.1.2.3 -> true
- TestCheckNetgroupAccess_CIDRNoMatch: Client is 192.168.1.1 -> false
- TestCheckNetgroupAccess_HostnameMatch: Use mock DNS (replace net.LookupAddr or test with known PTR)
  - Since net.LookupAddr is hard to mock, test the hostname matching logic separately:
  - `TestMatchHostname_ExactMatch`: "host.example.com" matches "host.example.com"
  - `TestMatchHostname_WildcardMatch`: "host.example.com" matches "*.example.com"
  - `TestMatchHostname_WildcardNoMatch`: "host.other.com" does NOT match "*.example.com"
- TestDNSCache_TTL: Cache entry, verify served from cache, wait for expiry, verify re-lookup
- TestDNSCache_NegativeCache: Cache a lookup failure, verify cached for negative TTL
- TestCheckNetgroupAccess_MixedMembers: Netgroup with IP + CIDR + hostname, verify any match works

For hostname matching, extract the matching logic into a testable function `matchHostname(hostnames []string, pattern string) bool` that takes already-resolved hostnames. Test that function directly. The DNS lookup integration is tested separately or via E2E.
  </action>
  <verify>
`go test ./pkg/controlplane/runtime/... -count=1 -race` passes.
All new tests pass with race detection enabled.
  </verify>
  <done>
20+ tests covering: settings watcher lifecycle, version-based change detection, atomic reads under concurrency, DB error resilience, netgroup access for all member types (IP/CIDR/hostname), wildcard matching, DNS cache TTL behavior.
  </done>
</task>

</tasks>

<verification>
- `go test ./pkg/controlplane/... -count=1 -race` all pass
- `go test ./internal/controlplane/... -count=1 -race` all pass
- No test flakiness with race detector enabled
</verification>

<success_criteria>
50+ unit/integration tests covering all new control plane v2.0 functionality. Store CRUD, handler validation, PATCH/PUT semantics, force/dry_run, settings watcher polling and concurrency, netgroup access checking.
</success_criteria>

<output>
After completion, create `.planning/phases/14-control-plane-v2-0/14-06-SUMMARY.md`
</output>
