---
phase: 14-control-plane-v2-0
plan: 03
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - pkg/controlplane/runtime/settings_watcher.go
  - pkg/controlplane/runtime/netgroups.go
  - pkg/controlplane/runtime/runtime.go
  - pkg/controlplane/runtime/shares.go
  - pkg/adapter/nfs/nfs_adapter.go
  - pkg/adapter/smb/config.go
autonomous: true

must_haves:
  truths:
    - "SettingsWatcher polls DB every 10 seconds for settings changes"
    - "Settings change detection uses monotonic version counter (not timestamps)"
    - "Adapter reads settings snapshot under RLock (atomic swap, no field-by-field mutation)"
    - "New connections use updated settings; existing connections are grandfathered"
    - "Netgroup IP matching works for IPs, CIDRs, and DNS hostnames"
    - "Reverse DNS lookups are cached with 5-minute TTL"
    - "Empty netgroup allowlist = allow all (no IP restrictions)"
    - "Security policy changes logged at INFO level (audit trail)"
  artifacts:
    - path: "pkg/controlplane/runtime/settings_watcher.go"
      provides: "DB polling goroutine for settings hot-reload"
      contains: "SettingsWatcher"
    - path: "pkg/controlplane/runtime/netgroups.go"
      provides: "Netgroup access checking with DNS cache"
      contains: "CheckNetgroupAccess"
  key_links:
    - from: "pkg/controlplane/runtime/settings_watcher.go"
      to: "pkg/controlplane/store/adapter_settings.go"
      via: "Polling store for settings changes"
      pattern: "store\\.Get.*AdapterSettings"
    - from: "pkg/controlplane/runtime/runtime.go"
      to: "pkg/controlplane/runtime/settings_watcher.go"
      via: "Watcher lifecycle management"
      pattern: "settingsWatcher"
    - from: "pkg/controlplane/runtime/netgroups.go"
      to: "pkg/controlplane/store/netgroups.go"
      via: "Netgroup member lookup"
      pattern: "store\\.GetNetgroupMembers"
---

<objective>
Implement settings hot-reload via DB polling and netgroup IP access checking in the runtime.

Purpose: Make adapter settings changes take effect without adapter restart (10s polling), and provide the runtime-level netgroup membership checking that adapters use for IP access control.
Output: SettingsWatcher goroutine, netgroup access checker with DNS caching, adapter integration hooks.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-control-plane-v2-0/14-CONTEXT.md
@.planning/phases/14-control-plane-v2-0/14-RESEARCH.md
@.planning/phases/14-control-plane-v2-0/14-01-SUMMARY.md
@pkg/controlplane/runtime/runtime.go
@pkg/controlplane/runtime/shares.go
@pkg/adapter/nfs/nfs_adapter.go
@pkg/adapter/smb/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Settings Watcher with DB Polling</name>
  <files>
    pkg/controlplane/runtime/settings_watcher.go
    pkg/controlplane/runtime/runtime.go
  </files>
  <action>
**1. Create `settings_watcher.go`**:

```go
type SettingsWatcher struct {
    mu           sync.RWMutex
    store        store.Store
    logger       *slog.Logger // or use internal/logger

    // Cached settings (read by adapters via GetNFS/SMBSettings)
    nfsSettings  *models.NFSAdapterSettings
    smbSettings  *models.SMBAdapterSettings

    // Last known version for change detection
    nfsVersion   int
    smbVersion   int

    pollInterval time.Duration
    stopCh       chan struct{}
    stopped      chan struct{} // closed when polling goroutine exits
}
```

Constructor: `NewSettingsWatcher(store store.Store, pollInterval time.Duration) *SettingsWatcher`
- Default pollInterval = 10 * time.Second per locked decision

Methods:
- `Start(ctx context.Context)` -- starts polling goroutine. On each tick:
  1. Get NFS adapter from store (by type "nfs"), get its settings
  2. Compare settings.Version with cached nfsVersion
  3. If changed: acquire write lock, swap entire settings struct atomically (pointer swap per Pitfall 2), update nfsVersion, release lock
  4. Log at INFO level: "NFS adapter settings updated", include changed_at timestamp and key values
  5. Same for SMB
  6. On error: log at WARN and continue (don't crash on transient DB errors)

- `Stop()` -- signal polling to stop, wait for goroutine exit

- `GetNFSSettings() *models.NFSAdapterSettings` -- read under RLock, return pointer (callers should NOT mutate)
- `GetSMBSettings() *models.SMBAdapterSettings` -- same pattern

- `LoadInitial(ctx context.Context) error` -- called once at startup to populate cache before serving begins. Returns error if DB is unreachable.

Thread safety:
- Writers (poll goroutine): acquire mu.Lock(), swap entire struct pointer
- Readers (adapter goroutines): acquire mu.RLock(), read pointer
- Per Pitfall 2: NEVER mutate fields on the cached struct. Always create new struct and swap.

**2. Modify `runtime.go`**:
- Add `settingsWatcher *SettingsWatcher` field to Runtime struct
- In `New()` or `Init()`: create SettingsWatcher, call LoadInitial
- In `Serve()`: start watcher goroutine as part of runtime lifecycle
- In `Shutdown()`: stop watcher
- Add `GetSettingsWatcher() *SettingsWatcher` accessor for adapters to use
- Add `GetNFSSettings() *models.NFSAdapterSettings` convenience method that delegates to watcher
- Add `GetSMBSettings() *models.SMBAdapterSettings` convenience method

Security policy audit logging: When settings change is detected, log the diff:
```go
logger.Info("NFS adapter settings reloaded",
    "version", newSettings.Version,
    "lease_time", newSettings.LeaseTime,
    "delegations_enabled", newSettings.DelegationsEnabled)
```
  </action>
  <verify>
`go build ./pkg/controlplane/runtime/...` compiles.
`go vet ./pkg/controlplane/runtime/...` passes.
  </verify>
  <done>
SettingsWatcher polls DB every 10s. Atomic pointer swap for thread safety. Version-based change detection. LoadInitial for startup. Start/Stop lifecycle integrated into Runtime. Audit logging on settings changes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Netgroup Access Checking with DNS Cache</name>
  <files>
    pkg/controlplane/runtime/netgroups.go
    pkg/controlplane/runtime/shares.go
    pkg/adapter/nfs/nfs_adapter.go
    pkg/adapter/smb/config.go
  </files>
  <action>
**1. Create `netgroups.go`** in runtime package:

DNS cache:
```go
type dnsCache struct {
    mu      sync.RWMutex
    entries map[string]*dnsCacheEntry
    ttl     time.Duration     // 5 minutes default
    negTTL  time.Duration     // 1 minute for lookup failures
}

type dnsCacheEntry struct {
    hostnames []string   // reverse DNS results
    err       error      // cached error (negative cache)
    expiresAt time.Time
}
```

`CheckNetgroupAccess(ctx context.Context, shareName string, clientIP net.IP) (bool, error)`:
1. Get share from runtime state (not DB -- use cached share config)
2. If share has no NetgroupID -> return true (empty allowlist = allow all per locked decision)
3. Get netgroup members from store (or cache them with short TTL)
4. For each member:
   - Type "ip": `net.ParseIP(member.Value).Equal(clientIP)`
   - Type "cidr": `_, network, _ := net.ParseCIDR(member.Value); network.Contains(clientIP)`
   - Type "hostname": call `matchHostname(clientIP, member.Value)` which:
     a. Reverse DNS lookup on clientIP using `net.LookupAddr()` (cached via dnsCache)
     b. Compare PTR results against member.Value
     c. Support wildcards: "*.example.com" matches any hostname ending in ".example.com"
     d. Use simple suffix matching after stripping the leading "*"
5. Return false if no member matches

DNS cache methods:
- `lookupAddr(ip string) ([]string, error)` -- check cache first, call `net.LookupAddr` on miss
- `cleanExpired()` -- called periodically (piggybacked on lookups, not separate goroutine)

Per Pitfall 3 (DNS blocking): cache TTL = 5 minutes for successful lookups, 1 minute for failures. Fall back to IP matching if DNS lookup fails (do not block).

**2. Modify `shares.go`** (runtime package) - If the runtime's Share/ShareConfig struct needs updating to include NetgroupID and security policy fields, extend it here. The runtime ShareConfig should carry:
- AllowAuthSys bool
- RequireKerberos bool
- MinKerberosLevel string
- NetgroupID string
- BlockedOperations []string

These should be populated when shares are loaded from the DB into the runtime.

**3. Add adapter integration hooks** in `nfs_adapter.go` and `smb/config.go`:
- Add methods or interfaces that adapters can call to get current settings from runtime
- For NFS adapter: `GetNFSSettings()` returns the cached settings from the watcher
- The NFS adapter should use these settings for:
  - lease_time -> StateManager configuration
  - max_connections -> connection limit check
  - delegations_enabled -> delegation grant policy
  - blocked_operations -> COMPOUND op dispatch

NOTE: Do NOT change the full adapter behavior in this plan. Just add the accessor methods and document where they should be consumed. The actual enforcement (connection limiting, op blocking, etc.) is covered in Plan 14-04.

The NFS adapter's `SetRuntime` method already has access to the runtime. Add a comment documenting that the adapter should call `rt.GetNFSSettings()` to get current settings for new connections.
  </action>
  <verify>
`go build ./pkg/controlplane/runtime/...` compiles.
`go build ./pkg/adapter/...` compiles.
`go vet ./pkg/controlplane/runtime/... ./pkg/adapter/...` passes.
  </verify>
  <done>
Runtime has netgroup access checking with IP/CIDR/hostname matching. DNS cache with 5-min positive / 1-min negative TTL. Runtime ShareConfig extended with security policy fields. Adapter accessor methods for settings watcher. All compiles without errors.
  </done>
</task>

</tasks>

<verification>
- `go build ./pkg/controlplane/runtime/...` compiles
- `go build ./pkg/adapter/...` compiles
- `go test ./pkg/controlplane/runtime/... -count=1` passes (existing tests)
- Settings watcher has Start/Stop lifecycle
- Netgroup checker handles all three member types
</verification>

<success_criteria>
Runtime has working settings hot-reload (10s poll, version-based change detection, atomic pointer swap) and netgroup access checking (IP/CIDR/hostname with DNS cache). Adapters can access live settings via runtime.
</success_criteria>

<output>
After completion, create `.planning/phases/14-control-plane-v2-0/14-03-SUMMARY.md`
</output>
