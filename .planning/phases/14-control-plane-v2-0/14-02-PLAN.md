---
phase: 14-control-plane-v2-0
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - internal/controlplane/api/handlers/adapter_settings.go
  - internal/controlplane/api/handlers/netgroups.go
  - internal/controlplane/api/handlers/shares.go
  - pkg/controlplane/api/router.go
  - pkg/apiclient/client.go
  - pkg/apiclient/adapter_settings.go
  - pkg/apiclient/netgroups.go
autonomous: true

must_haves:
  truths:
    - "GET/PUT/PATCH /adapters/{type}/settings manages adapter settings"
    - "GET /adapters/{type}/settings/defaults returns default values and valid ranges"
    - "PATCH applies partial updates (nil = keep current), PUT replaces all"
    - "Validation returns per-field errors as RFC 7807 with errors map"
    - "--force query param bypasses range validation (logs warning)"
    - "--dry_run query param validates without applying"
    - "GET/POST/DELETE /netgroups manages netgroups as top-level resources"
    - "POST/DELETE /netgroups/{name}/members manages netgroup members"
    - "Share create/update handles security policy fields"
    - "Kerberos required + no keytab = share creation rejected (fail-fast)"
    - "API client has patch() method and adapter settings + netgroup methods"
  artifacts:
    - path: "internal/controlplane/api/handlers/adapter_settings.go"
      provides: "Adapter settings API handlers"
      contains: "PatchNFSSettings"
    - path: "internal/controlplane/api/handlers/netgroups.go"
      provides: "Netgroup CRUD handlers"
      contains: "CreateNetgroup"
    - path: "pkg/controlplane/api/router.go"
      provides: "Router with new routes registered"
      contains: "settings"
    - path: "pkg/apiclient/adapter_settings.go"
      provides: "API client adapter settings methods"
      contains: "GetNFSSettings"
    - path: "pkg/apiclient/netgroups.go"
      provides: "API client netgroup methods"
      contains: "CreateNetgroup"
  key_links:
    - from: "internal/controlplane/api/handlers/adapter_settings.go"
      to: "pkg/controlplane/store/adapter_settings.go"
      via: "Store methods for settings CRUD"
      pattern: "store\\.Get.*AdapterSettings"
    - from: "internal/controlplane/api/handlers/netgroups.go"
      to: "pkg/controlplane/store/netgroups.go"
      via: "Store methods for netgroup CRUD"
      pattern: "store\\.CreateNetgroup"
    - from: "pkg/controlplane/api/router.go"
      to: "internal/controlplane/api/handlers/adapter_settings.go"
      via: "Route registration"
      pattern: "settingsHandler"
---

<objective>
Build the REST API layer and API client for adapter settings, netgroups, and share security policy.

Purpose: Expose all control plane v2.0 functionality via REST API following existing chi router patterns, and provide the API client methods that the CLI (Plan 03) depends on.
Output: API handlers, router registration, API client with patch support.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-control-plane-v2-0/14-CONTEXT.md
@.planning/phases/14-control-plane-v2-0/14-RESEARCH.md
@.planning/phases/14-control-plane-v2-0/14-01-SUMMARY.md
@pkg/controlplane/api/router.go
@internal/controlplane/api/handlers/adapters.go
@internal/controlplane/api/handlers/shares.go
@internal/controlplane/api/handlers/problem.go
@internal/controlplane/api/handlers/response.go
@internal/controlplane/api/handlers/helpers.go
@internal/controlplane/api/middleware/auth.go
@pkg/apiclient/client.go
@pkg/apiclient/adapters.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: API Handlers for Adapter Settings and Netgroups</name>
  <files>
    internal/controlplane/api/handlers/adapter_settings.go
    internal/controlplane/api/handlers/netgroups.go
    internal/controlplane/api/handlers/shares.go
    pkg/controlplane/api/router.go
  </files>
  <action>
**1. Create `adapter_settings.go`** - AdapterSettingsHandler with runtime + store:

Request types using pointer fields for PATCH (nil = not provided):
```go
type PatchNFSSettingsRequest struct {
    MinVersion            *string `json:"min_version,omitempty"`
    MaxVersion            *string `json:"max_version,omitempty"`
    LeaseTime             *int    `json:"lease_time,omitempty"`
    GracePeriod           *int    `json:"grace_period,omitempty"`
    DelegationRecallTimeout *int  `json:"delegation_recall_timeout,omitempty"`
    CallbackTimeout       *int    `json:"callback_timeout,omitempty"`
    LeaseBreakTimeout     *int    `json:"lease_break_timeout,omitempty"`
    MaxConnections        *int    `json:"max_connections,omitempty"`
    MaxClients            *int    `json:"max_clients,omitempty"`
    MaxCompoundOps        *int    `json:"max_compound_ops,omitempty"`
    MaxReadSize           *int    `json:"max_read_size,omitempty"`
    MaxWriteSize          *int    `json:"max_write_size,omitempty"`
    PreferredTransferSize *int    `json:"preferred_transfer_size,omitempty"`
    DelegationsEnabled    *bool   `json:"delegations_enabled,omitempty"`
    BlockedOperations     *[]string `json:"blocked_operations,omitempty"`
}
```
Similar for SMB. For PUT, use value types (all fields required).

Handlers:
- `GetSettings(w, r)` -- GET /adapters/{type}/settings. Lookup adapter by chi URL param {type}, get settings from store, return JSON response.
- `GetDefaults(w, r)` -- GET /adapters/{type}/settings/defaults. Return static default values + valid ranges (min/max per field) as JSON.
- `PutSettings(w, r)` -- PUT /adapters/{type}/settings. Full replace. Decode all fields, validate, save.
- `PatchSettings(w, r)` -- PATCH /adapters/{type}/settings. Partial update. Get current from store, apply non-nil fields from request, validate merged result, save.
- `ResetSettings(w, r)` -- DELETE /adapters/{type}/settings (or POST .../reset with optional `setting` query param). Reset all or specific setting.

Query params:
- `force=true` -- bypass range validation, log warning via logger.Warn
- `dry_run=true` -- validate and return would-be result without saving

Validation function `validateNFSSettings(s *NFSAdapterSettings) map[string]string`:
- lease_time: >= 30, <= 3600
- grace_period: >= 30, <= 3600
- callback_timeout: >= 1, <= 60
- lease_break_timeout: >= 5, <= 300
- max_compound_ops: >= 10, <= 1000
- max_clients: >= 100, <= 100000
- max_read_size: >= 4096, <= 16777216 (16MB)
- max_write_size: same
- min_version/max_version: must be valid version string ("3", "4.0", "4.1")
- blocked_operations: each must be a valid NFS operation name (validate against known list)

Return per-field errors as `ValidationErrorResponse` (RFC 7807 with `errors` map) using status 422 per research Pattern 5.

Audit logging: `logger.Info("NFS adapter settings updated", "changed_by", claims.Username, ...)` for all mutations per locked decision.

**2. Create `netgroups.go`** - NetgroupHandler:

Standard CRUD following groups.go handler pattern:
- `Create(w, r)` -- POST /netgroups. Decode {name} body, create via store.
- `List(w, r)` -- GET /netgroups. List all with members.
- `Get(w, r)` -- GET /netgroups/{name}. Get with members.
- `Delete(w, r)` -- DELETE /netgroups/{name}. Fails with 409 Conflict if referenced by shares.
- `AddMember(w, r)` -- POST /netgroups/{name}/members. Decode {type, value}, validate, add.
- `RemoveMember(w, r)` -- DELETE /netgroups/{name}/members/{id}. Remove by member ID.

**3. Modify `shares.go`** - Extend CreateShareRequest and UpdateShareRequest with security policy fields:
- AllowAuthSys *bool, RequireKerberos *bool, MinKerberosLevel *string, NetgroupID *string, BlockedOperations *[]string
- On create: apply defaults for nil fields (AllowAuthSys=true, RequireKerberos=false, MinKerberosLevel="krb5")
- On update: only apply non-nil fields (PATCH semantics)
- **Fail-fast validation**: If RequireKerberos=true, check if NFS adapter has Kerberos configured. Access runtime to check this. If not configured, return 422 with error "Kerberos required but NFS adapter has no keytab configured". Per locked decision: "refuse to start share."
- Validate NetgroupID references an existing netgroup (FK check)
- Validate BlockedOperations entries against known operation names

**4. Modify `router.go`** - Register new routes:
- Under `/adapters/{type}` admin group, add:
  - GET `/{type}/settings` -> settingsHandler.GetSettings
  - PUT `/{type}/settings` -> settingsHandler.PutSettings
  - PATCH `/{type}/settings` -> settingsHandler.PatchSettings
  - GET `/{type}/settings/defaults` -> settingsHandler.GetDefaults
  - POST `/{type}/settings/reset` -> settingsHandler.ResetSettings
- New top-level `/netgroups` route group (admin only):
  - POST / -> netgroupHandler.Create
  - GET / -> netgroupHandler.List
  - GET /{name} -> netgroupHandler.Get
  - DELETE /{name} -> netgroupHandler.Delete
  - POST /{name}/members -> netgroupHandler.AddMember
  - DELETE /{name}/members/{id} -> netgroupHandler.RemoveMember

The AdapterSettingsHandler needs both the store and the runtime (for Kerberos config check). Pass both to constructor: `NewAdapterSettingsHandler(cpStore, rt)`.
  </action>
  <verify>
`go build ./internal/controlplane/api/...` compiles.
`go build ./pkg/controlplane/api/...` compiles.
`go vet ./internal/controlplane/api/...` passes.
  </verify>
  <done>
All API handlers compile. Router registers all new routes. PATCH/PUT/GET/DELETE for adapter settings with validation, force, dry_run. Netgroup CRUD with member management. Share CRUD extended with security policy. Kerberos fail-fast validation in share creation.
  </done>
</task>

<task type="auto">
  <name>Task 2: API Client Extension (patch method, adapter settings, netgroups)</name>
  <files>
    pkg/apiclient/client.go
    pkg/apiclient/adapter_settings.go
    pkg/apiclient/netgroups.go
    pkg/apiclient/shares.go
  </files>
  <action>
**1. Extend `client.go`** - Add `patch` method following the existing `put` pattern:
```go
func (c *Client) patch(path string, body, result any) error {
    return c.do(http.MethodPatch, path, body, result)
}
```
This is a simple addition since `do()` already handles all HTTP methods.

**2. Create `adapter_settings.go`** - API client methods:

Types matching handler request/response:
```go
type NFSAdapterSettingsResponse struct {
    // All fields from model, exposed as JSON
    MinVersion string `json:"min_version"`
    MaxVersion string `json:"max_version"`
    LeaseTime  int    `json:"lease_time"`
    // ... all fields
    BlockedOperations []string `json:"blocked_operations"`
    Version int `json:"version"`
}

type NFSSettingsDefaultsResponse struct {
    Defaults NFSAdapterSettingsResponse `json:"defaults"`
    Ranges   map[string]SettingRange    `json:"ranges"`
}

type SettingRange struct {
    Min any    `json:"min,omitempty"`
    Max any    `json:"max,omitempty"`
    Values []string `json:"values,omitempty"` // for enum fields
}
```

Methods:
- `GetAdapterSettings(adapterType string) (*NFSAdapterSettingsResponse, error)` -- GET /adapters/{type}/settings
- `GetAdapterSettingsDefaults(adapterType string) (*NFSSettingsDefaultsResponse, error)` -- GET /adapters/{type}/settings/defaults
- `UpdateAdapterSettings(adapterType string, req any) (*NFSAdapterSettingsResponse, error)` -- PUT
- `PatchAdapterSettings(adapterType string, req any, opts ...SettingsOption) (*NFSAdapterSettingsResponse, error)` -- PATCH. SettingsOption adds query params (force, dry_run).
- `ResetAdapterSettings(adapterType string, setting string) error` -- POST .../reset with optional ?setting= query param

Use `SettingsOption` functional options for force/dry_run:
```go
type SettingsOption func(url *string)
func WithForce() SettingsOption { ... appends ?force=true }
func WithDryRun() SettingsOption { ... appends ?dry_run=true }
```

**3. Create `netgroups.go`** - API client methods:

Types:
```go
type Netgroup struct {
    ID      string           `json:"id"`
    Name    string           `json:"name"`
    Members []NetgroupMember `json:"members,omitempty"`
}
type NetgroupMember struct {
    ID    string `json:"id"`
    Type  string `json:"type"`
    Value string `json:"value"`
}
```

Methods:
- `ListNetgroups() ([]*Netgroup, error)` -- GET /netgroups
- `GetNetgroup(name string) (*Netgroup, error)` -- GET /netgroups/{name}
- `CreateNetgroup(name string) (*Netgroup, error)` -- POST /netgroups
- `DeleteNetgroup(name string) error` -- DELETE /netgroups/{name}
- `AddNetgroupMember(netgroupName, memberType, memberValue string) (*NetgroupMember, error)` -- POST /netgroups/{name}/members
- `RemoveNetgroupMember(netgroupName, memberID string) error` -- DELETE /netgroups/{name}/members/{id}

**4. Extend `shares.go`** (if needed) - Add security policy fields to existing CreateShareRequest/UpdateShareRequest types in the API client. The existing share methods should already work since Go JSON will include new fields.
  </action>
  <verify>
`go build ./pkg/apiclient/...` compiles.
`go vet ./pkg/apiclient/...` passes.
  </verify>
  <done>
API client has patch() method. Adapter settings and netgroup client methods compile. SettingsOption pattern supports force and dry_run query params. All types defined for request/response.
  </done>
</task>

</tasks>

<verification>
- `go build ./...` compiles (full project)
- `go vet ./internal/controlplane/... ./pkg/controlplane/... ./pkg/apiclient/...` clean
- Router has all new routes registered
- API client has patch method and all new resource methods
</verification>

<success_criteria>
Complete REST API for adapter settings (GET/PUT/PATCH with validation, defaults, force, dry_run, reset) and netgroups (full CRUD with members). Share API extended with security policy. API client ready for CLI consumption.
</success_criteria>

<output>
After completion, create `.planning/phases/14-control-plane-v2-0/14-02-SUMMARY.md`
</output>
