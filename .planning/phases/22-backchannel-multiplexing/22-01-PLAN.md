---
phase: 22-backchannel-multiplexing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/protocol/nfs/v4/state/callback_common.go
  - internal/protocol/nfs/v4/state/callback.go
  - internal/protocol/nfs/v4/state/backchannel.go
  - internal/protocol/nfs/v4/state/session.go
  - internal/protocol/nfs/v4/state/manager.go
  - internal/protocol/nfs/v4/state/delegation.go
  - internal/protocol/nfs/v4/handlers/backchannel_ctl_handler.go
  - internal/protocol/nfs/v4/handlers/handler.go
  - pkg/adapter/nfs/nfs_connection.go
autonomous: true
requirements: [BACK-01, BACK-03, BACK-04]

must_haves:
  truths:
    - "Server sends CB_SEQUENCE + CB_RECALL over a back-bound connection without dialing out"
    - "BACKCHANNEL_CTL updates session callback security parameters"
    - "v4.0 clients continue using dial-out callbacks unchanged"
    - "v4.1 clients receive callbacks over their existing fore-channel TCP connection"
    - "Read loop demuxes: fore-channel CALL messages dispatch to handlers, backchannel REPLY messages route to sender goroutine"
  artifacts:
    - path: "internal/protocol/nfs/v4/state/callback_common.go"
      provides: "Shared wire-format helpers (RPC framing, record marking, CB_COMPOUND encoding)"
      exports: ["BuildCBRPCCallMessage", "AddCBRecordMark", "EncodeCBRecallOp", "ReadFragment", "ValidateCBReply"]
    - path: "internal/protocol/nfs/v4/state/backchannel.go"
      provides: "BackchannelSender goroutine, CallbackRequest, XID-keyed response routing, v4.1 CB_COMPOUND encoding"
      exports: ["BackchannelSender", "CallbackRequest", "PendingCBReplies"]
    - path: "internal/protocol/nfs/v4/handlers/backchannel_ctl_handler.go"
      provides: "BACKCHANNEL_CTL handler replacing stub"
      exports: ["handleBackchannelCtl"]
  key_links:
    - from: "internal/protocol/nfs/v4/state/delegation.go"
      to: "internal/protocol/nfs/v4/state/backchannel.go"
      via: "sendRecall checks v4.1 client and enqueues to BackchannelSender"
      pattern: "getBackchannelSender.*Enqueue"
    - from: "pkg/adapter/nfs/nfs_connection.go"
      to: "internal/protocol/nfs/v4/state/backchannel.go"
      via: "Read loop demux routes REPLY messages to PendingCBReplies"
      pattern: "RPCReply.*routeBackchannelReply"
    - from: "internal/protocol/nfs/v4/state/backchannel.go"
      to: "internal/protocol/nfs/v4/state/callback_common.go"
      via: "BackchannelSender uses shared wire-format helpers"
      pattern: "BuildCBRPCCallMessage|AddCBRecordMark"
    - from: "internal/protocol/nfs/v4/handlers/handler.go"
      to: "internal/protocol/nfs/v4/handlers/backchannel_ctl_handler.go"
      via: "v41DispatchTable entry for OP_BACKCHANNEL_CTL"
      pattern: "OP_BACKCHANNEL_CTL.*handleBackchannelCtl"
---

<objective>
Implement the core NFSv4.1 backchannel infrastructure: BackchannelSender goroutine for sending CB_SEQUENCE + CB_RECALL over back-bound connections, read-loop demux for bidirectional I/O on shared TCP connections, callback routing (v4.0 dial-out vs v4.1 multiplexed), BACKCHANNEL_CTL handler, and shared wire-format helpers extracted from callback.go.

Purpose: Enable the server to send delegation recall callbacks to v4.1 clients over their existing TCP connections (no separate dial-out), which is the core v4.1 backchannel mechanism per RFC 8881. This makes callbacks work through NAT/firewalls.

Output: Working backchannel send path, BACKCHANNEL_CTL handler, read-loop demux, and callback routing layer.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-backchannel-multiplexing/22-CONTEXT.md
@.planning/phases/22-backchannel-multiplexing/22-RESEARCH.md
@.planning/phases/21-connection-management-and-trunking/21-01-SUMMARY.md

Key source files to read before implementing:
@internal/protocol/nfs/v4/state/callback.go
@internal/protocol/nfs/v4/state/connection.go
@internal/protocol/nfs/v4/state/delegation.go
@internal/protocol/nfs/v4/state/manager.go
@internal/protocol/nfs/v4/state/session.go
@internal/protocol/nfs/v4/handlers/handler.go
@pkg/adapter/nfs/nfs_connection.go
@pkg/adapter/nfs/nfs_connection_handlers.go
@internal/protocol/nfs/v4/types/backchannel_ctl.go
@internal/protocol/nfs/v4/types/cb_sequence.go
@internal/protocol/CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Shared wire-format helpers, BackchannelSender, and session backchannel state</name>
  <files>
    internal/protocol/nfs/v4/state/callback_common.go
    internal/protocol/nfs/v4/state/callback.go
    internal/protocol/nfs/v4/state/backchannel.go
    internal/protocol/nfs/v4/state/session.go
    internal/protocol/nfs/v4/state/manager.go
  </files>
  <action>
    **1. Create `callback_common.go` -- extract shared wire-format helpers from `callback.go`:**
    - Move these functions from callback.go to callback_common.go (export them with capital first letter):
      - `encodeCBRecallOp` -> `EncodeCBRecallOp` (unchanged logic, just exported)
      - `buildCBRPCCallMessage` -> `BuildCBRPCCallMessage`
      - `addCBRecordMark` -> `AddCBRecordMark`
      - `readFragment` -> `ReadFragment`
      - `readAndValidateCBReply` -> keep as-is or adapt for both v4.0 and v4.1
    - Keep `cbRPCVersion`, `maxFragmentSize`, `CBCallbackTimeout` constants in callback_common.go
    - Update callback.go to call the exported versions (e.g., `SendCBRecall` calls `EncodeCBRecallOp`, `BuildCBRPCCallMessage`, `AddCBRecordMark`)
    - Keep v4.0-specific functions (`encodeCBCompound` with callback_ident, `dialCallback`, `ParseUniversalAddr`, `SendCBRecall`, `SendCBNull`) in callback.go

    **2. Create `backchannel.go` -- v4.1 BackchannelSender:**
    - `BackchannelSender` struct with fields:
      - `sessionID types.SessionId4`, `clientID uint64`, `cbProgram uint32`
      - `queue chan CallbackRequest` (buffered, capacity 64 per discretion)
      - `slotTable *SlotTable` (backchannel slot table from session)
      - `sm *StateManager` (for connection lookup)
      - `stopCh chan struct{}`
      - `nextXID atomic.Uint32`
      - `callbackTimeout time.Duration` (default 10s per discretion)
      - `metrics *BackchannelMetrics` (nil-safe, wired in Plan 02)
    - `CallbackRequest` struct: `OpCode uint32`, `Payload []byte`, `ResultCh chan error`
    - `PendingCBReplies` struct: `mu sync.Mutex`, `waiters map[uint32]chan []byte` (XID -> reply channel)
      - Methods: `Register(xid uint32) chan []byte`, `Deliver(xid uint32, reply []byte) bool`, `Cancel(xid uint32)`
    - `encodeCBCompoundV41(ops [][]byte) []byte` -- v4.1 CB_COMPOUND encoding (minorversion=1, callback_ident=0, multi-op support)
    - `encodeCBSequenceOp(sessionID, seqID, slotID, highestSlotID)` -- encodes CB_SEQUENCE args using types.CbSequenceArgs.Encode()
    - `BackchannelSender.Run(ctx context.Context)` -- goroutine loop: select on ctx.Done, stopCh, queue
    - `BackchannelSender.Stop()` -- closes stopCh
    - `BackchannelSender.Enqueue(req CallbackRequest) bool` -- non-blocking send to queue, returns false if full
    - `BackchannelSender.sendCallback(ctx, req)` -- core send logic:
      1. Use slot 0 with monotonic seqid (simplified EOS per discretion)
      2. Build CB_COMPOUND: CB_SEQUENCE + req.Payload
      3. Frame with RPC CALL message using BuildCBRPCCallMessage
      4. Add record marking with AddCBRecordMark
      5. Find a back-bound connection: call sm.getBackBoundConnection(sessionID) which returns the connection with most recent fore-channel activity (per locked decision)
      6. Register XID with PendingCBReplies on that connection
      7. Write framed message to connection using connection's write method (must acquire writeMu)
      8. Wait for reply with timeout (10s default)
      9. On send failure: retry once on another back-bound connection (per locked decision). If both fail, return error.
      10. On reply: validate CB_COMPOUND reply status
    - Exponential backoff retry wrapper: 3 attempts with 5s/10s/20s delays (per locked decision)

    **3. Add backchannel state to Session:**
    - Add `BackchannelSecParms []types.CallbackSecParms` field to Session struct (stores BACKCHANNEL_CTL security params)
    - Add `backchannelSender *BackchannelSender` field to Session struct (nil until first backchannel operation)

    **4. Add StateManager backchannel methods:**
    - `StartBackchannelSender(sessionID)` -- creates and starts BackchannelSender for a session if it has BackChannelSlots. Called lazily on first back-channel bind or first callback enqueue (per discretion).
    - `StopBackchannelSender(sessionID)` -- stops sender goroutine. Called from destroySessionLocked.
    - `getBackchannelSender(clientID) *BackchannelSender` -- returns sender for the client's first session that has a backchannel. Returns nil if no v4.1 backchannel exists.
    - `getBackBoundConnection(sessionID) (connectionID uint64, ok bool)` -- finds back-bound connection with most recent fore-channel activity. Uses connMu.RLock, reads from connBySession, picks connection where Direction is ConnDirBack or ConnDirBoth. Track LastActivity on BoundConnection (add field if missing).
    - `UpdateBackchannelParams(sessionID, cbProgram, secParms)` -- stores new callback params on session. Called by BACKCHANNEL_CTL handler.
    - Add `PendingCBReplies` field to NFSConnection (or a connection-level registry accessible by connectionID). Since BackchannelSender needs to write to a net.Conn and register XID waiters, add a `ConnWriter` callback or store a reference map. Approach: add a `backchannelReplies *PendingCBReplies` field on a struct accessible from StateManager by connectionID. The simplest approach is a `cbReplies` map on StateManager keyed by connectionID (protected by connMu), populated when a connection is bound for back-channel.
    - Integrate sender stop into `destroySessionLocked` to prevent orphan goroutines.
    - Add WriteCallback method: StateManager needs a way for BackchannelSender to write bytes to a connection by ID. Add a `connWriters map[uint64]ConnWriter` on StateManager (or the adapter) where ConnWriter is `func(data []byte) error`. The NFS adapter registers this function when binding a connection.

    **IMPORTANT lock ordering:** sm.mu before connMu. The BackchannelSender must NOT hold any lock during network I/O. Sequence: acquire connMu.RLock to find connection and writer -> release connMu.RLock -> perform write (no lock held) -> wait for reply (no lock held).
  </action>
  <verify>
    `cd /Users/marmos91/Projects/dittofs && go build ./...` compiles successfully.
    `cd /Users/marmos91/Projects/dittofs && go vet ./...` passes.
    `cd /Users/marmos91/Projects/dittofs && go test ./internal/protocol/nfs/v4/state/... -race -count=1` passes.
    Verify callback.go still compiles and its existing tests pass (v4.0 path unchanged).
  </verify>
  <done>
    BackchannelSender can encode CB_SEQUENCE + CB_RECALL, frame as RPC, write to a back-bound connection, and await reply via XID routing.
    Shared wire-format helpers extracted and callback.go refactored to use them.
    Session has backchannel security params and sender reference.
    StateManager has methods to start/stop senders, find back-bound connections, and write to connections by ID.
  </done>
</task>

<task type="auto">
  <name>Task 2: Read-loop demux, callback routing, and BACKCHANNEL_CTL handler</name>
  <files>
    pkg/adapter/nfs/nfs_connection.go
    pkg/adapter/nfs/nfs_adapter.go
    internal/protocol/nfs/v4/state/delegation.go
    internal/protocol/nfs/v4/handlers/backchannel_ctl_handler.go
    internal/protocol/nfs/v4/handlers/handler.go
    internal/protocol/nfs/v4/state/manager.go
  </files>
  <action>
    **1. Read-loop demux in nfs_connection.go:**
    - Add `pendingCBReplies *state.PendingCBReplies` field to NFSConnection struct (nil by default, set when connection is bound for backchannel)
    - Modify `readRequest()` to demux incoming RPC messages:
      After reading the fragment into `message` but BEFORE calling `rpc.ReadCall(message)`:
      - Parse the first 8 bytes: XID (bytes 0-3) and msg_type (bytes 4-7)
      - If msg_type == rpc.RPCReply (1): this is a backchannel response
        - Route to `c.pendingCBReplies.Deliver(xid, message)` if pendingCBReplies is non-nil
        - Return a sentinel error (e.g., `errBackchannelReply`) so Serve() loop can `continue` without treating it as a request error
        - Return the pooled buffer after delivering the reply bytes (copy the bytes for delivery since buffer is pooled)
      - If msg_type == rpc.RPCCall (0): proceed with existing `rpc.ReadCall(message)` path
    - In `Serve()` loop: after `readRequest` returns, check if error is `errBackchannelReply` and `continue` (don't log or return)
    - Add `SetPendingCBReplies(p *state.PendingCBReplies)` method on NFSConnection

    **2. ConnWriter registration in nfs_adapter.go:**
    - After a connection is bound (auto-bind on CREATE_SESSION or BIND_CONN_TO_SESSION), if direction includes back-channel:
      - Register a ConnWriter callback on StateManager that captures the NFSConnection reference
      - The ConnWriter acquires `c.writeMu` before writing to `c.conn` (same mutex used for fore-channel replies, preventing interleaving per locked decision)
      - Set `c.pendingCBReplies` to a new PendingCBReplies instance (or the session's shared one)
    - On disconnect cleanup (in deferred close handler): unregister ConnWriter and clean up PendingCBReplies

    **3. Callback routing in delegation.go:**
    - Modify `sendRecall(deleg *DelegationState)`:
      - Before the existing v4.0 dial-out path, check if the delegation owner is a v4.1 client:
        - Call `sm.getBackchannelSender(deleg.ClientID)`
        - If sender != nil (v4.1 client with backchannel):
          - Encode CB_RECALL op using `EncodeCBRecallOp`
          - Create `CallbackRequest{OpCode: types.OP_CB_RECALL, Payload: recallOp, ResultCh: make(chan error, 1)}`
          - Call `sender.Enqueue(req)`
          - If enqueue fails (queue full), fall through to revocation
          - Otherwise, wait on ResultCh with timeout. On error, start short revocation timer.
          - On success, start normal lease-duration revocation timer (same as v4.0 success path)
          - Return (skip v4.0 path)
      - If sender is nil, continue with existing v4.0 dial-out path unchanged
    - Tag clients as v4.0 or v4.1 at registration time (per locked decision). The v4.1 clients are already in `v41ClientsByID`; v4.0 clients are in `clientsByID`. The routing check is: if `sm.v41ClientsByID[deleg.ClientID]` exists, it's a v4.1 client.

    **4. BACKCHANNEL_CTL handler:**
    - Create `backchannel_ctl_handler.go` in handlers package
    - Handler signature: `func (h *Handler) handleBackchannelCtl(ctx *types.CompoundContext, v41ctx *types.V41RequestContext, reader io.Reader) *types.CompoundResult`
    - Logic:
      1. Decode `types.BackchannelCtlArgs` from reader
      2. Validate session has backchannel: `v41ctx.Session.BackChannelSlots != nil`, else return NFS4ERR_INVAL
      3. Validate at least one acceptable security flavor from args.SecParms (use `HasAcceptableCallbackSecurity` from state package)
      4. Call `h.StateManager.UpdateBackchannelParams(v41ctx.Session.SessionID, args.CbProgram, args.SecParms)`
      5. Encode success `types.BackchannelCtlRes{Status: types.NFS4_OK}`
      6. Log at INFO level
    - BACKCHANNEL_CTL requires SEQUENCE (non-exempt per RFC 8881, per discretion), so no changes needed to isSessionExemptOp

    **5. Wire handler into dispatch table:**
    - In `handler.go` NewHandler(): replace the BACKCHANNEL_CTL stub with `h.handleBackchannelCtl`

    **6. Update GetStatusFlags:**
    - In manager.go `GetStatusFlags()`: update the CB_PATH_DOWN / BACKCHANNEL_FAULT logic:
      - CB_PATH_DOWN: clear when at least one back-bound connection exists for any session of this client (per discretion recommendation)
      - BACKCHANNEL_FAULT: set only when a callback send actually fails (add a `backchannelFault` bool per-client or per-session, set on send failure, cleared on successful send)
      - This replaces the current "set if BackChannelSlots == nil" check which was a Phase 20 placeholder
  </action>
  <verify>
    `cd /Users/marmos91/Projects/dittofs && go build ./...` compiles successfully.
    `cd /Users/marmos91/Projects/dittofs && go vet ./...` passes.
    `cd /Users/marmos91/Projects/dittofs && go test ./internal/protocol/nfs/v4/... -race -count=1` passes.
    `cd /Users/marmos91/Projects/dittofs && go test ./pkg/adapter/nfs/... -race -count=1` passes.
    Verify BACKCHANNEL_CTL stub test in compound_test.go still passes (or update it to test the real handler).
  </verify>
  <done>
    Read loop demuxes CALL vs REPLY messages on shared TCP connections.
    Delegation recall routes to BackchannelSender for v4.1 clients, falls back to dial-out for v4.0.
    BACKCHANNEL_CTL handler validates and stores session callback parameters.
    GetStatusFlags correctly reports CB_PATH_DOWN/BACKCHANNEL_FAULT based on actual backchannel health.
    ConnWriter registered on back-bound connections, using existing writeMu to prevent interleaving.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` -- full codebase compiles
2. `go vet ./...` -- no static analysis issues
3. `go test ./internal/protocol/nfs/v4/state/... -race -count=1` -- state layer tests pass with race detection
4. `go test ./internal/protocol/nfs/v4/handlers/... -race -count=1` -- handler tests pass with race detection
5. `go test ./pkg/adapter/nfs/... -race -count=1` -- adapter tests pass
6. `go test ./... -race -count=1 2>&1 | tail -5` -- full test suite passes
</verification>

<success_criteria>
- BackchannelSender sends CB_SEQUENCE + CB_RECALL over back-bound connections (no dial-out for v4.1)
- Read-loop demux distinguishes fore-channel CALL from backchannel REPLY on shared TCP
- Callback routing: v4.1 clients use BackchannelSender, v4.0 clients use existing SendCBRecall
- BACKCHANNEL_CTL handler replaces stub, validates session backchannel, stores security params
- Shared wire-format helpers extracted from callback.go and used by both v4.0 and v4.1 paths
- GetStatusFlags reports accurate CB_PATH_DOWN / BACKCHANNEL_FAULT based on backchannel health
- No orphan goroutines: sender lifecycle tied to session destruction
- Write serialization: backchannel writes use same writeMu as fore-channel replies
- All existing tests continue passing (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/22-backchannel-multiplexing/22-01-SUMMARY.md`
</output>
