---
phase: 24-directory-delegations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/protocol/nfs/v4/state/delegation.go
  - internal/protocol/nfs/v4/state/dir_delegation.go
  - internal/protocol/nfs/v4/state/dir_delegation_test.go
  - internal/protocol/nfs/v4/state/manager.go
  - internal/protocol/nfs/v4/state/callback_common.go
  - internal/protocol/nfs/v4/types/cb_notify.go
  - internal/protocol/nfs/v4/types/constants.go
  - pkg/controlplane/models/adapter_settings.go
autonomous: true
requirements: [DDELEG-03]

must_haves:
  truths:
    - "DelegationState can represent both file and directory delegations with IsDirectory flag"
    - "Directory delegations track a notification bitmask and pending notifications"
    - "NotifyDirChange appends to pending notifications and manages batch timers"
    - "Batch timer flush sends accumulated notifications to BackchannelSender"
    - "Lock ordering (sm.mu before NotifMu) prevents deadlocks"
    - "DESTROY_CLIENTID auto-revokes all directory delegations for that client"
  artifacts:
    - path: "internal/protocol/nfs/v4/state/delegation.go"
      provides: "Extended DelegationState with IsDirectory, NotificationMask, PendingNotifs, BatchTimer, RecallReason"
      contains: "IsDirectory"
    - path: "internal/protocol/nfs/v4/state/dir_delegation.go"
      provides: "GrantDirDelegation, NotifyDirChange, flushDirNotifications, resetBatchTimer, DirNotification type"
      min_lines: 150
    - path: "internal/protocol/nfs/v4/state/dir_delegation_test.go"
      provides: "Tests for directory delegation grant, notification batching, flush, recall, revocation"
      min_lines: 200
    - path: "internal/protocol/nfs/v4/types/cb_notify.go"
      provides: "NotifyAdd4, NotifyRemove4, NotifyRename4, NotifyAttrChange4 sub-type encoders"
      contains: "NotifyAdd4"
    - path: "internal/protocol/nfs/v4/state/callback_common.go"
      provides: "EncodeCBNotifyOp helper for building CB_NOTIFY wire format"
      contains: "EncodeCBNotifyOp"
    - path: "pkg/controlplane/models/adapter_settings.go"
      provides: "MaxDelegations and DirDelegBatchWindowMs config fields"
      contains: "MaxDelegations"
  key_links:
    - from: "internal/protocol/nfs/v4/state/dir_delegation.go"
      to: "internal/protocol/nfs/v4/state/callback_common.go"
      via: "EncodeCBNotifyOp call in flushDirNotifications"
      pattern: "EncodeCBNotifyOp"
    - from: "internal/protocol/nfs/v4/state/dir_delegation.go"
      to: "internal/protocol/nfs/v4/state/backchannel.go"
      via: "BackchannelSender.Enqueue in flushDirNotifications"
      pattern: "Enqueue"
    - from: "internal/protocol/nfs/v4/state/dir_delegation.go"
      to: "internal/protocol/nfs/v4/state/delegation.go"
      via: "DelegationState.IsDirectory and PendingNotifs fields"
      pattern: "IsDirectory"
---

<objective>
Extend DelegationState with directory delegation fields, implement notification batching in StateManager, add CB_NOTIFY sub-type encoders, and add config fields for delegation limits and batch window.

Purpose: Provides the state model foundation that both the GET_DIR_DELEGATION handler (Plan 02) and CB_NOTIFY delivery hooks (Plan 03) depend on. Without this, directory delegations cannot be tracked or notifications batched.

Output: Extended DelegationState, DirNotification type, GrantDirDelegation/NotifyDirChange/flushDirNotifications methods, CB_NOTIFY sub-type encoders, EncodeCBNotifyOp wire-format helper, config fields, comprehensive tests.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-directory-delegations/24-CONTEXT.md
@.planning/phases/24-directory-delegations/24-RESEARCH.md
@internal/protocol/nfs/v4/state/delegation.go
@internal/protocol/nfs/v4/state/manager.go
@internal/protocol/nfs/v4/state/callback_common.go
@internal/protocol/nfs/v4/state/backchannel.go
@internal/protocol/nfs/v4/types/cb_notify.go
@internal/protocol/nfs/v4/types/constants.go
@pkg/controlplane/models/adapter_settings.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend DelegationState, add notification types, CB_NOTIFY encoders, and config fields</name>
  <files>
    internal/protocol/nfs/v4/state/delegation.go
    internal/protocol/nfs/v4/types/cb_notify.go
    internal/protocol/nfs/v4/types/constants.go
    internal/protocol/nfs/v4/state/callback_common.go
    pkg/controlplane/models/adapter_settings.go
  </files>
  <action>
**1. Extend DelegationState in delegation.go** with directory-specific fields:
```go
// Directory delegation fields (zero values for file delegations)
IsDirectory      bool           // true for directory delegations
NotificationMask uint32         // NOTIFY4_* bitmask from GET_DIR_DELEGATION
CookieVerf       [8]byte        // cookie verifier for directory delegation
PendingNotifs    []DirNotification // batched notifications awaiting flush
NotifMu          sync.Mutex     // protects PendingNotifs (separate from sm.mu)
BatchTimer       *time.Timer    // notification batch flush timer
RecallReason     string         // "conflict", "resource_pressure", "admin", "directory_deleted" for metrics/logging
```

Add `DirNotification` type in delegation.go:
```go
type DirNotification struct {
    Type       uint32  // NOTIFY4_ADD_ENTRY, NOTIFY4_REMOVE_ENTRY, etc.
    EntryName  string  // name of affected entry
    Cookie     uint64  // readdir cookie for the entry
    Attrs      []byte  // pre-encoded fattr4 (optional, for attr change notifications)
    NewName    string  // for RENAME: new name (EntryName is old name)
    NewDirFH   []byte  // for cross-dir RENAME: destination dir handle
}
```

**2. Add CB_NOTIFY sub-type structs in types/cb_notify.go:**

Add NotifyAdd4, NotifyRemove4, NotifyRename4, NotifyAttrChange4 structs with Encode methods. These produce the inner opaque data for each notification type within the notify4 structure. Follow RFC 8881 Section 20.4:

- `NotifyAdd4`: EntryName (component4), Cookie (nfs_cookie4), Attrs (raw fattr4 bytes), optional prev entry info (HasPrev, PrevName, PrevCookie)
- `NotifyRemove4`: EntryName (component4), Cookie (nfs_cookie4)
- `NotifyRename4`: OldEntryName (component4), NewEntryName (component4) -- single RENAME event per user decision
- `NotifyAttrChange4`: EntryName (component4), Attrs (raw fattr4 bytes), Cookie (nfs_cookie4)

Each struct needs an `Encode(buf *bytes.Buffer) error` method that writes XDR-encoded content.

**3. Add EncodeCBNotifyOp in callback_common.go:**

Follow the exact pattern of EncodeCBRecallOp. Create `EncodeCBNotifyOp(stateid *types.Stateid4, dirFH []byte, notifs []DirNotification, mask uint32) []byte` that:
- Writes OP_CB_NOTIFY (6) as argop
- Encodes stateid4
- Encodes nfs_fh4 (dirFH)
- Groups notifications by type, encodes as notify4 array (each notify4 has Mask bitmap + Values array of opaque entries)
- Uses the existing NotifyEntry4 and Notify4 types from cb_notify.go for the outer structure

**4. Add config fields to NFSAdapterSettings in adapter_settings.go:**

Add two new fields to the NFSAdapterSettings struct (after the DelegationsEnabled field):
```go
MaxDelegations       int `gorm:"default:10000" json:"max_delegations"`         // max total outstanding delegations (file + directory combined)
DirDelegBatchWindowMs int `gorm:"default:50" json:"dir_deleg_batch_window_ms"` // notification batching window in milliseconds
```

Update `DefaultNFSAdapterSettings()` to set MaxDelegations=10000 and DirDelegBatchWindowMs=50.

**5. Ensure existing NOTIFY4_* constants are complete** (already defined in constants.go: NOTIFY4_CHANGE_CHILD_ATTRS=0, NOTIFY4_CHANGE_DIR_ATTRS=1, NOTIFY4_REMOVE_ENTRY=2, NOTIFY4_ADD_ENTRY=3, NOTIFY4_RENAME_ENTRY=4, NOTIFY4_CHANGE_COOKIE_VERIFIER=5). No changes needed if all present.
  </action>
  <verify>
```bash
cd /Users/marmos91/Projects/dittofs && go build ./internal/protocol/nfs/v4/... && go build ./pkg/controlplane/models/... && go vet ./internal/protocol/nfs/v4/... ./pkg/controlplane/models/...
```
  </verify>
  <done>DelegationState has directory-specific fields, DirNotification type exists, CB_NOTIFY sub-type encoders produce correct XDR, EncodeCBNotifyOp builds wire-format payloads, config has MaxDelegations and DirDelegBatchWindowMs fields with defaults.</done>
</task>

<task type="auto">
  <name>Task 2: Implement GrantDirDelegation, NotifyDirChange, batching logic, and tests</name>
  <files>
    internal/protocol/nfs/v4/state/dir_delegation.go
    internal/protocol/nfs/v4/state/dir_delegation_test.go
    internal/protocol/nfs/v4/state/manager.go
  </files>
  <action>
**1. Create dir_delegation.go** with the following methods on StateManager:

**GrantDirDelegation(clientID uint64, dirFH []byte, notifMask uint32) (*DelegationState, error)**:
- Acquire sm.mu write lock
- Check delegationsEnabled (if false, return nil, specific error)
- Check client has valid lease (if not, return NFS4ERR_EXPIRED)
- Check total delegation count (delegByOther map length) against maxDelegations limit. If exceeded, return nil with a "limit exceeded" indicator (caller returns GDD4_UNAVAIL). Per user decision: refuse, do NOT recall LRU.
- Check no existing directory delegation for same client+handle combo (prevent double-grant)
- Generate stateid using sm.generateStateidOther(StateTypeDeleg) -- same type byte 0x03 as file delegations
- Create DelegationState with IsDirectory=true, NotificationMask=notifMask, CookieVerf (generate random 8 bytes)
- Add to delegByOther and delegByFile maps (same as file delegations)
- Return the DelegationState

**NotifyDirChange(dirFH []byte, notif DirNotification)**:
- Acquire sm.mu RLock to read delegByFile
- Get all delegations for the file handle
- Release sm.mu RLock
- For each delegation that is IsDirectory, not Revoked, not RecallSent:
  - Check if client subscribed to this notification type via `deleg.NotificationMask & (1 << notif.Type) != 0`
  - Acquire deleg.NotifMu
  - Append notif to deleg.PendingNotifs
  - Call sm.resetBatchTimer(deleg) to start/reset the batch timer
  - If len(deleg.PendingNotifs) >= maxBatchSize (100), trigger immediate flush
  - Release deleg.NotifMu
- Must be non-blocking (do NOT hold sm.mu during BackchannelSender calls)

**flushDirNotifications(deleg *DelegationState)**:
- Acquire deleg.NotifMu
- Swap PendingNotifs with nil (drain pattern)
- Release deleg.NotifMu
- If no notifications, return
- Encode using EncodeCBNotifyOp from callback_common.go
- Get BackchannelSender via sm.getBackchannelSender(deleg.ClientID)
- If sender exists, create CallbackRequest{OpCode: OP_CB_NOTIFY, Payload: encoded} and Enqueue
- If no sender available, log warning (notifications lost, but per discretion: CB_NOTIFY failure does not immediately revoke)

**resetBatchTimer(deleg *DelegationState)** (called with NotifMu held):
- If deleg.BatchTimer == nil, create new timer with sm.dirDelegBatchWindow duration, on expiry call flushDirNotifications(deleg)
- If timer exists and is running, do nothing (let it expire naturally -- notifications accumulate)
- Use time.AfterFunc pattern

**RecallDirDelegation(deleg *DelegationState, reason string)**:
- Set deleg.RecallReason = reason
- Flush any pending notifications before sending recall (per user decision)
- Reuse existing sendRecall pattern (sendRecallV41 or sendRecallV40 based on client version)
- Set RecallSent=true, start RecallTimer for revocation after lease timeout
- For reason="directory_deleted": revoke immediately (no recall, per discretion)

**2. Update manager.go:**
- Add `maxDelegations int` and `dirDelegBatchWindow time.Duration` fields to StateManager
- Add `SetMaxDelegations(n int)` and `SetDirDelegBatchWindow(d time.Duration)` methods
- In existing `purgeV41Client` (or equivalent client cleanup path), ensure directory delegations are cleaned up: stop batch timers, clear pending notifications before removing from maps
- Add `maxBatchSize` constant (100) to dir_delegation.go

**3. Create dir_delegation_test.go** with comprehensive tests:
- TestGrantDirDelegation: basic grant, verify IsDirectory=true, NotificationMask set, stateid valid
- TestGrantDirDelegation_DelegationsDisabled: verify refused when delegations disabled
- TestGrantDirDelegation_LimitExceeded: verify refused when maxDelegations reached
- TestGrantDirDelegation_DoubleGrant: verify same client+handle rejected
- TestGrantDirDelegation_ExpiredLease: verify refused when lease expired
- TestNotifyDirChange_Basic: grant delegation, send notification, verify PendingNotifs populated
- TestNotifyDirChange_FilterByMask: verify notifications only for subscribed types
- TestNotifyDirChange_RecalledSkipped: verify recalled/revoked delegations skipped
- TestNotifyDirChange_BatchFlush: verify flush sends CB_NOTIFY via BackchannelSender (mock or verify queue)
- TestNotifyDirChange_CountFlush: verify immediate flush when batch count exceeds 100
- TestRecallDirDelegation_FlushBeforeRecall: verify pending notifications flushed before recall sent
- TestRecallDirDelegation_DirectoryDeleted: verify immediate revocation for deleted directory
- TestDirDelegation_ClientCleanup: verify DESTROY_CLIENTID cleans up directory delegations (stop timers, clear pending)
- TestDirDelegation_Concurrent: concurrent NotifyDirChange calls with race detection

All tests with `-race` flag.
  </action>
  <verify>
```bash
cd /Users/marmos91/Projects/dittofs && go test -race -count=1 ./internal/protocol/nfs/v4/state/... -run "DirDeleg|NotifyDir" -v
```
  </verify>
  <done>GrantDirDelegation creates directory delegations with limit checking, NotifyDirChange batches notifications with per-delegation timers and sends via BackchannelSender on flush, recall flushes pending notifications first, client cleanup stops timers, all tests pass with -race.</done>
</task>

</tasks>

<verification>
- `go build ./...` compiles without errors
- `go test -race ./internal/protocol/nfs/v4/state/...` passes (existing + new tests)
- `go test -race ./internal/protocol/nfs/v4/types/...` passes (existing + new CB_NOTIFY encoder tests)
- `go vet ./...` passes
- DelegationState struct has IsDirectory, NotificationMask, PendingNotifs, NotifMu, BatchTimer, RecallReason fields
- DirNotification type exists with Type, EntryName, Cookie, Attrs, NewName, NewDirFH fields
- EncodeCBNotifyOp produces valid XDR bytes
- GrantDirDelegation, NotifyDirChange, flushDirNotifications, RecallDirDelegation methods exist on StateManager
- NFSAdapterSettings has MaxDelegations and DirDelegBatchWindowMs fields
</verification>

<success_criteria>
- Directory delegation state model fully established
- Notification batching with time + count flush triggers works correctly
- CB_NOTIFY sub-type encoders produce valid XDR for ADD, REMOVE, RENAME, ATTR_CHANGE
- Config fields for max delegations and batch window exist with sensible defaults
- No deadlocks (lock ordering: sm.mu before NotifMu)
- All tests pass with race detection
</success_criteria>

<output>
After completion, create `.planning/phases/24-directory-delegations/24-01-SUMMARY.md`
</output>
