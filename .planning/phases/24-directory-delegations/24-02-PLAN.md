---
phase: 24-directory-delegations
plan: 02
type: execute
wave: 2
depends_on: [24-01]
files_modified:
  - internal/protocol/nfs/v4/handlers/get_dir_delegation_handler.go
  - internal/protocol/nfs/v4/handlers/get_dir_delegation_handler_test.go
  - internal/protocol/nfs/v4/handlers/handler.go
  - internal/protocol/nfs/v4/handlers/delegreturn.go
  - internal/protocol/nfs/v4/state/delegation.go
  - pkg/adapter/nfs/nfs_adapter_settings.go
  - pkg/controlplane/store/adapter_settings.go
  - internal/controlplane/api/handlers/adapter_settings.go
  - pkg/apiclient/adapter_settings.go
  - cmd/dfsctl/commands/adapter/settings.go
autonomous: true
requirements: [DDELEG-01, DDELEG-03]

must_haves:
  truths:
    - "GET_DIR_DELEGATION grants a directory delegation with notification bitmask to clients with valid lease"
    - "GET_DIR_DELEGATION returns GDD4_UNAVAIL when delegation limit reached or delegations disabled"
    - "GET_DIR_DELEGATION returns GDD4_OK with stateid, cookie verifier, and notification types on success"
    - "DELEGRETURN for directory delegations flushes pending notifications before acknowledging"
    - "MaxDelegations and DirDelegBatchWindowMs are configurable via adapter settings API and CLI"
    - "Settings watcher propagates MaxDelegations and batch window to StateManager at runtime"
  artifacts:
    - path: "internal/protocol/nfs/v4/handlers/get_dir_delegation_handler.go"
      provides: "handleGetDirDelegation V41OpHandler implementation"
      min_lines: 60
    - path: "internal/protocol/nfs/v4/handlers/get_dir_delegation_handler_test.go"
      provides: "Tests for GET_DIR_DELEGATION handler (grant success, unavail, no FH, bad session)"
      min_lines: 100
    - path: "internal/protocol/nfs/v4/handlers/handler.go"
      provides: "OP_GET_DIR_DELEGATION registered with real handler in v41DispatchTable"
      contains: "handleGetDirDelegation"
  key_links:
    - from: "internal/protocol/nfs/v4/handlers/get_dir_delegation_handler.go"
      to: "internal/protocol/nfs/v4/state/dir_delegation.go"
      via: "StateManager.GrantDirDelegation call"
      pattern: "GrantDirDelegation"
    - from: "internal/protocol/nfs/v4/handlers/handler.go"
      to: "internal/protocol/nfs/v4/handlers/get_dir_delegation_handler.go"
      via: "v41DispatchTable registration replacing stub"
      pattern: "OP_GET_DIR_DELEGATION.*handleGetDirDelegation"
    - from: "internal/protocol/nfs/v4/handlers/delegreturn.go"
      to: "internal/protocol/nfs/v4/state/dir_delegation.go"
      via: "flushDirNotifications before ReturnDelegation for directory delegations"
      pattern: "IsDirectory"
    - from: "pkg/adapter/nfs/nfs_adapter_settings.go"
      to: "internal/protocol/nfs/v4/state/dir_delegation.go"
      via: "SetMaxDelegations and SetDirDelegBatchWindow calls"
      pattern: "SetMaxDelegations|SetDirDelegBatchWindow"
---

<objective>
Implement the GET_DIR_DELEGATION handler, update DELEGRETURN to flush directory notifications before acknowledgment, wire config settings through the full stack (model -> store -> API -> apiclient -> CLI -> settings watcher), and replace the stub dispatch entry with the real handler.

Purpose: Clients can request directory delegations via GET_DIR_DELEGATION and return them via DELEGRETURN. Server operators can configure max delegation limits and batch window via API/CLI.

Output: Working GET_DIR_DELEGATION handler, DELEGRETURN directory flush, config full stack for MaxDelegations and DirDelegBatchWindowMs, handler tests.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-directory-delegations/24-CONTEXT.md
@.planning/phases/24-directory-delegations/24-RESEARCH.md
@.planning/phases/24-directory-delegations/24-01-SUMMARY.md
@internal/protocol/nfs/v4/handlers/handler.go
@internal/protocol/nfs/v4/handlers/delegreturn.go
@internal/protocol/nfs/v4/state/delegation.go
@internal/protocol/nfs/v4/state/dir_delegation.go
@internal/protocol/nfs/v4/types/get_dir_delegation.go
@pkg/adapter/nfs/nfs_adapter_settings.go
@pkg/controlplane/models/adapter_settings.go
@pkg/controlplane/store/adapter_settings.go
@internal/controlplane/api/handlers/adapter_settings.go
@pkg/apiclient/adapter_settings.go
@cmd/dfsctl/commands/adapter/settings.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: GET_DIR_DELEGATION handler, DELEGRETURN flush, and dispatch registration</name>
  <files>
    internal/protocol/nfs/v4/handlers/get_dir_delegation_handler.go
    internal/protocol/nfs/v4/handlers/get_dir_delegation_handler_test.go
    internal/protocol/nfs/v4/handlers/handler.go
    internal/protocol/nfs/v4/handlers/delegreturn.go
    internal/protocol/nfs/v4/state/delegation.go
  </files>
  <action>
**1. Create get_dir_delegation_handler.go:**

Implement `handleGetDirDelegation` as a V41OpHandler (same signature as handleFreeStateid/handleTestStateid from Phase 23). The handler:

a. Requires current filehandle via `types.RequireCurrentFH(ctx)` -- return NFS4ERR_NOFILEHANDLE if missing
b. Decodes `types.GetDirDelegationArgs` from reader (already has Decode method from Phase 16)
c. Gets session from `h.StateManager.GetSession(v41ctx.SessionID)` -- return NFS4ERR_BADSESSION if nil
d. Validates the current FH is a directory by checking metadata (call `h.MetadataService.GetAttr(ctx.CurrentFH)` or equivalent to check file type). Return NFS4ERR_NOTDIR if not a directory. If metadata lookup not available in handler context, skip this check (the StateManager grant method is the authority).
e. Extracts notification types from args.NotificationTypes bitmap -- convert to uint32 bitmask
f. Calls `h.StateManager.GrantDirDelegation(session.ClientID, ctx.CurrentFH, notifMask)`
g. On success: encode `GetDirDelegationRes` with Status=NFS4_OK, NonFatalStatus=GDD4_OK, OK containing the delegation's CookieVerf, Stateid, and the granted NotificationTypes
h. On limit exceeded or disabled: encode `GetDirDelegationRes` with Status=NFS4_OK, NonFatalStatus=GDD4_UNAVAIL, WillSignalDelegAvail=false (per user decision: do not signal, no proactive offering)
i. On expired lease: encode with Status=NFS4ERR_EXPIRED
j. Log at Debug level for grants and refusals

**2. Update handler.go dispatch table:**

Replace the existing v41StubHandler for OP_GET_DIR_DELEGATION with the real handler:
```go
h.v41DispatchTable[types.OP_GET_DIR_DELEGATION] = h.handleGetDirDelegation
```

Remove the old stub entry.

**3. Update delegreturn.go for directory delegation flush:**

In the existing DELEGRETURN handler (or in the ReturnDelegation StateManager method called by it), add a check before returning the delegation:

- If the delegation being returned has IsDirectory=true, call `sm.flushDirNotifications(deleg)` synchronously before removing it from state maps
- This ensures the client gets all pending notifications before the delegation is fully returned (per locked decision: "Flush any batched notifications before acknowledging DELEGRETURN")
- The flush call should also stop the batch timer if running

If ReturnDelegation is the right place (in delegation.go), modify it to check `deleg.IsDirectory` and flush before cleanup. Add a helper `stopBatchTimer(deleg)` that stops and nils the timer.

**4. Create get_dir_delegation_handler_test.go:**

Follow the pattern of free_stateid_handler_test.go and test_stateid_handler_test.go from Phase 23. Tests:

- TestGetDirDelegation_Success: Valid session, directory FH, notification mask -> GDD4_OK response with valid stateid
- TestGetDirDelegation_Unavail_LimitReached: MaxDelegations=0, verify GDD4_UNAVAIL response
- TestGetDirDelegation_Unavail_Disabled: DelegationsEnabled=false, verify GDD4_UNAVAIL response
- TestGetDirDelegation_NoFilehandle: No current FH set, verify NFS4ERR_NOFILEHANDLE
- TestGetDirDelegation_BadSession: Invalid session ID, verify NFS4ERR_BADSESSION
- TestGetDirDelegation_ExpiredLease: Expired client lease, verify NFS4ERR_EXPIRED
- TestDelegReturn_FlushesDirectoryNotifications: Grant dir deleg, add pending notifications, DELEGRETURN, verify notifications were flushed before return

All tests with -race.
  </action>
  <verify>
```bash
cd /Users/marmos91/Projects/dittofs && go test -race -count=1 ./internal/protocol/nfs/v4/handlers/... -run "GetDirDelegation|DelegReturn.*Flush" -v
```
  </verify>
  <done>GET_DIR_DELEGATION handler grants directory delegations with GDD4_OK/GDD4_UNAVAIL responses, DELEGRETURN flushes pending notifications for directory delegations, dispatch table uses real handler, all tests pass with -race.</done>
</task>

<task type="auto">
  <name>Task 2: Config full stack for MaxDelegations and DirDelegBatchWindowMs</name>
  <files>
    pkg/controlplane/store/adapter_settings.go
    internal/controlplane/api/handlers/adapter_settings.go
    pkg/apiclient/adapter_settings.go
    cmd/dfsctl/commands/adapter/settings.go
    pkg/adapter/nfs/nfs_adapter_settings.go
  </files>
  <action>
**1. Update adapter_settings.go (store layer):**

Add `max_delegations` and `dir_deleg_batch_window_ms` to the settings column map in both `SaveNFSAdapterSettings` and `GetNFSAdapterSettings` (follow the exact pattern of existing fields like `delegations_enabled`). Also add to defaults map.

**2. Update adapter_settings.go (API handlers):**

Add fields to the three API types:
- `AdapterSettingsPutRequest`: `MaxDelegations int`, `DirDelegBatchWindowMs int`
- `AdapterSettingsPatchRequest`: `MaxDelegations *int`, `DirDelegBatchWindowMs *int`
- `AdapterSettingsResponse`: `MaxDelegations int`, `DirDelegBatchWindowMs int`

Wire into PUT handler (direct assignment), PATCH handler (nil-check before assignment), and response builder (toAdapterSettingsResponse).

Add to the per-field reset handler for DELETE individual setting.

**3. Update adapter_settings.go (apiclient):**

Add `MaxDelegations int` and `DirDelegBatchWindowMs int` to `AdapterSettingsResponse` struct.
Add `MaxDelegations *int` and `DirDelegBatchWindowMs *int` to `AdapterSettingsPatchRequest` struct.

**4. Update settings.go (CLI):**

Add `--max-delegations` and `--dir-deleg-batch-window-ms` flags to the settings patch command.
Add the fields to the settings display table (in the "NFSv4 Configuration" group or a new "Delegation Configuration" group).
Wire flag values into the patch request.

**5. Update nfs_adapter_settings.go (settings watcher):**

Add calls to `s.v4Handler.StateManager.SetMaxDelegations(settings.MaxDelegations)` and `s.v4Handler.StateManager.SetDirDelegBatchWindow(time.Duration(settings.DirDelegBatchWindowMs) * time.Millisecond)` in the settings application method, following the same pattern as `SetDelegationsEnabled`.

All changes follow existing patterns exactly -- no new abstractions needed.
  </action>
  <verify>
```bash
cd /Users/marmos91/Projects/dittofs && go build ./... && go vet ./... && go test -race -count=1 ./pkg/controlplane/store/... -run "AdapterSettings" -v
```
  </verify>
  <done>MaxDelegations and DirDelegBatchWindowMs flow through the full config stack: model defaults -> store persistence -> API PUT/PATCH/DELETE -> apiclient types -> CLI flags/display -> settings watcher propagation to StateManager at runtime.</done>
</task>

</tasks>

<verification>
- `go build ./...` compiles without errors
- `go test -race ./internal/protocol/nfs/v4/handlers/...` passes (existing + new tests)
- `go vet ./...` passes
- GET_DIR_DELEGATION handler registered in v41DispatchTable (stub replaced)
- DELEGRETURN flushes directory delegation notifications before returning
- MaxDelegations and DirDelegBatchWindowMs visible in `dfsctl adapter settings show`
- Settings watcher propagates new config to StateManager
</verification>

<success_criteria>
- GET_DIR_DELEGATION grants directory delegations with correct GDD4_OK/GDD4_UNAVAIL responses
- DELEGRETURN directory flush ensures no pending notifications lost
- Config full stack works end-to-end (model -> store -> API -> CLI -> runtime)
- All handler tests pass with race detection
</success_criteria>

<output>
After completion, create `.planning/phases/24-directory-delegations/24-02-SUMMARY.md`
</output>
