---
phase: 15-v2-0-testing
plan: 02
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - test/e2e/nfsv4_locking_test.go
  - test/e2e/nfsv4_delegation_test.go
  - test/e2e/framework/lock_helpers.go
autonomous: true
requirements:
  - TEST2-02
  - TEST2-03

must_haves:
  truths:
    - "NFSv4 byte-range locks acquired and released via fcntl on v4 mount"
    - "Read/write lock conflicts detected between two clients on v4 mount"
    - "Lock upgrade (shared to exclusive) works via v4 mount"
    - "Delegation grant observable via server metrics or log output when client has exclusive access on v4 mount"
    - "Delegation recalled when second client opens same file on v4 mount, confirmed by data consistency AND server log/metric indicating recall"
    - "Data written under write delegation is visible after recall completes"
  artifacts:
    - path: "test/e2e/nfsv4_locking_test.go"
      provides: "NFSv4 locking E2E tests"
      contains: "TestNFSv4Locking"
    - path: "test/e2e/nfsv4_delegation_test.go"
      provides: "NFSv4 delegation E2E tests"
      contains: "TestNFSv4Delegations"
    - path: "test/e2e/framework/lock_helpers.go"
      provides: "Lock helper functions (already exists, may need NFSv4-specific additions)"
      contains: "LockFile"
  key_links:
    - from: "test/e2e/nfsv4_locking_test.go"
      to: "test/e2e/framework/mount.go"
      via: "MountNFSWithVersion for v4 mounts"
      pattern: "framework\\.MountNFSWithVersion"
    - from: "test/e2e/nfsv4_locking_test.go"
      to: "test/e2e/framework/lock_helpers.go"
      via: "LockFile, TryLockFile, LockFileRange helpers"
      pattern: "framework\\.LockFile"
    - from: "test/e2e/nfsv4_delegation_test.go"
      to: "test/e2e/helpers/server.go"
      via: "Server log/metrics scraping for delegation grant/recall evidence"
      pattern: "helpers\\."
---

<objective>
Implement E2E tests for NFSv4 byte-range locking and delegation lifecycle.

Purpose: Validates that NFSv4 locking (LOCK/LOCKT/LOCKU) and delegations (grant/recall/revoke) work correctly through actual NFS kernel client mounts, not just unit tests. Delegation tests include observable evidence of grant/recall at the server level (not just data consistency side effects).

Output: nfsv4_locking_test.go with full lock matrix tests, nfsv4_delegation_test.go with delegation lifecycle tests including server-observable grant/recall verification.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-v2-0-testing/15-CONTEXT.md
@.planning/phases/15-v2-0-testing/15-RESEARCH.md
@.planning/phases/15-v2-0-testing/15-01-SUMMARY.md
@test/e2e/framework/mount.go
@test/e2e/framework/lock_helpers.go
@test/e2e/cross_protocol_lock_test.go
@test/e2e/grace_period_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: NFSv4 locking E2E tests</name>
  <files>test/e2e/nfsv4_locking_test.go, test/e2e/framework/lock_helpers.go</files>
  <action>
Create test/e2e/nfsv4_locking_test.go with `//go:build e2e` tag, package `e2e`.

Each test starts its own server (per-test isolation pattern). Use memory/memory stores for protocol feature testing (per CONTEXT.md decision). Use `framework.SkipIfDarwin(t)` at the top of tests that need Linux NFSv4 locking. Tests run for both v3 and v4 where applicable using version-parameterized subtests.

First, check if test/e2e/framework/lock_helpers.go needs any additions for NFSv4 integrated locking:
- The existing file (already in codebase) provides LockFile, TryLockFile, LockFileRange, TryLockFileRange, UnlockFile, UnlockFileRange, WaitForLockRelease, WaitForRangeLockRelease, GetLockInfo, SkipIfNFSLockingUnsupported.
- These helpers use flock() and fcntl() which work for BOTH NFSv3 (NLM) and NFSv4 (integrated locking) through the kernel client.
- Add `SkipIfNFSv4LockingUnsupported(t *testing.T)` if needed (NFSv4 integrated locking should work on Linux without portmapper, unlike NLM).
- No other additions expected -- the existing helpers are sufficient for NFSv4 locking tests.

Implement:

1. `TestNFSv4Locking(t *testing.T)` -- starts server, creates share, enables NFS adapter, then runs subtests for both v3 and v4:

   a. `ReadWriteLocks`: Create file, acquire shared (read) lock via fcntl on one fd, verify second shared lock succeeds, verify exclusive lock on overlapping range fails (EAGAIN or EACCES).

   b. `ExclusiveLock`: Create file, acquire exclusive lock, verify second exclusive lock fails, release first, verify second now succeeds.

   c. `OverlappingRanges`: Create file, lock bytes 0-100 exclusive, lock bytes 200-300 exclusive (non-overlapping, should succeed), try lock bytes 50-250 (overlapping, should fail).

   d. `LockUpgrade`: Acquire shared lock, upgrade to exclusive (may depend on implementation -- if not supported via single fcntl, acquire exclusive on same range after releasing shared).

   e. `LockUnlock`: Acquire exclusive lock, write data, unlock, verify another process/fd can now lock.

   f. `CrossClientConflict`: Mount same share twice (two mount points), acquire exclusive lock via mount1, try same lock via mount2 -- should fail. Release via mount1, retry via mount2 -- should succeed.

2. `TestNFSv4BlockingLock(t *testing.T)` -- NFSv4 only (blocking lock semantics):
   - Acquire exclusive lock on file via mount1
   - Start goroutine that tries blocking lock via mount2 (F_SETLKW)
   - Release lock on mount1
   - Verify goroutine acquired lock within 5s timeout

Use existing framework.LockFile, framework.TryLockFile, framework.LockFileRange helpers from lock_helpers.go. Add framework.SkipIfNFSLockingUnsupported(t) check at test start.
  </action>
  <verify>
`go build -tags=e2e ./test/e2e/...` compiles.
`go vet -tags=e2e ./test/e2e/...` passes.
Verify lock_helpers.go exists and has the expected exports: `grep -c 'func Lock\|func TryLock\|func Unlock\|func WaitFor\|func GetLockInfo\|func SkipIfNFS' test/e2e/framework/lock_helpers.go`
  </verify>
  <done>
nfsv4_locking_test.go contains TestNFSv4Locking with 6 subtests (read/write locks, exclusive, overlapping ranges, upgrade, unlock, cross-client) parameterized by NFS version, plus TestNFSv4BlockingLock for v4-only blocking semantics. lock_helpers.go confirmed to exist with all required exports. All compile with -tags=e2e.
  </done>
</task>

<task type="auto">
  <name>Task 2: NFSv4 delegation E2E tests with observable grant/recall</name>
  <files>test/e2e/nfsv4_delegation_test.go</files>
  <action>
Create test/e2e/nfsv4_delegation_test.go with `//go:build e2e` tag, package `e2e`.

Delegation tests are NFSv4 ONLY (v3 has no delegations). Use `framework.SkipIfDarwin(t)` -- delegations require Linux kernel NFS client. Use memory/memory stores.

IMPORTANT -- Delegation observability (locked decision #7 -- "full delegation cycle"):
The kernel NFS client requests delegations implicitly during OPEN. Tests MUST verify not only data consistency but also that delegations were actually granted and recalled at the server level. Two approaches (use whichever is feasible):
  a. **Metrics approach (preferred)**: Enable Prometheus metrics on the test server. After the delegation grant/recall sequence, scrape the metrics endpoint for `dittofs_nfs_delegations_granted_total` and `dittofs_nfs_delegations_recalled_total` counters. Assert these counters incremented.
  b. **Log approach (fallback)**: Start server with DEBUG logging, capture server log output, grep for delegation grant/recall log lines (e.g., "delegation granted", "delegation recalled", "CB_RECALL sent"). Assert log lines are present.

If neither metrics nor log scraping is practical (e.g., delegation metrics not yet instrumented), document this explicitly in the test with a TODO comment referencing locked decision #7 and t.Log the limitation.

Implement:

1. `TestNFSv4DelegationBasicLifecycle(t *testing.T)`:
   - Start server with metrics enabled, create share, enable NFS, mount v4
   - Record initial delegation metric values (scrape /metrics or initialize to 0)
   - Open file, write data -- if delegation granted, writes are local until CLOSE/COMMIT
   - CLOSE file, reopen and read -- verify data persisted correctly
   - Scrape delegation metrics: assert `delegations_granted_total` > initial value
   - This tests the basic open/close lifecycle that involves delegations

2. `TestNFSv4DelegationRecall(t *testing.T)`:
   - Start server with metrics enabled, create share, enable NFS
   - Record initial delegation metrics
   - Mount1: open file exclusively, write data (may get delegation)
   - Mount2: open same file (triggers delegation recall if delegation was granted)
   - Verify mount2 can read the data written by mount1 (delegation return flushed data)
   - Scrape delegation metrics: assert `delegations_recalled_total` > initial value
   - This is the key multi-client data consistency + observable recall test

3. `TestNFSv4DelegationRevocation(t *testing.T)`:
   - Similar to recall test but with unresponsive first client scenario
   - Mount1: open file, write data
   - Mount1: hold file open (don't close)
   - Mount2: try to open same file -- should eventually succeed even if delegation recall times out (server revokes after timeout)
   - Verify data consistency

4. `TestNFSv4NoDelegationConflict(t *testing.T)`:
   - Two mounts, concurrent reads on same file -- no conflict, both succeed
   - This verifies read delegations don't block read access

For multi-client tests: create two separate mount points to the same share (same server). The Linux kernel NFS client uses different open-owners per mount point, which is sufficient for triggering delegation behavior.

Each test has a generous timeout (30s) since delegation recall involves async callbacks with configurable timeouts.
  </action>
  <verify>
`go build -tags=e2e ./test/e2e/...` compiles.
`go vet -tags=e2e ./test/e2e/...` passes.
  </verify>
  <done>
nfsv4_delegation_test.go contains 4 test functions covering delegation lifecycle (with metrics-based grant verification), recall via multi-client access (with metrics-based recall verification), revocation timeout, and concurrent read access. Delegation grant/recall is observable at the server level, not just inferred from data consistency. All compile with -tags=e2e. Tests use SkipIfDarwin for Linux-only execution.
  </done>
</task>

</tasks>

<verification>
- `go build -tags=e2e ./test/e2e/...` compiles successfully
- `go vet -tags=e2e ./test/e2e/...` passes
- Lock tests cover: read/write, exclusive, overlapping ranges, upgrade, unlock, cross-client, blocking
- Delegation tests cover: basic lifecycle with observable grant, recall with observable recall metric, revocation, concurrent reads
- lock_helpers.go exists with all required helpers (confirmed via verify step)
- All tests use memory/memory stores per CONTEXT.md decision
</verification>

<success_criteria>
- NFSv4 locking E2E tests validate lock/unlock cycles with multiple lock types and cross-client conflicts
- NFSv4 delegation tests verify data consistency AND observable delegation grant/recall at server level
- Tests compile and are parameterized correctly for v3/v4 (locking) or v4-only (delegations)
</success_criteria>

<output>
After completion, create `.planning/phases/15-v2-0-testing/15-02-SUMMARY.md`
</output>
