---
phase: 18-exchange-id-and-client-registration
plan: 02
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - internal/controlplane/api/handlers/clients.go
  - pkg/controlplane/api/router.go
  - internal/controlplane/api/handlers/health.go
  - pkg/apiclient/clients.go
  - cmd/dfsctl/commands/client/client.go
  - cmd/dfsctl/commands/client/list.go
  - cmd/dfsctl/commands/client/evict.go
  - cmd/dfsctl/commands/root.go
autonomous: true
requirements: [SESS-01, TRUNK-02]

must_haves:
  truths:
    - "GET /api/v1/clients returns list of both v4.0 and v4.1 clients with NFS version, address, lease status"
    - "DELETE /api/v1/clients/{id} evicts a client and returns 204"
    - "GET /health returns server_owner and implementation info in response data"
    - "dfsctl client list shows clients in table format with version column"
    - "dfsctl client evict <id> removes client with confirmation prompt"
  artifacts:
    - path: "internal/controlplane/api/handlers/clients.go"
      provides: "ClientHandler with List and Evict methods"
      min_lines: 60
    - path: "pkg/apiclient/clients.go"
      provides: "ListClients() and EvictClient() API client methods"
      min_lines: 30
    - path: "cmd/dfsctl/commands/client/client.go"
      provides: "client parent Cobra command"
      min_lines: 15
    - path: "cmd/dfsctl/commands/client/list.go"
      provides: "dfsctl client list command"
      min_lines: 40
    - path: "cmd/dfsctl/commands/client/evict.go"
      provides: "dfsctl client evict command"
      min_lines: 30
  key_links:
    - from: "internal/controlplane/api/handlers/clients.go"
      to: "internal/protocol/nfs/v4/state/manager.go"
      via: "stateManager.ListV41Clients() and ListV40Clients()"
      pattern: "ListV4[01]Clients"
    - from: "pkg/controlplane/api/router.go"
      to: "internal/controlplane/api/handlers/clients.go"
      via: "Route /clients with ClientHandler"
      pattern: "/clients"
    - from: "cmd/dfsctl/commands/client/list.go"
      to: "pkg/apiclient/clients.go"
      via: "client.ListClients()"
      pattern: "ListClients"
    - from: "cmd/dfsctl/commands/root.go"
      to: "cmd/dfsctl/commands/client/client.go"
      via: "rootCmd.AddCommand(clientcmd.Cmd)"
      pattern: "clientcmd"
---

<objective>
Add REST API endpoints for NFS client visibility (/clients list and evict, /health server info) and `dfsctl client` CLI commands so administrators can inspect connected NFS clients and evict misbehaving ones.

Purpose: Operational visibility into connected NFS clients (both v4.0 and v4.1) for debugging and administration. Server identity info on /health enables trunking verification (TRUNK-02).
Output: Working REST API client endpoints, apiclient methods, and dfsctl client commands.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-exchange-id-and-client-registration/18-CONTEXT.md
@.planning/phases/18-exchange-id-and-client-registration/18-RESEARCH.md
@.planning/phases/18-exchange-id-and-client-registration/18-01-SUMMARY.md

Key source files:
@pkg/controlplane/api/router.go (API route registration pattern)
@internal/controlplane/api/handlers/adapters.go (AdapterHandler pattern for REST handlers)
@internal/controlplane/api/handlers/health.go (HealthHandler pattern)
@internal/controlplane/api/handlers/problem.go (WriteJSON, WriteNoContent, BadRequest, NotFound helpers)
@internal/controlplane/api/handlers/helpers.go (decodeJSONBody)
@internal/controlplane/api/handlers/response.go (Response struct, healthyResponse)
@pkg/apiclient/adapters.go (API client method pattern)
@pkg/apiclient/client.go (apiclient.Client struct)
@cmd/dfsctl/commands/adapter/adapter.go (parent command pattern)
@cmd/dfsctl/commands/adapter/list.go (list command with TableRenderer pattern)
@cmd/dfsctl/commands/adapter/disable.go (action command pattern)
@cmd/dfsctl/commands/root.go (root command registration)
@cmd/dfsctl/cmdutil/util.go (GetAuthenticatedClient, PrintOutput, PrintResourceWithSuccess)
</context>

<tasks>

<task type="auto">
  <name>Task 1: REST API client endpoints and /health server info</name>
  <files>
    internal/controlplane/api/handlers/clients.go
    pkg/controlplane/api/router.go
    internal/controlplane/api/handlers/health.go
  </files>
  <action>
Create `internal/controlplane/api/handlers/clients.go` with ClientHandler:

1. **ClientHandler struct:**
   - Holds a reference to `*state.StateManager` (not Runtime, since StateManager owns client state directly)
   - Constructor: `NewClientHandler(sm *state.StateManager) *ClientHandler`

2. **ClientInfo response struct** (per locked decision -- rich fields):
   ```go
   type ClientInfo struct {
       ClientID    string    `json:"client_id"`       // hex-encoded uint64
       Address     string    `json:"address"`
       NFSVersion  string    `json:"nfs_version"`     // "4.0" or "4.1"
       ConnectedAt time.Time `json:"connected_at"`
       LastRenewal time.Time `json:"last_renewal"`
       LeaseStatus string    `json:"lease_status"`    // "active", "expired", "unknown"
       Confirmed   bool      `json:"confirmed"`
       ImplName    string    `json:"impl_name,omitempty"`   // v4.1 only
       ImplDomain  string    `json:"impl_domain,omitempty"` // v4.1 only
   }
   ```

3. **List method** (`GET /api/v1/clients`):
   - Call `sm.ListV40Clients()` and `sm.ListV41Clients()` (from Plan 01)
   - Convert v4.0 ClientRecord to ClientInfo with NFSVersion="4.0", LeaseStatus from lease state, ImplName/ImplDomain empty
   - Convert v4.1 V41ClientRecord to ClientInfo with NFSVersion="4.1", include ImplName/ImplDomain
   - Combine into single slice, encode with WriteJSONOK
   - ClientID formatted as hex: `fmt.Sprintf("%016x", record.ClientID)`
   - LeaseStatus logic: if Lease != nil && not expired -> "active", if expired -> "expired", else "unknown"

4. **Evict method** (`DELETE /api/v1/clients/{id}`):
   - Parse hex client ID from URL param: `chi.URLParam(r, "id")`, parse with `strconv.ParseUint(idStr, 16, 64)`
   - If parse error -> BadRequest("invalid client ID format, expected hex")
   - Try sm.EvictV41Client(clientID) first; if not found, try evicting v4.0 client
   - For v4.0 eviction: add `EvictV40Client(clientID uint64) error` method to StateManager (removes from clientsByID and clientsByName/unconfirmedByName maps, cleans up open state)
   - If neither found -> NotFound("client not found")
   - On success -> WriteNoContent

5. **Wire into router** (in `pkg/controlplane/api/router.go`):
   - The router needs access to StateManager. Since the router receives Runtime, and Runtime doesn't currently expose StateManager, there are two approaches. The cleanest: add a `StateManager()` getter on the Runtime type OR pass the StateManager separately to NewRouter. Since API handlers already receive Runtime directly (see existing pattern), add a method `NFS4StateManager() *state.StateManager` to Runtime that returns a stored reference. Set this reference during adapter setup.
   - ALTERNATIVE (simpler): Since the router file already imports `handlers` package, create the ClientHandler in router.go by getting StateManager from the NFS adapter. However, this creates a dependency problem. The SIMPLEST approach: add a `SetNFS4StateManager(sm)` and `NFS4StateManager()` method pair to Runtime. The NFS adapter calls `SetNFS4StateManager()` during its setup, and the router reads it.
   - For Phase 18, use the simplest viable approach: add `nfs4StateManager *state.StateManager` field to Runtime with getter/setter. Wire in router only if StateManager is set (graceful nil check -- no client endpoints if no NFS adapter configured).
   - Add routes in the admin-only protected section:
     ```go
     r.Route("/clients", func(r chi.Router) {
         r.Use(apiMiddleware.RequireAdmin())
         clientHandler := handlers.NewClientHandler(rt.NFS4StateManager())
         r.Get("/", clientHandler.List)
         r.Delete("/{id}", clientHandler.Evict)
     })
     ```
   - Import the state package in router.go if needed for the type reference

6. **Update HealthHandler** to include server identity info (per locked decision -- server_owner, server_scope, impl_id on /health):
   - In `health.go` Liveness method, if `h.registry.NFS4StateManager()` is not nil, call `h.registry.NFS4StateManager().ServerInfo()` and include in the response data:
     ```json
     {
       "server_owner": {"major_id": "hostname", "minor_id": "hex"},
       "server_impl": {"name": "dittofs", "domain": "dittofs.io"},
       "server_scope": "hostname"
     }
     ```
   - Format minor_id as hex string of the 4 bootEpoch bytes
   - Only include these fields if NFS4StateManager is available

7. **Runtime modifications** (add to `pkg/controlplane/runtime/runtime.go`):
   - Add field: `nfs4StateManager interface{}` (use interface{} to avoid import cycle with internal/protocol, store as any)
   - Actually, since StateManager is in `internal/protocol/nfs/v4/state/`, the runtime package (in pkg/) cannot import it directly. Instead, define a minimal interface in runtime:
     ```go
     type NFSClientProvider interface {
         ListV40Clients() []interface{}
         ListV41Clients() []interface{}
         // ... etc
     }
     ```
   - SIMPLEST approach to avoid import cycles: Store as `any` with type assertion in handler. Add `SetNFSClientProvider(p any)` and `NFSClientProvider() any` on Runtime. The handlers package (in internal/) CAN import the state package and does the type assertion. This keeps Runtime clean of NFS protocol imports.
  </action>
  <verify>
Run `go build ./pkg/controlplane/...` -- compiles without import cycle errors.
Run `go build ./internal/controlplane/...` -- compiles.
Run `go build ./cmd/dfs/` -- server binary builds.
Run `go vet ./pkg/controlplane/... ./internal/controlplane/...` -- clean.
  </verify>
  <done>
GET /api/v1/clients returns unified list of v4.0 and v4.1 clients with rich fields. DELETE /api/v1/clients/{id} evicts a client. GET /health includes server_owner and implementation info when NFS is active. No import cycles. Server binary builds.
  </done>
</task>

<task type="auto">
  <name>Task 2: dfsctl client commands and apiclient methods</name>
  <files>
    pkg/apiclient/clients.go
    cmd/dfsctl/commands/client/client.go
    cmd/dfsctl/commands/client/list.go
    cmd/dfsctl/commands/client/evict.go
    cmd/dfsctl/commands/root.go
  </files>
  <action>
1. **Create `pkg/apiclient/clients.go`** with API client methods:
   - `ClientInfo` struct mirroring the API response (same JSON tags as handlers/clients.go):
     ```go
     type ClientInfo struct {
         ClientID    string `json:"client_id"`
         Address     string `json:"address"`
         NFSVersion  string `json:"nfs_version"`
         ConnectedAt string `json:"connected_at"`
         LastRenewal string `json:"last_renewal"`
         LeaseStatus string `json:"lease_status"`
         Confirmed   bool   `json:"confirmed"`
         ImplName    string `json:"impl_name,omitempty"`
         ImplDomain  string `json:"impl_domain,omitempty"`
     }
     ```
   - `ListClients() ([]ClientInfo, error)` -- GET /api/v1/clients, decode JSON array
   - `EvictClient(clientID string) error` -- DELETE /api/v1/clients/{clientID}, expect 204
   - Follow the exact pattern from `adapters.go` for HTTP method calls and error handling

2. **Create `cmd/dfsctl/commands/client/client.go`** -- parent command:
   - `var Cmd = &cobra.Command{Use: "client", Short: "NFS client management"}`
   - `func init()` adding listCmd and evictCmd
   - Follow the adapter/adapter.go pattern exactly

3. **Create `cmd/dfsctl/commands/client/list.go`** -- list command:
   - `var listCmd = &cobra.Command{Use: "list", Short: "List connected NFS clients"}`
   - `ClientList` type implementing `output.TableRenderer` with Headers/Rows methods
   - Headers: CLIENT_ID, VERSION, ADDRESS, LEASE, CONFIRMED, IMPL_NAME
   - Rows: formatted from ClientInfo (truncate client_id to last 8 hex chars for readability, show full in JSON)
   - Call `cmdutil.GetAuthenticatedClient()`, then `client.ListClients()`, then `cmdutil.PrintOutput()`
   - Follow the adapter/list.go pattern exactly

4. **Create `cmd/dfsctl/commands/client/evict.go`** -- evict command:
   - `var evictCmd = &cobra.Command{Use: "evict <client-id>", Short: "Evict an NFS client", Args: cobra.ExactArgs(1)}`
   - Get client ID from args[0]
   - Use `prompt.Confirm()` from `internal/cli/prompt` to ask "Evict client {id}? This will disconnect the client." (skip if --force flag or non-interactive)
   - Call `client.EvictClient(clientID)` -- note clientID is the hex string, sent as-is in the URL
   - On success, print "Client {id} evicted"
   - Follow the adapter/disable.go pattern for the action flow

5. **Register in root.go**:
   - Add import: `clientcmd "github.com/marmos91/dittofs/cmd/dfsctl/commands/client"`
   - Add in init(): `rootCmd.AddCommand(clientcmd.Cmd)`
  </action>
  <verify>
Run `go build ./cmd/dfsctl/` -- client binary builds.
Run `go vet ./cmd/dfsctl/...` -- clean.
Run `go vet ./pkg/apiclient/...` -- clean.
Run `go build ./...` -- entire project builds.
Run `go test -race ./... 2>&1 | tail -5` -- all tests pass.
  </verify>
  <done>
`dfsctl client list` command shows connected NFS clients in table/JSON/YAML format. `dfsctl client evict <id>` removes a client with confirmation. apiclient has ListClients and EvictClient methods. Full project builds and all tests pass.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` -- entire project compiles without errors or import cycles
2. `go test -race ./...` -- full test suite passes
3. `go vet ./...` -- clean
4. `./dfsctl client --help` -- shows list and evict subcommands
5. Verify router registers /api/v1/clients routes (grep router.go for "/clients")
6. Verify /health includes server identity info (inspect health.go Liveness response)
</verification>

<success_criteria>
- GET /api/v1/clients returns JSON array with both v4.0 and v4.1 clients, each with client_id, address, nfs_version, lease_status, confirmed, impl_name (v4.1 only)
- DELETE /api/v1/clients/{hex-id} returns 204 on success, 404 if not found, 400 if bad hex
- GET /health response includes server_owner major_id, minor_id, server_impl name/domain when NFS is configured
- `dfsctl client list` renders table with CLIENT_ID, VERSION, ADDRESS, LEASE, CONFIRMED, IMPL_NAME columns
- `dfsctl client list -o json` outputs full JSON
- `dfsctl client evict <id>` prompts for confirmation then evicts
- No import cycles between pkg/ and internal/ packages
- All existing tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/18-exchange-id-and-client-registration/18-02-SUMMARY.md`
</output>
