---
phase: 02-server-identity
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - test/e2e/helpers/server.go
  - test/e2e/helpers/cli.go
  - test/e2e/server_test.go
autonomous: true

must_haves:
  truths:
    - "Server starts successfully and responds to health checks"
    - "Server stops gracefully on SIGTERM within timeout"
    - "Status command reports correct running/stopped state"
    - "Health and readiness endpoints return expected structure"
    - "Server startup fails fast with clear error on invalid config"
  artifacts:
    - path: "test/e2e/helpers/server.go"
      provides: "Server process lifecycle management (start, stop, signal, wait)"
      exports: ["ServerProcess", "StartServerProcess", "FindFreePort"]
    - path: "test/e2e/helpers/cli.go"
      provides: "CLI command execution with JSON output parsing"
      exports: ["CLIRunner", "NewCLIRunner", "UniqueTestName"]
    - path: "test/e2e/server_test.go"
      provides: "Server lifecycle E2E tests"
      contains: "func TestServerLifecycle"
  key_links:
    - from: "test/e2e/server_test.go"
      to: "test/e2e/helpers/server.go"
      via: "StartServerProcess, WaitReady, SendSignal"
      pattern: "helpers\\.StartServerProcess|helpers\\.ServerProcess"
    - from: "test/e2e/helpers/server.go"
      to: "dittofs start"
      via: "exec.Command subprocess"
      pattern: "exec\\.Command.*dittofs.*start"
---

<objective>
Create server lifecycle test infrastructure and E2E tests validating that the DittoFS server starts, stops gracefully, and reports correct status.

Purpose: Foundation for all subsequent Phase 2 tests - users and groups tests require a running server. Validates server lifecycle before testing CRUD operations.

Output:
- `test/e2e/helpers/server.go` - ServerProcess struct for managing server subprocess
- `test/e2e/helpers/cli.go` - CLIRunner for executing dittofsctl commands with JSON parsing
- `test/e2e/server_test.go` - Server lifecycle tests (start, stop, status, health, signals)
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-server-identity/02-CONTEXT.md
@.planning/phases/02-server-identity/02-RESEARCH.md
@.planning/phases/01-foundation/01-02-SUMMARY.md

# Existing test infrastructure
@test/e2e/helpers/environment.go
@test/e2e/helpers/scope.go
@test/e2e/main_test.go

# Server CLI commands for reference
@cmd/dittofs/commands/start.go
@cmd/dittofs/commands/status.go
@cmd/dittofs/commands/stop.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create server.go and cli.go helpers</name>
  <files>
    test/e2e/helpers/server.go
    test/e2e/helpers/cli.go
  </files>
  <action>
Create two new helper files in `test/e2e/helpers/`:

**server.go** - Server process management:
```go
// ServerProcess manages a dittofs server subprocess
type ServerProcess struct {
    cmd       *exec.Cmd
    pidFile   string
    apiPort   int
    logFile   string
    stateDir  string
}
```

Key functions:
- `StartServerProcess(t *testing.T, configPath string) *ServerProcess` - Start server in foreground mode with custom config, poll `/health/ready` until ready (5-second timeout per CONTEXT.md). Use `t.TempDir()` for state directory (pid file, log file). Find free port for API server via `FindFreePort(t)`.
- `FindFreePort(t *testing.T) int` - Find available TCP port by binding to :0 and reading assigned port
- `(sp *ServerProcess) WaitReady(timeout time.Duration) error` - Poll `/health/ready` endpoint
- `(sp *ServerProcess) CheckHealth() (*HealthResponse, error)` - GET `/health` and parse response
- `(sp *ServerProcess) CheckReady() (*ReadinessResponse, error)` - GET `/health/ready` and parse response
- `(sp *ServerProcess) SendSignal(sig syscall.Signal) error` - Send signal to server process
- `(sp *ServerProcess) WaitForExit(timeout time.Duration) error` - Wait for process to exit
- `(sp *ServerProcess) ForceKill()` - Force kill process (for cleanup)
- `(sp *ServerProcess) StopGracefully() error` - SIGTERM + wait
- `(sp *ServerProcess) APIPort() int` - Return API port for client connections

Define response structs matching existing health endpoint format:
```go
type HealthResponse struct {
    Status string `json:"status"`
    Error  string `json:"error,omitempty"`
    Data   struct {
        StartedAt string `json:"started_at"`
        Uptime    string `json:"uptime"`
    } `json:"data"`
}
```

**cli.go** - CLI execution helpers:
```go
// CLIRunner executes dittofsctl commands with JSON output
type CLIRunner struct {
    serverURL string
    token     string
}
```

Key functions:
- `NewCLIRunner(serverURL, token string) *CLIRunner` - Create CLI runner
- `(r *CLIRunner) Run(args ...string) ([]byte, error)` - Execute dittofsctl with `--server`, `--token`, `--output json` prepended
- `(r *CLIRunner) RunRaw(args ...string) ([]byte, error)` - Execute without prepending standard args
- `(r *CLIRunner) SetToken(token string)` - Update token
- `UniqueTestName(prefix string) string` - Generate unique name: `{prefix}_{uuid8}`
- `LoginAsAdmin(serverURL string) (*CLIRunner, error)` - Login as admin, return runner with token

Note: Use the `--output json` flag for all commands to enable reliable parsing. The dittofsctl CLI already supports this (see cmd/dittofsctl/commands/root.go).

Both files need `//go:build e2e` tag.
  </action>
  <verify>
`go build -tags=e2e ./test/e2e/helpers/...` compiles without errors
  </verify>
  <done>
Both helper files exist, compile, and export the documented types and functions
  </done>
</task>

<task type="auto">
  <name>Task 2: Create server lifecycle tests</name>
  <files>
    test/e2e/server_test.go
  </files>
  <action>
Create `test/e2e/server_test.go` with comprehensive server lifecycle tests.

Test structure (use table-driven tests where appropriate):

```go
//go:build e2e

package e2e

func TestServerLifecycle(t *testing.T) {
    // Skip in short mode
    if testing.Short() {
        t.Skip("Skipping server lifecycle tests in short mode")
    }

    // These tests are sequential (can't run parallel - each needs its own server)
    t.Run("start and check health", func(t *testing.T) { ... })
    t.Run("health vs readiness endpoints", func(t *testing.T) { ... })
    t.Run("status command reports running", func(t *testing.T) { ... })
    t.Run("graceful shutdown on SIGTERM", func(t *testing.T) { ... })
    t.Run("graceful shutdown on SIGINT", func(t *testing.T) { ... })
}
```

**Subtests to implement:**

1. **start and check health** - Start server, verify `/health` returns healthy status, verify response structure includes started_at and uptime

2. **health vs readiness endpoints** - Per CONTEXT.md, readiness = all adapters started + all store healthchecks pass. Test both `/health` and `/health/ready` respond correctly after startup

3. **status command reports running** - Start server, run `dittofs status --api-port <port> --output json`, verify JSON output shows `running: true`, `healthy: true`

4. **graceful shutdown on SIGTERM** - Start server, send SIGTERM, verify clean exit within 10 seconds (no error code), verify process actually exits

5. **graceful shutdown on SIGINT** - Same as SIGTERM but with SIGINT signal

Important implementation notes:
- Each subtest needs its own server instance (use `t.Cleanup(sp.ForceKill)` as safety net)
- Create a minimal test config file in `t.TempDir()` with in-memory stores (fastest)
- Use default config if possible - CONTEXT.md says "Default config only (no config variations in this phase)"
- Server lifecycle tests should NOT run in parallel with each other (they're sequential within TestServerLifecycle)
  </action>
  <verify>
`go test -tags=e2e -v -run TestServerLifecycle ./test/e2e/` runs and passes (requires dittofs binary built)
  </verify>
  <done>
Server lifecycle tests verify: startup, health/readiness endpoints, status command, and graceful shutdown on both SIGTERM and SIGINT
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Helpers compile:
   ```bash
   go build -tags=e2e ./test/e2e/helpers/...
   ```

2. Server tests run (requires dittofs binary):
   ```bash
   go build -o dittofs ./cmd/dittofs/
   go test -tags=e2e -v -run TestServerLifecycle ./test/e2e/
   ```

3. All tests pass without flakiness
</verification>

<success_criteria>
- [ ] `test/e2e/helpers/server.go` provides ServerProcess with start/stop/signal/health methods
- [ ] `test/e2e/helpers/cli.go` provides CLIRunner for command execution with JSON parsing
- [ ] `test/e2e/server_test.go` has passing tests for server lifecycle
- [ ] Health endpoint returns expected JSON structure
- [ ] Readiness endpoint distinguishes from health endpoint
- [ ] Status command correctly reports running state
- [ ] SIGTERM triggers graceful shutdown
- [ ] SIGINT triggers graceful shutdown
- [ ] Each test cleans up its server process via t.Cleanup
</success_criteria>

<output>
After completion, create `.planning/phases/02-server-identity/02-01-SUMMARY.md`
</output>
