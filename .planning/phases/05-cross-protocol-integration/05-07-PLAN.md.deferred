---
phase: 05-cross-protocol-integration
plan: 07
type: execute
wave: 2
depends_on: ["05-06"]
files_modified:
  - pkg/adapter/nfs/portmap.go
  - pkg/adapter/nfs/nfs_adapter.go
  - pkg/adapter/nfs/nfs_config.go
  - pkg/adapter/nfs/portmap_test.go
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "NFS adapter registers NLM (100021) and MOUNT (100005) with system rpcbind on startup"
    - "NFS adapter deregisters from rpcbind on shutdown"
    - "Registration failure logs a warning but does not prevent server startup"
    - "Registration is opt-out via config (enabled by default)"
  artifacts:
    - path: "pkg/adapter/nfs/portmap.go"
      provides: "Portmapper registration and deregistration using RFC 1833 PMAP protocol"
      contains: "RegisterWithPortmapper"
    - path: "pkg/adapter/nfs/nfs_adapter.go"
      provides: "Portmapper lifecycle integration in Serve() and Stop()"
      contains: "RegisterWithPortmapper"
    - path: "pkg/adapter/nfs/portmap_test.go"
      provides: "Unit tests for portmap message encoding and registration logic"
      contains: "TestPortmapRegister"
  key_links:
    - from: "pkg/adapter/nfs/nfs_adapter.go"
      to: "pkg/adapter/nfs/portmap.go"
      via: "RegisterWithPortmapper call in Serve(), DeregisterFromPortmapper in Stop()"
      pattern: "RegisterWithPortmapper"
---

<objective>
Auto-register NFS-related RPC services (NLM, MOUNT, NFS, NSM) with the system's rpcbind/portmapper on startup, following the NFS-Ganesha pattern.

Purpose: Enable NFS clients to discover the NLM service port via standard portmapper queries (port 111). Without this, clients cannot acquire file locks because they can't find the NLM endpoint. This is a hard requirement for NLM locking to work on any standard NFS client (Linux or macOS).

Output: Automatic portmapper registration on startup, deregistration on shutdown, graceful degradation when rpcbind is unavailable.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-cross-protocol-integration/05-CONTEXT.md
@pkg/adapter/nfs/nfs_adapter.go
@pkg/adapter/nfs/nfs_config.go
@internal/protocol/nfs/rpc/constants.go
</context>

<background>
## Why This Is Needed

NFS clients discover the NLM service port by querying the system's portmapper (rpcbind) on port 111. Without registration:
- `fcntl(F_SETLK)` and `flock()` fail with ENOLCK (errno 77)
- No file locking works for any NFS client
- The entire NLM/NSM implementation is unreachable

## What the Competition Does

| Implementation | Strategy |
|---|---|
| **NFS-Ganesha** | Registers with system rpcbind via `svc_reg()`. Fatal on failure. |
| **go-nfs** | No NLM at all. Clients must use `-o nolock`. |
| **UNFS3** | No NLM. Clients use `-o nolock`. |
| **Linux kernel nfsd** | Kernel lockd registers automatically. |

DittoFS should follow the NFS-Ganesha pattern: register on startup, warn (not fail) if rpcbind is unavailable.

## Protocol Details

Portmapper v2 (RFC 1057) runs on port 111 and provides:
- `PMAPPROC_SET` (procedure 1): Register {program, version, protocol, port}
- `PMAPPROC_UNSET` (procedure 2): Deregister {program, version}

RPC programs to register:
- 100003 (NFS) version 3, TCP, port N
- 100005 (MOUNT) version 3, TCP, port N
- 100021 (NLM) versions 1,3,4, TCP, port N
- 100024 (NSM) version 1, TCP, port N

All on the same port since DittoFS multiplexes RPC programs on a single TCP listener.
</background>

<tasks>

<task type="auto">
  <name>Task 1: Implement portmapper client</name>
  <files>
    pkg/adapter/nfs/portmap.go
  </files>
  <action>
Create `pkg/adapter/nfs/portmap.go` implementing portmapper registration:

1. **`PortmapRegistration` struct**:
   - `Program uint32`
   - `Version uint32`
   - `Protocol uint32` (IPPROTO_TCP=6, IPPROTO_UDP=17)
   - `Port uint32`

2. **`RegisterWithPortmapper(port int) error`**:
   - Builds the list of registrations: NFS(100003/3), MOUNT(100005/3), NLM(100021/1,3,4), NSM(100024/1) — all TCP on the given port
   - For each registration, first calls PMAPPROC_UNSET to clear stale entries, then PMAPPROC_SET
   - Connects to localhost:111 via TCP
   - Sends portmapper v2 RPC calls (program=100000, version=2)
   - Uses record marking (4-byte fragment header with last-fragment bit)
   - Returns nil on success, error on failure (caller decides severity)
   - Uses a single TCP connection for all registrations

3. **`DeregisterFromPortmapper() error`**:
   - Calls PMAPPROC_UNSET for each program/version pair
   - Best-effort (log errors but don't fail)
   - Safe to call even if registration was never done

4. **Helper functions**:
   - `buildPmapCallMessage(xid, procedure uint32, args []byte) []byte` — builds RPC call with AUTH_NULL
   - `encodePmapArgs(reg PortmapRegistration) []byte` — XDR encodes {prog, vers, prot, port}
   - `parsePmapReply(data []byte) (bool, error)` — parses PMAP reply, returns success bool

Use the existing RPC constants from `internal/protocol/nfs/rpc/constants.go` (ProgramNFS, ProgramMount, ProgramNLM, ProgramNSM).

**Important**: This is a pure client — it talks to the system's existing rpcbind on port 111. It does NOT implement a portmapper server.
  </action>
  <verify>
    `go build ./pkg/adapter/nfs/...` succeeds.
  </verify>
  <done>
    RegisterWithPortmapper and DeregisterFromPortmapper exist and compile.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add portmap config option</name>
  <files>
    pkg/adapter/nfs/nfs_config.go
  </files>
  <action>
Add a `RegisterPortmap` field to `NFSConfig`:

```go
// RegisterPortmap controls whether the NFS adapter registers its RPC services
// (NFS, MOUNT, NLM, NSM) with the system's portmapper/rpcbind on port 111.
// This is required for NFS clients to discover the NLM service for file locking.
// Default: true. Set to false if running without rpcbind or in a container.
RegisterPortmap bool
```

Default should be `true` in whatever constructor/default initializer exists.

Also check `pkg/config/` if adapter config is parsed there and propagate the field.
  </action>
  <verify>
    `go build ./...` succeeds. Field accessible from NFS adapter.
  </verify>
  <done>
    RegisterPortmap config field exists with default true.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate into NFS adapter lifecycle</name>
  <files>
    pkg/adapter/nfs/nfs_adapter.go
  </files>
  <action>
Integrate portmapper registration into the NFS adapter:

1. **In `Serve()`**: After the TCP listener is created and port is known, call `RegisterWithPortmapper(port)` if `config.RegisterPortmap` is true:
   - On success: log at INFO level "Registered RPC services with portmapper" with port
   - On failure: log at WARN level "Failed to register with portmapper, NFS clients may not discover NLM for file locking. Ensure rpcbind is running or mount with -o nolock" with the error
   - **Do NOT fail server startup** on registration failure

2. **In `Stop()` / `initiateShutdown()`**: Call `DeregisterFromPortmapper()` during shutdown:
   - Best-effort, log errors at DEBUG level
   - Run early in shutdown sequence (before closing listener)

3. **In `gracefulShutdown()`**: Also ensure deregistration happens if Stop() wasn't called directly.
  </action>
  <verify>
    `go build ./pkg/adapter/nfs/...` succeeds.
    Start server with rpcbind running: logs show successful registration.
    Start server without rpcbind: logs show warning, server starts normally.
    `rpcinfo -p localhost` shows NLM registered on the NFS port after startup.
  </verify>
  <done>
    NFS adapter registers on start and deregisters on stop.
  </done>
</task>

<task type="auto">
  <name>Task 4: Unit tests for portmap client</name>
  <files>
    pkg/adapter/nfs/portmap_test.go
  </files>
  <action>
Write unit tests for the portmap client:

1. **TestBuildPmapCallMessage**: Verify RPC message structure (XID, program=100000, version=2, procedure, AUTH_NULL)
2. **TestEncodePmapArgs**: Verify XDR encoding of {program, version, protocol, port}
3. **TestParsePmapReply**: Test parsing successful (bool=1) and failed (bool=0) replies
4. **TestPortmapRegistrationList**: Verify the correct set of programs/versions are registered (NFS/3, MOUNT/3, NLM/1,3,4, NSM/1)
5. **TestDeregisterFromPortmapper_NoRpcbind**: Verify graceful failure when rpcbind is not reachable (connection refused)
6. **TestRegisterWithPortmapper_NoRpcbind**: Verify graceful error return when rpcbind is not reachable

Do NOT require rpcbind to be running for unit tests. Test message encoding/decoding directly, and test connection failure handling.
  </action>
  <verify>
    `go test ./pkg/adapter/nfs/... -run TestPortmap -v` passes.
    `go test ./pkg/adapter/nfs/... -run TestBuild -v` passes.
    `go test ./pkg/adapter/nfs/... -run TestEncode -v` passes.
    `go test ./pkg/adapter/nfs/... -run TestParse -v` passes.
  </verify>
  <done>
    Portmap unit tests pass without requiring rpcbind.
  </done>
</task>

</tasks>

<verification>
1. Build: `go build ./...` succeeds
2. Unit tests: `go test ./pkg/adapter/nfs/... -v` passes
3. Full test suite: `go test ./...` passes
4. With rpcbind: `rpcinfo -p localhost` shows NLM on NFS port after startup
5. Without rpcbind: Server starts with warning, basic NFS ops still work
6. On shutdown: `rpcinfo -p localhost` no longer shows DittoFS registrations
</verification>

<success_criteria>
1. NFS adapter auto-registers NLM/MOUNT/NFS/NSM with system portmapper on startup
2. NFS clients can discover NLM via standard portmapper queries
3. Registration failure is non-fatal (warning logged, server continues)
4. Cleanup on shutdown removes stale registrations
5. Opt-out via config for containerized environments without rpcbind
6. All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-cross-protocol-integration/05-07-SUMMARY.md`
</output>
