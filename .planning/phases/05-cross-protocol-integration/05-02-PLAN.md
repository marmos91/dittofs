---
phase: 05-cross-protocol-integration
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - internal/protocol/nlm/handlers/lock.go
  - internal/protocol/nlm/handlers/cross_protocol.go
  - internal/protocol/nfs/v3/handlers/remove.go
  - internal/protocol/nfs/v3/handlers/rename.go
  - pkg/metadata/service.go
autonomous: true

must_haves:
  truths:
    - "NLM LOCK checks for SMB leases before granting"
    - "NLM LOCK waits for SMB Write lease break acknowledgment"
    - "NLM4_DENIED includes SMB holder info when denied due to SMB lease"
    - "NFS REMOVE/RENAME break SMB Handle leases before proceeding"
  artifacts:
    - path: "internal/protocol/nlm/handlers/lock.go"
      provides: "SMB lease check in NLM LOCK handler"
      contains: "CheckAndBreakForWrite"
    - path: "internal/protocol/nlm/handlers/cross_protocol.go"
      provides: "Cross-protocol denial response builder"
      exports: ["buildDeniedResponseFromSMBLease"]
    - path: "internal/protocol/nfs/v3/handlers/remove.go"
      provides: "Handle lease break before REMOVE"
      contains: "CheckAndBreakForDelete"
  key_links:
    - from: "internal/protocol/nlm/handlers/lock.go"
      to: "pkg/metadata/service.go"
      via: "OplockChecker interface"
      pattern: "CheckAndBreakForWrite"
    - from: "internal/protocol/nfs/v3/handlers/remove.go"
      to: "pkg/metadata/service.go"
      via: "CheckAndBreakLeasesForDelete"
      pattern: "CheckAndBreakLeasesForDelete"
---

<objective>
Integrate NLM handlers with SMB lease visibility for cross-protocol locking.

Purpose: When NFS clients request locks or delete/rename files, they must respect SMB leases. This plan adds SMB lease checking to NLM LOCK handler and Handle lease breaking to NFS REMOVE/RENAME.

Output: NLM handlers that wait for SMB lease breaks, NFS handlers that break Handle leases, and proper NLM4_DENIED responses with SMB holder info.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-cross-protocol-integration/05-CONTEXT.md
@.planning/phases/05-cross-protocol-integration/05-RESEARCH.md
@.planning/phases/05-cross-protocol-integration/05-01-SUMMARY.md
@internal/protocol/nlm/handlers/lock.go
@internal/protocol/nlm/handlers/handler.go
@internal/protocol/nfs/v3/handlers/remove.go
@internal/protocol/nfs/v3/handlers/rename.go
@internal/protocol/smb/v2/handlers/oplock.go
@pkg/metadata/service.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SMB lease checking to NLM LOCK handler</name>
  <files>internal/protocol/nlm/handlers/lock.go, internal/protocol/nlm/handlers/cross_protocol.go</files>
  <action>
Create `internal/protocol/nlm/handlers/cross_protocol.go`:

1. **buildDeniedResponseFromSMBLease(cookie []byte, lease *lock.EnhancedLock) *LockResponse**:
   - Translate SMB lease to NLM holder format using lock.TranslateToNLMHolder()
   - Return LockResponse with Status=NLM4Denied and holder info
   - Per CONTEXT.md: owner="smb:<client>", offset=0, length=MAX

2. **waitForLeaseBreak(ctx context.Context, checker metadata.OplockChecker, handle lock.FileHandle, timeout time.Duration) error**:
   - Poll with 100ms interval (per Phase 4 decision)
   - Return nil when break completes
   - Return ctx.Err() on context cancellation
   - Return nil after timeout (proceed anyway, per Phase 4)

Update `internal/protocol/nlm/handlers/lock.go`:

1. Before calling `h.metadataService.LockFileNLM()`, add SMB lease check:
   ```go
   // Check for SMB Write leases that need to break
   checker := metadata.GetOplockChecker()
   if checker != nil {
       err := waitForLeaseBreak(ctx.Context, checker, lock.FileHandle(handle), 35*time.Second)
       // Log at INFO level per CONTEXT.md (working as designed)
       if err != nil {
           logger.Info("NLM LOCK: lease break wait interrupted", "error", err)
       }
   }
   ```

2. After lock conflict, check if conflict is from SMB lease:
   - Query UnifiedLockView for file locks
   - If conflicting lock is a lease, use buildDeniedResponseFromSMBLease()
   - Log cross-protocol conflict at INFO level

3. Record metrics: RecordCrossProtocolConflict("nfs", "smb_lease", resolution)
  </action>
  <verify>
    go build ./internal/protocol/nlm/...
    go test ./internal/protocol/nlm/... -race -v
  </verify>
  <done>
    NLM LOCK waits for SMB lease breaks and returns proper holder info when denied due to SMB lease.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Handle lease break to NFS REMOVE/RENAME</name>
  <files>internal/protocol/nfs/v3/handlers/remove.go, internal/protocol/nfs/v3/handlers/rename.go, pkg/metadata/service.go</files>
  <action>
First, extend OplockChecker interface in `pkg/metadata/service.go`:

1. Add method to OplockChecker interface:
   ```go
   // CheckAndBreakForDelete checks for SMB Handle leases that must break
   // before file deletion. H leases protect against surprise deletion.
   CheckAndBreakForDelete(ctx context.Context, fileHandle lock.FileHandle) error
   ```

2. Add MetadataService wrapper method:
   ```go
   func (s *MetadataService) CheckAndBreakLeasesForDelete(ctx context.Context, handle FileHandle) error
   ```

Update `internal/protocol/nfs/v3/handlers/remove.go`:

1. Add Handle lease break check before DeleteFile:
   ```go
   // Break SMB Handle leases before delete
   // Per CONTEXT.md: H leases exist to prevent surprise deletion
   if err := s.metadataService.CheckAndBreakLeasesForDelete(ctx.Context, handle); err != nil {
       if err == handlers.ErrLeaseBreakPending {
           // Wait for Handle lease acknowledgment (client closes handles)
           err = waitForLeaseBreak(ctx.Context, 35*time.Second)
       }
       if err != nil && err != context.DeadlineExceeded {
           logger.Info("NFS REMOVE: Handle lease break wait interrupted", "error", err)
       }
   }
   ```

Update `internal/protocol/nfs/v3/handlers/rename.go`:

1. Add Handle lease break check for BOTH source and destination files:
   ```go
   // Break H leases on source file
   _ = s.metadataService.CheckAndBreakLeasesForDelete(ctx.Context, srcHandle)
   // Break H leases on destination file (if exists)
   if dstHandle != nil {
       _ = s.metadataService.CheckAndBreakLeasesForDelete(ctx.Context, dstHandle)
   }
   ```

2. Wait for both breaks to complete before proceeding

Record metrics for Handle lease breaks.
  </action>
  <verify>
    go build ./internal/protocol/nfs/...
    go build ./pkg/metadata/...
    go test ./internal/protocol/nfs/... -race -v
  </verify>
  <done>
    NFS REMOVE/RENAME break SMB Handle leases and wait for acknowledgment before proceeding.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement CheckAndBreakForDelete in OplockManager</name>
  <files>internal/protocol/smb/v2/handlers/oplock.go</files>
  <action>
Add CheckAndBreakForDelete method to OplockManager:

1. **CheckAndBreakForDelete(ctx context.Context, fileHandle lock.FileHandle) error**:
   - Query lock store for leases on the file
   - Check for Handle (H) leases specifically (lease.Lease.HasHandle())
   - If H lease found:
     - Initiate break to None (delete requires full release)
     - Return ErrLeaseBreakPending
   - Return nil if no H leases

2. Update initiateLeaseBreak to handle delete case:
   - Break to LeaseStateNone for delete operations
   - Send LEASE_BREAK_NOTIFICATION with NewLeaseState=0

3. Ensure OplockManager implements OplockChecker interface:
   - CheckAndBreakForWrite (existing)
   - CheckAndBreakForRead (existing)
   - CheckAndBreakForDelete (new)

4. Update SetOplockChecker call in SMB adapter to register the manager.
  </action>
  <verify>
    go build ./internal/protocol/smb/...
    go test ./internal/protocol/smb/... -race -v
  </verify>
  <done>
    OplockManager.CheckAndBreakForDelete breaks Handle leases for NFS delete operations.
  </done>
</task>

</tasks>

<verification>
All verification commands should pass:

```bash
# Build all affected packages
go build ./internal/protocol/nlm/...
go build ./internal/protocol/nfs/...
go build ./internal/protocol/smb/...
go build ./pkg/metadata/...

# Run tests
go test ./internal/protocol/nlm/... -race -v
go test ./internal/protocol/nfs/... -race -v
go test ./internal/protocol/smb/... -race -v
```
</verification>

<success_criteria>
- NLM LOCK handler checks for SMB leases and waits for breaks
- NLM4_DENIED responses include SMB holder info when appropriate
- NFS REMOVE breaks Handle leases before delete
- NFS RENAME breaks Handle leases on source and destination
- OplockChecker interface includes CheckAndBreakForDelete
- Cross-protocol conflicts logged at INFO level
- All tests pass with race detector
</success_criteria>

<output>
After completion, create `.planning/phases/05-cross-protocol-integration/05-02-SUMMARY.md`
</output>
