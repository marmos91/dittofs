---
phase: 05-cross-protocol-integration
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - internal/protocol/nlm/handlers/lock.go
  - internal/protocol/nlm/handlers/cross_protocol.go
  - internal/protocol/nfs/v3/handlers/remove.go
  - internal/protocol/nfs/v3/handlers/rename.go
  - pkg/metadata/service.go
  - pkg/config/config.go
autonomous: true

must_haves:
  truths:
    - "NLM LOCK checks for SMB leases before granting"
    - "NLM LOCK waits for SMB Write lease break acknowledgment"
    - "NLM4_DENIED includes SMB holder info when denied due to SMB lease"
    - "NFS REMOVE/RENAME break SMB Handle leases before proceeding"
    - "Lease break timeout is configurable (default 35s, 5s for CI)"
  artifacts:
    - path: "internal/protocol/nlm/handlers/lock.go"
      provides: "SMB lease check in NLM LOCK handler"
      contains: "CheckAndBreakForWrite"
    - path: "internal/protocol/nlm/handlers/cross_protocol.go"
      provides: "Cross-protocol denial response builder"
      exports: ["buildDeniedResponseFromSMBLease"]
    - path: "internal/protocol/nfs/v3/handlers/remove.go"
      provides: "Handle lease break before REMOVE"
      contains: "CheckAndBreakForDelete"
    - path: "pkg/metadata/service.go"
      provides: "OplockChecker registration and routing"
      contains: "SetOplockChecker"
  key_links:
    - from: "internal/protocol/nlm/handlers/lock.go"
      to: "pkg/metadata/service.go"
      via: "OplockChecker interface"
      pattern: "CheckAndBreakForWrite"
    - from: "internal/protocol/nfs/v3/handlers/remove.go"
      to: "pkg/metadata/service.go"
      via: "CheckAndBreakLeasesForDelete"
      pattern: "CheckAndBreakLeasesForDelete"
    - from: "pkg/metadata/service.go"
      to: "internal/protocol/smb/v2/handlers/oplock.go"
      via: "SetOplockChecker registration"
      pattern: "SetOplockChecker"
---

<objective>
Integrate NLM handlers with SMB lease visibility for cross-protocol locking.

Purpose: When NFS clients request locks or delete/rename files, they must respect SMB leases. This plan adds SMB lease checking to NLM LOCK handler and Handle lease breaking to NFS REMOVE/RENAME.

Output: NLM handlers that wait for SMB lease breaks (with configurable timeout), NFS handlers that break Handle leases, proper NLM4_DENIED responses with SMB holder info, and OplockChecker wiring between MetadataService and OplockManager.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-cross-protocol-integration/05-CONTEXT.md
@.planning/phases/05-cross-protocol-integration/05-RESEARCH.md
@.planning/phases/05-cross-protocol-integration/05-01-SUMMARY.md
@internal/protocol/nlm/handlers/lock.go
@internal/protocol/nlm/handlers/handler.go
@internal/protocol/nfs/v3/handlers/remove.go
@internal/protocol/nfs/v3/handlers/rename.go
@internal/protocol/smb/v2/handlers/oplock.go
@pkg/metadata/service.go
@pkg/config/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add configurable lease break timeout and SMB lease checking to NLM LOCK handler</name>
  <files>internal/protocol/nlm/handlers/lock.go, internal/protocol/nlm/handlers/cross_protocol.go, pkg/config/config.go</files>
  <action>
First, add configurable timeout in `pkg/config/config.go`:

1. **Add LeaseBreakTimeout to config**:
   ```go
   type LockingConfig struct {
       // ... existing fields ...

       // LeaseBreakTimeout is how long to wait for SMB lease breaks
       // Default: 35s (SMB2 spec maximum). Set to 5s for faster CI tests.
       // Env: DITTOFS_LOCKING_LEASE_BREAK_TIMEOUT
       LeaseBreakTimeout time.Duration `yaml:"lease_break_timeout" env:"DITTOFS_LOCKING_LEASE_BREAK_TIMEOUT"`
   }
   ```

2. **Default value**: 35 * time.Second in defaults
3. **Test override**: Environment variable DITTOFS_LOCKING_LEASE_BREAK_TIMEOUT=5s for CI

Create `internal/protocol/nlm/handlers/cross_protocol.go`:

1. **buildDeniedResponseFromSMBLease(cookie []byte, lease *lock.EnhancedLock) *LockResponse**:
   - Translate SMB lease to NLM holder format using lock.TranslateToNLMHolder()
   - Return LockResponse with Status=NLM4Denied and holder info
   - Per CONTEXT.md: owner="smb:<client>", offset=0, length=MAX

2. **waitForLeaseBreak(ctx context.Context, checker metadata.OplockChecker, handle lock.FileHandle, timeout time.Duration) error**:
   - Poll with 100ms interval (per Phase 4 decision)
   - Return nil when break completes
   - Return ctx.Err() on context cancellation
   - Return nil after timeout (proceed anyway, per Phase 4)

3. **getLeaseBreakTimeout(cfg *config.Config) time.Duration**:
   - Return configured timeout (default 35s)
   - Allow tests to override via env var

Update `internal/protocol/nlm/handlers/lock.go`:

1. Before calling `h.metadataService.LockFileNLM()`, add SMB lease check:
   ```go
   // Check for SMB Write leases that need to break
   // Timeout is configurable: default 35s, 5s for CI tests
   checker := h.metadataService.GetOplockChecker()
   if checker != nil {
       timeout := getLeaseBreakTimeout(h.config) // Configurable, not hard-coded
       err := waitForLeaseBreak(ctx.Context, checker, lock.FileHandle(handle), timeout)
       // Log at INFO level per CONTEXT.md (working as designed)
       if err != nil {
           logger.Info("NLM LOCK: lease break wait interrupted", "error", err)
       }
   }
   ```

2. After lock conflict, check if conflict is from SMB lease:
   - Query UnifiedLockView for file locks
   - If conflicting lock is a lease, use buildDeniedResponseFromSMBLease()
   - Log cross-protocol conflict at INFO level

3. Record metrics: RecordCrossProtocolConflict("nfs", "smb_lease", resolution)
  </action>
  <verify>
    go build ./internal/protocol/nlm/...
    go build ./pkg/config/...
    go test ./internal/protocol/nlm/... -race -v
  </verify>
  <done>
    NLM LOCK waits for SMB lease breaks with configurable timeout (default 35s, 5s for CI) and returns proper holder info when denied due to SMB lease.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add OplockChecker wiring and Handle lease break to NFS REMOVE/RENAME</name>
  <files>internal/protocol/nfs/v3/handlers/remove.go, internal/protocol/nfs/v3/handlers/rename.go, pkg/metadata/service.go</files>
  <action>
First, add OplockChecker registration wiring in `pkg/metadata/service.go`:

1. **Add OplockChecker interface** (if not exists):
   ```go
   // OplockChecker allows NFS/NLM to check and break SMB leases
   type OplockChecker interface {
       // CheckAndBreakForWrite checks/breaks SMB Write leases for NFS write operations
       CheckAndBreakForWrite(ctx context.Context, fileHandle lock.FileHandle) error

       // CheckAndBreakForRead checks/breaks SMB leases for NFS read operations
       CheckAndBreakForRead(ctx context.Context, fileHandle lock.FileHandle) error

       // CheckAndBreakForDelete checks for SMB Handle leases that must break
       // before file deletion. H leases protect against surprise deletion.
       CheckAndBreakForDelete(ctx context.Context, fileHandle lock.FileHandle) error
   }
   ```

2. **Add oplockChecker field to MetadataService**:
   ```go
   type MetadataService struct {
       // ... existing fields ...
       oplockChecker OplockChecker // Set by SMB adapter during init
   }
   ```

3. **Add SetOplockChecker method**:
   ```go
   // SetOplockChecker registers the SMB OplockManager for cross-protocol lease breaks.
   // Called by SMB adapter during initialization.
   func (s *MetadataService) SetOplockChecker(checker OplockChecker) {
       s.oplockChecker = checker
   }
   ```

4. **Add GetOplockChecker method**:
   ```go
   // GetOplockChecker returns the registered OplockChecker (may be nil if SMB not enabled)
   func (s *MetadataService) GetOplockChecker() OplockChecker {
       return s.oplockChecker
   }
   ```

5. **Add MetadataService wrapper method**:
   ```go
   // CheckAndBreakLeasesForDelete breaks SMB Handle leases before file deletion.
   // Returns nil if no OplockChecker registered (SMB not enabled).
   func (s *MetadataService) CheckAndBreakLeasesForDelete(ctx context.Context, handle FileHandle) error {
       if s.oplockChecker == nil {
           return nil // SMB not enabled, no leases to break
       }
       return s.oplockChecker.CheckAndBreakForDelete(ctx, lock.FileHandle(handle))
   }
   ```

Update `internal/protocol/nfs/v3/handlers/remove.go`:

1. Add Handle lease break check before DeleteFile:
   ```go
   // Break SMB Handle leases before delete
   // Per CONTEXT.md: H leases exist to prevent surprise deletion
   if err := s.metadataService.CheckAndBreakLeasesForDelete(ctx.Context, handle); err != nil {
       timeout := getLeaseBreakTimeout(s.config) // Configurable timeout
       if err == handlers.ErrLeaseBreakPending {
           // Wait for Handle lease acknowledgment (client closes handles)
           err = waitForLeaseBreak(ctx.Context, timeout)
       }
       if err != nil && err != context.DeadlineExceeded {
           logger.Info("NFS REMOVE: Handle lease break wait interrupted", "error", err)
       }
   }
   ```

Update `internal/protocol/nfs/v3/handlers/rename.go`:

1. Add Handle lease break check for BOTH source and destination files:
   ```go
   // Break H leases on source file
   _ = s.metadataService.CheckAndBreakLeasesForDelete(ctx.Context, srcHandle)
   // Break H leases on destination file (if exists)
   if dstHandle != nil {
       _ = s.metadataService.CheckAndBreakLeasesForDelete(ctx.Context, dstHandle)
   }
   ```

2. Wait for both breaks to complete before proceeding (use configurable timeout)

Record metrics for Handle lease breaks.
  </action>
  <verify>
    go build ./internal/protocol/nfs/...
    go build ./pkg/metadata/...
    go test ./internal/protocol/nfs/... -race -v
  </verify>
  <done>
    MetadataService has SetOplockChecker/GetOplockChecker for registration wiring. NFS REMOVE/RENAME break SMB Handle leases and wait for acknowledgment with configurable timeout.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement CheckAndBreakForDelete in OplockManager and register with MetadataService</name>
  <files>internal/protocol/smb/v2/handlers/oplock.go, pkg/adapter/smb/adapter.go</files>
  <action>
Add CheckAndBreakForDelete method to OplockManager in `internal/protocol/smb/v2/handlers/oplock.go`:

1. **CheckAndBreakForDelete(ctx context.Context, fileHandle lock.FileHandle) error**:
   - Query lock store for leases on the file
   - Check for Handle (H) leases specifically (lease.Lease.HasHandle())
   - If H lease found:
     - Initiate break to None (delete requires full release)
     - Return ErrLeaseBreakPending
   - Return nil if no H leases

2. Update initiateLeaseBreak to handle delete case:
   - Break to LeaseStateNone for delete operations
   - Send LEASE_BREAK_NOTIFICATION with NewLeaseState=0

3. Ensure OplockManager implements OplockChecker interface:
   - CheckAndBreakForWrite (existing)
   - CheckAndBreakForRead (existing)
   - CheckAndBreakForDelete (new)

Update SMB adapter initialization in `pkg/adapter/smb/adapter.go` (or equivalent):

1. After creating OplockManager, call MetadataService.SetOplockChecker:
   ```go
   // Register OplockManager with MetadataService for cross-protocol lease breaks
   // This enables NFS handlers to break SMB leases
   if a.metadataService != nil {
       a.metadataService.SetOplockChecker(a.oplockManager)
   }
   ```

2. Add this registration in the Serve() or init method of the SMB adapter.

3. Ensure registration happens BEFORE NFS adapter starts processing requests.
  </action>
  <verify>
    go build ./internal/protocol/smb/...
    go build ./pkg/adapter/smb/...
    go test ./internal/protocol/smb/... -race -v
  </verify>
  <done>
    OplockManager.CheckAndBreakForDelete breaks Handle leases for NFS delete operations. SMB adapter registers OplockManager with MetadataService.SetOplockChecker during initialization.
  </done>
</task>

</tasks>

<verification>
All verification commands should pass:

```bash
# Build all affected packages
go build ./internal/protocol/nlm/...
go build ./internal/protocol/nfs/...
go build ./internal/protocol/smb/...
go build ./pkg/metadata/...
go build ./pkg/config/...
go build ./pkg/adapter/smb/...

# Run tests
go test ./internal/protocol/nlm/... -race -v
go test ./internal/protocol/nfs/... -race -v
go test ./internal/protocol/smb/... -race -v

# Verify configurable timeout
DITTOFS_LOCKING_LEASE_BREAK_TIMEOUT=5s go test ./internal/protocol/nlm/... -run TestLeaseBreak -v
```
</verification>

<success_criteria>
- NLM LOCK handler checks for SMB leases and waits for breaks with CONFIGURABLE timeout (not hard-coded 35s)
- Default timeout: 35s for production, overridable to 5s for CI via env var
- NLM4_DENIED responses include SMB holder info when appropriate
- NFS REMOVE breaks Handle leases before delete
- NFS RENAME breaks Handle leases on source and destination
- OplockChecker interface in pkg/metadata/service.go includes CheckAndBreakForDelete
- MetadataService has SetOplockChecker/GetOplockChecker methods for registration
- SMB adapter calls SetOplockChecker during initialization to wire OplockManager
- Cross-protocol conflicts logged at INFO level
- All tests pass with race detector
</success_criteria>

<output>
After completion, create `.planning/phases/05-cross-protocol-integration/05-02-SUMMARY.md`
</output>
