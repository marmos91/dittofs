---
phase: 05-cross-protocol-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/metadata/unified_view.go
  - pkg/metadata/lock/cross_protocol.go
  - pkg/metadata/lock/metrics.go
  - pkg/metadata/service.go
autonomous: true

must_haves:
  truths:
    - "UnifiedLockView provides single API to query all locks and leases on a file"
    - "Both NLM byte-range locks and SMB leases returned from GetAllLocksOnFile"
    - "Translation helpers convert between protocol-specific formats"
  artifacts:
    - path: "pkg/metadata/unified_view.go"
      provides: "UnifiedLockView struct with GetAllLocksOnFile method"
      exports: ["UnifiedLockView", "FileLocksInfo", "GetAllLocksOnFile"]
    - path: "pkg/metadata/lock/cross_protocol.go"
      provides: "Cross-protocol translation helpers"
      exports: ["TranslateToNLMHolder", "NLMHolderInfo"]
    - path: "pkg/metadata/lock/metrics.go"
      provides: "Cross-protocol conflict metrics"
      contains: "cross_protocol_conflict_total"
  key_links:
    - from: "pkg/metadata/unified_view.go"
      to: "pkg/metadata/lock/store.go"
      via: "LockStore.ListLocks query"
      pattern: "lockStore\\.ListLocks"
    - from: "pkg/metadata/service.go"
      to: "pkg/metadata/unified_view.go"
      via: "MetadataService owns UnifiedLockView"
      pattern: "UnifiedLockView"
---

<objective>
Create the UnifiedLockView foundation for cross-protocol lock visibility.

Purpose: Enable any protocol handler to query all locks (NLM byte-range and SMB leases) on a file through a single API. This is the foundation for cross-protocol conflict detection and holder info translation.

Output: UnifiedLockView struct in pkg/metadata/ (per user decision), NLM holder translation helpers, and Prometheus metrics for cross-protocol events.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-cross-protocol-integration/05-CONTEXT.md
@.planning/phases/05-cross-protocol-integration/05-RESEARCH.md
@pkg/metadata/lock/types.go
@pkg/metadata/lock/store.go
@pkg/metadata/lock/lease_types.go
@pkg/metadata/service.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create UnifiedLockView struct and query API</name>
  <files>pkg/metadata/unified_view.go</files>
  <action>
Create new file `pkg/metadata/unified_view.go` (NOT in pkg/metadata/lock/ - per CONTEXT.md decision: "UnifiedLockView struct: New struct in `pkg/metadata/` owned by MetadataService but separate for cleanliness"):

1. **FileLocksInfo struct** - Contains query results:
   ```go
   type FileLocksInfo struct {
       ByteRangeLocks []*lock.EnhancedLock // NLM/SMB byte-range locks
       Leases         []*lock.EnhancedLock // SMB2/3 leases (whole-file)
   }
   ```

2. **UnifiedLockView struct** - Provides unified query API:
   ```go
   type UnifiedLockView struct {
       lockStore lock.LockStore
   }
   ```

3. **NewUnifiedLockView(store lock.LockStore)** - Constructor

4. **GetAllLocksOnFile(ctx context.Context, fileHandle lock.FileHandle) (*FileLocksInfo, error)**:
   - Query lockStore.ListLocks with FileID filter
   - Separate results into ByteRangeLocks (Lease == nil) and Leases (Lease != nil)
   - Return FileLocksInfo with both collections

5. **HasConflictingLocks(ctx context.Context, fileHandle lock.FileHandle, lockType lock.LockType) (bool, []*lock.EnhancedLock, error)**:
   - Helper to check if any conflicting locks exist
   - Returns conflicting locks for holder info

Add comprehensive doc comments explaining cross-protocol usage.
  </action>
  <verify>
    go build ./pkg/metadata/...
    go test ./pkg/metadata/... -run TestUnified -v
  </verify>
  <done>
    UnifiedLockView in pkg/metadata/unified_view.go can query all locks on a file and separate them by type (byte-range vs lease).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create cross-protocol translation helpers</name>
  <files>pkg/metadata/lock/cross_protocol.go</files>
  <action>
Create new file `pkg/metadata/lock/cross_protocol.go` (lock-specific logic stays in lock package):

1. **NLMHolderInfo struct** - NLM-compatible holder info:
   ```go
   type NLMHolderInfo struct {
       CallerName string   // "smb:<clientID>" for SMB leases
       Svid       int32    // 0 for SMB (no process ID)
       OH         []byte   // LeaseKey bytes for SMB
       Offset     uint64   // 0 for leases (whole file)
       Length     uint64   // ^uint64(0) for leases (whole file)
       Exclusive  bool     // true if Write lease
   }
   ```

2. **TranslateToNLMHolder(lease *EnhancedLock) NLMHolderInfo**:
   - Per CONTEXT.md: owner="smb:<client>", offset=0, length=MAX
   - Extract ClientID from lease.Owner
   - Use LeaseKey as OH (first 8 bytes)
   - Exclusive = lease.Lease.HasWrite()

3. **TranslateSMBConflictReason(lock *EnhancedLock) string**:
   - Human-readable reason for SMB denial due to NLM conflict
   - Used for logging at INFO level per CONTEXT.md

Add doc comments explaining translation rules and cross-protocol semantics.
  </action>
  <verify>
    go build ./pkg/metadata/lock/...
    go test ./pkg/metadata/lock/... -run TestTranslate -v
  </verify>
  <done>
    Translation helpers convert SMB leases to NLM holder format for NLM4_DENIED responses.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add cross-protocol Prometheus metrics</name>
  <files>pkg/metadata/lock/metrics.go, pkg/metadata/service.go</files>
  <action>
Extend `pkg/metadata/lock/metrics.go` with cross-protocol metrics:

1. **cross_protocol_conflict_total** (CounterVec):
   - Labels: initiator (nfs/smb), conflicting (nfs_lock/smb_lease), resolution (denied/break_initiated/break_completed)
   - Example: initiator=nfs, conflicting=smb_lease, resolution=break_initiated

2. **cross_protocol_break_duration_seconds** (HistogramVec):
   - Labels: trigger (nfs_write/nfs_lock/nfs_remove), target (smb_write_lease/smb_handle_lease)
   - Buckets: 0.1s to ~100s exponential

3. **Helper functions** to record metrics:
   - RecordCrossProtocolConflict(initiator, conflicting, resolution string)
   - RecordCrossProtocolBreakDuration(trigger, target string, duration time.Duration)

Update `pkg/metadata/service.go`:
- Add UnifiedLockView field to MetadataService (one per share, alongside LockManager)
- Initialize in RegisterStoreForShare when LockStore is available
- Add GetUnifiedLockView(shareName string) method
  </action>
  <verify>
    go build ./pkg/metadata/...
    go test ./pkg/metadata/... -race -v
  </verify>
  <done>
    Cross-protocol events are observable via Prometheus metrics. MetadataService owns UnifiedLockView per share.
  </done>
</task>

</tasks>

<verification>
All verification commands should pass:

```bash
# Build
go build ./pkg/metadata/...

# Unit tests
go test ./pkg/metadata/lock/... -race -v
go test ./pkg/metadata/... -race -v

# Verify new types exported
go doc github.com/marmos91/dittofs/pkg/metadata | grep -E "UnifiedLockView|FileLocksInfo"
go doc github.com/marmos91/dittofs/pkg/metadata/lock | grep -E "NLMHolderInfo"
```
</verification>

<success_criteria>
- UnifiedLockView in pkg/metadata/unified_view.go (NOT pkg/metadata/lock/)
- UnifiedLockView.GetAllLocksOnFile returns both NLM locks and SMB leases
- TranslateToNLMHolder produces valid NLM holder info from SMB lease
- Cross-protocol metrics registered and recordable
- MetadataService provides UnifiedLockView per share
- All tests pass with race detector
</success_criteria>

<output>
After completion, create `.planning/phases/05-cross-protocol-integration/05-01-SUMMARY.md`
</output>
