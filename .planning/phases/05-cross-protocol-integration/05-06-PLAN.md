---
phase: 05-cross-protocol-integration
plan: 06
type: execute
wave: 2
depends_on: ["05-05"]
files_modified:
  - test/e2e/framework/mount.go
  - test/e2e/framework/docker_cifs.go
  - test/e2e/cross_protocol_lock_test.go
  - test/e2e/grace_period_test.go
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "E2E tests can mount SMB shares using CIFS client"
    - "Cross-protocol lock tests run with both NFS and SMB mounts"
    - "Grace period tests verify SMB lease reclaim behavior"
  artifacts:
    - path: "test/e2e/framework/docker_cifs.go"
      provides: "Docker-based CIFS mount helper for E2E tests"
      min_lines: 100
      exports: ["MountSMBWithDocker", "SMBDockerMount"]
    - path: "test/e2e/framework/mount.go"
      provides: "Updated MountSMB with fallback to Docker-based mount"
      contains: "MountSMBWithDocker"
    - path: "test/e2e/cross_protocol_lock_test.go"
      provides: "Working cross-protocol lock tests"
      contains: "TestCrossProtocolLocking"
    - path: "test/e2e/grace_period_test.go"
      provides: "Working SMB lease grace period tests"
      contains: "TestGracePeriodWithSMBLeases"
  key_links:
    - from: "test/e2e/cross_protocol_lock_test.go"
      to: "test/e2e/framework/mount.go"
      via: "MountSMB call"
      pattern: "framework\\.MountSMB"
    - from: "test/e2e/framework/mount.go"
      to: "test/e2e/framework/docker_cifs.go"
      via: "Fallback to Docker mount"
      pattern: "MountSMBWithDocker"
---

<objective>
Enable E2E tests to use actual SMB/CIFS mounts for cross-protocol testing.

Purpose: Close the verification gap where E2E tests exist but cannot be executed because SMB mount requires CIFS client (mount.cifs on Linux, mount_smbfs on macOS). This plan adds Docker-based CIFS mounting as a fallback.

Output: Docker-based CIFS mount helper, updated test framework, working cross-protocol E2E tests.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-cross-protocol-integration/05-VERIFICATION.md
@.planning/phases/05-cross-protocol-integration/05-CONTEXT.md
@.planning/phases/05-cross-protocol-integration/05-05-PLAN.md
@test/e2e/framework/mount.go
@test/e2e/cross_protocol_lock_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Docker-based CIFS mount helper</name>
  <files>
    test/e2e/framework/docker_cifs.go
  </files>
  <action>
Create `test/e2e/framework/docker_cifs.go` with Docker-based SMB mount functionality:

1. Add build tag `//go:build e2e`

2. Create `SMBDockerMount` struct:
   ```go
   type SMBDockerMount struct {
       T            *testing.T
       ContainerID  string        // Docker container ID
       HostPath     string        // Path on host where mount is exposed
       Protocol     string        // Always "smb"
       Port         int           // SMB server port
       mounted      bool
   }
   ```

3. Create `MountSMBWithDocker` function:
   - Parameters: t *testing.T, port int, creds SMBCredentials
   - Returns: *SMBDockerMount
   - Implementation:
     a. Check if Docker is available (`docker version`)
     b. Create temp directory for mount data exchange
     c. Run Alpine container with CIFS utils:
        ```bash
        docker run -d --rm --privileged \
          --network host \
          -v /tmp/smb-mount-{id}:/mnt/smb \
          alpine:latest \
          sh -c "apk add --no-cache cifs-utils && \
                 mkdir -p /mnt/smb && \
                 mount -t cifs //localhost/export /mnt/smb \
                 -o port={port},username={user},password={pass},vers=2.1 && \
                 tail -f /dev/null"
        ```
     d. Wait for mount to be ready (check container logs)
     e. Return SMBDockerMount with container ID and host path

4. Add `Cleanup` method to SMBDockerMount:
   - Runs `docker stop {containerID}`
   - Removes temp directory
   - Handles cleanup errors gracefully

5. Add `FilePath` method to SMBDockerMount:
   - Returns path within the mounted share
   - Accounts for Docker volume mapping

6. Add `CopyFileToMount` and `CopyFileFromMount` helpers:
   - Use `docker cp` to transfer files between host and container mount
   - Essential for tests that need to read/write files via SMB

7. Add `IsDockerAvailable` helper function:
   - Checks if Docker is running and accessible
   - Returns bool and optional error message
  </action>
  <verify>
    `go build -tags=e2e ./test/e2e/framework/...` succeeds.
  </verify>
  <done>
    docker_cifs.go exists with MountSMBWithDocker, SMBDockerMount struct, and helper methods.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update MountSMB with Docker fallback</name>
  <files>
    test/e2e/framework/mount.go
  </files>
  <action>
1. Modify `MountSMB` function to try native mount first, then fallback to Docker:
   ```go
   func MountSMB(t *testing.T, port int, creds SMBCredentials) *Mount {
       // Try native mount first (existing logic)
       mount, err := tryNativeSMBMount(t, port, creds)
       if err == nil {
           return mount
       }

       // Log native mount failure
       t.Logf("Native SMB mount failed: %v, trying Docker-based mount", err)

       // Fallback to Docker-based mount
       if IsDockerAvailable() {
           dockerMount := MountSMBWithDocker(t, port, creds)
           // Wrap in Mount interface for compatibility
           return &Mount{
               T:        t,
               Path:     dockerMount.HostPath,
               Protocol: "smb",
               Port:     port,
               mounted:  true,
               dockerMount: dockerMount, // New field
           }
       }

       t.Fatalf("SMB mount failed: native mount unavailable and Docker not available")
       return nil
   }
   ```

2. Extract existing MountSMB logic into `tryNativeSMBMount`:
   - Returns (*Mount, error) instead of fataling
   - Allows MountSMB to decide how to handle failure

3. Update `Mount` struct to optionally track Docker mount:
   ```go
   type Mount struct {
       // ... existing fields ...
       dockerMount *SMBDockerMount // Non-nil if using Docker-based mount
   }
   ```

4. Update `Cleanup` method to handle Docker cleanup:
   ```go
   func (m *Mount) Cleanup() {
       if m.dockerMount != nil {
           m.dockerMount.Cleanup()
           return
       }
       // ... existing cleanup logic ...
   }
   ```

5. Update `FilePath` method:
   ```go
   func (m *Mount) FilePath(relativePath string) string {
       if m.dockerMount != nil {
           return m.dockerMount.FilePath(relativePath)
       }
       return filepath.Join(m.Path, relativePath)
   }
   ```
  </action>
  <verify>
    `go build -tags=e2e ./test/e2e/framework/...` succeeds.
    Existing NFS-only tests still work.
  </verify>
  <done>
    MountSMB tries native mount first, falls back to Docker. Mount struct supports both modes.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update cross-protocol and grace period tests for Docker mount</name>
  <files>
    test/e2e/cross_protocol_lock_test.go
    test/e2e/grace_period_test.go
  </files>
  <action>
1. Update `TestCrossProtocolLocking` in cross_protocol_lock_test.go:
   - Add skip condition if neither native CIFS nor Docker available:
     ```go
     if !framework.IsNativeSMBAvailable() && !framework.IsDockerAvailable() {
         t.Skip("Skipping: no SMB mount capability (need CIFS client or Docker)")
     }
     ```
   - Log which mount method is being used for debugging
   - File operations may need adjustment for Docker mount:
     - Use `os.ReadFile/WriteFile` through mount path
     - For Docker mount, files written to HostPath appear in container

2. Update `TestCrossProtocolLockingByteRange` similarly

3. Update `TestGracePeriodWithSMBLeases` in grace_period_test.go:
   - Add same skip condition
   - This test currently just simulates behavior - update to actually test reclaim:
     ```go
     // After SMB lease established, simulate server restart
     // 1. Record current lease state
     // 2. Stop server (sp.StopGracefully)
     // 3. Start new server (sp2)
     // 4. Remount SMB (triggers reconnect with lease reclaim)
     // 5. Verify lease still functional
     ```

4. Update `TestCrossProtocolReclaim` for actual SMB lease reclaim testing:
   - With plan 05-05's ReclaimLeaseSMB, this can now actually verify reclaim

5. Add helper function `SkipIfNoSMBMount`:
   ```go
   func SkipIfNoSMBMount(t *testing.T) {
       t.Helper()
       if !IsNativeSMBAvailable() && !IsDockerAvailable() {
           t.Skip("Skipping: requires SMB mount capability (CIFS or Docker)")
       }
   }
   ```

6. Add `IsNativeSMBAvailable` helper to check for mount.cifs/mount_smbfs
  </action>
  <verify>
    `go build -tags=e2e ./test/e2e/...` succeeds.
    If Docker available: `sudo go test -tags=e2e -v -run TestCrossProtocolLocking ./test/e2e/` runs tests.
    If Docker not available: Tests skip gracefully with clear message.
  </verify>
  <done>
    Cross-protocol tests work with Docker-based SMB mount. Grace period SMB tests verify actual reclaim behavior.
  </done>
</task>

</tasks>

<verification>
1. Build: `go build -tags=e2e ./test/e2e/...` succeeds
2. Docker check: `go test -tags=e2e -v -run TestIsDockerAvailable ./test/e2e/framework/` passes
3. With Docker: `sudo go test -tags=e2e -v -timeout 10m -run TestCrossProtocolLocking ./test/e2e/` executes
4. Without Docker: Tests skip gracefully with informative message
5. Grace period tests verify SMB lease reclaim when Docker available
</verification>

<success_criteria>
1. docker_cifs.go provides Docker-based SMB mount functionality
2. MountSMB transparently falls back to Docker when native CIFS unavailable
3. Cross-protocol lock tests execute successfully with Docker mount
4. Grace period SMB lease tests verify actual reclaim behavior
5. Tests skip gracefully on systems without CIFS or Docker
6. All existing E2E tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-cross-protocol-integration/05-06-SUMMARY.md`
</output>
