---
phase: 05-cross-protocol-integration
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - internal/protocol/smb/v2/handlers/oplock.go
  - internal/protocol/smb/v2/handlers/create.go
  - internal/protocol/smb/v2/handlers/lock.go
  - internal/protocol/smb/v2/handlers/cross_protocol.go
autonomous: true

must_haves:
  truths:
    - "SMB lease request denied immediately when NLM exclusive lock exists"
    - "SMB returns STATUS_LOCK_NOT_GRANTED for NLM lock conflicts"
    - "SMB shared access coexists with NLM shared locks"
  artifacts:
    - path: "internal/protocol/smb/v2/handlers/oplock.go"
      provides: "NLM lock checking in RequestLease"
      contains: "ListLocks.*IsLease.*false"
    - path: "internal/protocol/smb/v2/handlers/cross_protocol.go"
      provides: "Status code selection for NLM conflicts"
      exports: ["statusForNLMConflict"]
  key_links:
    - from: "internal/protocol/smb/v2/handlers/oplock.go"
      to: "pkg/metadata/lock/store.go"
      via: "LockStore.ListLocks query for byte-range locks"
      pattern: "lockStore\\.ListLocks"
    - from: "internal/protocol/smb/v2/handlers/create.go"
      to: "internal/protocol/smb/v2/handlers/oplock.go"
      via: "RequestLease call with NLM check"
      pattern: "RequestLease"
---

<objective>
Integrate SMB handlers with NLM lock visibility for cross-protocol locking.

Purpose: When SMB clients request leases, they must respect NLM byte-range locks. Per CONTEXT.md: NFS locks win over SMB opportunistic leases (deny immediately). This plan adds NLM lock checking to SMB lease requests.

Output: SMB handlers that check NLM locks and deny leases when conflicts exist, with appropriate STATUS codes.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-cross-protocol-integration/05-CONTEXT.md
@.planning/phases/05-cross-protocol-integration/05-RESEARCH.md
@.planning/phases/05-cross-protocol-integration/05-01-SUMMARY.md
@internal/protocol/smb/v2/handlers/oplock.go
@internal/protocol/smb/v2/handlers/create.go
@pkg/metadata/lock/store.go
@pkg/metadata/lock/types.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SMB cross-protocol helpers</name>
  <files>internal/protocol/smb/v2/handlers/cross_protocol.go</files>
  <action>
Create new file `internal/protocol/smb/v2/handlers/cross_protocol.go`:

1. **statusForNLMConflict(nlmLock *lock.EnhancedLock) uint32**:
   - Return STATUS_LOCK_NOT_GRANTED (0xC0000054) for byte-range lock conflicts
   - Per MS-ERREF: STATUS_LOCK_NOT_GRANTED is appropriate for lock conflicts
   - NOT STATUS_SHARING_VIOLATION (that's for share mode conflicts at open time)

2. **formatNLMLockInfo(nlmLock *lock.EnhancedLock) string**:
   - Format NLM lock info for logging
   - Include: owner, offset, length, type (shared/exclusive)
   - Used for INFO-level cross-protocol conflict logs

3. **checkNLMLocksForLeaseConflict(ctx context.Context, lockStore lock.LockStore, fileHandle lock.FileHandle, requestedState uint32) ([]*lock.EnhancedLock, error)**:
   - Query lockStore.ListLocks with FileID and IsLease=false (byte-range only)
   - Check each lock for conflict with requested lease state:
     - Write lease requested: ANY exclusive NLM lock conflicts
     - Write lease requested: ANY shared NLM lock also conflicts (Write needs exclusive)
     - Read lease requested: Exclusive NLM locks conflict
   - Return list of conflicting locks (empty if no conflicts)

Add comprehensive doc comments explaining cross-protocol semantics and MS-ERREF reference.
  </action>
  <verify>
    go build ./internal/protocol/smb/...
  </verify>
  <done>
    SMB cross-protocol helpers provide status code selection and NLM conflict detection.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add NLM lock checking to RequestLease</name>
  <files>internal/protocol/smb/v2/handlers/oplock.go</files>
  <action>
Update OplockManager.RequestLease method:

1. Before checking for existing leases, add NLM lock check:
   ```go
   // Check for NLM byte-range locks that conflict with lease request
   // Per CONTEXT.md: "NFS lock vs SMB Write lease: Deny SMB immediately"
   if m.lockStore != nil {
       conflicts, err := checkNLMLocksForLeaseConflict(ctx, m.lockStore, fileHandle, requestedState)
       if err != nil {
           logger.Warn("Lease: failed to check NLM locks", "error", err)
           // Proceed anyway - fail open for availability
       } else if len(conflicts) > 0 {
           // Log at INFO level per CONTEXT.md (working as designed)
           logger.Info("Lease: denied due to NLM lock",
               "leaseKey", fmt.Sprintf("%x", leaseKey),
               "nlmLock", formatNLMLockInfo(conflicts[0]))

           // Record metric
           lock.RecordCrossProtocolConflict("smb", "nfs_lock", "denied")

           // Return None - caller will set STATUS_LOCK_NOT_GRANTED
           return lock.LeaseStateNone, 0, nil
       }
   }
   ```

2. Update return documentation to explain when LeaseStateNone indicates NLM conflict.

3. Ensure the check runs for ALL lease requests, not just Write leases:
   - Write lease: conflicts with ANY NLM lock (exclusive access required)
   - Read lease: conflicts with exclusive NLM locks only
   - Handle lease: does not conflict with NLM locks (H is about delete notification)
  </action>
  <verify>
    go build ./internal/protocol/smb/...
    go test ./internal/protocol/smb/... -race -v
  </verify>
  <done>
    RequestLease denies Write/Read leases when conflicting NLM locks exist.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update SMB CREATE to handle NLM conflicts</name>
  <files>internal/protocol/smb/v2/handlers/create.go</files>
  <action>
Update CREATE handler to handle NLM lock conflicts in lease requests:

1. When ProcessLeaseCreateContext returns LeaseStateNone, check if it's due to NLM conflict:
   - If original request was for Write/Read lease and result is None
   - Set response status to STATUS_LOCK_NOT_GRANTED
   - Include appropriate error in response

2. Add context to lease denial logging:
   ```go
   if grantedState == lock.LeaseStateNone && (requestedState & (lock.LeaseStateRead | lock.LeaseStateWrite)) != 0 {
       // Could be NLM conflict - set appropriate status
       // Note: STATUS_LOCK_NOT_GRANTED tells client that a lock exists
       logger.Debug("CREATE: lease denied, possibly due to NLM conflict",
           "requestedState", requestedState,
           "grantedState", grantedState)
   }
   ```

3. Ensure OplockLevel in response reflects the denial:
   - OplockLevel = OplockLevelNone when lease denied
   - CreateContexts still includes RsLs with LeaseState=0

4. Do NOT break existing SMB-only lease conflict handling - NLM check is additive.
  </action>
  <verify>
    go build ./internal/protocol/smb/...
    go test ./internal/protocol/smb/... -race -v
  </verify>
  <done>
    SMB CREATE returns STATUS_LOCK_NOT_GRANTED when lease denied due to NLM lock.
  </done>
</task>

</tasks>

<verification>
All verification commands should pass:

```bash
# Build
go build ./internal/protocol/smb/...

# Unit tests
go test ./internal/protocol/smb/... -race -v

# Verify NLM conflict handling
go test ./internal/protocol/smb/... -run TestLease -v
```
</verification>

<success_criteria>
- SMB lease requests check for NLM byte-range locks
- Write lease denied when ANY NLM lock exists on file
- Read lease denied when exclusive NLM lock exists
- STATUS_LOCK_NOT_GRANTED returned for NLM conflicts
- Cross-protocol conflicts logged at INFO level
- Existing SMB-only conflict handling unchanged
- All tests pass with race detector
</success_criteria>

<output>
After completion, create `.planning/phases/05-cross-protocol-integration/05-03-SUMMARY.md`
</output>
