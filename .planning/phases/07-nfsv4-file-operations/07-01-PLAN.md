---
phase: 07-nfsv4-file-operations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/protocol/nfs/v4/handlers/helpers.go
  - internal/protocol/nfs/v4/attrs/encode.go
  - internal/protocol/nfs/v4/handlers/lookup.go
  - internal/protocol/nfs/v4/handlers/lookupp.go
  - internal/protocol/nfs/v4/handlers/getattr.go
  - internal/protocol/nfs/v4/handlers/readdir.go
  - internal/protocol/nfs/v4/handlers/access.go
  - internal/protocol/nfs/v4/handlers/readlink.go
  - internal/protocol/nfs/v4/handlers/handler.go
  - internal/protocol/nfs/v4/handlers/helpers_test.go
  - internal/protocol/nfs/v4/handlers/realfs_test.go
autonomous: true

must_haves:
  truths:
    - "NFSv4 LOOKUP on a real filesystem directory resolves child entries"
    - "NFSv4 LOOKUPP from inside a real share navigates to parent, and from share root crosses back to pseudo-fs"
    - "NFSv4 GETATTR on a real file returns correct type, size, mode, times, owner"
    - "NFSv4 READDIR on a real directory returns entries with cookies and requested attributes"
    - "NFSv4 ACCESS on a real file checks Unix permission bits"
    - "NFSv4 READLINK on a symlink returns the target path"
  artifacts:
    - path: "internal/protocol/nfs/v4/handlers/helpers.go"
      provides: "buildV4AuthContext(), getMetadataService(), getPayloadService() shared helpers"
      min_lines: 40
    - path: "internal/protocol/nfs/v4/attrs/encode.go"
      provides: "EncodeRealFileAttrs() for real file attribute encoding"
      contains: "func EncodeRealFileAttrs"
    - path: "internal/protocol/nfs/v4/handlers/readlink.go"
      provides: "READLINK operation handler"
      contains: "func.*handleReadLink"
  key_links:
    - from: "internal/protocol/nfs/v4/handlers/helpers.go"
      to: "pkg/metadata"
      via: "DecodeFileHandle for share extraction, AuthContext building"
      pattern: "metadata\\.DecodeFileHandle"
    - from: "internal/protocol/nfs/v4/handlers/lookup.go"
      to: "pkg/metadata"
      via: "MetadataService.Lookup for real-FS name resolution"
      pattern: "metaSvc\\.Lookup"
    - from: "internal/protocol/nfs/v4/attrs/encode.go"
      to: "pkg/metadata"
      via: "FileAttr fields mapped to NFSv4 fattr4 encoding"
      pattern: "EncodeRealFileAttrs"
---

<objective>
Upgrade 5 existing NFSv4 operation handlers (LOOKUP, LOOKUPP, GETATTR, READDIR, ACCESS) from pseudo-fs-only to support real filesystems, add READLINK handler, and build shared helper infrastructure for all Phase 7 handlers.

Purpose: This is the foundation plan that enables NFSv4 clients to navigate and read attributes of real files/directories. Without this, NFSv4 can only browse the virtual namespace.

Output: Shared auth context builder, real file attribute encoder, 5 upgraded handlers with real-FS branches, 1 new READLINK handler, comprehensive tests.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-nfsv4-file-operations/07-RESEARCH.md
@.planning/phases/06-nfsv4-protocol-foundation/06-01-SUMMARY.md
@.planning/phases/06-nfsv4-protocol-foundation/06-02-SUMMARY.md
@.planning/phases/06-nfsv4-protocol-foundation/06-03-SUMMARY.md
@internal/protocol/nfs/v4/handlers/handler.go
@internal/protocol/nfs/v4/handlers/lookup.go
@internal/protocol/nfs/v4/handlers/lookupp.go
@internal/protocol/nfs/v4/handlers/getattr.go
@internal/protocol/nfs/v4/handlers/readdir.go
@internal/protocol/nfs/v4/handlers/access.go
@internal/protocol/nfs/v4/attrs/encode.go
@internal/protocol/nfs/v4/types/types.go
@internal/protocol/nfs/v4/types/constants.go
@internal/protocol/nfs/v3/handlers/auth_helper.go
@pkg/metadata/service.go
@pkg/metadata/file.go
@pkg/metadata/directory.go
@pkg/metadata/types.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Shared helpers and real file attribute encoder</name>
  <files>
    internal/protocol/nfs/v4/handlers/helpers.go
    internal/protocol/nfs/v4/attrs/encode.go
    internal/protocol/nfs/v4/handlers/helpers_test.go
  </files>
  <action>
Create `internal/protocol/nfs/v4/handlers/helpers.go` with these shared helpers:

1. **`buildV4AuthContext(ctx *types.CompoundContext, handle []byte) (*metadata.AuthContext, string, error)`**:
   - Extract share name from handle via `metadata.DecodeFileHandle(metadata.FileHandle(handle))`
   - Build `metadata.Identity` from CompoundContext UID/GID/GIDs fields
   - Set Username to `fmt.Sprintf("uid:%d", *ctx.UID)` when UID is non-nil
   - Call `h.Registry.ApplyIdentityMapping(shareName, identity)` for squash rules
   - Look up share via `h.Registry.GetShare(shareName)` for read-only flag
   - Resolve permissions via identity store (mirror pattern from v3 `BuildAuthContextWithMapping` in `internal/protocol/nfs/v3/handlers/auth_helper.go`)
   - Return `*metadata.AuthContext` with Context, ClientAddr, AuthMethod, Identity, ShareReadOnly
   - On DecodeFileHandle error, return nil with error
   - Method receiver on `*Handler`

2. **`getMetadataServiceForCtx(h *Handler) (*metadata.MetadataService, error)`**: Returns `h.Registry.GetMetadataService()` with nil-registry guard.

3. **`getPayloadServiceForCtx(h *Handler) (*payload.PayloadService, error)`**: Returns `h.Registry.GetPayloadService()` with nil-registry guard.

4. **`encodeChangeInfo4(buf *bytes.Buffer, atomic bool, before, after uint64)`**: Encode change_info4 struct (atomic bool as uint32 + before uint64 + after uint64). This will be used by CREATE, REMOVE, and OPEN in later plans.

Extend `internal/protocol/nfs/v4/attrs/encode.go` with:

5. **`EncodeRealFileAttrs(buf *bytes.Buffer, requested []uint32, file *metadata.File, handle metadata.FileHandle) error`**:
   - Compute `supported = SupportedRealAttrs()` (same as SupportedAttrs but also includes SIZE, MODE, NUMLINKS, OWNER, OWNER_GROUP, SPACE_USED, TIME_ACCESS, TIME_MODIFY, FILEHANDLE)
   - Compute `responseBitmap = Intersect(requested, supported)`
   - Encode responseBitmap via `EncodeBitmap4`
   - Build attr data buffer, iterate bits in ascending order:
     - FATTR4_SUPPORTED_ATTRS: encode `SupportedRealAttrs()` bitmap
     - FATTR4_TYPE: map `file.Type` to NF4REG/NF4DIR/NF4LNK/NF4SOCK/NF4FIFO/NF4BLK/NF4CHR
     - FATTR4_FH_EXPIRE_TYPE: FH4_PERSISTENT (handles don't expire)
     - FATTR4_CHANGE: `file.Ctime.UnixNano()` as uint64 (changeid4)
     - FATTR4_SIZE: `file.Size` as uint64
     - FATTR4_LINK_SUPPORT: true
     - FATTR4_SYMLINK_SUPPORT: true
     - FATTR4_NAMED_ATTR: false
     - FATTR4_FSID: major=1, minor=hash of share name (consistent across calls)
     - FATTR4_UNIQUE_HANDLES: true
     - FATTR4_LEASE_TIME: DefaultLeaseTime
     - FATTR4_RDATTR_ERROR: NFS4_OK
     - FATTR4_FILEHANDLE: encode handle as XDR opaque
     - FATTR4_FILEID: use file handle hash or file ID if available
     - FATTR4_MODE: `file.Mode & 0o7777` as uint32
     - FATTR4_NUMLINKS: `file.NLink` as uint32
     - FATTR4_OWNER: format as `fmt.Sprintf("%d", file.UID)` (numeric string per NFSv4 convention when no idmapping)
     - FATTR4_OWNER_GROUP: format as `fmt.Sprintf("%d", file.GID)` (numeric string)
     - FATTR4_SPACE_USED: `file.Size` as uint64 (approximation)
     - FATTR4_TIME_ACCESS: encode as nfstime4 (seconds int64 + nseconds uint32)
     - FATTR4_TIME_MODIFY: encode as nfstime4
     - FATTR4_MOUNTED_ON_FILEID: same as FILEID
   - Write attr data as XDR opaque (length-prefixed)
   - Add `SupportedRealAttrs()` function returning the full supported bitmap

Also add `mapFileTypeToNFS4(fileType metadata.FileType) uint32` helper to map metadata file types to NFS4 types.

Create `internal/protocol/nfs/v4/handlers/helpers_test.go` with tests for:
- `buildV4AuthContext` with valid handle, invalid handle, nil registry
- `encodeChangeInfo4` encoding correctness
  </action>
  <verify>
Run `go build ./internal/protocol/nfs/v4/...` and `go test ./internal/protocol/nfs/v4/... -count=1 -race` -- all pass.
  </verify>
  <done>
helpers.go exports buildV4AuthContext, getMetadataServiceForCtx, getPayloadServiceForCtx, encodeChangeInfo4. attrs/encode.go exports EncodeRealFileAttrs and SupportedRealAttrs. All compile and pass tests.
  </done>
</task>

<task type="auto">
  <name>Task 2: Upgrade 5 existing handlers for real-FS + add READLINK</name>
  <files>
    internal/protocol/nfs/v4/handlers/lookup.go
    internal/protocol/nfs/v4/handlers/lookupp.go
    internal/protocol/nfs/v4/handlers/getattr.go
    internal/protocol/nfs/v4/handlers/readdir.go
    internal/protocol/nfs/v4/handlers/access.go
    internal/protocol/nfs/v4/handlers/readlink.go
    internal/protocol/nfs/v4/handlers/handler.go
    internal/protocol/nfs/v4/handlers/realfs_test.go
  </files>
  <action>
**LOOKUP (lookup.go):** Replace the `NFS4ERR_NOTSUPP` real-handle branch with `lookupInRealFS`:
- Call `h.buildV4AuthContext(ctx, ctx.CurrentFH)` to get auth context
- Call `metaSvc.Lookup(authCtx, metadata.FileHandle(ctx.CurrentFH), name)` to resolve name
- On success, encode the child's file handle: `metadata.EncodeFileHandle(child)` -- note child is `*metadata.File`
- Copy-on-set the result into `ctx.CurrentFH` (make + copy pattern)
- Map errors via `types.MapMetadataErrorToNFS4(err)`
- Return status-only response (LOOKUP result has no body beyond status)

**LOOKUPP (lookupp.go):** Replace `NFS4ERR_NOTSUPP` real-handle branch with `lookupParentInRealFS`:
- Call `h.buildV4AuthContext(ctx, ctx.CurrentFH)` to get auth context and share name
- Call `metaSvc.GetFile(authCtx.Context, metadata.FileHandle(ctx.CurrentFH))` to get current file
- If the current file IS the share root (its parent handle resolves to itself or returns NOENT), cross back to pseudo-fs:
  - Find the pseudo-fs junction for this share name via `h.PseudoFS.FindJunction(shareName)`
  - Set `ctx.CurrentFH` to that junction's handle (copy-on-set)
- Otherwise: Call `metaSvc.Lookup` or get parent handle from the file's ParentHandle field
  - Use the parent handle from `file.ParentHandle` if available
  - Copy-on-set parent handle into `ctx.CurrentFH`
- Map errors appropriately

**GETATTR (getattr.go):** Replace `NFS4ERR_NOTSUPP` real-handle branch with `getAttrRealFS`:
- Call `h.buildV4AuthContext(ctx, ctx.CurrentFH)` (need share context)
- Call `metaSvc.GetFile(authCtx.Context, metadata.FileHandle(ctx.CurrentFH))`
- Call `attrs.EncodeRealFileAttrs(&buf, requested, file, metadata.FileHandle(ctx.CurrentFH))`
- Return OK with encoded attrs

**READDIR (readdir.go):** Replace `NFS4ERR_NOTSUPP` real-handle branch with `readDirRealFS`:
- Call `h.buildV4AuthContext(ctx, ctx.CurrentFH)`
- Call `metaSvc.ReadDirectory(authCtx, metadata.FileHandle(ctx.CurrentFH), cookie, maxcount)`
- Iterate over `ReadDirPage.Entries`, for each entry:
  - Write `value_follows = 1` (uint32)
  - Write cookie (uint64) from entry.Cookie
  - Write name (XDR string) from entry.Name
  - Encode entry attributes via `attrs.EncodeRealFileAttrs()` using entry's File data
  - Respect maxcount by pre-encoding each entry and checking accumulated size
- Write `value_follows = 0` at end
- Write `eof` bool from `ReadDirPage.EOF`
- Write cookieverf as 8 zero bytes (simplified; Phase 9 adds proper verifier)

**ACCESS (access.go):** Replace `NFS4ERR_NOTSUPP` real-handle branch with real permission check:
- Call `h.buildV4AuthContext(ctx, ctx.CurrentFH)` to get auth context
- Call `metaSvc.GetFile(authCtx.Context, metadata.FileHandle(ctx.CurrentFH))` to get file attrs
- Check Unix permission bits against UID/GID:
  - ACCESS4_READ (0x01): check read bit for owner/group/other based on UID/GID
  - ACCESS4_LOOKUP (0x02): for dirs, check execute bit
  - ACCESS4_MODIFY (0x04): check write bit
  - ACCESS4_EXTEND (0x08): check write bit
  - ACCESS4_DELETE (0x10): check parent write bit (simplified: grant if write on current)
  - ACCESS4_EXECUTE (0x20): check execute bit
- Return supported = all 6 bits, access = bits that passed permission check
- Note: MetadataService.CheckPermissions does this, but for v4 Phase 7 a simplified approach checking mode bits against the effective UID/GID is sufficient. Mirror the v3 approach.

**READLINK (readlink.go):** New handler:
- Check `RequireCurrentFH`
- If pseudo-fs handle: return `NFS4ERR_INVAL` (pseudo-fs has no symlinks)
- Call `h.buildV4AuthContext(ctx, ctx.CurrentFH)`
- Call `metaSvc.ReadSymlink(authCtx, metadata.FileHandle(ctx.CurrentFH))`
- On success: encode response as `NFS4_OK` + XDR string (link target)
- On error: map via `types.MapMetadataErrorToNFS4(err)`
- No args to decode (READLINK takes no arguments)

**handler.go:** Register READLINK in the dispatch table:
```go
h.opDispatchTable[types.OP_READLINK] = h.handleReadLink
```

**Tests (realfs_test.go):** Create comprehensive tests:
- Test LOOKUP on real-FS handle resolves child
- Test LOOKUPP from real-FS navigates to parent
- Test LOOKUPP from share root crosses to pseudo-fs
- Test GETATTR on real file returns correct type, size, mode
- Test READDIR on real directory lists entries
- Test ACCESS returns correct permission bits
- Test READLINK returns symlink target
- Use the established test patterns from ops_test.go (mock registry, encode/decode helpers)
  </action>
  <verify>
Run `go test ./internal/protocol/nfs/v4/... -count=1 -race -v` -- all tests pass including new realfs_test.go. Run `go vet ./internal/protocol/nfs/v4/...` -- no issues.
  </verify>
  <done>
All 5 existing handlers (LOOKUP, LOOKUPP, GETATTR, READDIR, ACCESS) work with both pseudo-fs and real filesystem handles. READLINK handler registered and functional. Pseudo-fs behavior unchanged. Real-FS operations delegate to MetadataService correctly.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` succeeds
2. `go test ./internal/protocol/nfs/v4/... -count=1 -race` passes all tests
3. `go vet ./internal/protocol/nfs/v4/...` reports no issues
4. Existing pseudo-fs tests from Phase 6 still pass (no regression)
5. New real-FS tests demonstrate LOOKUP, GETATTR, READDIR, ACCESS, READLINK working with real file handles
</verification>

<success_criteria>
- buildV4AuthContext correctly extracts share name, applies identity mapping, returns AuthContext
- EncodeRealFileAttrs encodes all mandatory + key recommended attributes for real files
- LOOKUP resolves names in real directories (not just pseudo-fs)
- LOOKUPP navigates to parent in real-FS and crosses back to pseudo-fs at share root
- GETATTR returns real file attributes (type, size, mode, times)
- READDIR lists real directory entries with cookies and attributes
- ACCESS checks real Unix permission bits
- READLINK returns symlink targets
- All 6 Phase 6 pseudo-fs tests still pass (no regression)
</success_criteria>

<output>
After completion, create `.planning/phases/07-nfsv4-file-operations/07-01-SUMMARY.md`
</output>
