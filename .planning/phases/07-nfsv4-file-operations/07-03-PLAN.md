---
phase: 07-nfsv4-file-operations
plan: 03
type: execute
wave: 3
depends_on: ["07-01", "07-02"]
files_modified:
  - internal/protocol/nfs/v4/handlers/open.go
  - internal/protocol/nfs/v4/handlers/close.go
  - internal/protocol/nfs/v4/handlers/read.go
  - internal/protocol/nfs/v4/handlers/write.go
  - internal/protocol/nfs/v4/handlers/commit.go
  - internal/protocol/nfs/v4/handlers/handler.go
  - internal/protocol/nfs/v4/types/types.go
  - internal/protocol/nfs/v4/handlers/io_test.go
autonomous: true

must_haves:
  truths:
    - "NFSv4 OPEN creates regular files (OPEN4_CREATE + CLAIM_NULL) and opens existing files"
    - "NFSv4 OPEN_CONFIRM acknowledges open-owner confirmation"
    - "NFSv4 CLOSE releases open state"
    - "NFSv4 READ returns file data with EOF detection"
    - "NFSv4 WRITE stores data and returns write count with stability level"
    - "NFSv4 COMMIT flushes unstable writes to stable storage"
    - "READ/WRITE accept special stateids (all-zeros, all-ones) without validation"
  artifacts:
    - path: "internal/protocol/nfs/v4/handlers/open.go"
      provides: "OPEN and OPEN_CONFIRM handlers with placeholder stateid generation"
      contains: "func.*handleOpen"
    - path: "internal/protocol/nfs/v4/handlers/read.go"
      provides: "READ handler via PayloadService.ReadAt"
      contains: "func.*handleRead"
    - path: "internal/protocol/nfs/v4/handlers/write.go"
      provides: "WRITE handler via two-phase write pattern"
      contains: "func.*handleWrite"
    - path: "internal/protocol/nfs/v4/handlers/commit.go"
      provides: "COMMIT handler via PayloadService.Flush"
      contains: "func.*handleCommit"
    - path: "internal/protocol/nfs/v4/types/types.go"
      provides: "Stateid4 type, special stateid helpers"
      contains: "Stateid4"
  key_links:
    - from: "internal/protocol/nfs/v4/handlers/read.go"
      to: "pkg/payload"
      via: "PayloadService.ReadAt for file content"
      pattern: "payloadSvc\\.ReadAt"
    - from: "internal/protocol/nfs/v4/handlers/write.go"
      to: "pkg/metadata"
      via: "MetadataService.PrepareWrite/CommitWrite two-phase pattern"
      pattern: "metaSvc\\.(PrepareWrite|CommitWrite)"
    - from: "internal/protocol/nfs/v4/handlers/write.go"
      to: "pkg/payload"
      via: "PayloadService.WriteAt for content storage"
      pattern: "payloadSvc\\.WriteAt"
    - from: "internal/protocol/nfs/v4/handlers/commit.go"
      to: "pkg/payload"
      via: "PayloadService.Flush for durability"
      pattern: "payloadSvc\\.Flush"
---

<objective>
Implement NFSv4 stateful I/O operations: OPEN (with OPEN4_CREATE for regular files), OPEN_CONFIRM, CLOSE, READ, WRITE, and COMMIT with placeholder state management.

Purpose: This is the plan that makes NFSv4 functionally complete for file I/O. After this, NFSv4 clients can mount, browse, create files, read, write, and commit. State management uses placeholders that Phase 9 replaces with proper client ID tracking.

Output: 6 new handlers (open.go, close.go, read.go, write.go, commit.go), Stateid4 type with special stateid helpers, comprehensive I/O tests.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-nfsv4-file-operations/07-RESEARCH.md
@.planning/phases/07-nfsv4-file-operations/07-01-SUMMARY.md
@.planning/phases/07-nfsv4-file-operations/07-02-SUMMARY.md
@internal/protocol/nfs/v4/handlers/handler.go
@internal/protocol/nfs/v4/handlers/helpers.go
@internal/protocol/nfs/v4/attrs/encode.go
@internal/protocol/nfs/v4/types/constants.go
@internal/protocol/nfs/v4/types/types.go
@internal/protocol/nfs/v3/handlers/read.go
@internal/protocol/nfs/v3/handlers/write.go
@internal/protocol/nfs/v3/handlers/commit.go
@pkg/metadata/io.go
@pkg/payload/service.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Stateid types and OPEN/OPEN_CONFIRM/CLOSE handlers</name>
  <files>
    internal/protocol/nfs/v4/types/types.go
    internal/protocol/nfs/v4/handlers/open.go
    internal/protocol/nfs/v4/handlers/close.go
    internal/protocol/nfs/v4/handlers/handler.go
  </files>
  <action>
**Extend `internal/protocol/nfs/v4/types/types.go`:**

Add stateid4 type and helpers after the existing types:

```go
// NFS4_OTHER_SIZE is the size of the "other" field in stateid4 (12 bytes).
const NFS4_OTHER_SIZE = 12

// Stateid4 represents an NFSv4 state identifier (stateid4).
// Per RFC 7530 Section 9.1.4:
//   struct stateid4 {
//       uint32_t seqid;
//       opaque   other[NFS4_OTHER_SIZE];
//   }
type Stateid4 struct {
    Seqid uint32
    Other [NFS4_OTHER_SIZE]byte
}

// IsSpecialStateid returns true if the stateid is a special stateid.
// Special stateids per RFC 7530 Section 9.1.4.3:
// - Anonymous: seqid=0, other=all-zeros (standard access check, no lock state)
// - READ bypass: seqid=0, other=all-ones (bypass locks for read only)
func (s *Stateid4) IsSpecialStateid() bool {
    if s.Seqid != 0 {
        return false
    }
    allZeros := true
    allOnes := true
    for _, b := range s.Other {
        if b != 0 { allZeros = false }
        if b != 0xFF { allOnes = false }
    }
    return allZeros || allOnes
}

// DecodeStateid4 reads a stateid4 from an io.Reader.
func DecodeStateid4(reader io.Reader) (*Stateid4, error) {
    seqid, err := xdr.DecodeUint32(reader)
    if err != nil { return nil, err }
    var other [NFS4_OTHER_SIZE]byte
    if _, err := io.ReadFull(reader, other[:]); err != nil { return nil, err }
    return &Stateid4{Seqid: seqid, Other: other}, nil
}

// EncodeStateid4 writes a stateid4 to a buffer.
func EncodeStateid4(buf *bytes.Buffer, sid *Stateid4) {
    xdr.WriteUint32(buf, sid.Seqid)
    buf.Write(sid.Other[:])
}
```

Add an `import` for `"io"` and `"bytes"` and the xdr package to types.go. Also add the import for the xdr package: `"github.com/marmos91/dittofs/internal/protocol/xdr"`.

**Create `internal/protocol/nfs/v4/handlers/open.go`:**

Implement `handleOpen`:
- `RequireCurrentFH` guard
- If pseudo-fs handle: return `NFS4ERR_ROFS`
- Decode OPEN4args in strict order per RFC 7530/7531:
  1. `seqid` (uint32): open-owner sequence number (log, don't validate in Phase 7)
  2. `share_access` (uint32): OPEN4_SHARE_ACCESS_READ/WRITE/BOTH
  3. `share_deny` (uint32): OPEN4_SHARE_DENY_NONE/READ/WRITE/BOTH (log, accept but don't enforce in Phase 7)
  4. `open_owner4`: clientid (uint64) + owner (XDR opaque)
  5. `openflag4` (opentype uint32):
     - If `OPEN4_CREATE`:
       - Decode `createhow4`: createmode (uint32)
       - If UNCHECKED4 or GUARDED4: decode createattrs (fattr4 = bitmap4 + opaque)
       - If EXCLUSIVE4: decode verifier (8 bytes) -- treat as GUARDED4 for Phase 7
     - If `OPEN4_NOCREATE`: no additional data
  6. `open_claim4`: claim_type (uint32)
     - If CLAIM_NULL: decode component name (XDR string) -- the filename to open/create
     - Other claim types: return NFS4ERR_NOTSUPP for Phase 7

- Build auth context via `h.buildV4AuthContext(ctx, ctx.CurrentFH)`
- Get MetadataService

- **For CLAIM_NULL + OPEN4_NOCREATE:** Look up existing file:
  - Call `metaSvc.Lookup(authCtx, metadata.FileHandle(ctx.CurrentFH), filename)`
  - If not found: return NFS4ERR_NOENT
  - Get file attributes for the response

- **For CLAIM_NULL + OPEN4_CREATE:** Create regular file or open existing:
  - Try `metaSvc.Lookup` first
  - If GUARDED4 and file exists: return NFS4ERR_EXIST
  - If UNCHECKED4 and file exists: open existing (no error)
  - If file doesn't exist: call `metaSvc.CreateFile(authCtx, metadata.FileHandle(ctx.CurrentFH), filename, &metadata.FileAttr{Mode: 0o644, UID: uid, GID: gid})`
  - Get pre/post parent ctime for change_info4

- Set `ctx.CurrentFH` to the opened file's handle (copy-on-set)

- Generate placeholder stateid:
  ```go
  var placeholderStateid types.Stateid4
  placeholderStateid.Seqid = 1
  // Use crypto/rand for 12 bytes of "other"
  crypto_rand.Read(placeholderStateid.Other[:])
  ```

- Encode OPEN4resok:
  1. NFS4_OK status
  2. stateid4 (placeholder)
  3. change_info4 (atomic=true, before=parentCtime, after=parentCtime -- or real values if created)
  4. rflags: `OPEN4_RESULT_CONFIRM | OPEN4_RESULT_LOCKTYPE_POSIX` (always request confirmation per research)
  5. attrset: empty bitmap4 (no attrs set by server)
  6. delegation: `OPEN_DELEGATE_NONE` (uint32 = 0)

Implement `handleOpenConfirm` in the same file:
- Decode OPEN_CONFIRM4args: stateid4 + seqid (uint32)
- Phase 7 stub: just return NFS4_OK with the same stateid (seqid + 1)
- Encode OPEN_CONFIRM4resok: NFS4_OK + stateid4

**Create `internal/protocol/nfs/v4/handlers/close.go`:**

Implement `handleClose`:
- `RequireCurrentFH` guard
- If pseudo-fs handle: return NFS4ERR_INVAL
- Decode CLOSE4args: seqid (uint32) + stateid4
- Phase 7 stub: accept any stateid, return OK with a "closed" stateid (seqid=0, other=all-zeros)
- Encode CLOSE4res: NFS4_OK + stateid4 (the zeroed-out stateid)
- NOTE: Do NOT clear ctx.CurrentFH -- CLOSE does not change the current filehandle per RFC 7530

**Update `handler.go`:** Register handlers:
```go
h.opDispatchTable[types.OP_OPEN] = h.handleOpen
h.opDispatchTable[types.OP_OPEN_CONFIRM] = h.handleOpenConfirm
h.opDispatchTable[types.OP_CLOSE] = h.handleClose
```
  </action>
  <verify>
Run `go build ./internal/protocol/nfs/v4/...` -- compiles. Run `go test ./internal/protocol/nfs/v4/types/... -count=1 -race` -- types tests pass.
  </verify>
  <done>
Stateid4 type with encode/decode/special-stateid detection. OPEN handles CLAIM_NULL (open existing + create regular files), returns placeholder stateid, always requests OPEN_CONFIRM, never grants delegation. OPEN_CONFIRM accepts and echoes stateid. CLOSE accepts and returns zeroed stateid.
  </done>
</task>

<task type="auto">
  <name>Task 2: READ, WRITE, COMMIT handlers and comprehensive tests</name>
  <files>
    internal/protocol/nfs/v4/handlers/read.go
    internal/protocol/nfs/v4/handlers/write.go
    internal/protocol/nfs/v4/handlers/commit.go
    internal/protocol/nfs/v4/handlers/handler.go
    internal/protocol/nfs/v4/handlers/io_test.go
  </files>
  <action>
**Create `internal/protocol/nfs/v4/handlers/read.go`:**

Implement `handleRead`:
- `RequireCurrentFH` guard
- If pseudo-fs handle: return NFS4ERR_ISDIR (pseudo-fs has only directories)
- Decode READ4args:
  1. stateid4 (decode via `types.DecodeStateid4(reader)`)
  2. offset (uint64)
  3. count (uint32)
- **Stateid validation (Phase 7):** Accept ALL stateids -- special stateids (all-zeros, all-ones) and any stateid from OPEN. Do NOT validate. Log stateid at DEBUG level. Phase 9 adds proper validation.
- Build auth context via `h.buildV4AuthContext(ctx, ctx.CurrentFH)`
- Get MetadataService and PayloadService
- Call `metaSvc.GetFile(authCtx.Context, metadata.FileHandle(ctx.CurrentFH))` to verify file exists and get attributes
- If not a regular file: return NFS4ERR_ISDIR
- If file.Size == 0 or file.PayloadID == "": return eof=true, empty data
- If offset >= file.Size: return eof=true, empty data
- Clamp read length: `actualLen = min(count, file.Size - offset)`
- Allocate buffer: `data := make([]byte, actualLen)` (use bufpool.Get for large reads if available)
- Call `payloadSvc.ReadAt(ctx.Context, file.PayloadID, data, offset)`
  - For COW source: check `file.COWSourcePayloadID` and use `payloadSvc.ReadAtWithCOWSource` if non-empty
- Detect EOF: `eof = offset + uint64(n) >= file.Size`
- Encode READ4resok:
  1. NFS4_OK status
  2. eof (bool as uint32: 0 or 1)
  3. data (XDR opaque: uint32 length + bytes + padding to 4-byte boundary)

**Create `internal/protocol/nfs/v4/handlers/write.go`:**

Implement `handleWrite`:
- `RequireCurrentFH` guard
- If pseudo-fs handle: return NFS4ERR_ROFS
- Decode WRITE4args:
  1. stateid4 (decode via `types.DecodeStateid4(reader)`)
  2. offset (uint64)
  3. stable (uint32): UNSTABLE4, DATA_SYNC4, or FILE_SYNC4
  4. data (XDR opaque: uint32 length + bytes + padding)
- **Stateid validation:** Accept all stateids (Phase 7 stub)
- Build auth context via `h.buildV4AuthContext(ctx, ctx.CurrentFH)`
- Get MetadataService and PayloadService
- Calculate new size: `newSize = offset + uint64(len(data))`; check for overflow
- Call `metaSvc.PrepareWrite(authCtx, metadata.FileHandle(ctx.CurrentFH), newSize)` -- validates permissions, returns WriteOperation intent
- Call `payloadSvc.WriteAt(ctx.Context, intent.PayloadID, data, offset)` -- writes actual data
- Call `metaSvc.CommitWrite(authCtx, intent)` -- updates metadata (size, timestamps)
- Encode WRITE4resok:
  1. NFS4_OK status
  2. count (uint32): len(data) (number of bytes written)
  3. committed (uint32): UNSTABLE4 (always, since cache is always enabled -- same as v3)
  4. writeverf (8 bytes): server boot time or fixed value for restart detection
- Use a package-level `var serverBootVerifier [8]byte` initialized in init() from current time

**Create `internal/protocol/nfs/v4/handlers/commit.go`:**

Implement `handleCommit`:
- `RequireCurrentFH` guard
- If pseudo-fs handle: return NFS4ERR_ROFS
- Decode COMMIT4args:
  1. offset (uint64): starting offset (0 = all)
  2. count (uint32): number of bytes (0 = all from offset to EOF)
- Build auth context via `h.buildV4AuthContext(ctx, ctx.CurrentFH)`
- Get MetadataService and PayloadService
- Call `metaSvc.GetFile(authCtx.Context, metadata.FileHandle(ctx.CurrentFH))` to get PayloadID
- Call `payloadSvc.Flush(ctx.Context, file.PayloadID)` -- flushes cache to stable storage
- Encode COMMIT4resok:
  1. NFS4_OK status
  2. writeverf (8 bytes): same server boot verifier as WRITE

**Update `handler.go`:** Register handlers:
```go
h.opDispatchTable[types.OP_READ] = h.handleRead
h.opDispatchTable[types.OP_WRITE] = h.handleWrite
h.opDispatchTable[types.OP_COMMIT] = h.handleCommit
```

**Create `internal/protocol/nfs/v4/handlers/io_test.go`:**

Comprehensive tests for all I/O operations:
- **OPEN tests:**
  - OPEN CLAIM_NULL + NOCREATE on existing file: returns stateid + OPEN4_RESULT_CONFIRM
  - OPEN CLAIM_NULL + CREATE (UNCHECKED4) creates new file: returns stateid
  - OPEN CLAIM_NULL + CREATE (GUARDED4) on existing file: returns NFS4ERR_EXIST
  - OPEN on pseudo-fs: returns NFS4ERR_ROFS
  - OPEN with unsupported claim type: returns NFS4ERR_NOTSUPP
- **OPEN_CONFIRM tests:**
  - OPEN_CONFIRM with valid stateid: returns OK + updated stateid
- **CLOSE tests:**
  - CLOSE with stateid: returns OK + zeroed stateid
  - CLOSE on pseudo-fs: returns NFS4ERR_INVAL
- **READ tests:**
  - READ from file with data: returns correct bytes + EOF detection
  - READ with offset beyond EOF: returns 0 bytes + eof=true
  - READ from empty file: returns 0 bytes + eof=true
  - READ on pseudo-fs: returns NFS4ERR_ISDIR
  - READ with special stateid (all-zeros): succeeds
- **WRITE tests:**
  - WRITE data to file: returns count + UNSTABLE4 + writeverf
  - WRITE extends file: new data written at offset
  - WRITE on pseudo-fs: returns NFS4ERR_ROFS
- **COMMIT tests:**
  - COMMIT on file: returns OK + writeverf
  - COMMIT on pseudo-fs: returns NFS4ERR_ROFS

Use the established test patterns (mock registry with in-memory metadata/payload services, encode/decode helpers).
  </action>
  <verify>
Run `go build ./...` and `go test ./internal/protocol/nfs/v4/... -count=1 -race -v` -- all tests pass. Run `go test ./... -count=1` (full project) to verify no regressions.
  </verify>
  <done>
READ returns file data via PayloadService.ReadAt with proper EOF detection and special stateid acceptance. WRITE uses two-phase pattern (PrepareWrite + PayloadService.WriteAt + CommitWrite) returning UNSTABLE4 stability. COMMIT flushes via PayloadService.Flush. All I/O handlers accept special stateids. Server boot verifier consistent between WRITE and COMMIT responses.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` succeeds
2. `go test ./internal/protocol/nfs/v4/... -count=1 -race` passes all tests
3. `go test ./... -count=1` passes (full project, no regressions)
4. `go vet ./...` reports no issues
5. OPEN with OPEN4_CREATE creates regular files (distinct from CREATE which makes dirs/symlinks)
6. OPEN always sets OPEN4_RESULT_CONFIRM in rflags
7. READ/WRITE accept special stateids without error
8. WRITE returns UNSTABLE4 and server boot verifier
9. COMMIT flushes to stable storage and returns matching verifier
</verification>

<success_criteria>
- OPEN with CLAIM_NULL opens existing files
- OPEN with CLAIM_NULL + OPEN4_CREATE creates regular files
- OPEN_CONFIRM echoes stateid with incremented seqid
- CLOSE returns zeroed stateid
- READ returns file data with correct EOF detection
- READ accepts special stateids (all-zeros, all-ones)
- WRITE stores data via two-phase pattern and returns UNSTABLE4
- COMMIT flushes unstable writes via PayloadService.Flush
- All Phase 6 pseudo-fs tests still pass
- All Plan 07-01 and 07-02 tests still pass
- NFSv4 is functionally complete for basic file I/O (mount, browse, read, write, create, delete)
</success_criteria>

<output>
After completion, create `.planning/phases/07-nfsv4-file-operations/07-03-SUMMARY.md`
</output>
