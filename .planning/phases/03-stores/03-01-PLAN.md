---
phase: 03-stores
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - test/e2e/helpers/cli.go
  - test/e2e/metadata_stores_test.go
autonomous: true

must_haves:
  truths:
    - "Admin can create a memory metadata store via CLI"
    - "Admin can create a BadgerDB metadata store via CLI"
    - "Admin can create a PostgreSQL metadata store via CLI"
    - "Admin can list all metadata stores via CLI"
    - "Admin can delete a metadata store via CLI"
    - "Deleting a metadata store in use by a share fails with clear error"
  artifacts:
    - path: "test/e2e/helpers/cli.go"
      provides: "MetadataStore type and CRUD methods"
      contains: "CreateMetadataStore"
    - path: "test/e2e/metadata_stores_test.go"
      provides: "Metadata store E2E tests"
      contains: "TestMetadataStoresCRUD"
  key_links:
    - from: "test/e2e/metadata_stores_test.go"
      to: "test/e2e/helpers/cli.go"
      via: "CLIRunner.CreateMetadataStore"
      pattern: "cli\\.CreateMetadataStore"
    - from: "test/e2e/helpers/cli.go"
      to: "dittofsctl store metadata"
      via: "CLI execution"
      pattern: "store.*metadata.*add"
---

<objective>
Implement E2E tests for metadata store CRUD operations via the dittofsctl CLI.

Purpose: Validate that admins can create, list, edit, and delete metadata stores (memory, BadgerDB, PostgreSQL) through the CLI interface, with proper error handling when attempting to delete stores in use.

Output: MetadataStore type and methods on CLIRunner, comprehensive test file covering all metadata store operations.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-stores/03-RESEARCH.md
@test/e2e/helpers/cli.go
@test/e2e/users_test.go
@cmd/dittofsctl/commands/store/metadata/add.go
@cmd/dittofsctl/commands/store/metadata/list.go
@cmd/dittofsctl/commands/store/metadata/remove.go
@pkg/apiclient/stores.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add MetadataStore type and CLIRunner methods to helpers</name>
  <files>test/e2e/helpers/cli.go</files>
  <action>
Add MetadataStore CRUD support to CLIRunner following the established functional options pattern from Phase 2.

1. Add MetadataStore type:
```go
type MetadataStore struct {
    Name   string          `json:"name"`
    Type   string          `json:"type"`
    Config json.RawMessage `json:"config,omitempty"`
}
```

2. Add MetadataStoreOption functional options type and options struct:
```go
type MetadataStoreOption func(*metadataStoreOptions)

type metadataStoreOptions struct {
    // BadgerDB specific
    dbPath string
    // PostgreSQL specific
    pgHost     string
    pgPort     int
    pgDatabase string
    pgUser     string
    pgPassword string
    pgSSLMode  string
    // Generic JSON config
    rawConfig string
}
```

3. Add option functions:
- `WithMetaDBPath(path string)` - sets BadgerDB path
- `WithMetaPostgresConfig(host string, port int, database, user, password string)` - sets Postgres connection
- `WithMetaRawConfig(config string)` - sets raw JSON config

4. Add CLIRunner methods:
- `CreateMetadataStore(name, storeType string, opts ...MetadataStoreOption) (*MetadataStore, error)` - uses `store metadata add`
- `ListMetadataStores() ([]*MetadataStore, error)` - uses `store metadata list`
- `GetMetadataStore(name string) (*MetadataStore, error)` - uses list+filter (no get command)
- `EditMetadataStore(name string, opts ...MetadataStoreOption) (*MetadataStore, error)` - uses `store metadata edit`
- `DeleteMetadataStore(name string) error` - uses `store metadata remove --force`

CLI command patterns (from research):
- `dittofsctl store metadata add --name NAME --type TYPE [--db-path PATH] [--config JSON]`
- `dittofsctl store metadata list`
- `dittofsctl store metadata edit NAME [--db-path PATH] [--config JSON]`
- `dittofsctl store metadata remove NAME --force`

Use prefix `WithMeta` for options to avoid collision with future PayloadStore options.
  </action>
  <verify>
Run `go build ./test/e2e/helpers/...` to verify no compilation errors.
Run `grep -n "CreateMetadataStore" test/e2e/helpers/cli.go` to confirm method exists.
  </verify>
  <done>
CLIRunner has CreateMetadataStore, ListMetadataStores, GetMetadataStore, EditMetadataStore, DeleteMetadataStore methods. MetadataStoreOption with WithMetaDBPath, WithMetaPostgresConfig, WithMetaRawConfig options exist.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create metadata stores E2E test file</name>
  <files>test/e2e/metadata_stores_test.go</files>
  <action>
Create comprehensive E2E tests for metadata store operations following the established test patterns from Phase 2.

Test structure:
```go
//go:build e2e

package e2e

import (
    "path/filepath"
    "strings"
    "testing"

    "github.com/marmos91/dittofs/test/e2e/helpers"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

func TestMetadataStoresCRUD(t *testing.T) {
    if testing.Short() {
        t.Skip("Skipping metadata stores tests in short mode")
    }

    // Start server with automatic cleanup
    sp := helpers.StartServerProcess(t, "")
    t.Cleanup(sp.ForceKill)

    serverURL := sp.APIURL()
    cli := helpers.LoginAsAdmin(t, serverURL)

    // Subtests...
}
```

Implement these subtests (refer to research patterns):

1. `t.Run("create memory store", ...)` - MDS-01
   - Use t.Parallel()
   - Create memory store with UniqueTestName("meta_mem")
   - Assert name and type == "memory"
   - Cleanup with t.Cleanup()

2. `t.Run("create badger store", ...)` - MDS-02
   - Use t.Parallel()
   - Create badger store with WithMetaDBPath(filepath.Join(t.TempDir(), "badger"))
   - Assert type == "badger"

3. `t.Run("create postgres store", ...)` - MDS-03
   - Use t.Parallel()
   - Create postgres store with raw JSON config (using placeholder host - actual connectivity tested in integration tests)
   - Assert type == "postgres"
   - Note: This tests CLI acceptance, not Postgres connectivity

4. `t.Run("list stores", ...)` - MDS-04
   - Use t.Parallel()
   - Create 2 stores, list, verify both found

5. `t.Run("edit badger store path", ...)` - MDS-05
   - Use t.Parallel()
   - Create badger store, edit with new path
   - Verify edit succeeds

6. `t.Run("delete store", ...)` - MDS-06
   - Use t.Parallel()
   - Create store, delete it, verify list doesn't contain it

7. `t.Run("duplicate name rejected", ...)`
   - Use t.Parallel()
   - Create store, try create same name again
   - Assert error contains "already exists" or "duplicate"

8. `t.Run("cannot delete store in use", ...)` - MDS-07
   - NOT parallel (creates share)
   - Create metadata store + payload store
   - Create share referencing metadata store (need to add minimal CreateShare helper)
   - Try delete metadata store - should fail with "in use"
   - Delete share first, then delete succeeds
   - Cleanup properly

For the "store in use" test, add a minimal CreateShare helper to cli.go if not already present:
```go
func (r *CLIRunner) CreateShare(name, metadataStore, payloadStore string) error {
    _, err := r.Run("share", "create", "--name", name, "--metadata", metadataStore, "--payload", payloadStore)
    return err
}

func (r *CLIRunner) DeleteShare(name string) error {
    _, err := r.Run("share", "delete", name, "--force")
    return err
}
```

Key patterns from research:
- Use UniqueTestName("prefix") for all store names
- Use t.TempDir() for BadgerDB paths (unique per test)
- Register cleanup via t.Cleanup() even for expected failures
- Check error strings case-insensitively (strings.ToLower)
  </action>
  <verify>
Run `go build -tags=e2e ./test/e2e/...` to verify compilation.
Run `go test -tags=e2e -v -run TestMetadataStoresCRUD ./test/e2e/ -count=1` (requires running server or will start one).
  </verify>
  <done>
TestMetadataStoresCRUD exists with subtests covering: create memory, create badger, create postgres, list, edit, delete, duplicate rejection, and store-in-use protection. All tests use t.Parallel() where safe and proper cleanup.
  </done>
</task>

</tasks>

<verification>
1. `go build -tags=e2e ./test/e2e/helpers/...` compiles without errors
2. `go build -tags=e2e ./test/e2e/...` compiles without errors
3. `grep -c "func.*MetadataStore" test/e2e/helpers/cli.go` shows 5+ methods
4. `grep -c "t.Run" test/e2e/metadata_stores_test.go` shows 8+ subtests
</verification>

<success_criteria>
- MetadataStore type and 5 CRUD methods exist on CLIRunner
- MetadataStoreOption with 3 option functions (DBPath, PostgresConfig, RawConfig)
- Test file covers all 7 MDS requirements (MDS-01 through MDS-07)
- Tests use established patterns (UniqueTestName, t.Cleanup, t.Parallel)
- Code compiles with e2e build tag
</success_criteria>

<output>
After completion, create `.planning/phases/03-stores/03-01-SUMMARY.md`
</output>
