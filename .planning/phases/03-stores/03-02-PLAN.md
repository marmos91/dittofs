---
phase: 03-stores
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - test/e2e/helpers/cli.go
  - test/e2e/payload_stores_test.go
autonomous: true

must_haves:
  truths:
    - "Admin can create a memory payload store via CLI"
    - "Admin can create a filesystem payload store via CLI"
    - "Admin can create an S3 payload store via CLI"
    - "Admin can list all payload stores via CLI"
    - "Admin can delete a payload store via CLI"
    - "Deleting a payload store in use by a share fails with clear error"
  artifacts:
    - path: "test/e2e/helpers/cli.go"
      provides: "PayloadStore type and CRUD methods"
      contains: "CreatePayloadStore"
    - path: "test/e2e/payload_stores_test.go"
      provides: "Payload store E2E tests"
      contains: "TestPayloadStoresCRUD"
  key_links:
    - from: "test/e2e/payload_stores_test.go"
      to: "test/e2e/helpers/cli.go"
      via: "CLIRunner.CreatePayloadStore"
      pattern: "cli\\.CreatePayloadStore"
    - from: "test/e2e/helpers/cli.go"
      to: "dittofsctl store payload"
      via: "CLI execution"
      pattern: "store.*payload.*add"
---

<objective>
Implement E2E tests for payload store CRUD operations via the dittofsctl CLI.

Purpose: Validate that admins can create, list, edit, and delete payload stores (memory, filesystem, S3) through the CLI interface, with proper error handling when attempting to delete stores in use.

Output: PayloadStore type and methods on CLIRunner, comprehensive test file covering all payload store operations.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-stores/03-RESEARCH.md
@test/e2e/helpers/cli.go
@test/e2e/users_test.go
@cmd/dittofsctl/commands/store/payload/add.go
@cmd/dittofsctl/commands/store/payload/list.go
@cmd/dittofsctl/commands/store/payload/remove.go
@pkg/apiclient/stores.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add PayloadStore type and CLIRunner methods to helpers</name>
  <files>test/e2e/helpers/cli.go</files>
  <action>
Add PayloadStore CRUD support to CLIRunner following the established functional options pattern from Phase 2.

1. Add PayloadStore type:
```go
type PayloadStore struct {
    Name   string          `json:"name"`
    Type   string          `json:"type"`
    Config json.RawMessage `json:"config,omitempty"`
}
```

2. Add PayloadStoreOption functional options type and options struct:
```go
type PayloadStoreOption func(*payloadStoreOptions)

type payloadStoreOptions struct {
    // Filesystem specific
    path string
    // S3 specific
    bucket    string
    region    string
    endpoint  string
    accessKey string
    secretKey string
    // Generic JSON config
    rawConfig string
}
```

3. Add option functions:
- `WithPayloadPath(path string)` - sets filesystem storage path
- `WithPayloadS3Config(bucket, region, endpoint, accessKey, secretKey string)` - sets S3 config
- `WithPayloadRawConfig(config string)` - sets raw JSON config

4. Add CLIRunner methods:
- `CreatePayloadStore(name, storeType string, opts ...PayloadStoreOption) (*PayloadStore, error)` - uses `store payload add`
- `ListPayloadStores() ([]*PayloadStore, error)` - uses `store payload list`
- `GetPayloadStore(name string) (*PayloadStore, error)` - uses list+filter (no get command)
- `EditPayloadStore(name string, opts ...PayloadStoreOption) (*PayloadStore, error)` - uses `store payload edit`
- `DeletePayloadStore(name string) error` - uses `store payload remove --force`

CLI command patterns (from research):
- `dittofsctl store payload add --name NAME --type TYPE [--path PATH] [--bucket B --region R --endpoint E --access-key K --secret-key S] [--config JSON]`
- `dittofsctl store payload list`
- `dittofsctl store payload edit NAME [--path PATH] [--bucket B ...] [--config JSON]`
- `dittofsctl store payload remove NAME --force`

Use prefix `WithPayload` for options to avoid collision with MetadataStore options.

For S3 config building:
- Only add S3 flags if all required fields (bucket) are provided
- Region defaults to "us-east-1" if not specified
- Endpoint, accessKey, secretKey are optional (for AWS default auth)
  </action>
  <verify>
Run `go build ./test/e2e/helpers/...` to verify no compilation errors.
Run `grep -n "CreatePayloadStore" test/e2e/helpers/cli.go` to confirm method exists.
  </verify>
  <done>
CLIRunner has CreatePayloadStore, ListPayloadStores, GetPayloadStore, EditPayloadStore, DeletePayloadStore methods. PayloadStoreOption with WithPayloadPath, WithPayloadS3Config, WithPayloadRawConfig options exist.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create payload stores E2E test file</name>
  <files>test/e2e/payload_stores_test.go</files>
  <action>
Create comprehensive E2E tests for payload store operations following the established test patterns from Phase 2.

Test structure:
```go
//go:build e2e

package e2e

import (
    "path/filepath"
    "strings"
    "testing"

    "github.com/marmos91/dittofs/test/e2e/helpers"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

func TestPayloadStoresCRUD(t *testing.T) {
    if testing.Short() {
        t.Skip("Skipping payload stores tests in short mode")
    }

    // Start server with automatic cleanup
    sp := helpers.StartServerProcess(t, "")
    t.Cleanup(sp.ForceKill)

    serverURL := sp.APIURL()
    cli := helpers.LoginAsAdmin(t, serverURL)

    // Subtests...
}
```

Implement these subtests (refer to research patterns):

1. `t.Run("create memory store", ...)` - PLS-01
   - Use t.Parallel()
   - Create memory store with UniqueTestName("payload_mem")
   - Assert name and type == "memory"
   - Cleanup with t.Cleanup()

2. `t.Run("create filesystem store", ...)` - PLS-02
   - Use t.Parallel()
   - Create filesystem store with WithPayloadPath(filepath.Join(t.TempDir(), "content"))
   - Assert type == "filesystem"

3. `t.Run("create s3 store", ...)` - PLS-03
   - Use t.Parallel()
   - Create S3 store with placeholder config (using fake endpoint - actual S3 connectivity tested later)
   - For this test, use WithPayloadRawConfig with minimal valid JSON
   - Assert type == "s3"
   - Note: This tests CLI acceptance, not S3 connectivity

4. `t.Run("list stores", ...)` - PLS-04
   - Use t.Parallel()
   - Create 2 stores, list, verify both found

5. `t.Run("edit filesystem store path", ...)` - PLS-05
   - Use t.Parallel()
   - Create filesystem store, edit with new path
   - Verify edit succeeds

6. `t.Run("delete store", ...)` - PLS-06
   - Use t.Parallel()
   - Create store, delete it, verify list doesn't contain it

7. `t.Run("duplicate name rejected", ...)`
   - Use t.Parallel()
   - Create store, try create same name again
   - Assert error contains "already exists" or "duplicate"

8. `t.Run("cannot delete store in use", ...)` - PLS-07
   - NOT parallel (creates share)
   - Create metadata store (memory) + payload store (memory)
   - Create share referencing payload store
   - Try delete payload store - should fail with "in use"
   - Delete share first, then delete succeeds
   - Cleanup properly

Share helper methods should already exist from 03-01 plan (CreateShare, DeleteShare). If running in parallel before 03-01 completes, add them here too - the e2e build tag will handle any duplication at compile time.

Key patterns from research:
- Use UniqueTestName("prefix") for all store names
- Use t.TempDir() for filesystem paths (unique per test)
- Register cleanup via t.Cleanup() even for expected failures
- Check error strings case-insensitively (strings.ToLower)
- For S3 tests without Localstack, just test creation with valid config structure
  </action>
  <verify>
Run `go build -tags=e2e ./test/e2e/...` to verify compilation.
Run `go test -tags=e2e -v -run TestPayloadStoresCRUD ./test/e2e/ -count=1` (requires running server or will start one).
  </verify>
  <done>
TestPayloadStoresCRUD exists with subtests covering: create memory, create filesystem, create s3, list, edit, delete, duplicate rejection, and store-in-use protection. All tests use t.Parallel() where safe and proper cleanup.
  </done>
</task>

</tasks>

<verification>
1. `go build -tags=e2e ./test/e2e/helpers/...` compiles without errors
2. `go build -tags=e2e ./test/e2e/...` compiles without errors
3. `grep -c "func.*PayloadStore" test/e2e/helpers/cli.go` shows 5+ methods
4. `grep -c "t.Run" test/e2e/payload_stores_test.go` shows 8+ subtests
</verification>

<success_criteria>
- PayloadStore type and 5 CRUD methods exist on CLIRunner
- PayloadStoreOption with 3 option functions (Path, S3Config, RawConfig)
- Test file covers all 7 PLS requirements (PLS-01 through PLS-07)
- Tests use established patterns (UniqueTestName, t.Cleanup, t.Parallel)
- Code compiles with e2e build tag
</success_criteria>

<output>
After completion, create `.planning/phases/03-stores/03-02-SUMMARY.md`
</output>
