---
phase: 21-connection-management-and-trunking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/protocol/nfs/v4/state/connection.go
  - internal/protocol/nfs/v4/state/connection_test.go
  - internal/protocol/nfs/v4/state/manager.go
  - internal/protocol/nfs/v4/types/types.go
  - internal/protocol/nfs/v4/handlers/bind_conn_to_session_handler.go
  - internal/protocol/nfs/v4/handlers/bind_conn_to_session_handler_test.go
  - internal/protocol/nfs/v4/handlers/handler.go
  - internal/protocol/nfs/v4/handlers/create_session_handler.go
  - internal/protocol/nfs/v4/handlers/compound.go
  - pkg/adapter/nfs/nfs_adapter.go
  - pkg/adapter/nfs/nfs_connection.go
  - pkg/adapter/nfs/nfs_connection_handlers.go
autonomous: true
requirements:
  - BACK-02
  - TRUNK-01

must_haves:
  truths:
    - "BIND_CONN_TO_SESSION associates a TCP connection with an existing session in fore, back, or both directions"
    - "Multiple connections bound to one session can each send COMPOUND requests and receive responses"
    - "Server tracks which connections are bound to which sessions and cleans up on disconnect"
    - "Connection that sends CREATE_SESSION is automatically bound as fore-channel"
    - "Re-binding an already-bound connection to a different session silently unbinds from the old session"
    - "Connection limit per session is enforced (default 16) with NFS4ERR_RESOURCE on exceeding"
    - "Session always has at least one fore-channel connection (reject binds that would leave zero)"
  artifacts:
    - path: "internal/protocol/nfs/v4/state/connection.go"
      provides: "BoundConnection struct, ConnectionDirection, ConnectionType, negotiateDirection"
      contains: "BoundConnection"
    - path: "internal/protocol/nfs/v4/state/manager.go"
      provides: "BindConnToSession, UnbindConnection, connection maps, connMu RWMutex"
      contains: "connMu"
    - path: "internal/protocol/nfs/v4/handlers/bind_conn_to_session_handler.go"
      provides: "BIND_CONN_TO_SESSION handler replacing stub"
      contains: "handleBindConnToSession"
    - path: "internal/protocol/nfs/v4/types/types.go"
      provides: "ConnectionID field on CompoundContext"
      contains: "ConnectionID"
    - path: "pkg/adapter/nfs/nfs_adapter.go"
      provides: "Global atomic uint64 connection ID counter"
      contains: "nextConnID"
  key_links:
    - from: "pkg/adapter/nfs/nfs_adapter.go"
      to: "pkg/adapter/nfs/nfs_connection.go"
      via: "Connection ID assigned at accept() time"
      pattern: "nextConnID\\.Add"
    - from: "pkg/adapter/nfs/nfs_connection_handlers.go"
      to: "internal/protocol/nfs/v4/types/types.go"
      via: "ConnectionID set on CompoundContext before ProcessCompound"
      pattern: "ConnectionID"
    - from: "internal/protocol/nfs/v4/handlers/bind_conn_to_session_handler.go"
      to: "internal/protocol/nfs/v4/state/manager.go"
      via: "Handler delegates to StateManager.BindConnToSession"
      pattern: "BindConnToSession"
    - from: "pkg/adapter/nfs/nfs_adapter.go"
      to: "internal/protocol/nfs/v4/state/manager.go"
      via: "Connection close deferred cleanup calls UnbindConnection"
      pattern: "UnbindConnection"
---

<objective>
Implement the core connection binding model for NFSv4.1 trunking: connection ID plumbing from TCP accept through CompoundContext, StateManager connection binding state with a separate connMu RWMutex, the BIND_CONN_TO_SESSION handler replacing the existing stub, auto-bind on CREATE_SESSION, disconnect cleanup, draining support, and comprehensive unit tests.

Purpose: Enable multiple TCP connections to be bound to a single NFSv4.1 session, which is the foundation for trunking, reconnection after network disruption, and backchannel multiplexing (Phase 22).

Output: Working BIND_CONN_TO_SESSION handler, connection tracking in StateManager, connection ID threading, and disconnect cleanup with 30+ unit tests.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-connection-management-and-trunking/21-CONTEXT.md
@.planning/phases/21-connection-management-and-trunking/21-RESEARCH.md
@.planning/phases/19-session-lifecycle/19-01-SUMMARY.md
@.planning/phases/20-sequence-and-compound-bifurcation/20-01-SUMMARY.md

Key reference files:
@internal/protocol/nfs/v4/state/manager.go (StateManager struct, DestroySession, session maps)
@internal/protocol/nfs/v4/state/session_metrics.go (nil-safe Prometheus pattern reference)
@internal/protocol/nfs/v4/types/types.go (CompoundContext, V41RequestContext)
@internal/protocol/nfs/v4/types/bind_conn_to_session.go (XDR types already implemented)
@internal/protocol/nfs/v4/handlers/handler.go (Handler struct, v41DispatchTable, NewHandler)
@internal/protocol/nfs/v4/handlers/create_session_handler.go (session-exempt handler pattern)
@internal/protocol/nfs/v4/handlers/sequence_handler.go (isSessionExemptOp, SEQUENCE gating)
@internal/protocol/nfs/v4/handlers/compound.go (dispatchV41, exempt ops path)
@pkg/adapter/nfs/nfs_adapter.go (TCP accept loop, connection lifecycle)
@pkg/adapter/nfs/nfs_connection.go (NFSConnection struct)
@pkg/adapter/nfs/nfs_connection_handlers.go (handleNFSv4Procedure, ExtractV4HandlerContext)
@internal/protocol/CLAUDE.md (handler conventions, dispatch patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Connection binding model, StateManager methods, and connection ID plumbing</name>
  <files>
    internal/protocol/nfs/v4/state/connection.go
    internal/protocol/nfs/v4/state/connection_test.go
    internal/protocol/nfs/v4/state/manager.go
    internal/protocol/nfs/v4/types/types.go
    pkg/adapter/nfs/nfs_adapter.go
    pkg/adapter/nfs/nfs_connection.go
    pkg/adapter/nfs/nfs_connection_handlers.go
  </files>
  <action>
**Part A: Connection model types** (`internal/protocol/nfs/v4/state/connection.go`)

Create new file with:
- `ConnectionDirection` type (`uint8`): `ConnDirFore`, `ConnDirBack`, `ConnDirBoth` (iota+1)
- `ConnectionType` type (`uint8`): `ConnTypeTCP`, `ConnTypeRDMA` (iota)
- `BoundConnection` struct with fields: `ConnectionID uint64`, `SessionID types.SessionId4`, `Direction ConnectionDirection`, `ConnType ConnectionType`, `BoundAt time.Time`, `LastActivity time.Time`, `Draining bool`
- `BindConnResult` struct with `ServerDir uint32` field
- `negotiateDirection(clientDir uint32) (ConnectionDirection, uint32)` function implementing the generous policy per CONTEXT.md:
  - `CDFC4_FORE` -> `ConnDirFore, CDFS4_FORE`
  - `CDFC4_BACK` -> `ConnDirBack, CDFS4_BACK`
  - `CDFC4_FORE_OR_BOTH` -> `ConnDirBoth, CDFS4_BOTH`
  - `CDFC4_BACK_OR_BOTH` -> `ConnDirBoth, CDFS4_BOTH`
  - default -> `ConnDirFore, CDFS4_FORE`
- String methods on ConnectionDirection and ConnectionType for logging
- Look up the CDFC4_*/CDFS4_* constants in `internal/protocol/nfs/v4/types/constants.go` -- they should already exist from Phase 16. If not, define them.

**Part B: StateManager connection state** (`internal/protocol/nfs/v4/state/manager.go`)

Add to `StateManager` struct:
- `connMu sync.RWMutex` -- separate from `sm.mu` per CONTEXT.md
- `connByID map[uint64]*BoundConnection` -- connectionID -> binding
- `connBySession map[types.SessionId4][]*BoundConnection` -- sessionID -> bindings
- `maxConnsPerSession int` -- default 16

Initialize maps in the constructor/init function (wherever `clientsByID` etc. are initialized).

Add methods:
1. `BindConnToSession(connectionID uint64, sessionID types.SessionId4, clientDir uint32) (*BindConnResult, error)`:
   - First acquire `sm.mu.RLock()` to validate session exists and get clientID. Release `sm.mu.RUnlock()`.
   - Call `negotiateDirection(clientDir)` for direction.
   - Acquire `sm.connMu.Lock()`.
   - If connection already bound to different session, silently unbind via `sm.unbindConnectionLocked(connectionID)`.
   - Check connection limit: count bindings in `sm.connBySession[sessionID]`, allow rebind (same connID already present), reject new if at limit with `NFS4ERR_RESOURCE`.
   - Fore-channel enforcement: if new direction is `ConnDirBack` only, count fore connections excluding self. If foreCount == 0, return `NFS4ERR_INVAL` (cannot leave session with zero fore connections).
   - Create or update `BoundConnection`, set `BoundAt` and `LastActivity` to `time.Now()`, `ConnType = ConnTypeTCP`.
   - Remove old binding for this connID from session list (rebind case) via `sm.removeConnFromSession(connectionID, sessionID)`.
   - Store in both maps.
   - Return `&BindConnResult{ServerDir: serverDir}`.

2. `UnbindConnection(connectionID uint64)`:
   - Acquire `sm.connMu.Lock()`. Call `sm.unbindConnectionLocked(connectionID)`. Release.

3. `unbindConnectionLocked(connectionID uint64)` (unexported, caller holds `connMu`):
   - Look up binding in `connByID`. If not found, return.
   - Remove from `connByID`.
   - Remove from `connBySession` (filter out the entry with matching connectionID).

4. `removeConnFromSession(connectionID uint64, sessionID types.SessionId4)` (unexported, caller holds `connMu`):
   - Filter `connBySession[sessionID]` to remove entry with matching connectionID.

5. `UnbindAllForSession(sessionID types.SessionId4)`:
   - Acquire `sm.connMu.Lock()`.
   - For each binding in `connBySession[sessionID]`, remove from `connByID`.
   - Delete `connBySession[sessionID]`.
   - Release lock.

6. `GetConnectionBindings(sessionID types.SessionId4) []*BoundConnection`:
   - Acquire `sm.connMu.RLock()`.
   - Return a copy of the slice from `connBySession[sessionID]`.

7. `GetConnectionBinding(connectionID uint64) *BoundConnection`:
   - Acquire `sm.connMu.RLock()`.
   - Return copy of binding from `connByID`.

8. `UpdateConnectionActivity(connectionID uint64)`:
   - Acquire `sm.connMu.Lock()`.
   - If binding exists, set `LastActivity = time.Now()`.

9. `SetConnectionDraining(connectionID uint64, draining bool) error`:
   - Acquire `sm.connMu.Lock()`.
   - If binding not found, return error.
   - Set `Draining` flag.

10. `IsConnectionDraining(connectionID uint64) bool`:
    - Acquire `sm.connMu.RLock()`.
    - Return `Draining` flag (false if not found).

Update `destroySessionLocked` to call `sm.UnbindAllForSession(sessionID)` AFTER releasing `sm.mu` -- but since `destroySessionLocked` is called with `sm.mu` held, follow the pitfall avoidance: collect connection IDs under `sm.mu`, then call unbind after. **Alternative (simpler):** Since `unbindConnectionLocked` only touches `connMu` maps and `destroySessionLocked` holds `sm.mu`, just acquire `connMu` inside `destroySessionLocked` (lock ordering: `sm.mu` before `connMu`). Use this approach: at the end of `destroySessionLocked`, call `sm.connMu.Lock()`, remove all entries for sessionID from both maps, `sm.connMu.Unlock()`.

Update the session reaper to also clean up orphaned connection bindings (connections referencing sessions that no longer exist).

Add `SetMaxConnectionsPerSession(max int)` method to allow configuration.

**Part C: Connection ID on CompoundContext** (`internal/protocol/nfs/v4/types/types.go`)

Add `ConnectionID uint64` field to `CompoundContext` struct with comment: `// ConnectionID is the unique identifier for the TCP connection, assigned at accept() time and threaded through dispatch.`

**Part D: Connection ID at accept time** (`pkg/adapter/nfs/nfs_adapter.go`, `pkg/adapter/nfs/nfs_connection.go`)

In `NFSAdapter` struct, add `nextConnID atomic.Uint64` field.

In `NFSConnection` struct, add `connectionID uint64` field.

In `NewNFSConnection`, add a `connectionID uint64` parameter and store it. Or alternatively, in the `Serve()` accept loop where `NewNFSConnection` is called, pass the next ID: `connID := s.nextConnID.Add(1)` and pass it to the constructor. Adapt as needed.

**Part E: Thread ConnectionID into CompoundContext** (`pkg/adapter/nfs/nfs_connection_handlers.go`)

In `handleNFSv4Procedure`, after `compCtx := v4handlers.ExtractV4HandlerContext(ctx, call, clientAddr)`, add `compCtx.ConnectionID = c.connectionID`.

**Part F: Disconnect cleanup** (`pkg/adapter/nfs/nfs_adapter.go` or `nfs_connection.go`)

In the goroutine that runs per-connection (the `go func()` in `Serve()` accept loop), add a deferred call to unbind the connection on close:
```go
defer func() {
    // existing cleanup...
    if s.v4Handler != nil && s.v4Handler.StateManager != nil {
        s.v4Handler.StateManager.UnbindConnection(connID)
    }
}()
```

Ensure the `v4Handler` field is accessible on `NFSAdapter`. It should be -- check the struct. If the v4Handler is not stored on NFSAdapter, find where it is stored and access the StateManager through the appropriate path.

**Part G: Draining check in dispatch** (`internal/protocol/nfs/v4/handlers/compound.go`)

In `dispatchV41`, after SEQUENCE validation succeeds and before executing subsequent ops, check if the connection is draining:
- Access `h.StateManager.IsConnectionDraining(ctx.ConnectionID)`.
- If draining, return `NFS4ERR_DELAY` (the client should retry on another connection).
- This check goes after SEQUENCE (so SEQUENCE itself always works, even on draining connections).

**Part H: Unit tests** (`internal/protocol/nfs/v4/state/connection_test.go`)

Create comprehensive tests:
1. `TestNegotiateDirection` -- all 5 CDFC4 cases
2. `TestBindConnToSession_Basic` -- bind a connection, verify it's stored
3. `TestBindConnToSession_RebindDirection` -- rebind same connection with different direction
4. `TestBindConnToSession_SilentUnbindFromOtherSession` -- bind to session A, then bind to session B, verify removed from A
5. `TestBindConnToSession_ConnectionLimit` -- create 16 connections, verify 17th fails with appropriate error
6. `TestBindConnToSession_RebindAtLimit` -- at limit, rebinding existing connection succeeds
7. `TestBindConnToSession_ForeChannelEnforcement` -- reject bind that would leave zero fore connections
8. `TestBindConnToSession_OwnershipValidation` -- if CONTEXT.md says return NFS4ERR_BADSESSION for wrong client, verify session lookup fails for wrong client (the session won't be found since we validate clientID)
9. `TestUnbindConnection` -- bind then unbind, verify removed from both maps
10. `TestUnbindAllForSession` -- bind 3 connections, unbind all, verify all removed
11. `TestGetConnectionBindings` -- bind 3 connections to a session, verify list returns all 3
12. `TestDestroySession_UnbindsConnections` -- create session with bound connections, destroy session, verify connections unbound
13. `TestSetConnectionDraining` -- set draining flag, verify IsConnectionDraining returns true
14. `TestUpdateConnectionActivity` -- bind connection, wait, update activity, verify timestamp changed

For tests that need sessions: create a StateManager, register a v4.1 client via `ExchangeID`, create a session via `CreateSession`, then test connection binding. Follow the pattern in `session_test.go`.
  </action>
  <verify>
```bash
go test -race -count=1 ./internal/protocol/nfs/v4/state/... -run "TestNegotiateDirection|TestBindConn|TestUnbind|TestGetConnection|TestDestroySession_Unbinds|TestSetConnection|TestUpdateConnection"
go vet ./internal/protocol/nfs/v4/state/... ./internal/protocol/nfs/v4/types/... ./pkg/adapter/nfs/...
go build ./...
```
  </verify>
  <done>
ConnectionDirection/ConnectionType types exist with negotiateDirection function. StateManager has connMu, connByID, connBySession maps and all 10 connection methods. CompoundContext has ConnectionID field. NFSAdapter assigns monotonic connection IDs at accept() time. NFSConnection stores connectionID and threads it into CompoundContext. Disconnect cleanup calls UnbindConnection. Draining check in dispatchV41 returns NFS4ERR_DELAY. 14+ unit tests pass with -race.
  </done>
</task>

<task type="auto">
  <name>Task 2: BIND_CONN_TO_SESSION handler, auto-bind on CREATE_SESSION, and handler integration tests</name>
  <files>
    internal/protocol/nfs/v4/handlers/bind_conn_to_session_handler.go
    internal/protocol/nfs/v4/handlers/bind_conn_to_session_handler_test.go
    internal/protocol/nfs/v4/handlers/handler.go
    internal/protocol/nfs/v4/handlers/create_session_handler.go
    internal/protocol/nfs/v4/handlers/compound_test.go
    internal/protocol/CLAUDE.md
  </files>
  <action>
**Part A: BIND_CONN_TO_SESSION handler** (`internal/protocol/nfs/v4/handlers/bind_conn_to_session_handler.go`)

Create the handler following the session-exempt handler pattern from `create_session_handler.go`:

```go
func (h *Handler) handleBindConnToSession(
    ctx *types.CompoundContext,
    _ *types.V41RequestContext, // nil for session-exempt ops
    reader io.Reader,
) *types.CompoundResult
```

Implementation:
1. Decode `BindConnToSessionArgs` from reader. On bad XDR, return `NFS4ERR_BADXDR`.
2. Log RDMA request at DEBUG level if `args.UseConnInRDMAMode` is true per CONTEXT.md.
3. Validate `ctx.ConnectionID != 0` (if zero, something went wrong in plumbing -- return `NFS4ERR_SERVERFAULT`).
4. Delegate to `h.StateManager.BindConnToSession(ctx.ConnectionID, args.SessionID, args.Dir)`.
5. Map state errors to NFS status codes:
   - `ErrBadSession` -> `NFS4ERR_BADSESSION`
   - Error with `NFS4ERR_RESOURCE` status -> `NFS4ERR_RESOURCE`
   - Error with `NFS4ERR_INVAL` status -> `NFS4ERR_INVAL`
   - Other errors -> `NFS4ERR_SERVERFAULT`
6. On success, encode `BindConnToSessionRes` with `Status=NFS4_OK`, `SessionID` from args, `Dir` from result, `UseConnInRDMAMode=false`.
7. Log at INFO level: "BIND_CONN_TO_SESSION: connection bound" with session_id, connection_id, direction, client.
8. Return `CompoundResult` with `NFS4_OK`, `OP_BIND_CONN_TO_SESSION`, encoded data.

Use `encodeStatusOnly` helper for error responses (check if this exists in the handler package -- it may be in `create_session_handler.go` or a shared helper). If it doesn't exist, create a small helper that encodes just the NFS4 status uint32 for the BIND_CONN_TO_SESSION response format.

**Part B: Replace stub in dispatch table** (`internal/protocol/nfs/v4/handlers/handler.go`)

In `NewHandler()`, find the line that registers the BIND_CONN_TO_SESSION stub in `v41DispatchTable[types.OP_BIND_CONN_TO_SESSION]`. Replace the stub closure with `h.handleBindConnToSession`.

**Part C: Auto-bind on CREATE_SESSION** (`internal/protocol/nfs/v4/handlers/create_session_handler.go`)

In the CREATE_SESSION handler, after the successful `StateManager.CreateSession()` call and before returning the success response, add auto-bind:
```go
if ctx.ConnectionID != 0 {
    // Auto-bind the connection that created the session as fore-channel
    _, _ = h.StateManager.BindConnToSession(ctx.ConnectionID, result.SessionID, types.CDFC4_FORE)
}
```

The error from BindConnToSession is intentionally ignored here -- CREATE_SESSION succeeded, the auto-bind is best-effort. Log at DEBUG if it fails.

**Part D: Handler tests** (`internal/protocol/nfs/v4/handlers/bind_conn_to_session_handler_test.go`)

Create tests following the pattern in `create_session_handler_test.go`:
1. `TestBindConnToSession_BadXDR` -- garbage data, expect NFS4ERR_BADXDR
2. `TestBindConnToSession_NonExistentSession` -- valid XDR with unknown session ID, expect NFS4ERR_BADSESSION
3. `TestBindConnToSession_Success_Fore` -- bind with CDFC4_FORE, verify response has CDFS4_FORE
4. `TestBindConnToSession_Success_Both` -- bind with CDFC4_FORE_OR_BOTH, verify response has CDFS4_BOTH (generous policy)
5. `TestBindConnToSession_RDMA_Rejected` -- bind with UseConnInRDMAMode=true, verify response has UseConnInRDMAMode=false
6. `TestBindConnToSession_ZeroConnectionID` -- ctx.ConnectionID=0, expect NFS4ERR_SERVERFAULT
7. `TestBindConnToSession_XDRDesync` -- verify reader is consumed (no leftover bytes after handler)

For test setup: create a StateManager, register v4.1 client via EXCHANGE_ID, create session via CREATE_SESSION, then test BIND_CONN_TO_SESSION. Follow the pattern established in Phase 19/20 handler tests (check `create_session_handler_test.go` for the exact helper pattern).

**Part E: COMPOUND integration tests** (`internal/protocol/nfs/v4/handlers/compound_test.go`)

Add integration tests that exercise the full COMPOUND dispatch path:
1. `TestCompound_BindConnToSession_ExemptOp` -- BIND_CONN_TO_SESSION as first op (no SEQUENCE), verify it works as an exempt op
2. `TestCompound_CreateSession_AutoBinds` -- CREATE_SESSION with ConnectionID set, verify the connection is auto-bound (check via StateManager.GetConnectionBindings)
3. `TestCompound_MultiConnection_SameSession` -- two connections (different ConnectionIDs) both send SEQUENCE on the same session, both succeed

**Part F: Update protocol CLAUDE.md** (`internal/protocol/CLAUDE.md`)

Add a new section "### Connection Management (Phase 21)" documenting:
- Connection ID assignment: global atomic counter in NFSAdapter, assigned at accept()
- ConnectionID threading: set on CompoundContext before ProcessCompound
- BIND_CONN_TO_SESSION: session-exempt op, delegates to StateManager.BindConnToSession
- Auto-bind on CREATE_SESSION: connection automatically bound as fore-channel
- Disconnect cleanup: UnbindConnection called in deferred close handler
- Draining: IsConnectionDraining check in dispatchV41 returns NFS4ERR_DELAY
- Lock ordering: sm.mu before connMu (never reverse)
- Connection limit: NFS4ERR_RESOURCE when exceeded (default 16)
- Direction negotiation: generous policy (FORE_OR_BOTH -> BOTH, BACK_OR_BOTH -> BOTH)
  </action>
  <verify>
```bash
go test -race -count=1 ./internal/protocol/nfs/v4/handlers/... -run "TestBindConnToSession|TestCompound_BindConn|TestCompound_CreateSession_AutoBinds|TestCompound_MultiConnection"
go test -race -count=1 ./internal/protocol/nfs/v4/handlers/... -run "TestCompound" # all existing compound tests still pass
go vet ./internal/protocol/nfs/v4/handlers/...
go build ./...
```
  </verify>
  <done>
BIND_CONN_TO_SESSION handler replaces stub in v41DispatchTable. Handler decodes XDR, delegates to StateManager, encodes response. Auto-bind on CREATE_SESSION records fore-channel connection. 7+ handler tests and 3+ compound integration tests pass with -race. RDMA requests accepted but always return false. Protocol CLAUDE.md updated with connection management conventions. All existing tests continue passing.
  </done>
</task>

</tasks>

<verification>
```bash
# All connection-related tests pass
go test -race -count=1 ./internal/protocol/nfs/v4/state/... ./internal/protocol/nfs/v4/handlers/...

# Full test suite passes (no regressions)
go test -race -count=1 ./...

# Build succeeds
go build ./...

# Vet passes
go vet ./...
```
</verification>

<success_criteria>
1. BIND_CONN_TO_SESSION handler is wired into v41DispatchTable and handles all RFC 8881 Section 18.34 cases
2. StateManager tracks connection bindings with separate connMu RWMutex (not global sm.mu)
3. Connection IDs are assigned at TCP accept() time and threaded through CompoundContext
4. CREATE_SESSION auto-binds the originating connection as fore-channel
5. TCP disconnect triggers immediate unbind of the connection from any session
6. Connection draining flag checked in dispatchV41 (returns NFS4ERR_DELAY)
7. Direction negotiation follows generous policy (FORE_OR_BOTH -> BOTH)
8. Connection limit enforced with NFS4ERR_RESOURCE
9. Fore-channel enforcement prevents leaving session with zero fore connections
10. 20+ new tests pass with -race detection
11. All existing tests pass (zero regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/21-connection-management-and-trunking/21-01-SUMMARY.md`
</output>
