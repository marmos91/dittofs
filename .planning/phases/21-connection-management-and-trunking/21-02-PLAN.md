---
phase: 21-connection-management-and-trunking
plan: 02
type: execute
wave: 2
depends_on: ["21-01"]
files_modified:
  - internal/protocol/nfs/v4/state/connection_metrics.go
  - internal/protocol/nfs/v4/state/connection_metrics_test.go
  - internal/protocol/nfs/v4/state/manager.go
  - internal/protocol/nfs/v4/handlers/handler.go
  - internal/protocol/nfs/v4/handlers/bind_conn_to_session_handler.go
  - internal/protocol/nfs/v4/handlers/compound_test.go
  - internal/controlplane/api/handlers/clients.go
  - pkg/apiclient/clients.go
  - pkg/controlplane/models/adapter_settings.go
  - internal/controlplane/api/handlers/adapter_settings.go
  - pkg/apiclient/adapter_settings.go
  - cmd/dfsctl/commands/adapter/settings.go
  - cmd/dfsctl/commands/client/sessions_list.go
autonomous: true
requirements:
  - BACK-02
  - TRUNK-01

must_haves:
  truths:
    - "Prometheus metrics track connection bind/unbind events and bound connection count per session"
    - "REST API session detail response includes per-direction connection breakdown (fore, back, both, total)"
    - "V4MaxConnectionsPerSession is configurable via REST API and CLI"
    - "Multi-connection COMPOUND dispatch integration tests verify trunking behavior"
  artifacts:
    - path: "internal/protocol/nfs/v4/state/connection_metrics.go"
      provides: "ConnectionMetrics with nil-safe Prometheus counters"
      contains: "ConnectionMetrics"
    - path: "internal/controlplane/api/handlers/clients.go"
      provides: "Session detail API with connection breakdown"
      contains: "ConnectionInfo"
    - path: "pkg/controlplane/models/adapter_settings.go"
      provides: "V4MaxConnectionsPerSession field"
      contains: "V4MaxConnectionsPerSession"
  key_links:
    - from: "internal/protocol/nfs/v4/state/manager.go"
      to: "internal/protocol/nfs/v4/state/connection_metrics.go"
      via: "StateManager calls ConnectionMetrics.RecordBind/RecordUnbind"
      pattern: "connectionMetrics"
    - from: "internal/controlplane/api/handlers/clients.go"
      to: "internal/protocol/nfs/v4/state/manager.go"
      via: "Session detail handler calls GetConnectionBindings"
      pattern: "GetConnectionBindings"
    - from: "pkg/controlplane/models/adapter_settings.go"
      to: "internal/protocol/nfs/v4/state/manager.go"
      via: "V4MaxConnectionsPerSession configures StateManager.maxConnsPerSession"
      pattern: "V4MaxConnectionsPerSession"
---

<objective>
Add observability and management for connection binding: Prometheus connection metrics (bind/unbind counters, bound gauge), REST API session detail extension with per-direction connection breakdown, V4MaxConnectionsPerSession configuration through the full stack (adapter settings, REST API, dfsctl CLI), and multi-connection integration tests verifying trunking behavior.

Purpose: Provide operators with visibility into connection binding state, configurable connection limits, and confidence through comprehensive integration tests that multiple connections work correctly with a single session.

Output: Prometheus metrics, enriched session API, connection limit configuration, and 10+ integration tests.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-connection-management-and-trunking/21-CONTEXT.md
@.planning/phases/21-connection-management-and-trunking/21-RESEARCH.md
@.planning/phases/21-connection-management-and-trunking/21-01-SUMMARY.md

Key reference files:
@internal/protocol/nfs/v4/state/session_metrics.go (nil-safe Prometheus pattern to follow exactly)
@internal/protocol/nfs/v4/state/sequence_metrics.go (nil-safe Prometheus pattern to follow exactly)
@internal/protocol/nfs/v4/state/connection.go (BoundConnection, ConnectionDirection -- from Plan 01)
@internal/protocol/nfs/v4/state/manager.go (StateManager with connection methods -- from Plan 01)
@internal/protocol/nfs/v4/handlers/handler.go (Handler struct, SetSequenceMetrics pattern)
@internal/controlplane/api/handlers/clients.go (SessionInfo, ListSessions -- Phase 19)
@pkg/apiclient/clients.go (SessionInfo, ListSessions -- Phase 19)
@pkg/controlplane/models/adapter_settings.go (NFSAdapterSettings, V4Max* fields)
@internal/controlplane/api/handlers/adapter_settings.go (adapter settings REST handler)
@pkg/apiclient/adapter_settings.go (adapter settings client)
@cmd/dfsctl/commands/adapter/settings.go (dfsctl adapter settings CLI)
@cmd/dfsctl/commands/client/sessions_list.go (sessions list CLI -- Phase 19)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Prometheus connection metrics and V4MaxConnectionsPerSession configuration full stack</name>
  <files>
    internal/protocol/nfs/v4/state/connection_metrics.go
    internal/protocol/nfs/v4/state/connection_metrics_test.go
    internal/protocol/nfs/v4/state/manager.go
    internal/protocol/nfs/v4/handlers/handler.go
    internal/protocol/nfs/v4/handlers/bind_conn_to_session_handler.go
    pkg/controlplane/models/adapter_settings.go
    internal/controlplane/api/handlers/adapter_settings.go
    pkg/apiclient/adapter_settings.go
    cmd/dfsctl/commands/adapter/settings.go
  </files>
  <action>
**Part A: ConnectionMetrics** (`internal/protocol/nfs/v4/state/connection_metrics.go`)

Create new file following the exact pattern from `session_metrics.go`:

```go
type ConnectionMetrics struct {
    BindTotal   *prometheus.CounterVec  // label: "direction" (fore, back, both)
    UnbindTotal *prometheus.CounterVec  // label: "reason" (explicit, disconnect, session_destroy, reaper)
    BoundGauge  *prometheus.GaugeVec    // label: "session_id"
}
```

Constructor: `NewConnectionMetrics(reg prometheus.Registerer) *ConnectionMetrics`
- Namespace: `dittofs`, Subsystem: `nfs_connections`
- Names: `bind_total`, `unbind_total`, `bound`
- Use `registerOrReuse` pattern from `session_metrics.go`

Nil-safe methods:
- `RecordBind(direction string)` -- increment BindTotal
- `RecordUnbind(reason string)` -- increment UnbindTotal
- `SetBoundConnections(sessionID string, count float64)` -- set BoundGauge
- `RemoveSessionGauge(sessionID string)` -- delete label from BoundGauge (called on session destroy)

**Part B: Wire metrics into StateManager** (`internal/protocol/nfs/v4/state/manager.go`)

Add `connectionMetrics *ConnectionMetrics` field to StateManager.
Add `SetConnectionMetrics(m *ConnectionMetrics)` method.

In `BindConnToSession`:
- After successful bind, call `sm.connectionMetrics.RecordBind(direction.String())`
- Call `sm.connectionMetrics.SetBoundConnections(sessionID.String(), float64(len(sm.connBySession[sessionID])))`

In `unbindConnectionLocked`:
- Call `sm.connectionMetrics.RecordUnbind(reason)` -- add a `reason` parameter to `unbindConnectionLocked(connectionID uint64, reason string)` and update all call sites
- After unbind, update `sm.connectionMetrics.SetBoundConnections(sessionID.String(), float64(len(sm.connBySession[sessionID])))`

In `UnbindAllForSession`:
- Call `sm.connectionMetrics.RecordUnbind("session_destroy")` for each connection
- Call `sm.connectionMetrics.RemoveSessionGauge(sessionID.String())`

**Part C: Wire metrics into Handler** (`internal/protocol/nfs/v4/handlers/handler.go`)

Add `connectionMetrics *state.ConnectionMetrics` field to Handler.
Add `SetConnectionMetrics(m *state.ConnectionMetrics)` method (follows `SetSequenceMetrics` pattern).
In `NewHandler`, after creating StateManager, if metrics are enabled, create `NewConnectionMetrics` and set it on both Handler and StateManager.

Find where session metrics and sequence metrics are created in the Handler init path (likely in `NewHandler` or wherever the NFS adapter sets up the Handler). Add connection metrics creation alongside them. The `NFSAdapter` likely has a Prometheus registerer it passes in -- follow the existing pattern.

**Part D: V4MaxConnectionsPerSession in adapter settings** (`pkg/controlplane/models/adapter_settings.go`)

Add to `NFSAdapterSettings` struct:
```go
V4MaxConnectionsPerSession int `gorm:"default:16" json:"v4_max_connections_per_session"` // max connections per session (0=unlimited)
```

**Part E: REST API for V4MaxConnectionsPerSession** (`internal/controlplane/api/handlers/adapter_settings.go`)

Add `V4MaxConnectionsPerSession` to the request/response types used in the adapter settings handlers. Look at how `V4MinMinorVersion`/`V4MaxMinorVersion` are handled (they were added in Phase 20) -- follow the exact same pattern for `V4MaxConnectionsPerSession`.

**Part F: API client for V4MaxConnectionsPerSession** (`pkg/apiclient/adapter_settings.go`)

Add `V4MaxConnectionsPerSession` field to the client-side adapter settings types. Follow the pattern used for `V4MinMinorVersion`/`V4MaxMinorVersion`.

**Part G: CLI for V4MaxConnectionsPerSession** (`cmd/dfsctl/commands/adapter/settings.go`)

Add `--v4-max-connections-per-session` flag to the adapter settings command. Follow the pattern used for `--v4-min-minor-version` and `--v4-max-minor-version` flags. Display the value in the settings table output.

**Part H: Connection metrics tests** (`internal/protocol/nfs/v4/state/connection_metrics_test.go`)

1. `TestConnectionMetrics_NilSafe` -- call all methods on nil pointer, verify no panic
2. `TestConnectionMetrics_RecordBind` -- create metrics, record bind, verify counter incremented
3. `TestConnectionMetrics_RecordUnbind` -- record unbind, verify counter incremented with correct reason label
4. `TestConnectionMetrics_BoundGauge` -- set bound count, verify gauge value
  </action>
  <verify>
```bash
go test -race -count=1 ./internal/protocol/nfs/v4/state/... -run "TestConnectionMetrics"
go test -race -count=1 ./internal/protocol/nfs/v4/handlers/...
go vet ./internal/protocol/nfs/v4/state/... ./internal/protocol/nfs/v4/handlers/... ./pkg/controlplane/models/... ./internal/controlplane/api/handlers/... ./pkg/apiclient/... ./cmd/dfsctl/...
go build ./...
```
  </verify>
  <done>
ConnectionMetrics with nil-safe BindTotal/UnbindTotal/BoundGauge created and wired into StateManager. Handler creates and passes metrics through. V4MaxConnectionsPerSession added to adapter settings model, REST API, API client, and CLI. 4+ metrics unit tests pass with -race. All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: REST API session detail extension, CLI updates, and multi-connection integration tests</name>
  <files>
    internal/controlplane/api/handlers/clients.go
    pkg/apiclient/clients.go
    cmd/dfsctl/commands/client/sessions_list.go
    internal/protocol/nfs/v4/handlers/compound_test.go
  </files>
  <action>
**Part A: Session detail API with connection info** (`internal/controlplane/api/handlers/clients.go`)

Extend the existing `SessionInfo` struct (added in Phase 19) with connection information:

```go
type ConnectionInfo struct {
    ConnectionID uint64 `json:"connection_id"`
    Direction    string `json:"direction"` // "fore", "back", "both"
    ConnType     string `json:"conn_type"` // "tcp", "rdma"
    BoundAt      string `json:"bound_at"`
    LastActivity string `json:"last_activity"`
    Draining     bool   `json:"draining"`
}

type ConnectionSummary struct {
    Fore  int `json:"fore"`
    Back  int `json:"back"`
    Both  int `json:"both"`
    Total int `json:"total"`
}
```

Add to `SessionInfo`:
- `Connections []ConnectionInfo `json:"connections,omitempty"``
- `ConnectionSummary *ConnectionSummary `json:"connection_summary,omitempty"``

In the `ListSessions` handler, after building `SessionInfo`, look up connection bindings:
```go
bindings := handler.stateManager.GetConnectionBindings(session.ID)
// Build ConnectionInfo slice and ConnectionSummary from bindings
```

The handler needs access to the StateManager. Check how it currently accesses session data -- it likely goes through the Runtime which has a reference to the NFS handler's StateManager. Follow the existing pattern (the Phase 19 handlers for sessions already access StateManager somehow).

If the handler doesn't have direct StateManager access, it may use the Runtime's NFSClientProvider. Look at how `ListSessions` currently accesses sessions -- it should show the pattern.

**Part B: API client types** (`pkg/apiclient/clients.go`)

Add `ConnectionInfo`, `ConnectionSummary` types and update `SessionInfo` to include `Connections` and `ConnectionSummary` fields matching the API response.

**Part C: CLI session list display** (`cmd/dfsctl/commands/client/sessions_list.go`)

Update the sessions list table output to include connection count column. When using JSON/YAML output, include full connection details. For table output, just show total connection count as a column.

If there's a "session detail" or "session describe" command pattern, add connection details there. Otherwise, add a `Total Connections` column to the list table.

**Part D: Multi-connection integration tests** (`internal/protocol/nfs/v4/handlers/compound_test.go`)

Add comprehensive integration tests that exercise the full COMPOUND dispatch path with multiple connections:

1. `TestCompound_MultiConnection_DifferentSlots` -- Two connections (different ConnectionIDs) each send SEQUENCE on the same session using different slots. Both succeed. Verify both connections are bound.

2. `TestCompound_BindConnToSession_Rebind` -- Bind connection with FORE, then rebind with BACK_OR_BOTH, verify direction changed to BOTH.

3. `TestCompound_BindConnToSession_LimitExceeded` -- Create max_connections bindings, attempt one more, verify NFS4ERR_RESOURCE.

4. `TestCompound_BindConnToSession_ForeEnforcement` -- Bind 1 connection as BOTH (the only fore-capable connection), attempt to rebind as BACK only, verify NFS4ERR_INVAL.

5. `TestCompound_DisconnectCleanup` -- Bind a connection, call UnbindConnection (simulating disconnect), verify GetConnectionBindings returns empty.

6. `TestCompound_Draining_RejectsNewRequests` -- Set a connection as draining, send a SEQUENCE+GETATTR compound, verify the compound returns NFS4ERR_DELAY after SEQUENCE.

7. `TestCompound_BindConnToSession_SilentUnbind` -- Bind connection to session A, then bind same connection to session B, verify session A has 0 connections and session B has 1.

8. `TestCompound_CreateSession_AutoBind_Verify` -- Create a session with ConnectionID set, immediately call GetConnectionBindings, verify exactly 1 connection bound as fore.

These tests should use the same test helpers as existing compound tests (registerExchangeID, createTestSession). Set `compCtx.ConnectionID` to unique values for each simulated connection.
  </action>
  <verify>
```bash
go test -race -count=1 ./internal/protocol/nfs/v4/handlers/... -run "TestCompound_MultiConnection|TestCompound_BindConn|TestCompound_DisconnectCleanup|TestCompound_Draining|TestCompound_CreateSession_AutoBind"
go test -race -count=1 ./internal/protocol/nfs/v4/handlers/... -run "TestCompound" # all compound tests still pass
go test -race -count=1 ./internal/controlplane/api/handlers/...
go vet ./...
go build ./...
```
  </verify>
  <done>
Session detail API includes per-direction connection breakdown (fore, back, both, total) and full connection list. API client types updated. CLI shows connection count. 8+ multi-connection integration tests pass with -race. All existing tests pass (zero regressions). Connection lifecycle (bind, rebind, unbind, disconnect, drain) fully verified through COMPOUND dispatch.
  </done>
</task>

</tasks>

<verification>
```bash
# All new tests pass
go test -race -count=1 ./internal/protocol/nfs/v4/state/... ./internal/protocol/nfs/v4/handlers/...

# Full test suite passes (no regressions)
go test -race -count=1 ./...

# Build succeeds
go build ./...

# Vet passes
go vet ./...
```
</verification>

<success_criteria>
1. ConnectionMetrics with nil-safe Prometheus counters (bind/unbind/bound gauge) wired into StateManager
2. Metrics record bind direction, unbind reason, and per-session bound connection gauge
3. REST API session detail includes ConnectionInfo list and ConnectionSummary (fore/back/both/total)
4. V4MaxConnectionsPerSession added to adapter settings model, REST API, API client, and CLI
5. Session list CLI shows connection count
6. 8+ multi-connection integration tests verify trunking behavior end-to-end
7. All existing tests pass (zero regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/21-connection-management-and-trunking/21-02-SUMMARY.md`
</output>
