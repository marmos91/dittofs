---
phase: 33-smb3-dialect-negotiation-preauth-integrity
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/adapter/smb/smbenc/reader.go
  - internal/adapter/smb/smbenc/reader_test.go
  - internal/adapter/smb/smbenc/writer.go
  - internal/adapter/smb/smbenc/writer_test.go
  - internal/adapter/smb/smbenc/doc.go
  - internal/adapter/smb/types/negotiate_context.go
  - internal/adapter/smb/types/negotiate_context_test.go
  - internal/adapter/smb/types/constants.go
  - pkg/adapter/smb/crypto_state.go
  - pkg/adapter/smb/crypto_state_test.go
  - pkg/adapter/smb/connection.go
  - internal/adapter/smb/conn_types.go
autonomous: true
requirements:
  - ARCH-02
  - NEG-02
  - NEG-04

must_haves:
  truths:
    - "smbenc Reader decodes SMB wire data with error accumulation (first error stops further reads)"
    - "smbenc Writer encodes SMB wire data with little-endian byte order and 8-byte alignment support"
    - "Negotiate context types can parse and encode PREAUTH_INTEGRITY_CAPABILITIES, ENCRYPTION_CAPABILITIES, and NETNAME_NEGOTIATE_CONTEXT_ID"
    - "ConnectionCryptoState stores negotiated dialect, cipher, signing algorithm, server GUID, and computes SHA-512 preauth hash chain"
    - "ConnectionCryptoState is created eagerly for all connections and passed via ConnInfo"
  artifacts:
    - path: "internal/adapter/smb/smbenc/reader.go"
      provides: "Buffer-based SMB binary reader with error accumulation"
      exports: ["NewReader", "Reader"]
    - path: "internal/adapter/smb/smbenc/writer.go"
      provides: "Buffer-based SMB binary writer with error accumulation"
      exports: ["NewWriter", "Writer"]
    - path: "internal/adapter/smb/types/negotiate_context.go"
      provides: "Negotiate context types, constants, and encode/decode functions"
      exports: ["NegotiateContext", "PreauthIntegrityCaps", "EncryptionCaps", "NetnameContext"]
    - path: "pkg/adapter/smb/crypto_state.go"
      provides: "ConnectionCryptoState with SHA-512 preauth hash chain"
      exports: ["ConnectionCryptoState", "NewConnectionCryptoState"]
  key_links:
    - from: "internal/adapter/smb/types/negotiate_context.go"
      to: "internal/adapter/smb/smbenc/"
      via: "Uses smbenc Reader/Writer for context parsing/encoding"
      pattern: "smbenc\\.NewReader|smbenc\\.NewWriter"
    - from: "pkg/adapter/smb/crypto_state.go"
      to: "crypto/sha512"
      via: "SHA-512 hash chain computation"
      pattern: "sha512\\.New"
    - from: "internal/adapter/smb/conn_types.go"
      to: "pkg/adapter/smb/crypto_state.go"
      via: "CryptoState field on ConnInfo"
      pattern: "CryptoState"
---

<objective>
Create the foundation packages for SMB3 dialect negotiation: the smbenc binary codec, negotiate context types, and ConnectionCryptoState struct.

Purpose: These three components are the foundation that all subsequent SMB3 negotiate work depends on. The smbenc codec replaces ad-hoc encoding/binary calls with an error-accumulating pattern. Negotiate context types define the wire format for SMB 3.1.1 contexts. ConnectionCryptoState holds per-connection crypto state including the preauth integrity hash chain.

Output: Three new packages/files with comprehensive tests, plus Connection and ConnInfo modifications.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-smb3-dialect-negotiation-preauth-integrity/33-CONTEXT.md
@.planning/phases/33-smb3-dialect-negotiation-preauth-integrity/33-RESEARCH.md

<interfaces>
<!-- Existing types the executor needs -->

From internal/adapter/smb/types/constants.go:
```go
type Dialect uint16
const (
    SMB2DialectWild Dialect = 0x02FF
    SMB2Dialect0202 Dialect = 0x0202
    SMB2Dialect0210 Dialect = 0x0210
    Dialect0300     Dialect = 0x0300
    Dialect0302     Dialect = 0x0302
    Dialect0311     Dialect = 0x0311
)
type Capabilities uint32
const (
    CapLeasing          Capabilities = 0x00000002
    CapLargeMTU         Capabilities = 0x00000004
    CapDirectoryLeasing Capabilities = 0x00000020
    CapEncryption       Capabilities = 0x00000040
)
```

From internal/adapter/smb/conn_types.go:
```go
type ConnInfo struct {
    Conn           net.Conn
    Handler        *handlers.Handler
    SessionManager *session.Manager
    WriteMu        *LockedWriter
    WriteTimeout   time.Duration
    SessionTracker SessionTracker
}
```

From pkg/adapter/smb/connection.go:
```go
type Connection struct {
    server     *Adapter
    conn       net.Conn
    requestSem chan struct{}
    wg         sync.WaitGroup
    writeMu    smb.LockedWriter
    sessionsMu sync.Mutex
    sessions   map[uint64]struct{}
}
func (c *Connection) connInfo() *smb.ConnInfo { ... }
```
</interfaces>
</context>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Create smbenc binary codec package</name>
  <files>
    internal/adapter/smb/smbenc/reader.go,
    internal/adapter/smb/smbenc/reader_test.go,
    internal/adapter/smb/smbenc/writer.go,
    internal/adapter/smb/smbenc/writer_test.go,
    internal/adapter/smb/smbenc/doc.go
  </files>
  <behavior>
    Reader:
    - NewReader(data) creates reader wrapping byte slice with position at 0
    - ReadUint16() returns LE uint16 and advances position by 2; returns 0 and sets error on short read
    - ReadUint32() returns LE uint32 and advances position by 4; returns 0 and sets error on short read
    - ReadUint64() returns LE uint64 and advances position by 8; returns 0 and sets error on short read
    - ReadBytes(n) returns n bytes and advances position; returns nil and sets error if insufficient data
    - Skip(n) advances position by n; sets error if insufficient data
    - ExpectUint16(v) reads uint16 and sets error if value != expected
    - EnsureRemaining(n) sets error if fewer than n bytes remain (does not consume)
    - Err() returns first error (nil if no error)
    - Remaining() returns bytes remaining
    - Position() returns current read position
    - Once error is set, all subsequent reads become no-ops returning zero values
    - Error accumulation: multiple reads after error all return zero without panic
    Writer:
    - NewWriter(capacity) creates writer with pre-allocated buffer
    - WriteUint16(v) appends LE uint16
    - WriteUint32(v) appends LE uint32
    - WriteUint64(v) appends LE uint64
    - WriteBytes(data) appends raw bytes
    - WriteZeros(n) appends n zero bytes
    - Pad(alignment) pads to alignment boundary (e.g., Pad(8) pads to 8-byte boundary)
    - Bytes() returns accumulated bytes
    - Len() returns current length
    - Err() returns first error (nil if no error)
    - WriteAt(offset, data) overwrites bytes at specific offset (for backpatching)
  </behavior>
  <action>
    Create `internal/adapter/smb/smbenc/` package per CONTEXT.md locked decisions:
    - Buffer-based pattern (Reader wraps []byte with position cursor), not streaming io.Reader
    - Little-endian only -- methods named ReadUint16(), WriteUint32() etc. with implicit LE
    - Error accumulation pattern: Reader tracks first error, all subsequent reads become no-ops, caller checks reader.Err() once at end (like bufio.Scanner)
    - Include validation helpers: ExpectUint16(), EnsureRemaining(n)
    - Use encoding/binary.LittleEndian under the hood
    - Define error variables: ErrShortRead, ErrExpectMismatch
    - Writer uses append-based growth, pre-allocated capacity
    - Writer.Pad(alignment) calculates padding needed and appends zero bytes
    - Writer.WriteAt(offset, data) for backpatching offsets in negotiate contexts
    - doc.go with package documentation explaining the error accumulation pattern

    Write tests first (TDD), then implement. Tests should cover:
    - Normal read/write roundtrip for all integer sizes
    - Short read error propagation
    - Error accumulation (read after error returns zero, no panic)
    - ExpectUint16 success and failure
    - EnsureRemaining success and failure
    - Writer Pad alignment (test with 8-byte alignment, various starting positions)
    - Writer WriteAt backpatching
    - Empty reader/writer edge cases
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs-phase-30 && go test ./internal/adapter/smb/smbenc/ -v -count=1</automated>
  </verify>
  <done>
    smbenc package exists with Reader and Writer types. All tests pass. Error accumulation pattern works correctly. Pad(8) produces correct alignment.
  </done>
</task>

<task type="auto" tdd="true">
  <name>Task 2: Create negotiate context types and ConnectionCryptoState</name>
  <files>
    internal/adapter/smb/types/negotiate_context.go,
    internal/adapter/smb/types/negotiate_context_test.go,
    internal/adapter/smb/types/constants.go,
    pkg/adapter/smb/crypto_state.go,
    pkg/adapter/smb/crypto_state_test.go,
    pkg/adapter/smb/connection.go,
    internal/adapter/smb/conn_types.go
  </files>
  <behavior>
    Negotiate context types:
    - NegotiateContext struct: ContextType uint16, Data []byte
    - ParseNegotiateContextList(data, count) returns []NegotiateContext with 8-byte alignment between contexts
    - EncodeNegotiateContextList(contexts) returns wire-format bytes with 8-byte alignment padding
    - PreauthIntegrityCaps: HashAlgorithms []uint16, Salt []byte; Decode/Encode methods
    - EncryptionCaps: Ciphers []uint16; Decode/Encode methods
    - NetnameContext: NetName string (UTF-16LE); Decode method only (client-only context)
    - Constants: NegCtxPreauthIntegrity=0x0001, NegCtxEncryptionCaps=0x0002, NegCtxNetnameContextID=0x0005
    - Constants: HashAlgSHA512=0x0001, CipherAES128CCM=0x0001, CipherAES128GCM=0x0002, CipherAES256CCM=0x0003, CipherAES256GCM=0x0004
    ConnectionCryptoState:
    - Stores: Dialect, CipherId, SigningAlgorithmId, ServerGUID, ServerCapabilities, ServerSecurityMode
    - Stores: ClientCapabilities, ClientGUID, ClientSecurityMode, ClientDialects
    - PreauthIntegrityHashId uint16
    - UpdatePreauthHash(message []byte) computes H(i) = SHA-512(H(i-1) || message(i)) with mutex
    - GetPreauthHash() returns copy of current hash with read lock
    - NewConnectionCryptoState() returns zeroed state (H(0) = all zeros)
    Connection and ConnInfo changes:
    - Connection gets CryptoState *ConnectionCryptoState field, created eagerly in NewConnection
    - ConnInfo gets CryptoState *ConnectionCryptoState field, populated in connInfo()
  </behavior>
  <action>
    **Negotiate context types** in `internal/adapter/smb/types/negotiate_context.go`:
    - Add negotiate context type ID constants to constants.go (NegCtxPreauthIntegrity, NegCtxEncryptionCaps, etc.)
    - Add hash algorithm and cipher ID constants to constants.go
    - Create NegotiateContext base struct with ContextType and Data fields
    - Create PreauthIntegrityCaps struct with Decode/Encode using smbenc codec
    - Create EncryptionCaps struct with Decode/Encode using smbenc codec
    - Create NetnameContext struct with Decode only (client sends, server doesn't respond with it)
    - ParseNegotiateContextList: iterate with 8-byte alignment padding between contexts (not after last)
    - EncodeNegotiateContextList: encode with 8-byte alignment padding between contexts (not after last)
    - Unrecognized context types: skip silently (caller can log at DEBUG level)
    - Tests: roundtrip encode/decode for each context type, alignment padding verification, multi-context list parsing

    **ConnectionCryptoState** in `pkg/adapter/smb/crypto_state.go`:
    - Struct with immutable fields (set-once after negotiate) and mutable preauth hash (sync.RWMutex)
    - UpdatePreauthHash: lock hashMu, compute SHA-512(previousHash || message), copy result
    - GetPreauthHash: RLock, copy [64]byte, return
    - NewConnectionCryptoState: all zeros, PreauthIntegrityHashId = 0 (set during negotiate)
    - Tests: verify H(0) is all zeros, verify hash chain matches MS-SMB2 spec formula, verify concurrent access safety

    **Connection/ConnInfo updates**:
    - Add `CryptoState *smb.ConnectionCryptoState` field to Connection struct (import from pkg/adapter/smb)
    - Create CryptoState eagerly in NewConnection: `CryptoState: smb.NewConnectionCryptoState()`
    - Add `CryptoState *smb.ConnectionCryptoState` field to ConnInfo struct (import from pkg/adapter/smb but avoid circular imports -- ConnInfo is in internal/adapter/smb, CryptoState is in pkg/adapter/smb; this should work since internal can import pkg)
    - Wait -- ConnInfo is in `internal/adapter/smb` and imports from `internal/adapter/smb/v2/handlers`. CryptoState is in `pkg/adapter/smb`. The import from internal to pkg is fine. Update connInfo() method on Connection to populate CryptoState field.

    Note: The pkg/adapter/smb/connection.go Connection struct already has `import smb "github.com/marmos91/dittofs/internal/adapter/smb"` so adding a field of type from within that same package would be fine. The CryptoState type should be defined in the same `pkg/adapter/smb` package as Connection. Then ConnInfo in `internal/adapter/smb` needs to reference it. The import path is `pkg/adapter/smb` from `internal/adapter/smb` -- check that this doesn't create a circular dependency. If it does (since `pkg/adapter/smb/connection.go` already imports `internal/adapter/smb`), define CryptoState in a separate sub-package or use an interface. Likely best approach: keep CryptoState in `pkg/adapter/smb/` alongside Connection, and add CryptoState field directly to Connection. Then ConnInfo gets a pointer to it, which internal/adapter/smb already has access to via the Connection -> connInfo() path. Actually, looking at the code, ConnInfo is in `internal/adapter/smb` package, and it uses `*handlers.Handler` from `internal/adapter/smb/v2/handlers`. The Connection in `pkg/adapter/smb` imports `internal/adapter/smb`. So `internal/adapter/smb` cannot import `pkg/adapter/smb` (circular).

    **Resolution**: Define ConnectionCryptoState in `internal/adapter/smb/` package (same as ConnInfo). The Connection in `pkg/adapter/smb` already imports this package, so it can reference the type. This avoids circular imports. File: `internal/adapter/smb/crypto_state.go`.

    Updated plan:
    - `internal/adapter/smb/crypto_state.go`: ConnectionCryptoState struct and methods
    - `internal/adapter/smb/crypto_state_test.go`: Tests
    - `internal/adapter/smb/conn_types.go`: Add CryptoState field to ConnInfo
    - `pkg/adapter/smb/connection.go`: Add CryptoState field to Connection, create in NewConnection, populate in connInfo()
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs-phase-30 && go test ./internal/adapter/smb/types/ ./internal/adapter/smb/ ./pkg/adapter/smb/ -v -count=1 -run "Context|Crypto|State"</automated>
  </verify>
  <done>
    Negotiate context types parse and encode all three required context types with correct 8-byte alignment. ConnectionCryptoState computes SHA-512 hash chain per MS-SMB2 spec. CryptoState is eagerly created in NewConnection and available via ConnInfo. All tests pass. No circular imports.
  </done>
</task>

</tasks>

<verification>
```bash
# All new packages compile and tests pass
cd /Users/marmos91/Projects/dittofs-phase-30
go test ./internal/adapter/smb/smbenc/ -v -count=1
go test ./internal/adapter/smb/types/ -v -count=1
go test ./internal/adapter/smb/ -v -count=1
go test ./pkg/adapter/smb/ -v -count=1

# Full build succeeds (no circular imports)
go build ./...

# Existing tests still pass
go test ./... -count=1
```
</verification>

<success_criteria>
1. smbenc Reader/Writer package exists with comprehensive tests
2. Negotiate context types parse/encode all three required contexts correctly
3. ConnectionCryptoState computes SHA-512 preauth hash chain per spec
4. CryptoState created eagerly in NewConnection and accessible via ConnInfo
5. No circular imports, full build passes
6. All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/33-smb3-dialect-negotiation-preauth-integrity/33-01-SUMMARY.md`
</output>
