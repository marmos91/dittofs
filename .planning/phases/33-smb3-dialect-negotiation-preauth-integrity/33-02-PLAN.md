---
phase: 33-smb3-dialect-negotiation-preauth-integrity
plan: 02
type: execute
wave: 2
depends_on:
  - 33-01
files_modified:
  - internal/adapter/smb/v2/handlers/negotiate.go
  - internal/adapter/smb/v2/handlers/negotiate_test.go
  - internal/adapter/smb/hooks.go
  - internal/adapter/smb/response.go
  - internal/adapter/smb/v2/handlers/handler.go
  - internal/adapter/smb/v2/handlers/result.go
  - pkg/adapter/smb/connection.go
  - pkg/controlplane/models/adapter_settings.go
autonomous: true
requirements:
  - NEG-01
  - NEG-02
  - NEG-03
  - NEG-04

must_haves:
  truths:
    - "Server negotiates SMB 3.0, 3.0.2, and 3.1.1 dialects selecting the highest mutually supported within configured min/max range"
    - "SMB 3.1.1 negotiate response includes PREAUTH_INTEGRITY_CAPABILITIES and ENCRYPTION_CAPABILITIES contexts"
    - "Server advertises CapDirectoryLeasing and CapEncryption for SMB 3.0+ clients"
    - "Preauth integrity SHA-512 hash chain is computed over raw wire bytes via dispatch hooks for NEGOTIATE command"
    - "Multi-protocol negotiate (0x02FF) still works and does NOT include negotiate contexts"
    - "Handler stores negotiate response parameters on ConnectionCryptoState for VNEG validation"
  artifacts:
    - path: "internal/adapter/smb/v2/handlers/negotiate.go"
      provides: "SMB3-capable negotiate handler with context parsing/encoding and capability gating"
      min_lines: 150
    - path: "internal/adapter/smb/hooks.go"
      provides: "Dispatch hook mechanism with preauth hash hook for NEGOTIATE"
      exports: ["DispatchHook", "RegisterBeforeHook", "RegisterAfterHook", "RunBeforeHooks", "RunAfterHooks"]
    - path: "internal/adapter/smb/v2/handlers/result.go"
      provides: "HandlerResult with DropConnection field"
      contains: "DropConnection"
  key_links:
    - from: "internal/adapter/smb/v2/handlers/negotiate.go"
      to: "internal/adapter/smb/smbenc/"
      via: "Uses smbenc for request parsing and response encoding"
      pattern: "smbenc\\.NewReader|smbenc\\.NewWriter"
    - from: "internal/adapter/smb/v2/handlers/negotiate.go"
      to: "internal/adapter/smb/types/negotiate_context.go"
      via: "Parses and encodes negotiate contexts"
      pattern: "ParseNegotiateContextList|EncodeNegotiateContextList"
    - from: "internal/adapter/smb/hooks.go"
      to: "internal/adapter/smb/crypto_state.go"
      via: "Preauth hash hook updates CryptoState.UpdatePreauthHash"
      pattern: "UpdatePreauthHash"
    - from: "internal/adapter/smb/response.go"
      to: "internal/adapter/smb/hooks.go"
      via: "ProcessSingleRequest calls RunBeforeHooks/RunAfterHooks"
      pattern: "RunBeforeHooks|RunAfterHooks"
---

<objective>
Refactor the negotiate handler to support SMB 3.0/3.0.2/3.1.1 dialects with negotiate contexts, capability gating, and preauth integrity hash chain computation.

Purpose: This is the core protocol work that enables Windows 10/11, macOS, and Linux clients to connect using SMB3 dialects. The negotiate handler parses 3.1.1 negotiate contexts, selects the highest mutually supported dialect within configured range, advertises dialect-appropriate capabilities, and triggers preauth hash computation via dispatch hooks.

Output: Working SMB3 negotiation with preauth integrity hash chain, dispatch hooks, and comprehensive tests.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-smb3-dialect-negotiation-preauth-integrity/33-CONTEXT.md
@.planning/phases/33-smb3-dialect-negotiation-preauth-integrity/33-RESEARCH.md
@.planning/phases/33-smb3-dialect-negotiation-preauth-integrity/33-01-SUMMARY.md

<interfaces>
<!-- From Plan 01 (must exist before this plan runs) -->

From internal/adapter/smb/smbenc/reader.go:
```go
func NewReader(data []byte) *Reader
func (r *Reader) ReadUint16() uint16
func (r *Reader) ReadUint32() uint32
func (r *Reader) ReadUint64() uint64
func (r *Reader) ReadBytes(n int) []byte
func (r *Reader) Skip(n int)
func (r *Reader) ExpectUint16(expected uint16)
func (r *Reader) EnsureRemaining(n int)
func (r *Reader) Err() error
func (r *Reader) Remaining() int
func (r *Reader) Position() int
```

From internal/adapter/smb/smbenc/writer.go:
```go
func NewWriter(capacity int) *Writer
func (w *Writer) WriteUint16(v uint16)
func (w *Writer) WriteUint32(v uint32)
func (w *Writer) WriteUint64(v uint64)
func (w *Writer) WriteBytes(data []byte)
func (w *Writer) WriteZeros(n int)
func (w *Writer) Pad(alignment int)
func (w *Writer) WriteAt(offset int, data []byte)
func (w *Writer) Bytes() []byte
func (w *Writer) Len() int
func (w *Writer) Err() error
```

From internal/adapter/smb/types/negotiate_context.go:
```go
type NegotiateContext struct { ContextType uint16; Data []byte }
type PreauthIntegrityCaps struct { HashAlgorithms []uint16; Salt []byte }
type EncryptionCaps struct { Ciphers []uint16 }
type NetnameContext struct { NetName string }
func ParseNegotiateContextList(data []byte, count uint16) ([]NegotiateContext, error)
func EncodeNegotiateContextList(contexts []NegotiateContext) []byte
```

From internal/adapter/smb/crypto_state.go:
```go
type ConnectionCryptoState struct { ... }
func NewConnectionCryptoState() *ConnectionCryptoState
func (cs *ConnectionCryptoState) UpdatePreauthHash(message []byte)
func (cs *ConnectionCryptoState) GetPreauthHash() [64]byte
```

From internal/adapter/smb/conn_types.go:
```go
type ConnInfo struct {
    Conn           net.Conn
    Handler        *handlers.Handler
    SessionManager *session.Manager
    WriteMu        *LockedWriter
    WriteTimeout   time.Duration
    SessionTracker SessionTracker
    CryptoState    *ConnectionCryptoState  // Added in Plan 01
}
```

From internal/adapter/smb/v2/handlers/result.go:
```go
type HandlerResult struct {
    Data   []byte
    Status types.Status
}
```

From pkg/controlplane/models/adapter_settings.go:
```go
type SMBAdapterSettings struct {
    MinDialect       string  // "SMB2.0", "SMB2.1", "SMB3.0", "SMB3.1.1"
    MaxDialect       string  // "SMB2.0", "SMB2.1", "SMB3.0", "SMB3.1.1"
    EnableEncryption bool
    ...
}
var ValidSMBDialects = []string{"SMB2.0", "SMB2.1", "SMB3.0", "SMB3.1.1"}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dispatch hook mechanism and preauth hash hook</name>
  <files>
    internal/adapter/smb/hooks.go,
    internal/adapter/smb/response.go,
    internal/adapter/smb/v2/handlers/result.go,
    pkg/adapter/smb/connection.go
  </files>
  <action>
    **1. Create dispatch hook mechanism** in `internal/adapter/smb/hooks.go`:
    - Define `DispatchHook func(connInfo *ConnInfo, command types.Command, rawMessage []byte)` type
    - Package-level maps: `beforeHooks map[types.Command][]DispatchHook` and `afterHooks map[types.Command][]DispatchHook`
    - `init()` initializes both maps
    - `RegisterBeforeHook(cmd, hook)` appends to beforeHooks[cmd]
    - `RegisterAfterHook(cmd, hook)` appends to afterHooks[cmd]
    - `RunBeforeHooks(connInfo, cmd, rawMessage)` runs all before hooks for the command
    - `RunAfterHooks(connInfo, cmd, rawMessage)` runs all after hooks for the command
    - Register a preauth hash hook for NEGOTIATE in init():
      - Before-hook: updates CryptoState.UpdatePreauthHash(rawMessage) with the NEGOTIATE request bytes
      - After-hook: updates CryptoState.UpdatePreauthHash(rawMessage) with the NEGOTIATE response bytes
      - Only update if CryptoState is not nil and dialect is 3.1.1 (check after negotiate selects dialect -- the after-hook can check CryptoState.Dialect)
      - The before-hook always updates (dialect not yet known); the after-hook checks dialect

    **2. Wire hooks into ProcessSingleRequest** in `internal/adapter/smb/response.go`:
    - In ProcessSingleRequest, after prepareDispatch but before handler execution, call `RunBeforeHooks(connInfo, reqHeader.Command, rawMessage)`.
    - Problem: ProcessSingleRequest receives `reqHeader` and `body` separately, but the hook needs the full raw message (header + body). The raw bytes are needed for preauth hash.
    - Solution: Modify ProcessSingleRequest to also receive `rawMessage []byte` parameter (the complete SMB2 message from framing layer, header + body). This is available in the framing layer where ReadRequest returns the data. Pass it through.
    - Actually, looking at the code flow: `ReadRequest` in framing.go returns `hdr, body, remainingCompound`. The full message is `headerBytes + body`. The SMB2 header is 64 bytes and was parsed into `hdr`. We need the raw header bytes too.
    - Alternative approach: Reconstruct raw message from header + body. The header is always 64 bytes at the start of the message. We can reconstruct: `rawMessage = make([]byte, 64+len(body)); copy(rawMessage, headerBytes); copy(rawMessage[64:], body)`. But we don't have headerBytes in the current flow.
    - Best approach per CONTEXT.md: Modify the framing/dispatch flow to pass raw message bytes through. In `pkg/adapter/smb/connection.go` Serve(), the ReadRequest function reads the full NetBIOS frame. The full message bytes are available there before parsing into header + body. Add `rawMessage` to the ProcessSingleRequest call. This requires:
      1. ReadRequest to return raw message bytes alongside parsed header + body
      2. ProcessSingleRequest to accept rawMessage parameter
      3. ProcessCompoundRequest similarly (but compound can be deferred)
    - For Phase 33, we only need NEGOTIATE hooks. NEGOTIATE is always a single, non-compound request. So we can add rawMessage to ProcessSingleRequest.
    - Check ReadRequest implementation to see if rawMessage is available. If not, reconstruct it from the framing layer.
    - Likely simplest: In connection.go Serve(), after ReadRequest returns hdr + body, reconstruct `rawMessage := hdr.RawBytes + body` (if RawBytes is available) or compute from the NetBIOS frame data. Look at how ReadRequest works and add raw bytes preservation.
    - Implementation: Add a `RawBytes []byte` field to `header.SMB2Header` that stores the original 64-byte header. Then rawMessage = append(hdr.RawBytes, body...). This is clean and minimal.
    - After handler execution, reconstruct response rawMessage for the after-hook. The response raw bytes = response header (64 bytes) + response body. The response is built in SendResponse(). The after-hook needs the response bytes.
    - For response bytes: modify SendResponse to also call RunAfterHooks with the complete response bytes. The response is assembled in buildResponse() (or wherever the response header + body are combined). Add hook call there.
    - Alternative simpler approach: Since the preauth hash after-hook for NEGOTIATE needs the response raw bytes, and the response is built in a known location, add the hook call right after the response is assembled but before it's sent over the wire. Look at SendResponse in response.go.

    **3. Add DropConnection to HandlerResult** in `internal/adapter/smb/v2/handlers/result.go`:
    - Add `DropConnection bool` field to HandlerResult
    - In ProcessSingleRequest (response.go), after handler returns, check `result.DropConnection`. If true, close the TCP connection without sending a response. Use `connInfo.Conn.Close()` and return a sentinel error or nil.

    **4. Connection.Serve updates** in `pkg/adapter/smb/connection.go`:
    - Pass raw message bytes to ProcessSingleRequest
    - Ensure CryptoState is accessible for hooks via ConnInfo (already done in Plan 01)

    Note: The SMBAdapterSettings already has MinDialect/MaxDialect fields ("SMB2.0"-"SMB3.1.1"). Add a `DialectEnabled bool` field or a helper to parse these strings to Dialect values. Actually the settings already exist with these fields and ValidSMBDialects. Add a mapping function `ParseSMBDialect(s string) (types.Dialect, error)` to convert "SMB3.0" -> Dialect0300 etc. Place in types/constants.go or a new helper. The negotiate handler will use this to check min/max dialect range.

    Also add `EncryptionEnabled bool`, `DirectoryLeasingEnabled bool` fields to SMBAdapterSettings if not already present. Check existing model -- it has `EnableEncryption bool` already. Add `DirectoryLeasingEnabled` for capability gating. These are admin-configurable per CONTEXT.md.
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs-phase-30 && go build ./internal/adapter/smb/... && go build ./pkg/adapter/smb/... && go test ./internal/adapter/smb/ -v -count=1 -run "Hook"</automated>
  </verify>
  <done>
    Dispatch hook mechanism exists with before/after hooks. Preauth hash hook registered for NEGOTIATE. ProcessSingleRequest passes raw message bytes and calls hooks. HandlerResult has DropConnection field. DropConnection terminates TCP connection. Builds cleanly.
  </done>
</task>

<task type="auto" tdd="true">
  <name>Task 2: Refactor negotiate handler for SMB 3.x dialects with contexts and capability gating</name>
  <files>
    internal/adapter/smb/v2/handlers/negotiate.go,
    internal/adapter/smb/v2/handlers/negotiate_test.go,
    internal/adapter/smb/v2/handlers/handler.go
  </files>
  <behavior>
    Dialect selection:
    - Client offers [0x0202, 0x0210, 0x0300, 0x0302, 0x0311] -> server selects 0x0311 (highest supported)
    - Client offers [0x0202, 0x0210, 0x0300] -> server selects 0x0300
    - Client offers only 2.x dialects -> server selects 2.x as before (backward compatible)
    - Server configured min_dialect=3.0 max_dialect=3.1.1, client offers [0x0202, 0x0300, 0x0311] -> selects 0x0311 (highest within range, ignores 0x0202 below min)
    - Server configured min_dialect=3.0, client offers only [0x0202, 0x0210] -> STATUS_NOT_SUPPORTED (no dialects in range)
    - Wildcard 0x02FF with 3.x: select 3.x (wildcard only echoed when best is <= 2.0.2)
    Negotiate contexts (only when dialect is 3.1.1):
    - Parse client PREAUTH_INTEGRITY_CAPABILITIES: select SHA-512 (only supported algorithm)
    - Parse client ENCRYPTION_CAPABILITIES: select highest mutually supported cipher (server preference: AES-128-GCM > AES-128-CCM > AES-256-GCM > AES-256-CCM)
    - Parse client NETNAME_NEGOTIATE_CONTEXT_ID: log server name at DEBUG
    - Response includes PREAUTH_INTEGRITY_CAPABILITIES (HashAlgorithmCount=1, SHA-512, random 32-byte salt)
    - Response includes ENCRYPTION_CAPABILITIES (CipherCount=1, selected cipher)
    - Unrecognized contexts: log DEBUG, skip
    Capability gating:
    - SMB 2.0.2: capabilities = 0 (reserved)
    - SMB 2.1: CapLeasing | CapLargeMTU
    - SMB 3.0: CapLeasing | CapLargeMTU | CapDirectoryLeasing | CapEncryption (if admin-enabled)
    - SMB 3.0.2: same as 3.0
    - SMB 3.1.1: CapLeasing | CapLargeMTU | CapDirectoryLeasing (CapEncryption comes from context, not capabilities field for 3.1.1)
    CryptoState population:
    - After negotiate, store Dialect, CipherId, ServerGUID, ServerCapabilities, ServerSecurityMode, ClientCapabilities, ClientGUID, ClientSecurityMode on CryptoState
    - Store PreauthIntegrityHashId = HashAlgSHA512 if dialect is 3.1.1
    Context in response:
    - NegotiateContextOffset points to first context (after security buffer, 8-byte aligned)
    - NegotiateContextCount = number of contexts in response
    Multi-protocol negotiate:
    - 0x02FF echo behavior unchanged
    - Negotiate contexts NOT included in multi-protocol negotiate response
    Handler access to settings:
    - Handler needs access to MinDialect/MaxDialect from SMBAdapterSettings
    - Add DialectRange (min, max types.Dialect) to Handler struct, set during adapter initialization
    - Add CapabilityConfig (EncryptionEnabled, DirectoryLeasingEnabled) to Handler struct
  </behavior>
  <action>
    Major refactor of `internal/adapter/smb/v2/handlers/negotiate.go`:

    **1. Parse full negotiate request using smbenc:**
    - Replace all `binary.LittleEndian` calls with smbenc.NewReader
    - Parse: StructureSize, DialectCount, SecurityMode, Reserved, Capabilities, ClientGUID, NegotiateContextOffset, NegotiateContextCount, Reserved2
    - Parse dialect list
    - If dialect is 3.1.1 and NegotiateContextCount > 0, parse negotiate contexts from offset

    **2. Dialect selection with configurable range:**
    - Build dialect -> priority map for all supported dialects (0x0202 through 0x0311)
    - Filter client dialects: keep only those within server's [MinDialect, MaxDialect] range
    - Select highest from filtered set
    - Wildcard handling: only echo 0x02FF if best dialect is <= 0x0202 (unchanged)

    **3. Capability gating:**
    - Build capabilities based on selected dialect per MS-SMB2 section 3.3.5.4
    - Dialect -> max capabilities map:
      - 0x0202: 0 (reserved)
      - 0x0210: CapLeasing | CapLargeMTU
      - 0x0300, 0x0302: CapLeasing | CapLargeMTU | CapDirectoryLeasing | (CapEncryption if enabled)
      - 0x0311: CapLeasing | CapLargeMTU | CapDirectoryLeasing (encryption via contexts)
    - Intersect with admin-configured capability flags

    **4. Negotiate context processing (3.1.1 only):**
    - Parse client contexts using ParseNegotiateContextList
    - Process PREAUTH_INTEGRITY_CAPABILITIES: verify SHA-512 offered, select it
    - Process ENCRYPTION_CAPABILITIES: select preferred cipher from client's list
    - Process NETNAME: log at DEBUG
    - Skip unrecognized contexts with DEBUG log
    - Build response contexts: PREAUTH_INTEGRITY_CAPABILITIES (SHA-512, 32-byte random salt) + ENCRYPTION_CAPABILITIES (selected cipher)
    - Encode response contexts using EncodeNegotiateContextList

    **5. Build response using smbenc Writer:**
    - Replace all `binary.LittleEndian.PutUint*` with smbenc Writer
    - Set NegotiateContextCount and NegotiateContextOffset for 3.1.1
    - Append negotiate contexts after security buffer, 8-byte aligned

    **6. Populate CryptoState:**
    - Access CryptoState via handler context or ConnInfo
    - Problem: The handler receives SMBHandlerContext which currently doesn't have CryptoState. Need to add CryptoState to SMBHandlerContext or pass ConnInfo.CryptoState to the handler.
    - Solution: Add CryptoState field to SMBHandlerContext. In prepareDispatch (response.go), populate it from ConnInfo.CryptoState. This is clean and follows the existing pattern of enriching the handler context.
    - Store all negotiate values on CryptoState after selection

    **7. Update Handler struct:**
    - Add `MinDialect types.Dialect` and `MaxDialect types.Dialect` fields
    - Add `EncryptionEnabled bool` and `DirectoryLeasingEnabled bool` fields
    - These are set by the adapter during initialization from SMBAdapterSettings
    - Default: MinDialect=0x0202, MaxDialect=0x0311, EncryptionEnabled=false (progressive), DirectoryLeasingEnabled=true

    **8. Update tests:**
    - Refactor existing negotiate_test.go to use smbenc for building test payloads per CONTEXT.md
    - Add tests for:
      - 3.0 dialect selection
      - 3.0.2 dialect selection
      - 3.1.1 dialect selection with negotiate contexts
      - Capability gating per dialect
      - Min/max dialect range filtering
      - Negotiate context parsing and response encoding
      - Multi-protocol negotiate unchanged behavior
      - STATUS_NOT_SUPPORTED when no dialect in range
      - CryptoState populated correctly after negotiate
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs-phase-30 && go test ./internal/adapter/smb/v2/handlers/ -v -count=1 -run "Negotiate"</automated>
  </verify>
  <done>
    Negotiate handler supports SMB 3.0/3.0.2/3.1.1 with configurable dialect range. Negotiate contexts parsed and encoded for 3.1.1. Capability gating correct per dialect. Preauth hash computed via dispatch hooks. CryptoState populated after negotiate. All negotiate tests pass. Backward compatibility with 2.x maintained.
  </done>
</task>

</tasks>

<verification>
```bash
# All negotiate-related tests pass
cd /Users/marmos91/Projects/dittofs-phase-30
go test ./internal/adapter/smb/v2/handlers/ -v -count=1 -run "Negotiate"
go test ./internal/adapter/smb/ -v -count=1 -run "Hook"

# Full build succeeds
go build ./...

# All existing tests still pass
go test ./... -count=1 -timeout 5m
```
</verification>

<success_criteria>
1. Server selects SMB 3.0/3.0.2/3.1.1 as highest mutually supported dialect within configured range
2. SMB 3.1.1 negotiate response includes PREAUTH_INTEGRITY_CAPABILITIES and ENCRYPTION_CAPABILITIES contexts
3. CapDirectoryLeasing and CapEncryption advertised for 3.0+ (with dialect-appropriate rules)
4. Preauth integrity SHA-512 hash chain computed over raw wire bytes via dispatch hooks
5. CryptoState populated with all negotiate parameters for VNEG validation
6. DropConnection mechanism works for terminating connections
7. Multi-protocol negotiate backward compatible
8. All tests pass including new SMB3 negotiate tests
</success_criteria>

<output>
After completion, create `.planning/phases/33-smb3-dialect-negotiation-preauth-integrity/33-02-SUMMARY.md`
</output>
