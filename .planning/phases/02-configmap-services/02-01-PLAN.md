---
phase: 02-configmap-services
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - k8s/dittofs-operator/api/v1alpha1/dittoserver_types.go
  - k8s/dittofs-operator/api/v1alpha1/zz_generated.deepcopy.go
  - k8s/dittofs-operator/internal/controller/config/types.go
  - k8s/dittofs-operator/internal/controller/config/config.go
  - k8s/dittofs-operator/config/crd/bases/dittofs.dittofs.com_dittoservers.yaml
autonomous: true

must_haves:
  truths:
    - "CRD spec reflects infrastructure-only configuration (database, cache, controlplane, admin)"
    - "ConfigMap generated matches DittoFS develop branch format exactly"
    - "Shares, stores, adapters, users sections removed from CRD and ConfigMap"
    - "PostgreSQL connection string resolved from Secret and included in config YAML database.postgres field"
    - "If both SQLite and Postgres configured, Postgres takes precedence silently"
  artifacts:
    - path: "k8s/dittofs-operator/api/v1alpha1/dittoserver_types.go"
      provides: "Simplified CRD spec with infrastructure-only fields"
      contains: "DatabaseConfig"
    - path: "k8s/dittofs-operator/internal/controller/config/types.go"
      provides: "New DittoFS config types matching develop branch"
      contains: "ControlPlaneConfig"
    - path: "k8s/dittofs-operator/internal/controller/config/config.go"
      provides: "ConfigMap generation for develop branch format"
      contains: "GenerateDittoFSConfig"
  key_links:
    - from: "k8s/dittofs-operator/internal/controller/config/config.go"
      to: "k8s/dittofs-operator/api/v1alpha1/dittoserver_types.go"
      via: "CRD spec to config transformation"
      pattern: "dittoServer\\.Spec"
---

<objective>
Refactor CRD and ConfigMap generation to match the simplified DittoFS develop branch format.

Purpose: The develop branch of DittoFS has moved to a minimal infrastructure-only config format. Stores, shares, adapters, and users are now managed via REST API at runtime. The operator must generate ConfigMaps that match this new format.

Output: Updated CRD types, new config types matching develop branch, and ConfigMap generation that produces valid infrastructure-only config YAML.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-configmap-services/02-CONTEXT.md
@.planning/phases/02-configmap-services/02-RESEARCH.md
@k8s/dittofs-operator/api/v1alpha1/dittoserver_types.go
@k8s/dittofs-operator/internal/controller/config/config.go
@k8s/dittofs-operator/internal/controller/config/types.go
@pkg/config/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Simplify CRD spec to infrastructure-only fields</name>
  <files>
    k8s/dittofs-operator/api/v1alpha1/dittoserver_types.go
  </files>
  <action>
Refactor DittoServerSpec to contain only infrastructure configuration. Remove all dynamic configuration fields that are now managed via REST API.

**REMOVE these types and fields:**
- `DittoConfig` (shares, backends, caches)
- `ShareConfig`, `BackendConfig`, `CacheConfig`, `MemoryCacheConfig`, `PrefetchConfig`, `FlusherConfig`
- `UserManagementSpec`, `UserSpec`, `GroupSpec`, `GuestSpec`
- `IdentityMappingConfig`, `DirectoryAttributesConfig`
- Remove `Config DittoConfig` from `DittoServerSpec`
- Remove `Users *UserManagementSpec` from `DittoServerSpec`

**KEEP these existing types:**
- `StorageSpec` (PVC sizes for internal storage)
- `ServiceSpec` (Kubernetes Service configuration)
- `SMBAdapterSpec`, `SMBTimeoutsSpec`, `SMBCreditsSpec` (SMB protocol config)
- `IdentityConfig`, `JWTConfig`, `AdminConfig` (keep for JWT/admin secrets)

**ADD these new types:**

```go
// DatabaseConfig configures the control plane database
type DatabaseConfig struct {
    // Type is the database type: sqlite or postgres
    // +kubebuilder:validation:Enum=sqlite;postgres
    // +kubebuilder:default="sqlite"
    Type string `json:"type,omitempty"`

    // SQLite configuration (used when Type=sqlite)
    // +optional
    SQLite *SQLiteConfig `json:"sqlite,omitempty"`

    // PostgresSecretRef references a Secret containing the PostgreSQL connection string
    // The Secret must contain a key "connection-string" with the DSN
    // When configured, Postgres takes precedence over SQLite (regardless of Type field)
    // +optional
    PostgresSecretRef *corev1.SecretKeySelector `json:"postgresSecretRef,omitempty"`
}

// SQLiteConfig configures SQLite database
type SQLiteConfig struct {
    // Path is the database file path inside the container
    // +kubebuilder:default="/data/controlplane/controlplane.db"
    Path string `json:"path,omitempty"`
}

// InfraCacheConfig configures the WAL-backed cache for crash recovery
type InfraCacheConfig struct {
    // Path is the directory for cache WAL file
    // +kubebuilder:default="/data/cache"
    Path string `json:"path,omitempty"`

    // Size is the maximum cache size (e.g., "1GB", "512MB")
    // +kubebuilder:default="1GB"
    Size string `json:"size,omitempty"`
}

// MetricsConfig configures Prometheus metrics
type MetricsConfig struct {
    // Enabled controls whether metrics are exposed
    // +kubebuilder:default=false
    Enabled bool `json:"enabled,omitempty"`

    // Port is the metrics HTTP port
    // +kubebuilder:default=9090
    // +kubebuilder:validation:Minimum=1
    // +kubebuilder:validation:Maximum=65535
    Port int32 `json:"port,omitempty"`
}

// ControlPlaneAPIConfig configures the control plane REST API
type ControlPlaneAPIConfig struct {
    // Port is the API server port
    // +kubebuilder:default=8080
    // +kubebuilder:validation:Minimum=1
    // +kubebuilder:validation:Maximum=65535
    Port int32 `json:"port,omitempty"`
}
```

**UPDATE DittoServerSpec:**
```go
type DittoServerSpec struct {
    // Image is the container image for DittoFS server
    // +kubebuilder:default="marmos91c/dittofs:latest"
    Image string `json:"image,omitempty"`

    // Replicas is the number of server replicas (0 or 1 only)
    // +kubebuilder:default=1
    // +kubebuilder:validation:Minimum=0
    // +kubebuilder:validation:Maximum=1
    Replicas *int32 `json:"replicas,omitempty"`

    // Storage configures PVCs for internal server storage
    Storage StorageSpec `json:"storage"`

    // Database configures the control plane database
    // +optional
    Database *DatabaseConfig `json:"database,omitempty"`

    // Cache configures the WAL-backed cache
    // +optional
    Cache *InfraCacheConfig `json:"cache,omitempty"`

    // Metrics configures Prometheus metrics
    // +optional
    Metrics *MetricsConfig `json:"metrics,omitempty"`

    // ControlPlane configures the REST API server
    // +optional
    ControlPlane *ControlPlaneAPIConfig `json:"controlPlane,omitempty"`

    // Identity configures JWT authentication and admin user
    // +optional
    Identity *IdentityConfig `json:"identity,omitempty"`

    // Service configures the Kubernetes Service
    Service ServiceSpec `json:"service,omitempty"`

    // NFSPort is the NFS server port
    // +kubebuilder:default=2049
    // +kubebuilder:validation:Minimum=1
    // +kubebuilder:validation:Maximum=65535
    NFSPort *int32 `json:"nfsPort,omitempty"`

    // SMB configures the SMB protocol adapter
    // +optional
    SMB *SMBAdapterSpec `json:"smb,omitempty"`

    // Resources configures container resource requirements
    // +optional
    Resources corev1.ResourceRequirements `json:"resources,omitempty"`

    // SecurityContext for the container
    // +optional
    SecurityContext *corev1.SecurityContext `json:"securityContext,omitempty"`

    // PodSecurityContext for the pod
    // +optional
    PodSecurityContext *corev1.PodSecurityContext `json:"podSecurityContext,omitempty"`
}
```

Keep `IdentityConfig`, `JWTConfig`, and `AdminConfig` as they are (they're needed for JWT secret and admin password references).
  </action>
  <verify>
Run `cd k8s/dittofs-operator && make generate && make manifests` - should succeed without errors. Check that the generated CRD YAML no longer contains shares, backends, caches, users fields.
  </verify>
  <done>
CRD types updated with infrastructure-only fields. Old dynamic configuration types removed. Generated CRD manifest reflects new simplified schema.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewrite config types to match DittoFS develop branch format</name>
  <files>
    k8s/dittofs-operator/internal/controller/config/types.go
  </files>
  <action>
Replace the entire types.go with new types matching the DittoFS develop branch config format (from `pkg/config/config.go`).

**Write this content:**

```go
package config

// DittoFSConfig represents the DittoFS configuration matching develop branch format.
// This is infrastructure-only config - stores, shares, adapters, users are managed via REST API.
type DittoFSConfig struct {
    Logging         LoggingConfig      `yaml:"logging"`
    Telemetry       TelemetryConfig    `yaml:"telemetry,omitempty"`
    ShutdownTimeout string             `yaml:"shutdown_timeout"`
    Database        DatabaseConfig     `yaml:"database"`
    Metrics         MetricsConfig      `yaml:"metrics"`
    ControlPlane    ControlPlaneConfig `yaml:"controlplane"`
    Cache           CacheConfig        `yaml:"cache"`
    Admin           AdminConfig        `yaml:"admin,omitempty"`
}

// LoggingConfig controls logging behavior
type LoggingConfig struct {
    Level  string `yaml:"level"`
    Format string `yaml:"format"`
    Output string `yaml:"output"`
}

// TelemetryConfig controls OpenTelemetry tracing
type TelemetryConfig struct {
    Enabled    bool    `yaml:"enabled"`
    Endpoint   string  `yaml:"endpoint,omitempty"`
    Insecure   bool    `yaml:"insecure,omitempty"`
    SampleRate float64 `yaml:"sample_rate,omitempty"`
}

// DatabaseConfig configures the control plane database
type DatabaseConfig struct {
    Type     string        `yaml:"type"`
    SQLite   *SQLiteConfig `yaml:"sqlite,omitempty"`
    Postgres *string       `yaml:"postgres,omitempty"`
}

// SQLiteConfig configures SQLite database
type SQLiteConfig struct {
    Path string `yaml:"path"`
}

// MetricsConfig configures Prometheus metrics
type MetricsConfig struct {
    Enabled bool `yaml:"enabled"`
    Port    int  `yaml:"port,omitempty"`
}

// ControlPlaneConfig configures the control plane REST API
type ControlPlaneConfig struct {
    Port int       `yaml:"port"`
    JWT  JWTConfig `yaml:"jwt"`
}

// JWTConfig configures JWT authentication
type JWTConfig struct {
    Secret               string `yaml:"secret"`
    Issuer               string `yaml:"issuer,omitempty"`
    AccessTokenDuration  string `yaml:"access_token_duration"`
    RefreshTokenDuration string `yaml:"refresh_token_duration"`
}

// CacheConfig configures the WAL-backed cache
type CacheConfig struct {
    Path string `yaml:"path"`
    Size string `yaml:"size,omitempty"`
}

// AdminConfig configures the initial admin user
type AdminConfig struct {
    Username     string `yaml:"username"`
    Email        string `yaml:"email,omitempty"`
    PasswordHash string `yaml:"password_hash,omitempty"`
}
```

This removes ALL the old types (MetadataStore, ContentStore, Share, User, Group, Guest, AdaptersConfig, NFSAdapter, SMBAdapter, etc.) as they are no longer part of the config file format.
  </action>
  <verify>
Run `cd k8s/dittofs-operator && go build ./...` - should compile without errors. The types.go file should be significantly smaller (only ~80 lines vs the previous ~225 lines).
  </verify>
  <done>
Config types match DittoFS develop branch format. All dynamic configuration types removed.
  </done>
</task>

<task type="auto">
  <name>Task 3: Rewrite ConfigMap generation for develop branch format</name>
  <files>
    k8s/dittofs-operator/internal/controller/config/config.go
  </files>
  <action>
Rewrite GenerateDittoFSConfig to produce the simplified infrastructure-only config.

**Important PostgreSQL handling per CONTEXT.md decisions:**
- **Postgres takes precedence**: Check `PostgresSecretRef` presence FIRST, regardless of `Type` field value
- If `PostgresSecretRef` is set: Resolve connection string from Secret, include in config YAML `database.postgres` field
- If `PostgresSecretRef` is NOT set: Use SQLite configuration
- This implements "If both specified, Postgres takes precedence silently"

**Replace the entire config.go with:**

```go
package config

import (
    "context"
    "fmt"

    dittoiov1alpha1 "github.com/marmos91/dittofs/k8s/dittofs-operator/api/v1alpha1"
    "gopkg.in/yaml.v3"
    corev1 "k8s.io/api/core/v1"
    "k8s.io/apimachinery/pkg/types"
    "sigs.k8s.io/controller-runtime/pkg/client"
)

// GenerateDittoFSConfig generates DittoFS configuration YAML from the CRD spec.
// This generates infrastructure-only config matching the DittoFS develop branch format.
// Dynamic configuration (stores, shares, users, adapters) is managed via REST API.
func GenerateDittoFSConfig(ctx context.Context, c client.Client, dittoServer *dittoiov1alpha1.DittoServer) (string, error) {
    // Resolve JWT secret
    jwtSecret := ""
    if dittoServer.Spec.Identity != nil && dittoServer.Spec.Identity.JWT != nil {
        secret, err := resolveSecretValue(ctx, c, dittoServer.Namespace, dittoServer.Spec.Identity.JWT.SecretRef)
        if err != nil {
            return "", fmt.Errorf("failed to resolve JWT secret: %w", err)
        }
        jwtSecret = secret
    }

    // Resolve admin password hash
    adminPasswordHash := ""
    if dittoServer.Spec.Identity != nil && dittoServer.Spec.Identity.Admin != nil &&
       dittoServer.Spec.Identity.Admin.PasswordSecretRef != nil {
        hash, err := resolveSecretValue(ctx, c, dittoServer.Namespace, *dittoServer.Spec.Identity.Admin.PasswordSecretRef)
        if err != nil {
            return "", fmt.Errorf("failed to resolve admin password: %w", err)
        }
        adminPasswordHash = hash
    }

    // Build database config (resolves Postgres secret if configured)
    dbConfig, err := buildDatabaseConfig(ctx, c, dittoServer)
    if err != nil {
        return "", fmt.Errorf("failed to build database config: %w", err)
    }

    // Build config
    cfg := DittoFSConfig{
        Logging: LoggingConfig{
            Level:  "INFO",
            Format: "json",   // JSON for Kubernetes structured logging
            Output: "stdout",
        },
        Telemetry: TelemetryConfig{
            Enabled: false, // Disabled by default
        },
        ShutdownTimeout: "30s",
        Database:        dbConfig,
        Metrics:         buildMetricsConfig(dittoServer),
        ControlPlane:    buildControlPlaneConfig(dittoServer, jwtSecret),
        Cache:           buildCacheConfig(dittoServer),
    }

    // Add admin config if we have credentials
    adminUsername := "admin"
    if dittoServer.Spec.Identity != nil && dittoServer.Spec.Identity.Admin != nil {
        if dittoServer.Spec.Identity.Admin.Username != "" {
            adminUsername = dittoServer.Spec.Identity.Admin.Username
        }
    }
    if adminPasswordHash != "" {
        cfg.Admin = AdminConfig{
            Username:     adminUsername,
            PasswordHash: adminPasswordHash,
        }
    }

    yamlBytes, err := yaml.Marshal(&cfg)
    if err != nil {
        return "", fmt.Errorf("failed to marshal config to YAML: %w", err)
    }

    return string(yamlBytes), nil
}

// buildDatabaseConfig constructs database configuration.
// Per CONTEXT.md: If PostgresSecretRef is set, Postgres takes precedence silently (regardless of Type field).
// PostgreSQL connection string is resolved from Secret and included in config YAML.
func buildDatabaseConfig(ctx context.Context, c client.Client, ds *dittoiov1alpha1.DittoServer) (DatabaseConfig, error) {
    // Default to SQLite
    cfg := DatabaseConfig{
        Type: "sqlite",
        SQLite: &SQLiteConfig{
            Path: "/data/controlplane/controlplane.db",
        },
    }

    if ds.Spec.Database == nil {
        return cfg, nil
    }

    // Check for Postgres FIRST - takes precedence per CONTEXT.md
    // We check PostgresSecretRef being set as the indicator that Postgres is configured,
    // regardless of what Type field says. This implements "Postgres takes precedence silently".
    if ds.Spec.Database.PostgresSecretRef != nil {
        // Resolve PostgreSQL connection string from Secret
        connString, err := resolveSecretValue(ctx, c, ds.Namespace, *ds.Spec.Database.PostgresSecretRef)
        if err != nil {
            return cfg, fmt.Errorf("failed to resolve postgres secret: %w", err)
        }

        // PostgreSQL configured - set type AND connection string
        cfg.Type = "postgres"
        cfg.SQLite = nil
        cfg.Postgres = &connString
        return cfg, nil
    }

    // Postgres not configured - use SQLite settings
    if ds.Spec.Database.Type == "sqlite" || ds.Spec.Database.Type == "" {
        if ds.Spec.Database.SQLite != nil && ds.Spec.Database.SQLite.Path != "" {
            cfg.SQLite.Path = ds.Spec.Database.SQLite.Path
        }
    }

    return cfg, nil
}

// buildMetricsConfig constructs metrics configuration
func buildMetricsConfig(ds *dittoiov1alpha1.DittoServer) MetricsConfig {
    cfg := MetricsConfig{
        Enabled: false,
        Port:    9090,
    }

    if ds.Spec.Metrics != nil {
        cfg.Enabled = ds.Spec.Metrics.Enabled
        if ds.Spec.Metrics.Port > 0 {
            cfg.Port = int(ds.Spec.Metrics.Port)
        }
    }

    return cfg
}

// buildControlPlaneConfig constructs control plane API configuration
func buildControlPlaneConfig(ds *dittoiov1alpha1.DittoServer, jwtSecret string) ControlPlaneConfig {
    port := 8080
    if ds.Spec.ControlPlane != nil && ds.Spec.ControlPlane.Port > 0 {
        port = int(ds.Spec.ControlPlane.Port)
    }

    accessDuration := "15m"
    refreshDuration := "168h" // 7 days
    issuer := "dittofs"

    if ds.Spec.Identity != nil && ds.Spec.Identity.JWT != nil {
        if ds.Spec.Identity.JWT.AccessTokenDuration != "" {
            accessDuration = ds.Spec.Identity.JWT.AccessTokenDuration
        }
        if ds.Spec.Identity.JWT.RefreshTokenDuration != "" {
            refreshDuration = ds.Spec.Identity.JWT.RefreshTokenDuration
        }
        if ds.Spec.Identity.JWT.Issuer != "" {
            issuer = ds.Spec.Identity.JWT.Issuer
        }
    }

    return ControlPlaneConfig{
        Port: port,
        JWT: JWTConfig{
            Secret:               jwtSecret,
            Issuer:               issuer,
            AccessTokenDuration:  accessDuration,
            RefreshTokenDuration: refreshDuration,
        },
    }
}

// buildCacheConfig constructs cache configuration
func buildCacheConfig(ds *dittoiov1alpha1.DittoServer) CacheConfig {
    cfg := CacheConfig{
        Path: "/data/cache",
        Size: "1GB",
    }

    if ds.Spec.Cache != nil {
        if ds.Spec.Cache.Path != "" {
            cfg.Path = ds.Spec.Cache.Path
        }
        if ds.Spec.Cache.Size != "" {
            cfg.Size = ds.Spec.Cache.Size
        }
    }

    return cfg
}

// resolveSecretValue resolves a single secret value from a Kubernetes Secret.
func resolveSecretValue(ctx context.Context, c client.Client, namespace string, secretRef corev1.SecretKeySelector) (string, error) {
    secret := &corev1.Secret{}
    secretKey := types.NamespacedName{
        Name:      secretRef.Name,
        Namespace: namespace,
    }

    if err := c.Get(ctx, secretKey, secret); err != nil {
        return "", fmt.Errorf("failed to get secret %s: %w", secretRef.Name, err)
    }

    if secretValue, ok := secret.Data[secretRef.Key]; ok {
        return string(secretValue), nil
    }

    return "", fmt.Errorf("key %s not found in secret %s", secretRef.Key, secretRef.Name)
}
```

This removes:
- All backend/store resolution code
- Share configuration
- User/group/guest configuration
- NFS/SMB adapter configuration in config file (adapters are now managed via REST API)
- Cache store configuration (cache is now simple path+size)

The generated config will look like:
```yaml
logging:
  level: INFO
  format: json
  output: stdout
telemetry:
  enabled: false
shutdown_timeout: 30s
database:
  type: sqlite
  sqlite:
    path: /data/controlplane/controlplane.db
metrics:
  enabled: false
  port: 9090
controlplane:
  port: 8080
  jwt:
    secret: <from-secret>
    issuer: dittofs
    access_token_duration: 15m
    refresh_token_duration: 168h
cache:
  path: /data/cache
  size: 1GB
admin:
  username: admin
  password_hash: <from-secret>
```

When Postgres is configured (PostgresSecretRef is set), the database section will be:
```yaml
database:
  type: postgres
  postgres: "postgres://user:pass@host:5432/db"  # Resolved from Secret
```
  </action>
  <verify>
Run `cd k8s/dittofs-operator && go build ./...` - should compile without errors. Run `go test ./internal/controller/config/...` if tests exist.
  </verify>
  <done>
ConfigMap generation produces infrastructure-only config matching DittoFS develop branch format. PostgreSQL connection strings resolved from Secret and included in config YAML. Postgres takes precedence when PostgresSecretRef is set (regardless of Type field).
  </done>
</task>

</tasks>

<verification>
1. `cd k8s/dittofs-operator && make generate && make manifests` succeeds
2. `cd k8s/dittofs-operator && go build ./...` succeeds
3. Generated CRD at `config/crd/bases/dittofs.dittofs.com_dittoservers.yaml` contains only infrastructure fields (database, cache, metrics, controlPlane, identity) - no shares, backends, users
4. Config types in `internal/controller/config/types.go` match DittoFS `pkg/config/config.go` structure
5. `buildDatabaseConfig` checks PostgresSecretRef FIRST (takes precedence over Type field)
6. When PostgresSecretRef set, connection string resolved from Secret and included in config YAML
</verification>

<success_criteria>
- CRD spec contains only: image, replicas, storage, database, cache, metrics, controlPlane, identity, service, nfsPort, smb, resources, securityContext
- ConfigMap generation produces YAML with: logging, telemetry, shutdown_timeout, database, metrics, controlplane, cache, admin
- No shares, stores, adapters, users in generated config
- PostgreSQL DSN resolved from Secret and included in config YAML database.postgres field
- Postgres takes precedence when PostgresSecretRef is set (regardless of database.type value)
- All Go code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-configmap-services/02-01-SUMMARY.md`
</output>
