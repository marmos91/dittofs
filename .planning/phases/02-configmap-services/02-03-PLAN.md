---
phase: 02-configmap-services
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - k8s/dittofs-operator/pkg/resources/service.go
  - k8s/dittofs-operator/internal/controller/dittoserver_controller.go
  - k8s/dittofs-operator/api/v1alpha1/dittoserver_webhook.go
  - k8s/dittofs-operator/config/samples/dittofs_v1alpha1_dittofs_memory.yaml
autonomous: false

must_haves:
  truths:
    - "Headless Service exists for StatefulSet DNS"
    - "File Service exposes NFS and SMB ports via LoadBalancer"
    - "API Service exposes REST API port via LoadBalancer"
    - "Metrics Service created only when metrics enabled"
    - "Port validation rejects duplicate ports and warns on privileged ports"
    - "R2.6 NodePort fallback is manual user configuration via service.type field (not automatic detection)"
  artifacts:
    - path: "k8s/dittofs-operator/pkg/resources/service.go"
      provides: "Service builder pattern"
      contains: "NewServiceBuilder"
    - path: "k8s/dittofs-operator/internal/controller/dittoserver_controller.go"
      provides: "Reconciliation for all services"
      contains: "reconcileHeadlessService"
    - path: "k8s/dittofs-operator/api/v1alpha1/dittoserver_webhook.go"
      provides: "Port validation webhook"
      contains: "validatePorts"
  key_links:
    - from: "k8s/dittofs-operator/internal/controller/dittoserver_controller.go"
      to: "k8s/dittofs-operator/pkg/resources/service.go"
      via: "import and builder usage"
      pattern: "resources\\.NewServiceBuilder"
---

<objective>
Implement three-service topology with port validation webhook.

Purpose: StatefulSets require a headless Service for DNS. File protocols (NFS, SMB) need LoadBalancer for external access. REST API needs separate Service for management access. Metrics needs conditional Service when enabled.

Output: Service builder utility, four reconcile functions for services, and port validation in webhook.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-configmap-services/02-CONTEXT.md
@.planning/phases/02-configmap-services/02-RESEARCH.md
@k8s/dittofs-operator/internal/controller/dittoserver_controller.go
@k8s/dittofs-operator/api/v1alpha1/dittoserver_webhook.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Service builder utility</name>
  <files>
    k8s/dittofs-operator/pkg/resources/service.go
  </files>
  <action>
Add Service builder to the resources package. This provides a fluent API for building Services.

**Create file:**

```go
package resources

import (
    corev1 "k8s.io/api/core/v1"
    metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// ServiceBuilder provides a fluent API for building Kubernetes Services.
type ServiceBuilder struct {
    name        string
    namespace   string
    labels      map[string]string
    selector    map[string]string
    annotations map[string]string
    serviceType corev1.ServiceType
    ports       []corev1.ServicePort
    headless    bool
}

// NewServiceBuilder creates a new ServiceBuilder.
func NewServiceBuilder(name, namespace string) *ServiceBuilder {
    return &ServiceBuilder{
        name:        name,
        namespace:   namespace,
        serviceType: corev1.ServiceTypeLoadBalancer,
        labels:      make(map[string]string),
        selector:    make(map[string]string),
        annotations: make(map[string]string),
    }
}

// WithLabels sets the labels for the Service.
func (b *ServiceBuilder) WithLabels(labels map[string]string) *ServiceBuilder {
    for k, v := range labels {
        b.labels[k] = v
    }
    return b
}

// WithSelector sets the selector for the Service.
func (b *ServiceBuilder) WithSelector(selector map[string]string) *ServiceBuilder {
    for k, v := range selector {
        b.selector[k] = v
    }
    return b
}

// WithAnnotations sets annotations for the Service (e.g., cloud provider LB config).
func (b *ServiceBuilder) WithAnnotations(annotations map[string]string) *ServiceBuilder {
    for k, v := range annotations {
        b.annotations[k] = v
    }
    return b
}

// WithType sets the Service type (ClusterIP, NodePort, LoadBalancer).
func (b *ServiceBuilder) WithType(t corev1.ServiceType) *ServiceBuilder {
    b.serviceType = t
    return b
}

// AsHeadless makes this a headless Service (ClusterIP: None).
func (b *ServiceBuilder) AsHeadless() *ServiceBuilder {
    b.headless = true
    b.serviceType = corev1.ServiceTypeClusterIP
    return b
}

// AddTCPPort adds a TCP port to the Service.
func (b *ServiceBuilder) AddTCPPort(name string, port int32) *ServiceBuilder {
    b.ports = append(b.ports, corev1.ServicePort{
        Name:       name,
        Port:       port,
        TargetPort: intstr.FromInt32(port),
        Protocol:   corev1.ProtocolTCP,
    })
    return b
}

// Build constructs the Service object.
func (b *ServiceBuilder) Build() *corev1.Service {
    svc := &corev1.Service{
        ObjectMeta: metav1.ObjectMeta{
            Name:        b.name,
            Namespace:   b.namespace,
            Labels:      b.labels,
            Annotations: b.annotations,
        },
        Spec: corev1.ServiceSpec{
            Type:     b.serviceType,
            Selector: b.selector,
            Ports:    b.ports,
        },
    }

    if b.headless {
        svc.Spec.ClusterIP = corev1.ClusterIPNone
    }

    return svc
}
```

**Add import for intstr:**
```go
import (
    corev1 "k8s.io/api/core/v1"
    metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
    "k8s.io/apimachinery/pkg/util/intstr"
)
```
  </action>
  <verify>
Run `cd k8s/dittofs-operator && go build ./pkg/resources/...` - should compile without errors.
  </verify>
  <done>
Service builder utility created with fluent API for building headless, file, API, and metrics Services.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add service reconciliation functions to controller</name>
  <files>
    k8s/dittofs-operator/internal/controller/dittoserver_controller.go
  </files>
  <action>
Replace the single `reconcileService` function with four service reconciliation functions.

**Add new helper functions:**

```go
// getServiceType returns the Kubernetes Service type from the CRD spec.
func getServiceType(dittoServer *dittoiov1alpha1.DittoServer) corev1.ServiceType {
    if dittoServer.Spec.Service.Type != "" {
        return corev1.ServiceType(dittoServer.Spec.Service.Type)
    }
    return corev1.ServiceTypeLoadBalancer // Default to LoadBalancer
}

// getNFSPort returns the NFS port from the CRD spec (default 2049).
func getNFSPort(dittoServer *dittoiov1alpha1.DittoServer) int32 {
    if dittoServer.Spec.NFSPort != nil {
        return *dittoServer.Spec.NFSPort
    }
    return 2049
}

// getSMBPort returns the SMB port from the CRD spec (default 445).
func getSMBPort(dittoServer *dittoiov1alpha1.DittoServer) int32 {
    if dittoServer.Spec.SMB != nil && dittoServer.Spec.SMB.Port != nil {
        return *dittoServer.Spec.SMB.Port
    }
    return 445
}

// reconcileHeadlessService creates/updates the headless Service for StatefulSet DNS.
func (r *DittoServerReconciler) reconcileHeadlessService(ctx context.Context, dittoServer *dittoiov1alpha1.DittoServer) error {
    labels := map[string]string{
        "app":      "dittofs-server",
        "instance": dittoServer.Name,
    }

    nfsPort := getNFSPort(dittoServer)

    svc := resources.NewServiceBuilder(dittoServer.Name+"-headless", dittoServer.Namespace).
        WithLabels(labels).
        WithSelector(labels).
        AsHeadless().
        AddTCPPort("nfs", nfsPort).
        Build()

    existing := &corev1.Service{
        ObjectMeta: metav1.ObjectMeta{
            Name:      svc.Name,
            Namespace: svc.Namespace,
        },
    }

    _, err := controllerutil.CreateOrUpdate(ctx, r.Client, existing, func() error {
        if err := controllerutil.SetControllerReference(dittoServer, existing, r.Scheme); err != nil {
            return err
        }
        existing.Spec = svc.Spec
        existing.Labels = svc.Labels
        return nil
    })

    return err
}

// reconcileFileService creates/updates the Service for file protocols (NFS, SMB).
func (r *DittoServerReconciler) reconcileFileService(ctx context.Context, dittoServer *dittoiov1alpha1.DittoServer) error {
    labels := map[string]string{
        "app":      "dittofs-server",
        "instance": dittoServer.Name,
    }

    nfsPort := getNFSPort(dittoServer)

    builder := resources.NewServiceBuilder(dittoServer.Name+"-file", dittoServer.Namespace).
        WithLabels(labels).
        WithSelector(labels).
        WithType(getServiceType(dittoServer)).
        WithAnnotations(dittoServer.Spec.Service.Annotations).
        AddTCPPort("nfs", nfsPort)

    // Add SMB port if enabled
    if dittoServer.Spec.SMB != nil && dittoServer.Spec.SMB.Enabled {
        smbPort := getSMBPort(dittoServer)
        builder.AddTCPPort("smb", smbPort)
    }

    svc := builder.Build()

    existing := &corev1.Service{
        ObjectMeta: metav1.ObjectMeta{
            Name:      svc.Name,
            Namespace: svc.Namespace,
        },
    }

    _, err := controllerutil.CreateOrUpdate(ctx, r.Client, existing, func() error {
        if err := controllerutil.SetControllerReference(dittoServer, existing, r.Scheme); err != nil {
            return err
        }
        existing.Spec = svc.Spec
        existing.Labels = svc.Labels
        existing.Annotations = svc.Annotations
        return nil
    })

    return err
}

// reconcileAPIService creates/updates the Service for REST API access.
func (r *DittoServerReconciler) reconcileAPIService(ctx context.Context, dittoServer *dittoiov1alpha1.DittoServer) error {
    labels := map[string]string{
        "app":      "dittofs-server",
        "instance": dittoServer.Name,
    }

    apiPort := int32(8080)
    if dittoServer.Spec.ControlPlane != nil && dittoServer.Spec.ControlPlane.Port > 0 {
        apiPort = dittoServer.Spec.ControlPlane.Port
    }

    svc := resources.NewServiceBuilder(dittoServer.Name+"-api", dittoServer.Namespace).
        WithLabels(labels).
        WithSelector(labels).
        WithType(getServiceType(dittoServer)).
        WithAnnotations(dittoServer.Spec.Service.Annotations).
        AddTCPPort("api", apiPort).
        Build()

    existing := &corev1.Service{
        ObjectMeta: metav1.ObjectMeta{
            Name:      svc.Name,
            Namespace: svc.Namespace,
        },
    }

    _, err := controllerutil.CreateOrUpdate(ctx, r.Client, existing, func() error {
        if err := controllerutil.SetControllerReference(dittoServer, existing, r.Scheme); err != nil {
            return err
        }
        existing.Spec = svc.Spec
        existing.Labels = svc.Labels
        existing.Annotations = svc.Annotations
        return nil
    })

    return err
}

// reconcileMetricsService creates/updates the Service for Prometheus metrics (if enabled).
func (r *DittoServerReconciler) reconcileMetricsService(ctx context.Context, dittoServer *dittoiov1alpha1.DittoServer) error {
    // Only create metrics service if metrics are enabled
    if dittoServer.Spec.Metrics == nil || !dittoServer.Spec.Metrics.Enabled {
        // Delete metrics service if it exists
        existing := &corev1.Service{}
        err := r.Get(ctx, client.ObjectKey{
            Namespace: dittoServer.Namespace,
            Name:      dittoServer.Name + "-metrics",
        }, existing)
        if err == nil {
            // Service exists, delete it
            return r.Delete(ctx, existing)
        }
        return client.IgnoreNotFound(err)
    }

    labels := map[string]string{
        "app":      "dittofs-server",
        "instance": dittoServer.Name,
    }

    metricsPort := int32(9090)
    if dittoServer.Spec.Metrics.Port > 0 {
        metricsPort = dittoServer.Spec.Metrics.Port
    }

    // Metrics service is always ClusterIP (internal only)
    svc := resources.NewServiceBuilder(dittoServer.Name+"-metrics", dittoServer.Namespace).
        WithLabels(labels).
        WithSelector(labels).
        WithType(corev1.ServiceTypeClusterIP).
        AddTCPPort("metrics", metricsPort).
        Build()

    existing := &corev1.Service{
        ObjectMeta: metav1.ObjectMeta{
            Name:      svc.Name,
            Namespace: svc.Namespace,
        },
    }

    _, err := controllerutil.CreateOrUpdate(ctx, r.Client, existing, func() error {
        if err := controllerutil.SetControllerReference(dittoServer, existing, r.Scheme); err != nil {
            return err
        }
        existing.Spec = svc.Spec
        existing.Labels = svc.Labels
        return nil
    })

    return err
}
```

**Update the Reconcile function to call all four service functions:**

Replace the single `r.reconcileService(ctx, dittoServer)` call with:

```go
// Reconcile services (headless required for StatefulSet DNS)
if err := r.reconcileHeadlessService(ctx, dittoServer); err != nil {
    logger.Error(err, "Failed to reconcile headless Service")
    return ctrl.Result{}, err
}

if err := r.reconcileFileService(ctx, dittoServer); err != nil {
    logger.Error(err, "Failed to reconcile file Service")
    return ctrl.Result{}, err
}

if err := r.reconcileAPIService(ctx, dittoServer); err != nil {
    logger.Error(err, "Failed to reconcile API Service")
    return ctrl.Result{}, err
}

if err := r.reconcileMetricsService(ctx, dittoServer); err != nil {
    logger.Error(err, "Failed to reconcile metrics Service")
    return ctrl.Result{}, err
}
```

**Delete the old `reconcileService` and `buildServicePorts` functions.**

**Update container ports in reconcileStatefulSet:**

Update `buildContainerPorts` to include the API port:

```go
func buildContainerPorts(dittoServer *dittoiov1alpha1.DittoServer) []corev1.ContainerPort {
    nfsPort := getNFSPort(dittoServer)

    ports := []corev1.ContainerPort{
        {
            Name:          "nfs",
            ContainerPort: nfsPort,
            Protocol:      corev1.ProtocolTCP,
        },
    }

    // Add API port
    apiPort := int32(8080)
    if dittoServer.Spec.ControlPlane != nil && dittoServer.Spec.ControlPlane.Port > 0 {
        apiPort = dittoServer.Spec.ControlPlane.Port
    }
    ports = append(ports, corev1.ContainerPort{
        Name:          "api",
        ContainerPort: apiPort,
        Protocol:      corev1.ProtocolTCP,
    })

    // Add metrics port if enabled
    if dittoServer.Spec.Metrics != nil && dittoServer.Spec.Metrics.Enabled {
        metricsPort := int32(9090)
        if dittoServer.Spec.Metrics.Port > 0 {
            metricsPort = dittoServer.Spec.Metrics.Port
        }
        ports = append(ports, corev1.ContainerPort{
            Name:          "metrics",
            ContainerPort: metricsPort,
            Protocol:      corev1.ProtocolTCP,
        })
    }

    // Add SMB port if enabled
    if dittoServer.Spec.SMB != nil && dittoServer.Spec.SMB.Enabled {
        smbPort := getSMBPort(dittoServer)
        ports = append(ports, corev1.ContainerPort{
            Name:          "smb",
            ContainerPort: smbPort,
            Protocol:      corev1.ProtocolTCP,
        })
    }

    return ports
}
```

**Update status to include file and API endpoints:**

In the Reconcile function, update status:

```go
dittoServerCopy.Status.NFSEndpoint = fmt.Sprintf("%s-file.%s.svc.cluster.local:%d",
    dittoServer.Name, dittoServer.Namespace, getNFSPort(dittoServer))
```
  </action>
  <verify>
1. Run `cd k8s/dittofs-operator && go build ./...` - should compile
2. Verify all four reconcile functions exist: `grep -n "func.*reconcile.*Service" k8s/dittofs-operator/internal/controller/dittoserver_controller.go`
  </verify>
  <done>
Controller creates four Services: headless (StatefulSet DNS), file (NFS+SMB), API (REST), and metrics (conditional).
  </done>
</task>

<task type="auto">
  <name>Task 3: Add port validation to webhook</name>
  <files>
    k8s/dittofs-operator/api/v1alpha1/dittoserver_webhook.go
  </files>
  <action>
Add port validation to the webhook. This validates:
1. Port range (1-65535) - already handled by kubebuilder markers
2. Port uniqueness across NFS, SMB, API, metrics
3. Warning for privileged ports (< 1024)

**Update the webhook file to add validation logic:**

Find the `ValidateCreate` and `ValidateUpdate` methods and add port validation.

```go
// validatePorts checks port configuration for conflicts and warns about privileged ports.
func (r *DittoServer) validatePorts() (admission.Warnings, error) {
    var warnings admission.Warnings

    // Get NFS port (default 2049)
    nfsPort := int32(2049)
    if r.Spec.NFSPort != nil {
        nfsPort = *r.Spec.NFSPort
    }

    // Get SMB port (default 445)
    smbPort := int32(445)
    smbEnabled := r.Spec.SMB != nil && r.Spec.SMB.Enabled
    if smbEnabled && r.Spec.SMB.Port != nil {
        smbPort = *r.Spec.SMB.Port
    }

    // Get API port (default 8080)
    apiPort := int32(8080)
    if r.Spec.ControlPlane != nil && r.Spec.ControlPlane.Port > 0 {
        apiPort = r.Spec.ControlPlane.Port
    }

    // Get metrics port (default 9090)
    metricsPort := int32(9090)
    metricsEnabled := r.Spec.Metrics != nil && r.Spec.Metrics.Enabled
    if metricsEnabled && r.Spec.Metrics.Port > 0 {
        metricsPort = r.Spec.Metrics.Port
    }

    // Build port map for uniqueness check
    ports := map[int32]string{
        nfsPort: "nfs",
        apiPort: "api",
    }

    // Check SMB port uniqueness
    if smbEnabled {
        if existing, ok := ports[smbPort]; ok {
            return nil, fmt.Errorf("port %d is used by both %s and smb", smbPort, existing)
        }
        ports[smbPort] = "smb"
    }

    // Check metrics port uniqueness
    if metricsEnabled {
        if existing, ok := ports[metricsPort]; ok {
            return nil, fmt.Errorf("port %d is used by both %s and metrics", metricsPort, existing)
        }
        ports[metricsPort] = "metrics"
    }

    // Warn about privileged ports (< 1024)
    for port, name := range ports {
        if port < 1024 {
            warnings = append(warnings,
                fmt.Sprintf("%s port %d is privileged; may require CAP_NET_BIND_SERVICE capability", name, port))
        }
    }

    return warnings, nil
}
```

**Update ValidateCreate:**
```go
func (r *DittoServer) ValidateCreate() (admission.Warnings, error) {
    dittoserverlog.Info("validate create", "name", r.Name)

    warnings, err := r.validatePorts()
    if err != nil {
        return warnings, err
    }

    // Add any other validation here...

    return warnings, nil
}
```

**Update ValidateUpdate:**
```go
func (r *DittoServer) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
    dittoserverlog.Info("validate update", "name", r.Name)

    warnings, err := r.validatePorts()
    if err != nil {
        return warnings, err
    }

    // Add any other validation here...

    return warnings, nil
}
```

Add necessary imports if not present:
```go
import (
    "fmt"
    // ... other imports
)
```
  </action>
  <verify>
1. Run `cd k8s/dittofs-operator && go build ./...` - should compile
2. Verify webhook validation: `grep -n "validatePorts" k8s/dittofs-operator/api/v1alpha1/dittoserver_webhook.go`
  </verify>
  <done>
Webhook validates port uniqueness and warns about privileged ports.
  </done>
</task>

<task type="auto">
  <name>Task 4: Update sample CR for new CRD format</name>
  <files>
    k8s/dittofs-operator/config/samples/dittofs_v1alpha1_dittofs_memory.yaml
  </files>
  <action>
Update the sample CR to use the new simplified CRD format.

**Replace the sample with:**

```yaml
apiVersion: dittofs.dittofs.com/v1alpha1
kind: DittoServer
metadata:
  labels:
    app.kubernetes.io/name: dittofs-operator
    app.kubernetes.io/managed-by: kustomize
  name: dittofs-sample
spec:
  # Container image
  image: marmos91c/dittofs:latest
  replicas: 1

  # Internal storage for server (not NFS exports)
  storage:
    metadataSize: "10Gi"
    contentSize: "50Gi"
    # storageClassName: standard  # Optional: uses default if not specified

  # Database configuration (SQLite by default)
  database:
    type: sqlite
    sqlite:
      path: /data/controlplane/controlplane.db

  # Cache configuration (WAL-backed for crash recovery)
  cache:
    path: /data/cache
    size: "1GB"

  # Metrics (disabled by default)
  metrics:
    enabled: false
    port: 9090

  # Control plane REST API
  controlPlane:
    port: 8080

  # Identity/authentication configuration
  # NOTE: You must create these secrets before applying this CR
  identity:
    jwt:
      secretRef:
        name: dittofs-jwt-secret
        key: jwt-secret
      accessTokenDuration: "15m"
      refreshTokenDuration: "168h"
    admin:
      username: admin
      passwordSecretRef:
        name: dittofs-admin-secret
        key: password-hash

  # Kubernetes Service configuration
  service:
    type: LoadBalancer
    # annotations:
    #   service.beta.kubernetes.io/aws-load-balancer-type: nlb

  # NFS port (default 2049)
  nfsPort: 2049

  # SMB (optional, disabled by default)
  # smb:
  #   enabled: true
  #   port: 445
---
# JWT signing secret (required)
apiVersion: v1
kind: Secret
metadata:
  name: dittofs-jwt-secret
type: Opaque
stringData:
  jwt-secret: "your-jwt-signing-secret-at-least-32-chars-long"
---
# Admin password hash secret (required)
# Generate hash with: htpasswd -nbB "" "yourpassword" | cut -d: -f2
apiVersion: v1
kind: Secret
metadata:
  name: dittofs-admin-secret
type: Opaque
stringData:
  password-hash: "$2y$10$example-bcrypt-hash-here"
```

This sample demonstrates:
- New simplified CRD format
- Required secrets for JWT and admin password
- All infrastructure configuration options
- Commented examples for optional features
  </action>
  <verify>
Run `kubectl apply --dry-run=client -f k8s/dittofs-operator/config/samples/dittofs_v1alpha1_dittofs_memory.yaml` - should validate successfully (may need CRD installed).
  </verify>
  <done>
Sample CR updated to match new simplified CRD format with required secrets.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Phase 2 implementation:
- Simplified CRD with infrastructure-only fields
- ConfigMap generation matching DittoFS develop branch format
- Checksum annotation for automatic pod restart
- Four Services (headless, file, API, metrics)
- Port validation webhook
- Updated sample CR with required secrets
  </what-built>
  <how-to-verify>
1. Build and install CRD:
   ```bash
   cd k8s/dittofs-operator
   make generate && make manifests
   make install
   ```

2. Create test secrets:
   ```bash
   kubectl create secret generic dittofs-jwt-secret --from-literal=jwt-secret="test-jwt-secret-at-least-32-characters"
   kubectl create secret generic dittofs-admin-secret --from-literal=password-hash='$2y$10$test'
   ```

3. Apply sample CR:
   ```bash
   kubectl apply -f config/samples/dittofs_v1alpha1_dittofs_memory.yaml
   ```

4. Run operator locally:
   ```bash
   make run
   ```

5. Verify resources created:
   ```bash
   # Check all 4 services
   kubectl get svc | grep dittofs-sample
   # Expected: dittofs-sample-headless, dittofs-sample-file, dittofs-sample-api

   # Check ConfigMap
   kubectl get configmap dittofs-sample-config -o yaml
   # Expected: YAML with logging, database, controlplane, cache (NO shares, adapters)

   # Check StatefulSet has annotation
   kubectl get statefulset dittofs-sample -o jsonpath='{.spec.template.metadata.annotations}'
   # Expected: {"dittofs.io/config-hash":"<some-hash>"}
   ```

6. Verify port validation (should fail):
   ```bash
   # Create a CR with duplicate ports
   cat <<EOF | kubectl apply -f -
   apiVersion: dittofs.dittofs.com/v1alpha1
   kind: DittoServer
   metadata:
     name: test-duplicate-ports
   spec:
     storage:
       metadataSize: "1Gi"
     nfsPort: 8080
     controlPlane:
       port: 8080
   EOF
   ```
   # Expected: Error about duplicate port 8080
  </how-to-verify>
  <resume-signal>Type "approved" to complete Phase 2, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. `cd k8s/dittofs-operator && make generate && make manifests && go build ./...` succeeds
2. Four Services are created: headless, file, API, metrics (conditional)
3. Service builder provides fluent API for building Services
4. Port validation rejects duplicate ports
5. Sample CR updated with new format and required secrets
6. **R2.6 NodePort fallback**: This is manual user configuration via `service.type: NodePort` in the CRD spec, not automatic detection. The operator uses the user-specified serviceType (LoadBalancer default, can override to NodePort or ClusterIP).
</verification>

<success_criteria>
- Headless Service created with ClusterIP: None
- File Service exposes NFS (and SMB if enabled) via LoadBalancer
- API Service exposes REST API via LoadBalancer
- Metrics Service created only when metrics.enabled=true
- Port validation webhook rejects duplicate ports
- Privileged port warning shown for ports < 1024
- Sample CR demonstrates new CRD format with required secrets
</success_criteria>

<output>
After completion, create `.planning/phases/02-configmap-services/02-03-SUMMARY.md`
</output>
