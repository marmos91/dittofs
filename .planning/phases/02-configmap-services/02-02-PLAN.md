---
phase: 02-configmap-services
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - k8s/dittofs-operator/pkg/resources/hash.go
  - k8s/dittofs-operator/internal/controller/dittoserver_controller.go
autonomous: true

must_haves:
  truths:
    - "Pod restarts automatically when ConfigMap content changes"
    - "Pod restarts automatically when referenced Secret content changes"
    - "Hash is deterministic (same inputs produce same hash)"
    - "ConfigMap is reconciled BEFORE StatefulSet to ensure hash is computable"
  artifacts:
    - path: "k8s/dittofs-operator/pkg/resources/hash.go"
      provides: "SHA256 hash computation utility"
      contains: "ComputeConfigHash"
    - path: "k8s/dittofs-operator/internal/controller/dittoserver_controller.go"
      provides: "Checksum annotation on pod template"
      contains: "dittofs.io/config-hash"
  key_links:
    - from: "k8s/dittofs-operator/internal/controller/dittoserver_controller.go"
      to: "k8s/dittofs-operator/pkg/resources/hash.go"
      via: "import and function call"
      pattern: "resources\\.ComputeConfigHash"
    - from: "reconcileStatefulSet"
      to: "reconcileConfigMap"
      via: "ConfigMap must exist before computing hash"
      pattern: "reconcileConfigMap.*before.*reconcileStatefulSet"
---

<objective>
Implement checksum annotation pattern for automatic pod restart on configuration changes.

Purpose: When ConfigMap or referenced Secrets change, the DittoFS pod must restart to pick up new configuration. Kubernetes StatefulSets don't automatically restart pods when ConfigMaps change. The checksum annotation pattern triggers rolling updates by changing the pod template annotation.

Output: Hash utility package and updated controller that applies checksum annotation to pod template.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-configmap-services/02-CONTEXT.md
@.planning/phases/02-configmap-services/02-RESEARCH.md
@k8s/dittofs-operator/internal/controller/dittoserver_controller.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create hash utility package</name>
  <files>
    k8s/dittofs-operator/pkg/resources/hash.go
  </files>
  <action>
Create a new package `pkg/resources` with hash computation utility. This follows the pattern from Helm and Wave operator.

**Create directory and file:**

```go
// Package resources provides utilities for building Kubernetes resources.
package resources

import (
    "crypto/sha256"
    "encoding/hex"
    "fmt"
    "sort"
)

// ConfigHashAnnotation is the annotation key for the configuration hash.
// When this value changes, Kubernetes triggers a rolling update of the StatefulSet.
const ConfigHashAnnotation = "dittofs.io/config-hash"

// ComputeConfigHash computes a deterministic SHA256 hash of configuration data.
// The hash includes:
// - ConfigMap content (the YAML configuration)
// - All referenced Secrets (JWT secret, admin password, database credentials)
// - CRD generation number (for extra safety)
//
// The secrets map keys should be sorted before calling this function, or this
// function will sort them internally to ensure deterministic output.
//
// Parameters:
//   - configData: The ConfigMap content (YAML string)
//   - secrets: Map of secret name to secret data bytes
//   - generation: The CRD metadata.generation value
//
// Returns:
//   - A hex-encoded SHA256 hash string
func ComputeConfigHash(configData string, secrets map[string][]byte, generation int64) string {
    h := sha256.New()

    // Hash ConfigMap content
    h.Write([]byte(configData))

    // Hash secrets in sorted order for determinism
    keys := make([]string, 0, len(secrets))
    for k := range secrets {
        keys = append(keys, k)
    }
    sort.Strings(keys)

    for _, k := range keys {
        h.Write([]byte(k))
        h.Write(secrets[k])
    }

    // Hash generation number
    h.Write([]byte(fmt.Sprintf("gen:%d", generation)))

    return hex.EncodeToString(h.Sum(nil))
}
```

This utility:
- Uses Go standard library only (crypto/sha256, encoding/hex)
- Sorts secret keys for deterministic output
- Includes generation number for extra safety
- Returns hex-encoded hash string
  </action>
  <verify>
Run `cd k8s/dittofs-operator && go build ./pkg/resources/...` - should compile without errors.
  </verify>
  <done>
Hash utility package created with ComputeConfigHash function.
  </done>
</task>

<task type="auto">
  <name>Task 2: Apply checksum annotation in controller</name>
  <files>
    k8s/dittofs-operator/internal/controller/dittoserver_controller.go
  </files>
  <action>
Update the reconciler to compute and apply the config hash annotation to the StatefulSet pod template.

**CRITICAL: Reconciliation Order**

The Reconcile function MUST call `reconcileConfigMap` BEFORE `reconcileStatefulSet`. This ensures:
1. ConfigMap exists when we need to compute the hash
2. The config YAML is current before hash computation

**Verify/update the Reconcile function to have this order:**
```go
func (r *DittoServerReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
    // ... get DittoServer CR ...

    // 1. Reconcile ConfigMap FIRST (hash computation depends on this)
    if err := r.reconcileConfigMap(ctx, dittoServer); err != nil {
        logger.Error(err, "Failed to reconcile ConfigMap")
        return ctrl.Result{}, err
    }

    // 2. Reconcile StatefulSet AFTER ConfigMap (needs ConfigMap content for hash)
    if err := r.reconcileStatefulSet(ctx, dittoServer, replicas); err != nil {
        logger.Error(err, "Failed to reconcile StatefulSet")
        return ctrl.Result{}, err
    }

    // 3. Reconcile Services...
}
```

**Add import:**
```go
import (
    // ... existing imports ...
    "github.com/marmos91/dittofs/k8s/dittofs-operator/pkg/resources"
)
```

**Add helper function to collect secret data:**
```go
// collectSecretData gathers all secret data referenced by the DittoServer CR.
// This is used to compute the config hash - when any secret changes, the hash changes.
func (r *DittoServerReconciler) collectSecretData(ctx context.Context, dittoServer *dittoiov1alpha1.DittoServer) (map[string][]byte, error) {
    secrets := make(map[string][]byte)

    // JWT secret
    if dittoServer.Spec.Identity != nil && dittoServer.Spec.Identity.JWT != nil {
        secret := &corev1.Secret{}
        if err := r.Get(ctx, client.ObjectKey{
            Namespace: dittoServer.Namespace,
            Name:      dittoServer.Spec.Identity.JWT.SecretRef.Name,
        }, secret); err != nil {
            return nil, fmt.Errorf("failed to get JWT secret: %w", err)
        }
        key := dittoServer.Spec.Identity.JWT.SecretRef.Key
        if data, ok := secret.Data[key]; ok {
            secrets["jwt:"+key] = data
        }
    }

    // Admin password secret
    if dittoServer.Spec.Identity != nil && dittoServer.Spec.Identity.Admin != nil &&
       dittoServer.Spec.Identity.Admin.PasswordSecretRef != nil {
        secret := &corev1.Secret{}
        if err := r.Get(ctx, client.ObjectKey{
            Namespace: dittoServer.Namespace,
            Name:      dittoServer.Spec.Identity.Admin.PasswordSecretRef.Name,
        }, secret); err != nil {
            return nil, fmt.Errorf("failed to get admin password secret: %w", err)
        }
        key := dittoServer.Spec.Identity.Admin.PasswordSecretRef.Key
        if data, ok := secret.Data[key]; ok {
            secrets["admin:"+key] = data
        }
    }

    // PostgreSQL connection string secret (if configured)
    if dittoServer.Spec.Database != nil && dittoServer.Spec.Database.PostgresSecretRef != nil {
        secret := &corev1.Secret{}
        if err := r.Get(ctx, client.ObjectKey{
            Namespace: dittoServer.Namespace,
            Name:      dittoServer.Spec.Database.PostgresSecretRef.Name,
        }, secret); err != nil {
            return nil, fmt.Errorf("failed to get postgres secret: %w", err)
        }
        key := dittoServer.Spec.Database.PostgresSecretRef.Key
        if data, ok := secret.Data[key]; ok {
            secrets["postgres:"+key] = data
        }
    }

    return secrets, nil
}
```

**Update reconcileStatefulSet to apply checksum annotation:**

In the `reconcileStatefulSet` function, compute the hash and set annotation BEFORE CreateOrUpdate.

The key insight: We need the ConfigMap content to compute the hash. Since ConfigMap is reconciled FIRST, we can read it directly from the cluster OR regenerate the config YAML (both should produce the same result).

```go
func (r *DittoServerReconciler) reconcileStatefulSet(ctx context.Context, dittoServer *dittoiov1alpha1.DittoServer, replicas int32) error {
    logger := logf.FromContext(ctx)

    // Generate config to compute hash (same config that was just written to ConfigMap)
    configYAML, err := config.GenerateDittoFSConfig(ctx, r.Client, dittoServer)
    if err != nil {
        return fmt.Errorf("failed to generate config for hash: %w", err)
    }

    // Collect secret data for hash computation
    secretData, err := r.collectSecretData(ctx, dittoServer)
    if err != nil {
        logger.Error(err, "Failed to collect secret data for hash, using config-only hash")
        secretData = make(map[string][]byte)
    }

    // Compute config hash BEFORE CreateOrUpdate
    configHash := resources.ComputeConfigHash(configYAML, secretData, dittoServer.Generation)

    statefulSet := &appsv1.StatefulSet{
        ObjectMeta: metav1.ObjectMeta{
            Name:      dittoServer.Name,
            Namespace: dittoServer.Namespace,
        },
    }

    _, err = controllerutil.CreateOrUpdate(ctx, r.Client, statefulSet, func() error {
        if err := controllerutil.SetControllerReference(dittoServer, statefulSet, r.Scheme); err != nil {
            return err
        }

        labels := map[string]string{
            "app":      "dittofs-server",
            "instance": dittoServer.Name,
        }

        // ... existing volume mount setup ...

        statefulSet.Spec = appsv1.StatefulSetSpec{
            Replicas:    &replicas,
            ServiceName: dittoServer.Name + "-headless", // Will be created in Plan 03
            Selector: &metav1.LabelSelector{
                MatchLabels: labels,
            },
            Template: corev1.PodTemplateSpec{
                ObjectMeta: metav1.ObjectMeta{
                    Labels: labels,
                    Annotations: map[string]string{
                        resources.ConfigHashAnnotation: configHash,
                    },
                },
                Spec: corev1.PodSpec{
                    // ... rest of pod spec ...
                },
            },
            VolumeClaimTemplates: volumeClaimTemplates,
        }

        return nil
    })

    return err
}
```

**Key changes:**
1. Import the `resources` package
2. Add `collectSecretData` helper function
3. Compute config hash BEFORE CreateOrUpdate (hash is computed outside the mutate function)
4. Apply hash as annotation on `Template.ObjectMeta.Annotations`
5. Update `ServiceName` to use headless service name (`{name}-headless`)
6. **CRITICAL**: Ensure ConfigMap is reconciled BEFORE StatefulSet in Reconcile function (verify ordering)

The full updated function should maintain all existing logic (volume mounts, PVCs, container ports, probes) while adding the annotation.
  </action>
  <verify>
1. Run `cd k8s/dittofs-operator && go build ./...` - should compile without errors
2. Run `cd k8s/dittofs-operator && go test ./internal/controller/...` - tests should pass (if they exist)
3. Verify the annotation constant is used: `grep -r "dittofs.io/config-hash" k8s/dittofs-operator/`
4. Verify reconcile order: `grep -n "reconcileConfigMap\|reconcileStatefulSet" k8s/dittofs-operator/internal/controller/dittoserver_controller.go` - ConfigMap should appear before StatefulSet
  </verify>
  <done>
Controller computes and applies checksum annotation to StatefulSet pod template. Annotation changes when ConfigMap content or referenced Secrets change. ConfigMap is reconciled before StatefulSet to ensure hash is computable.
  </done>
</task>

</tasks>

<verification>
1. `cd k8s/dittofs-operator && go build ./...` succeeds
2. `pkg/resources/hash.go` exists with `ComputeConfigHash` function
3. `dittoserver_controller.go` imports `resources` package and calls `ComputeConfigHash`
4. Pod template in StatefulSet has `dittofs.io/config-hash` annotation
5. Hash includes ConfigMap content, JWT secret, admin password, and database credentials
6. **Reconcile function calls `reconcileConfigMap` BEFORE `reconcileStatefulSet`** (verify line numbers show correct order)
</verification>

<success_criteria>
- Hash utility computes deterministic SHA256 hash
- Hash includes ConfigMap content + all referenced Secrets + generation
- StatefulSet pod template has checksum annotation
- When ConfigMap or Secret changes, hash changes, triggering pod restart
- ConfigMap reconciled before StatefulSet (correct ordering verified)
</success_criteria>

<output>
After completion, create `.planning/phases/02-configmap-services/02-02-SUMMARY.md`
</output>
