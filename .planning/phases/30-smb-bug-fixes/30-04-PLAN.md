---
phase: 30-smb-bug-fixes
plan: 04
type: execute
wave: 2
depends_on:
  - 30-01
  - 30-02
  - 30-03
files_modified:
  - pkg/adapter/adapter.go
  - pkg/adapter/smb/adapter.go
  - internal/adapter/nfs/v3/handlers/write.go
  - internal/adapter/nfs/v3/handlers/read.go
  - internal/adapter/nfs/v3/handlers/remove.go
  - internal/adapter/nfs/v3/handlers/rename.go
  - internal/adapter/smb/v2/handlers/create.go
  - internal/adapter/smb/v2/handlers/handler.go
autonomous: true
requirements:
  - BUG-04
  - BUG-06

must_haves:
  truths:
    - "NFS v3 write operations trigger oplock break for SMB clients holding oplocks on same files"
    - "NFS v3 remove/rename operations trigger oplock break for SMB clients"
    - "NFS v3 read operations trigger oplock break for SMB Write leases"
    - "Share list is cached for pipe CREATE operations and invalidated on share add/remove"
    - "Oplock break mechanism is generic via Runtime — not hardwired NFS->SMB"
  artifacts:
    - path: "pkg/adapter/adapter.go"
      provides: "OplockBreaker interface for cross-protocol oplock coordination"
      contains: "OplockBreaker"
    - path: "pkg/adapter/smb/adapter.go"
      provides: "SMB adapter registers OplockManager via SetAdapterProvider"
      contains: "SetAdapterProvider"
    - path: "internal/adapter/nfs/v3/handlers/write.go"
      provides: "NFS write triggers oplock break via Runtime"
      contains: "CheckAndBreakForWrite"
    - path: "internal/adapter/smb/v2/handlers/handler.go"
      provides: "Cached share list with invalidation"
      contains: "cachedShares"
  key_links:
    - from: "internal/adapter/nfs/v3/handlers/write.go"
      to: "pkg/adapter/adapter.go"
      via: "OplockBreaker interface retrieved from Runtime"
      pattern: "GetAdapterProvider.*oplock"
    - from: "pkg/adapter/smb/adapter.go"
      to: "pkg/controlplane/runtime/runtime.go"
      via: "SetAdapterProvider registers OplockManager"
      pattern: "SetAdapterProvider"
    - from: "internal/adapter/smb/v2/handlers/handler.go"
      to: "pkg/controlplane/runtime/runtime.go"
      via: "OnShareChange invalidates cached share list"
      pattern: "OnShareChange"
---

<objective>
Wire cross-protocol oplock break (#213) and cache pipe share list (#223).

Purpose: (1) NFS v3 handlers have TODO placeholders for oplock break but never call the SMB OplockManager, meaning SMB clients with cached writes can lose data when NFS modifies the same file. The fix uses the generic Runtime adapter provider pattern (per user decision). (2) The pipe CREATE handler fetches the full share list from the control plane on every request, which is inefficient under high load. Fix with a cache invalidated on share changes.

Output: OplockBreaker interface + NFS handler wiring + SMB registration + share list cache with invalidation
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-smb-bug-fixes/30-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs -->

From pkg/controlplane/runtime/runtime.go:
```go
func (r *Runtime) SetAdapterProvider(key string, p any)
func (r *Runtime) GetAdapterProvider(key string) any
func (r *Runtime) OnShareChange(callback func(shares []string))
func (r *Runtime) ListShares() []string
```

From internal/adapter/smb/v2/handlers/oplock.go:
```go
type OplockManager struct { ... }

// CheckAndBreakForWrite checks for SMB leases that conflict with a write operation
func (m *OplockManager) CheckAndBreakForWrite(ctx context.Context, fileHandle lock.FileHandle) error

// CheckAndBreakForRead checks for SMB leases that conflict with a read operation
func (m *OplockManager) CheckAndBreakForRead(ctx context.Context, fileHandle lock.FileHandle) error

// CheckAndBreakForDelete checks for SMB Handle leases that must break before file deletion
func (m *OplockManager) CheckAndBreakForDelete(ctx context.Context, fileHandle lock.FileHandle) error
```

From pkg/metadata/lock/types.go:
```go
type FileHandle string  // Opaque file handle for lock operations
```

From internal/adapter/nfs/v3/handlers/doc.go:
```go
type Handler struct {
    Registry *runtime.Runtime
    authCache sync.Map
}
```

From internal/adapter/smb/v2/handlers/handler.go:
```go
type Handler struct {
    Registry      *runtime.Runtime
    OplockManager *OplockManager
    PipeManager   *rpc.PipeManager
    // ...
}
```

From pkg/adapter/smb/adapter.go:
```go
type Adapter struct {
    adapter.BaseAdapter
    handler  *handlers.Handler
    Registry *runtime.Runtime
    config   Config
    // ...
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define OplockBreaker interface and wire NFS v3 handlers + SMB adapter registration</name>
  <files>pkg/adapter/adapter.go, pkg/adapter/smb/adapter.go, internal/adapter/nfs/v3/handlers/write.go, internal/adapter/nfs/v3/handlers/read.go, internal/adapter/nfs/v3/handlers/remove.go, internal/adapter/nfs/v3/handlers/rename.go</files>
  <action>
**Step 1: Define OplockBreaker interface in `pkg/adapter/adapter.go`**

Add the `OplockBreaker` interface. This lives in `pkg/adapter/` which is a shared package both NFS and SMB handlers can import without circular dependencies:

```go
// OplockBreaker provides cross-protocol oplock break coordination.
// Adapters holding opportunistic locks register an implementation via
// Runtime.SetAdapterProvider("oplock_breaker", breaker).
// Other adapters retrieve and call it to trigger breaks before conflicting operations.
//
// This generic interface decouples protocol adapters: NFS handlers don't
// import SMB packages and vice versa. The OplockManager in the SMB adapter
// satisfies this interface.
type OplockBreaker interface {
    // CheckAndBreakForWrite triggers lease break for write-conflicting oplocks.
    // Returns nil if no break needed, ErrLeaseBreakPending if break initiated.
    CheckAndBreakForWrite(ctx context.Context, fileHandle lock.FileHandle) error

    // CheckAndBreakForRead triggers lease break for read-conflicting oplocks (Write leases).
    CheckAndBreakForRead(ctx context.Context, fileHandle lock.FileHandle) error

    // CheckAndBreakForDelete triggers lease break for Handle leases before deletion.
    CheckAndBreakForDelete(ctx context.Context, fileHandle lock.FileHandle) error
}
```

Add imports: `"context"`, `"github.com/marmos91/dittofs/pkg/metadata/lock"`.

Also add a constant for the provider key:
```go
// OplockBreakerProviderKey is the Runtime adapter provider key for the OplockBreaker.
const OplockBreakerProviderKey = "oplock_breaker"
```

**Step 2: Register OplockManager in SMB adapter**

In `pkg/adapter/smb/adapter.go`, in the `SetRuntime()` method (around the call to `s.applySMBSettings(rt)`), add:

```go
// Register OplockManager as the cross-protocol oplock breaker.
// This allows NFS handlers to trigger oplock breaks on SMB clients
// without importing the SMB handler package.
if s.handler != nil && s.handler.OplockManager != nil {
    rt.SetAdapterProvider(adapter.OplockBreakerProviderKey, s.handler.OplockManager)
}
```

Import `"github.com/marmos91/dittofs/pkg/adapter"` if not already present.

**Step 3: Wire NFS v3 handlers**

Create a helper function in a new file or at the top of one of the handler files (e.g., `write.go`) to avoid duplication. Or better, add a helper method on the NFS v3 Handler:

In `internal/adapter/nfs/v3/handlers/doc.go` (or a suitable handlers file), add:

```go
// getOplockBreaker retrieves the cross-protocol OplockBreaker from the Runtime.
// Returns nil if no adapter has registered an oplock breaker (e.g., SMB not running).
func (h *Handler) getOplockBreaker() adapter.OplockBreaker {
    if h.Registry == nil {
        return nil
    }
    provider := h.Registry.GetAdapterProvider(adapter.OplockBreakerProviderKey)
    if provider == nil {
        return nil
    }
    breaker, ok := provider.(adapter.OplockBreaker)
    if !ok {
        return nil
    }
    return breaker
}
```

Import `"github.com/marmos91/dittofs/pkg/adapter"`.

**Step 4: Replace TODO placeholders in NFS v3 handlers**

In `internal/adapter/nfs/v3/handlers/write.go` (around line 211-216), replace:
```go
// TODO(plan-03): Wire to LockManager.CheckAndBreakOpLocksForWrite() once
// centralized break methods are available (Phase 26 Plan 03).
```
With:
```go
if breaker := h.getOplockBreaker(); breaker != nil {
    if err := breaker.CheckAndBreakForWrite(ctx.Context, lock.FileHandle(string(fileHandle))); err != nil {
        // Fire-and-forget: per Samba behavior, NFS proceeds even if break is pending.
        // The break notification is sent to the SMB client asynchronously.
        logger.Debug("NFS WRITE: oplock break initiated",
            "handle", fileHandle, "result", err)
    }
}
```

In `internal/adapter/nfs/v3/handlers/read.go` (around line 186-191), replace the TODO:
```go
if breaker := h.getOplockBreaker(); breaker != nil {
    if err := breaker.CheckAndBreakForRead(ctx.Context, lock.FileHandle(string(fileHandle))); err != nil {
        logger.Debug("NFS READ: oplock break initiated",
            "handle", fileHandle, "result", err)
    }
}
```

In `internal/adapter/nfs/v3/handlers/remove.go` (around line 150-155), replace the TODO:
```go
if breaker := h.getOplockBreaker(); breaker != nil {
    if err := breaker.CheckAndBreakForDelete(ctx.Context, lock.FileHandle(string(childHandle))); err != nil {
        logger.Debug("NFS REMOVE: oplock break initiated",
            "handle", childHandle, "result", err)
    }
}
```

In `internal/adapter/nfs/v3/handlers/rename.go` (around line 251-257), replace the TODO:
```go
if breaker := h.getOplockBreaker(); breaker != nil {
    if err := breaker.CheckAndBreakForDelete(ctx.Context, lock.FileHandle(string(sourceHandle))); err != nil {
        logger.Debug("NFS RENAME: oplock break on source initiated",
            "handle", sourceHandle, "result", err)
    }
    // Also break on destination if it exists
    if destHandle != "" {
        if err := breaker.CheckAndBreakForDelete(ctx.Context, lock.FileHandle(string(destHandle))); err != nil {
            logger.Debug("NFS RENAME: oplock break on destination initiated",
                "handle", destHandle, "result", err)
        }
    }
}
```

Import `"github.com/marmos91/dittofs/pkg/metadata/lock"` in each handler file.

**Important:** The `lock.FileHandle` conversion from NFS handle to the format expected by OplockManager must use the same handle encoding. Check that the NFS `fileHandle` (metadata.FileHandle) can be cast to `lock.FileHandle` — they should be the same underlying string type. If not, use `lock.FileHandle(string(fileHandle))`.

Per user discretion: fire-and-forget approach for oplock breaks (ignore ErrLeaseBreakPending). NFS has no mechanism to delay responses for oplock breaks. This matches Samba's default behavior.
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs-phase-30 && go build ./pkg/adapter/... && go build ./internal/adapter/nfs/... && go build ./pkg/adapter/smb/...</automated>
  </verify>
  <done>OplockBreaker interface defined in pkg/adapter. SMB adapter registers OplockManager on startup. NFS v3 write/read/remove/rename handlers call oplock break via Runtime (fire-and-forget). All TODO(plan-03) placeholders replaced.</done>
</task>

<task type="auto">
  <name>Task 2: Cache pipe share list with event-driven invalidation</name>
  <files>internal/adapter/smb/v2/handlers/handler.go, internal/adapter/smb/v2/handlers/create.go</files>
  <action>
**Step 1: Add cache fields to Handler struct in `handler.go`**

Add cache fields to the `Handler` struct:
```go
type Handler struct {
    // ... existing fields ...

    // Cached share list for pipe CREATE operations (IPC$).
    // Protected by sharesCacheMu. Invalidated via Runtime.OnShareChange().
    cachedShares     []rpc.ShareInfo1
    sharesCacheMu    sync.RWMutex
    sharesCacheValid bool
}
```

The `rpc` and `sync` imports should already be present.

Add a method to get/refresh the cached shares:
```go
// getCachedShares returns the cached share list, rebuilding if invalidated.
// Thread-safe via RWMutex (concurrent reads allowed, exclusive write for rebuild).
func (h *Handler) getCachedShares() []rpc.ShareInfo1 {
    h.sharesCacheMu.RLock()
    if h.sharesCacheValid {
        shares := h.cachedShares
        h.sharesCacheMu.RUnlock()
        return shares
    }
    h.sharesCacheMu.RUnlock()

    // Rebuild cache under write lock
    h.sharesCacheMu.Lock()
    defer h.sharesCacheMu.Unlock()

    // Double-check after acquiring write lock (another goroutine may have rebuilt)
    if h.sharesCacheValid {
        return h.cachedShares
    }

    if h.Registry == nil {
        return nil
    }

    shareNames := h.Registry.ListShares()
    shares := make([]rpc.ShareInfo1, 0, len(shareNames))
    for _, name := range shareNames {
        if strings.EqualFold(name, "/ipc$") {
            continue
        }
        displayName := strings.TrimPrefix(name, "/")
        shares = append(shares, rpc.ShareInfo1{
            Name:    displayName,
            Type:    rpc.STYPE_DISKTREE,
            Comment: "DittoFS share",
        })
    }

    h.cachedShares = shares
    h.sharesCacheValid = true

    return shares
}

// invalidateShareCache marks the share list cache as stale.
// Called by the Runtime share change callback.
func (h *Handler) invalidateShareCache() {
    h.sharesCacheMu.Lock()
    h.sharesCacheValid = false
    h.sharesCacheMu.Unlock()
}
```

Import `"strings"` if not already present.

**Step 2: Register invalidation callback**

Add a method to register the callback, to be called during adapter setup. Add to `handler.go`:
```go
// RegisterShareChangeCallback subscribes to share change events from the Runtime
// to invalidate the cached share list used by pipe CREATE operations.
func (h *Handler) RegisterShareChangeCallback() {
    if h.Registry == nil {
        return
    }
    h.Registry.OnShareChange(func(_ []string) {
        h.invalidateShareCache()
    })
}
```

Call this from the SMB adapter's `SetRuntime()` method in `pkg/adapter/smb/adapter.go`:
```go
// Register share change callback for cache invalidation
s.handler.RegisterShareChangeCallback()
```

**Step 3: Update handlePipeCreate in `create.go`**

Replace the existing share list fetching block (lines 632-652):
```go
// Update pipe metaSvc with current shares from registry.
// TODO: This is called on every pipe CREATE which is inefficient under high load.
// Consider caching the share list and invalidating on share add/remove events.
if h.Registry != nil {
    shareNames := h.Registry.ListShares()
    shares := make([]rpc.ShareInfo1, 0, len(shareNames))
    for _, name := range shareNames {
        // Skip IPC$ virtual share
        if strings.EqualFold(name, "/ipc$") {
            continue
        }
        // Convert to share info
        displayName := strings.TrimPrefix(name, "/")
        shares = append(shares, rpc.ShareInfo1{
            Name:    displayName,
            Type:    rpc.STYPE_DISKTREE,
            Comment: "DittoFS share",
        })
    }
    h.PipeManager.SetShares(shares)
}
```

With the cached version:
```go
// Update pipe manager with cached share list.
// Cache is invalidated via Runtime.OnShareChange() callback.
if shares := h.getCachedShares(); shares != nil {
    h.PipeManager.SetShares(shares)
}
```

This removes the TODO comment and the inefficient per-request share list rebuild.
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs-phase-30 && go build ./internal/adapter/smb/... && go build ./pkg/adapter/smb/...</automated>
  </verify>
  <done>Share list cached in Handler with RWMutex. Cache invalidated via Runtime.OnShareChange() callback. Pipe CREATE uses cached shares instead of rebuilding on every request. Double-check locking pattern prevents race conditions.</done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles cleanly (full project build to catch import cycles)
2. `go test ./internal/adapter/nfs/v3/handlers/` passes
3. `go test ./internal/adapter/smb/v2/handlers/` passes
4. `go test ./pkg/adapter/...` passes
5. `go vet ./...` reports no issues
6. No import cycles (verified by successful build)
</verification>

<success_criteria>
- OplockBreaker interface defined in shared pkg/adapter package (no import cycles)
- SMB adapter registers OplockManager as adapter provider during SetRuntime
- NFS v3 write/read/remove/rename handlers call oplock break via generic Runtime pattern
- Fire-and-forget approach: NFS proceeds regardless of break result (per Samba behavior)
- Share list cached with RWMutex, invalidated via OnShareChange callback
- No regressions in NFS or SMB tests
</success_criteria>

<output>
After completion, create `.planning/phases/30-smb-bug-fixes/30-04-SUMMARY.md`
</output>
