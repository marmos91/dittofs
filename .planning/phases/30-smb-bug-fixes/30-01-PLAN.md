---
phase: 30-smb-bug-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/payload/offloader/download.go
  - pkg/payload/io/read.go
  - pkg/payload/offloader/download_test.go
  - pkg/payload/io/read_test.go
autonomous: true
requirements:
  - BUG-01

must_haves:
  truths:
    - "Reading unwritten regions within file size returns zero bytes instead of error"
    - "Reading beyond file size returns short read / EOF (standard POSIX behavior)"
    - "Both NFS and SMB reads of sparse files return zeros for gaps (payload layer fix)"
  artifacts:
    - path: "pkg/payload/offloader/download.go"
      provides: "Sparse block zero-fill in downloadBlock"
      contains: "ErrBlockNotFound"
    - path: "pkg/payload/io/read.go"
      provides: "Sparse-safe ensureAndReadFromCache"
      contains: "sparse"
  key_links:
    - from: "pkg/payload/offloader/download.go"
      to: "pkg/payload/store/store.go"
      via: "errors.Is(err, store.ErrBlockNotFound)"
      pattern: "ErrBlockNotFound"
    - from: "pkg/payload/io/read.go"
      to: "pkg/payload/offloader/download.go"
      via: "EnsureAvailable -> downloadBlock sparse-aware"
      pattern: "ensureAndReadFromCache"
---

<objective>
Fix sparse file READ to return zeros for unwritten blocks instead of errors (#180).

Purpose: Windows Explorer reads beyond written data within file size. The offloader's `downloadBlock()` propagates `ErrBlockNotFound` as a hard error instead of zero-filling sparse regions, causing read failures. The fix belongs in the payload layer so both NFS and SMB benefit automatically (per user decision).

Output: Sparse-aware offloader download + sparse-safe io/read path + unit tests
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-smb-bug-fixes/30-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs -->

From pkg/payload/store/store.go:
```go
// ErrBlockNotFound is returned when a requested block doesn't exist.
ErrBlockNotFound = errors.New("block not found")

type PayloadStore interface {
    ReadBlock(ctx context.Context, key string) ([]byte, error)
    ReadBlockRange(ctx context.Context, key string, offset, length int64) ([]byte, error)
    // ...
}
```

From pkg/payload/offloader/download.go:
```go
// downloadBlock downloads a single block from the block store and caches it.
func (m *Offloader) downloadBlock(ctx context.Context, payloadID string, chunkIdx, blockIdx uint32) error

// EnsureAvailable ensures the requested data range is in cache, downloading if needed.
func (m *Offloader) EnsureAvailable(ctx context.Context, payloadID string, chunkIdx uint32, offset, length uint32) error
```

From pkg/payload/io/read.go:
```go
type BlockDownloader interface {
    EnsureAvailable(ctx context.Context, payloadID string, chunkIdx uint32, offset, length uint32) error
    GetFileSize(ctx context.Context, payloadID string) (uint64, error)
    Exists(ctx context.Context, payloadID string) (bool, error)
}

// ensureAndReadFromCache ensures data is available from block store and reads it.
func (s *ServiceImpl) ensureAndReadFromCache(ctx, payloadID, blockRange, chunkOffset, dest) error
```

From pkg/cache/cache.go:
```go
// ReadAt reads data from cache. Returns (found=false, nil) for cache miss.
// For sparse blocks (never written), dest is unchanged (pre-zeroed by caller).
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix downloadBlock to zero-fill sparse blocks and update ensureAndReadFromCache</name>
  <files>pkg/payload/offloader/download.go, pkg/payload/io/read.go</files>
  <action>
**In `pkg/payload/offloader/download.go`, function `downloadBlock()`:**

1. Import `"errors"` and `"github.com/marmos91/dittofs/pkg/payload/store"` (for `store.ErrBlockNotFound`)
2. After the `m.blockStore.ReadBlock()` call (line 31-34), detect `ErrBlockNotFound` and treat it as a sparse block:
   ```go
   data, err := m.blockStore.ReadBlock(ctx, blockKeyStr)
   if err != nil {
       if errors.Is(err, store.ErrBlockNotFound) {
           // Sparse block: block was never written. Create zero-filled data.
           // Per user decision: zero-fill gaps within file size; the caller
           // (EnsureAvailable) only requests blocks within file boundaries.
           logger.Debug("Sparse block detected, zero-filling",
               "block", blockKeyStr)
           data = make([]byte, BlockSize)
       } else {
           return fmt.Errorf("download block %s: %w", blockKeyStr, err)
       }
   }
   ```
3. The rest of the function (`WriteDownloaded`) continues as-is with the zero-filled data

**In `pkg/payload/io/read.go`, function `ensureAndReadFromCache()` (line 213-228):**

The current code at line 223 treats `found=false` after `EnsureAvailable` as an error. For sparse blocks, `EnsureAvailable` may succeed (the downloadBlock wrote zero bytes via WriteDownloaded), but `ReadAt` may report `found=false` if the cache implementation doesn't track the zero data. Fix:

```go
func (s *ServiceImpl) ensureAndReadFromCache(ctx context.Context, payloadID string, blockRange chunk.BlockRange, chunkOffset uint32, dest []byte) error {
    err := s.blockDownloader.EnsureAvailable(ctx, payloadID, blockRange.ChunkIndex, chunkOffset, blockRange.Length)
    if err != nil {
        return fmt.Errorf("ensure available for block %d/%d failed: %w", blockRange.ChunkIndex, blockRange.BlockIndex, err)
    }

    found, err := s.cacheReader.ReadAt(ctx, payloadID, blockRange.ChunkIndex, chunkOffset, blockRange.Length, dest)
    if err != nil {
        return fmt.Errorf("read after download for block %d/%d failed: %w", blockRange.ChunkIndex, blockRange.BlockIndex, err)
    }
    if !found {
        // Sparse block: EnsureAvailable downloaded zero-filled data but cache
        // may not have stored it. dest is pre-zeroed by Go runtime (make([]byte, ...)),
        // so zero-fill is implicit. This is correct sparse behavior.
        logger.Debug("Sparse block: cache miss after download, returning zeros",
            "payloadID", payloadID,
            "chunk", blockRange.ChunkIndex,
            "block", blockRange.BlockIndex)
    }

    return nil
}
```

Also apply the same sparse-safe pattern to `readFromCOWSource()` (line 200-201):
```go
sourceFound, sourceErr = s.cacheReader.ReadAt(...)
if sourceErr != nil {
    return fmt.Errorf("COW source read after download for block %d/%d failed: %w", ...)
}
if !sourceFound {
    // Sparse block from COW source - zeros already in dest
    logger.Debug("Sparse COW block: returning zeros", ...)
}
```

Import `"github.com/marmos91/dittofs/internal/logger"` if not already imported in read.go.
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs-phase-30 && go build ./pkg/payload/...</automated>
  </verify>
  <done>downloadBlock returns zero-filled data for ErrBlockNotFound instead of error. ensureAndReadFromCache and readFromCOWSource treat cache miss after successful EnsureAvailable as sparse zero-fill instead of error.</done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for sparse block handling in offloader and io/read</name>
  <files>pkg/payload/offloader/download_test.go, pkg/payload/io/read_test.go</files>
  <action>
**In `pkg/payload/offloader/download_test.go`** (create if it doesn't exist, add to existing if it does):

1. Test `downloadBlock` with a mock block store that returns `store.ErrBlockNotFound`:
   - Verify no error returned
   - Verify cache received zero-filled `BlockSize` bytes via `WriteDownloaded`
   - Use testify assertions

2. Test `downloadBlock` with a real block store error (e.g., network error):
   - Verify error IS returned (not treated as sparse)

3. Test `EnsureAvailable` end-to-end with sparse blocks:
   - Set up an offloader with a mock store where some blocks return `ErrBlockNotFound`
   - Verify `EnsureAvailable` returns nil (not error)

**In `pkg/payload/io/read_test.go`** (add to existing tests):

1. Test `ensureAndReadFromCache` sparse path:
   - Mock `BlockDownloader.EnsureAvailable` returning nil
   - Mock `CacheReader.ReadAt` returning `(false, nil)` â€” cache miss after download
   - Verify function returns nil (not error)
   - Verify dest buffer contains zeros

2. Test `ReadAt` end-to-end with sparse blocks:
   - Mock cache returning `found=false` for specific block ranges
   - Mock downloader succeeding
   - Mock cache returning `found=false` again after download (sparse)
   - Verify total bytes read matches request length
   - Verify data buffer contains zeros for sparse regions

3. Test normal (non-sparse) flow still works:
   - Mock cache hit on first try
   - Verify data returned correctly

Use `github.com/stretchr/testify/assert` and `github.com/stretchr/testify/mock` or manual mock structs implementing the interfaces from read.go.
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs-phase-30 && go test -v ./pkg/payload/offloader/ -run "Sparse|sparse" && go test -v ./pkg/payload/io/ -run "Sparse|sparse"</automated>
  </verify>
  <done>Unit tests verify: (1) sparse blocks return zeros not errors in downloadBlock, (2) real errors still propagate, (3) ensureAndReadFromCache handles cache miss after download as sparse, (4) end-to-end ReadAt returns zeros for sparse regions.</done>
</task>

</tasks>

<verification>
1. `go build ./pkg/payload/...` compiles cleanly
2. `go test ./pkg/payload/offloader/` passes (including new sparse tests)
3. `go test ./pkg/payload/io/` passes (including new sparse tests)
4. `go vet ./pkg/payload/...` reports no issues
</verification>

<success_criteria>
- Sparse file reads within file size return zero-filled data instead of errors
- Reads beyond file size still return EOF/short read (unchanged behavior)
- Both NFS and SMB benefit from the fix (payload layer change)
- Unit tests cover sparse, normal, and error paths
- No regressions in existing payload tests
</success_criteria>

<output>
After completion, create `.planning/phases/30-smb-bug-fixes/30-01-SUMMARY.md`
</output>
