---
phase: 30-smb-bug-fixes
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/metadata/file_modify.go
  - pkg/metadata/file_modify_test.go
autonomous: true
requirements:
  - BUG-02

must_haves:
  truths:
    - "After renaming a directory, its children have updated paths in the metadata store"
    - "After renaming a directory, QUERY_DIRECTORY on the parent shows correct child paths"
    - "Nested subdirectories and files all have their Path prefixes updated recursively"
  artifacts:
    - path: "pkg/metadata/file_modify.go"
      provides: "Path update in Move() and recursive updateDescendantPaths helper"
      contains: "srcFile.Path = destPath"
    - path: "pkg/metadata/file_modify_test.go"
      provides: "Tests for directory rename path propagation"
      contains: "TestMove.*Rename"
  key_links:
    - from: "pkg/metadata/file_modify.go"
      to: "pkg/metadata/store.go"
      via: "Transaction.ListChildren + PutFile for recursive path update"
      pattern: "ListChildren.*PutFile"
---

<objective>
Fix renamed directory children to reflect updated paths in QUERY_DIRECTORY (#181).

Purpose: When a directory is renamed, the `Move()` function in `file_modify.go` updates the parent-child relationship and timestamps but never updates `srcFile.Path` to the new destination path. This causes children to retain stale path prefixes, which breaks QUERY_DIRECTORY responses on Windows. Additionally, for directory renames, all descendant paths must be updated recursively.

Output: Fixed Move() with path update + recursive descendant path updater + unit tests
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-smb-bug-fixes/30-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs -->

From pkg/metadata/store.go:
```go
type Transaction interface {
    GetFile(ctx context.Context, handle FileHandle) (*File, error)
    PutFile(ctx context.Context, file *File) error
    DeleteFile(ctx context.Context, handle FileHandle) error
    GetChild(ctx context.Context, dirHandle FileHandle, name string) (FileHandle, error)
    SetChild(ctx context.Context, dirHandle FileHandle, name string, childHandle FileHandle) error
    DeleteChild(ctx context.Context, dirHandle FileHandle, name string) error
    SetParent(ctx context.Context, handle FileHandle, parentHandle FileHandle) error
    ListChildren(ctx context.Context, dirHandle FileHandle, cursor string, limit int) ([]DirEntry, string, error)
    GetLinkCount(ctx context.Context, handle FileHandle) (uint32, error)
    SetLinkCount(ctx context.Context, handle FileHandle, count uint32) error
    WithTransaction(ctx context.Context, fn func(Transaction) error) error
}

type File struct {
    FileHandle FileHandle
    FileAttr
    PayloadID PayloadID
    Path      string  // <-- THIS is what needs updating
}

type DirEntry struct {
    Name   string
    Handle FileHandle
}
```

From pkg/metadata/file_modify.go (Move function, line 510-513):
```go
// Current (broken): Path not updated
now := time.Now()
srcFile.Ctime = now
_ = tx.PutFile(ctx.Context, srcFile)
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix Move() path update and add recursive descendant path updater</name>
  <files>pkg/metadata/file_modify.go</files>
  <action>
**In `pkg/metadata/file_modify.go`, function `Move()`, inside the `WithTransaction` callback (line 510-513):**

1. Update `srcFile.Path` to `destPath` BEFORE calling `PutFile`:
   ```go
   now := time.Now()
   srcFile.Path = destPath  // Fix: update path before persisting
   srcFile.Ctime = now
   _ = tx.PutFile(ctx.Context, srcFile)
   ```

2. For directory renames, recursively update all descendant paths. Add this immediately after the `PutFile` call:
   ```go
   // For directory renames, recursively update all descendants' paths
   if srcFile.Type == FileTypeDirectory {
       oldPrefix := buildPath(srcDir.Path, fromName)
       if err := s.updateDescendantPaths(ctx.Context, tx, srcHandle, oldPrefix, destPath); err != nil {
           logger.Debug("Move: failed to update descendant paths (non-fatal)",
               "error", err, "oldPrefix", oldPrefix, "newPrefix", destPath)
       }
   }
   ```

3. Add the `updateDescendantPaths` method on `MetadataService`:
   ```go
   // updateDescendantPaths recursively updates the Path field of all descendants
   // of a renamed directory. Uses iterative (queue-based) traversal to avoid
   // stack overflow on deep trees.
   func (s *MetadataService) updateDescendantPaths(ctx context.Context, tx Transaction, dirHandle FileHandle, oldPrefix, newPrefix string) error {
       // Queue-based BFS traversal within the transaction
       queue := []FileHandle{dirHandle}

       for len(queue) > 0 {
           current := queue[0]
           queue = queue[1:]

           cursor := ""
           for {
               entries, nextCursor, err := tx.ListChildren(ctx, current, cursor, 100)
               if err != nil {
                   return fmt.Errorf("list children for path update: %w", err)
               }

               for _, entry := range entries {
                   child, err := tx.GetFile(ctx, entry.Handle)
                   if err != nil {
                       logger.Debug("updateDescendantPaths: skip unreadable child",
                           "name", entry.Name, "error", err)
                       continue
                   }

                   // Replace old path prefix with new prefix
                   if strings.HasPrefix(child.Path, oldPrefix) {
                       child.Path = newPrefix + child.Path[len(oldPrefix):]
                       _ = tx.PutFile(ctx, child)
                   }

                   // Enqueue subdirectories for recursive traversal
                   if child.Type == FileTypeDirectory {
                       queue = append(queue, entry.Handle)
                   }
               }

               if nextCursor == "" {
                   break
               }
               cursor = nextCursor
           }
       }

       return nil
   }
   ```

4. Add `"strings"` to the import block if not already present.

Note: The `destPath` variable is already computed at line 355 (`destPath := buildPath(dstDir.Path, toName)`) but was only used for validation. Now it is also used for the path update.

Per user decision: fix root causes -- the recursive update is necessary because BadgerDB and PostgreSQL stores serialize/deserialize the File struct, so in-memory mutation without `PutFile` won't persist.
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs-phase-30 && go build ./pkg/metadata/...</automated>
  </verify>
  <done>Move() updates srcFile.Path to destPath before PutFile. Directory renames recursively update all descendant paths using queue-based BFS traversal within the transaction.</done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for directory rename path propagation</name>
  <files>pkg/metadata/file_modify_test.go</files>
  <action>
Add tests to the existing `file_modify_test.go` (or create it if it doesn't exist) using the memory store for fast execution:

1. **TestMove_UpdatesFilePath**: Create a file, move it to a different directory, verify `file.Path` is updated in the store.

2. **TestMove_UpdatesDirectoryPath**: Create a directory, move it, verify the directory's own `file.Path` is updated.

3. **TestMove_UpdatesDescendantPaths**: Create a directory tree (`/a/b/c/file.txt`), rename `/a` to `/x`, verify:
   - `/a`'s path becomes `/x`
   - `/a/b`'s path becomes `/x/b`
   - `/a/b/c`'s path becomes `/x/b/c`
   - `/a/b/c/file.txt`'s path becomes `/x/b/c/file.txt`

4. **TestMove_SameDirectoryRename**: Rename a file within the same directory (mv /dir/old /dir/new), verify path updated but no recursive traversal needed (not a directory).

5. **TestMove_EmptyDirectoryRename**: Rename an empty directory, verify its path is updated (no children to traverse).

Use the metadata test helpers pattern established in the codebase:
- Create a memory metadata store
- Create a MetadataService with the store
- Create root directory
- Build test file hierarchy
- Call Move()
- GetFile() each handle and verify Path field

Use `github.com/stretchr/testify/assert` and `github.com/stretchr/testify/require`.
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs-phase-30 && go test -v ./pkg/metadata/ -run "TestMove"</automated>
  </verify>
  <done>Tests verify: (1) file path updated on move, (2) directory path updated on move, (3) all descendants' paths updated recursively on directory rename, (4) same-directory rename updates path, (5) empty directory rename works correctly.</done>
</task>

</tasks>

<verification>
1. `go build ./pkg/metadata/...` compiles cleanly
2. `go test ./pkg/metadata/` passes (including new Move tests)
3. `go vet ./pkg/metadata/...` reports no issues
4. Existing metadata tests still pass (no regressions)
</verification>

<success_criteria>
- Move() updates srcFile.Path to destPath before PutFile
- Directory renames recursively update all descendant paths
- Works with all store implementations (memory, BadgerDB, PostgreSQL) because it uses PutFile
- Unit tests cover file move, directory move, deep recursive rename, and edge cases
</success_criteria>

<output>
After completion, create `.planning/phases/30-smb-bug-fixes/30-02-SUMMARY.md`
</output>
