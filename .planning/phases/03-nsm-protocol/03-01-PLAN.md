---
phase: 03-nsm-protocol
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/protocol/nsm/types/constants.go
  - internal/protocol/nsm/types/types.go
  - internal/protocol/nsm/xdr/decode.go
  - internal/protocol/nsm/xdr/encode.go
  - pkg/metadata/lock/connection.go
  - pkg/metadata/lock/client_store.go
autonomous: true

must_haves:
  truths:
    - "NSM constants defined (SM_PROG=100024, SM_VERS=1, procedure numbers)"
    - "NSM XDR types match Open Group specification"
    - "ClientRegistration extended with NSM-specific fields"
    - "ClientRegistrationStore interface enables persistence"
  artifacts:
    - path: "internal/protocol/nsm/types/constants.go"
      provides: "NSM program number, version, procedure constants"
      exports: ["ProgramNSM", "SMVersion1", "SMProcNull", "SMProcStat", "SMProcMon", "SMProcUnmon", "SMProcUnmonAll", "SMProcNotify", "StatSucc", "StatFail", "SMMaxStrLen"]
    - path: "internal/protocol/nsm/types/types.go"
      provides: "NSM XDR data structures"
      exports: ["SMName", "MyID", "MonID", "Mon", "SMStatRes", "SMStat", "StatChge", "Status"]
    - path: "internal/protocol/nsm/xdr/decode.go"
      provides: "Decode NSM requests from XDR"
      exports: ["DecodeSmName", "DecodeMyID", "DecodeMonID", "DecodeMon", "DecodeStatChge"]
    - path: "internal/protocol/nsm/xdr/encode.go"
      provides: "Encode NSM responses to XDR"
      exports: ["EncodeSMStatRes", "EncodeSMStat", "EncodeStatus"]
    - path: "pkg/metadata/lock/connection.go"
      provides: "Extended ClientRegistration with NSM fields"
      contains: "NSMCallback struct"
    - path: "pkg/metadata/lock/client_store.go"
      provides: "ClientRegistrationStore interface for persistence"
      exports: ["ClientRegistrationStore", "PersistedClientRegistration"]
  key_links:
    - from: "internal/protocol/nsm/types/types.go"
      to: "internal/protocol/nsm/xdr/decode.go"
      via: "Type definitions used by decoder"
      pattern: "types\\.Mon"
    - from: "pkg/metadata/lock/client_store.go"
      to: "pkg/metadata/lock/connection.go"
      via: "ClientRegistration fields mapped to PersistedClientRegistration"
      pattern: "ClientRegistration"
---

<objective>
Create NSM protocol types, XDR encoding/decoding, and extend ConnectionTracker with NSM-specific fields

Purpose: Establish the data structures and serialization layer for NSM protocol implementation
Output: NSM types package mirroring NLM structure, extended ConnectionTracker, client registration persistence interface
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-nsm-protocol/03-CONTEXT.md
@.planning/phases/03-nsm-protocol/03-RESEARCH.md
@internal/protocol/nlm/types/constants.go
@internal/protocol/nlm/types/types.go
@internal/protocol/xdr/decode.go
@internal/protocol/xdr/encode.go
@pkg/metadata/lock/connection.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create NSM types package with constants and data structures</name>
  <files>
    internal/protocol/nsm/types/constants.go
    internal/protocol/nsm/types/types.go
  </files>
  <action>
Create `internal/protocol/nsm/types/` directory mirroring the nlm/types structure.

**constants.go** - Define NSM RPC constants per Open Group spec:
```go
package types

const (
    // ProgramNSM is the NSM RPC program number
    ProgramNSM uint32 = 100024

    // SMVersion1 is the only NSM protocol version
    SMVersion1 uint32 = 1

    // SMMaxStrLen is the maximum length for NSM strings
    SMMaxStrLen = 1024
)

// NSM procedure numbers
const (
    SMProcNull     uint32 = 0  // NULL - ping
    SMProcStat     uint32 = 1  // STAT - query host status
    SMProcMon      uint32 = 2  // MON - register for monitoring
    SMProcUnmon    uint32 = 3  // UNMON - unregister single host
    SMProcUnmonAll uint32 = 4  // UNMON_ALL - unregister all hosts
    SMProcSimuCrsh uint32 = 5  // SIMU_CRASH - simulate crash (testing only)
    SMProcNotify   uint32 = 6  // NOTIFY - state change notification
)

// SMRes result enumeration
const (
    StatSucc uint32 = 0  // Monitoring established
    StatFail uint32 = 1  // Unable to monitor
)
```

**types.go** - Define NSM XDR data structures per Open Group spec:
```go
package types

// SMName identifies a host to monitor
type SMName struct {
    Name string  // mon_name<SM_MAXSTRLEN>
}

// MyID contains callback RPC information
type MyID struct {
    MyName string  // Callback hostname
    MyProg uint32  // RPC program number (e.g., NLM 100021)
    MyVers uint32  // Program version
    MyProc uint32  // Procedure number
}

// MonID combines monitored host and callback info
type MonID struct {
    MonName string  // Host to monitor
    MyID    MyID    // Callback details
}

// Mon is the SM_MON argument structure
type Mon struct {
    MonID MonID     // Monitor and callback info
    Priv  [16]byte  // Private data returned in notifications
}

// SMStatRes is returned by SM_STAT and SM_MON
type SMStatRes struct {
    Result uint32  // StatSucc or StatFail
    State  int32   // Current NSM state (odd=up, even=down)
}

// SMStat holds just the state number (for SM_STAT response details)
type SMStat struct {
    State int32
}

// StatChge is the SM_NOTIFY argument (incoming notification)
type StatChge struct {
    MonName string  // Host that changed state
    State   int32   // New state number
}

// Status is sent in SM_NOTIFY callbacks to registered monitors
type Status struct {
    MonName string    // Host that changed state
    State   int32     // New state number
    Priv    [16]byte  // Client's private data from SM_MON
}
```

Note: `priv` MUST be `[16]byte` (fixed array), not a slice. XDR encodes this as opaque[16].
  </action>
  <verify>
```bash
go build ./internal/protocol/nsm/types/...
```
  </verify>
  <done>NSM types package compiles with all constants and XDR structures defined per Open Group specification</done>
</task>

<task type="auto">
  <name>Task 2: Create NSM XDR encode/decode functions</name>
  <files>
    internal/protocol/nsm/xdr/decode.go
    internal/protocol/nsm/xdr/encode.go
  </files>
  <action>
Create `internal/protocol/nsm/xdr/` directory with encode and decode functions.

**decode.go** - Decode NSM requests using shared xdr utilities:
```go
package xdr

import (
    "fmt"
    "io"

    "github.com/marmos91/dittofs/internal/protocol/nsm/types"
    "github.com/marmos91/dittofs/internal/protocol/xdr"
)

// DecodeSmName decodes an sm_name structure
func DecodeSmName(r io.Reader) (*types.SMName, error) {
    name, err := xdr.DecodeString(r)
    if err != nil {
        return nil, fmt.Errorf("decode name: %w", err)
    }
    if len(name) > types.SMMaxStrLen {
        return nil, fmt.Errorf("name too long: %d > %d", len(name), types.SMMaxStrLen)
    }
    return &types.SMName{Name: name}, nil
}

// DecodeMyID decodes a my_id structure
func DecodeMyID(r io.Reader) (*types.MyID, error) {
    myName, err := xdr.DecodeString(r)
    if err != nil {
        return nil, fmt.Errorf("decode my_name: %w", err)
    }

    myProg, err := xdr.DecodeUint32(r)
    if err != nil {
        return nil, fmt.Errorf("decode my_prog: %w", err)
    }

    myVers, err := xdr.DecodeUint32(r)
    if err != nil {
        return nil, fmt.Errorf("decode my_vers: %w", err)
    }

    myProc, err := xdr.DecodeUint32(r)
    if err != nil {
        return nil, fmt.Errorf("decode my_proc: %w", err)
    }

    return &types.MyID{
        MyName: myName,
        MyProg: myProg,
        MyVers: myVers,
        MyProc: myProc,
    }, nil
}

// DecodeMonID decodes a mon_id structure
func DecodeMonID(r io.Reader) (*types.MonID, error) {
    monName, err := xdr.DecodeString(r)
    if err != nil {
        return nil, fmt.Errorf("decode mon_name: %w", err)
    }
    if len(monName) > types.SMMaxStrLen {
        return nil, fmt.Errorf("mon_name too long: %d > %d", len(monName), types.SMMaxStrLen)
    }

    myID, err := DecodeMyID(r)
    if err != nil {
        return nil, fmt.Errorf("decode my_id: %w", err)
    }

    return &types.MonID{
        MonName: monName,
        MyID:    *myID,
    }, nil
}

// DecodeMon decodes SM_MON arguments (mon structure)
func DecodeMon(r io.Reader) (*types.Mon, error) {
    monID, err := DecodeMonID(r)
    if err != nil {
        return nil, fmt.Errorf("decode mon_id: %w", err)
    }

    // Decode priv as opaque[16] (fixed size, no length prefix)
    var priv [16]byte
    if _, err := io.ReadFull(r, priv[:]); err != nil {
        return nil, fmt.Errorf("decode priv: %w", err)
    }

    return &types.Mon{
        MonID: *monID,
        Priv:  priv,
    }, nil
}

// DecodeStatChge decodes SM_NOTIFY arguments
func DecodeStatChge(r io.Reader) (*types.StatChge, error) {
    monName, err := xdr.DecodeString(r)
    if err != nil {
        return nil, fmt.Errorf("decode mon_name: %w", err)
    }

    state, err := xdr.DecodeInt32(r)
    if err != nil {
        return nil, fmt.Errorf("decode state: %w", err)
    }

    return &types.StatChge{
        MonName: monName,
        State:   state,
    }, nil
}
```

**encode.go** - Encode NSM responses:
```go
package xdr

import (
    "bytes"
    "fmt"

    "github.com/marmos91/dittofs/internal/protocol/nsm/types"
    "github.com/marmos91/dittofs/internal/protocol/xdr"
)

// EncodeSMStatRes encodes SM_STAT/SM_MON response
func EncodeSMStatRes(res *types.SMStatRes) ([]byte, error) {
    buf := new(bytes.Buffer)

    if err := xdr.EncodeUint32(buf, res.Result); err != nil {
        return nil, fmt.Errorf("encode result: %w", err)
    }

    if err := xdr.EncodeInt32(buf, res.State); err != nil {
        return nil, fmt.Errorf("encode state: %w", err)
    }

    return buf.Bytes(), nil
}

// EncodeSMStat encodes SM_STAT-only response (just state)
func EncodeSMStat(stat *types.SMStat) ([]byte, error) {
    buf := new(bytes.Buffer)

    if err := xdr.EncodeInt32(buf, stat.State); err != nil {
        return nil, fmt.Errorf("encode state: %w", err)
    }

    return buf.Bytes(), nil
}

// EncodeStatus encodes SM_NOTIFY callback payload
func EncodeStatus(status *types.Status) ([]byte, error) {
    buf := new(bytes.Buffer)

    if err := xdr.EncodeString(buf, status.MonName); err != nil {
        return nil, fmt.Errorf("encode mon_name: %w", err)
    }

    if err := xdr.EncodeInt32(buf, status.State); err != nil {
        return nil, fmt.Errorf("encode state: %w", err)
    }

    // Encode priv as opaque[16] (fixed size, no length prefix)
    if _, err := buf.Write(status.Priv[:]); err != nil {
        return nil, fmt.Errorf("encode priv: %w", err)
    }

    return buf.Bytes(), nil
}
```

Use the existing shared XDR utilities at `internal/protocol/xdr/` for primitives.
  </action>
  <verify>
```bash
go build ./internal/protocol/nsm/xdr/...
```
  </verify>
  <done>NSM XDR encode/decode functions compile and use shared XDR utilities</done>
</task>

<task type="auto">
  <name>Task 3: Extend ClientRegistration with NSM fields and create persistence interface</name>
  <files>
    pkg/metadata/lock/connection.go
    pkg/metadata/lock/client_store.go
  </files>
  <action>
**Extend ClientRegistration in connection.go** - Add NSM-specific fields per CONTEXT.md decision to extend existing type:

Add to ClientRegistration struct:
```go
// NSM-specific fields (Phase 3)
// MonName is the monitored hostname (mon_id.mon_name from SM_MON)
MonName string

// Priv is the 16-byte private data returned in SM_NOTIFY callbacks
Priv [16]byte

// SMState is the client's NSM state counter
SMState int32

// CallbackInfo contains RPC callback details from SM_MON my_id field
CallbackInfo *NSMCallback
```

Add NSMCallback struct after ClientRegistration:
```go
// NSMCallback holds callback RPC details from SM_MON my_id field.
// Used to send SM_NOTIFY callbacks when server restarts or client crashes.
type NSMCallback struct {
    // Hostname is the callback target (my_id.my_name)
    Hostname string

    // Program is the RPC program number (usually NLM 100021)
    Program uint32

    // Version is the program version
    Version uint32

    // Proc is the procedure number for the callback
    Proc uint32
}
```

Add methods to ConnectionTracker for NSM field updates:
```go
// UpdateNSMInfo updates NSM-specific fields for a client.
// Called after SM_MON to store monitoring callback details.
func (ct *ConnectionTracker) UpdateNSMInfo(clientID, monName string, priv [16]byte, callback *NSMCallback) {
    ct.mu.Lock()
    defer ct.mu.Unlock()

    if client, exists := ct.clients[clientID]; exists {
        client.MonName = monName
        client.Priv = priv
        client.CallbackInfo = callback
    }
}

// UpdateSMState updates the NSM state counter for a client.
func (ct *ConnectionTracker) UpdateSMState(clientID string, state int32) {
    ct.mu.Lock()
    defer ct.mu.Unlock()

    if client, exists := ct.clients[clientID]; exists {
        client.SMState = state
    }
}

// GetNSMClients returns all clients with NSM callback info (for SM_NOTIFY).
func (ct *ConnectionTracker) GetNSMClients() []*ClientRegistration {
    ct.mu.RLock()
    defer ct.mu.RUnlock()

    var result []*ClientRegistration
    for _, client := range ct.clients {
        if client.CallbackInfo != nil {
            copy := *client
            result = append(result, &copy)
        }
    }
    return result
}
```

**Create client_store.go** - Persistence interface for client registrations:
```go
package lock

import (
    "context"
    "time"
)

// PersistedClientRegistration is the storage representation of a client registration.
// Used to persist NSM client registrations across server restarts.
type PersistedClientRegistration struct {
    // ClientID is the unique identifier (e.g., hostname or IP)
    ClientID string

    // MonName is the monitored hostname (from SM_MON mon_id.mon_name)
    MonName string

    // Priv is the 16-byte private data for callbacks
    Priv [16]byte

    // CallbackHost is the callback target hostname
    CallbackHost string

    // CallbackProg is the RPC program number
    CallbackProg uint32

    // CallbackVers is the program version
    CallbackVers uint32

    // CallbackProc is the procedure number
    CallbackProc uint32

    // RegisteredAt is when the registration was created
    RegisteredAt time.Time

    // ServerEpoch is the server epoch at registration time (for stale detection)
    ServerEpoch uint64
}

// ClientRegistrationStore provides persistence for NSM client registrations.
// Implementations exist in memory, badger, and postgres stores.
type ClientRegistrationStore interface {
    // PutClientRegistration stores or updates a client registration.
    PutClientRegistration(ctx context.Context, reg *PersistedClientRegistration) error

    // GetClientRegistration retrieves a registration by client ID.
    GetClientRegistration(ctx context.Context, clientID string) (*PersistedClientRegistration, error)

    // DeleteClientRegistration removes a registration.
    DeleteClientRegistration(ctx context.Context, clientID string) error

    // ListClientRegistrations returns all stored registrations.
    ListClientRegistrations(ctx context.Context) ([]*PersistedClientRegistration, error)

    // DeleteAllClientRegistrations removes all registrations (for SM_UNMON_ALL).
    // Returns the count of deleted registrations.
    DeleteAllClientRegistrations(ctx context.Context) (int, error)
}
```
  </action>
  <verify>
```bash
go build ./pkg/metadata/lock/...
```
  </verify>
  <done>ClientRegistration extended with NSM fields, NSMCallback struct created, ClientRegistrationStore interface defined</done>
</task>

</tasks>

<verification>
```bash
# Build all new packages
go build ./internal/protocol/nsm/...
go build ./pkg/metadata/lock/...

# Run existing lock tests to verify no regressions
go test ./pkg/metadata/lock/...
```
</verification>

<success_criteria>
- NSM types package exists at internal/protocol/nsm/types/ with constants and XDR structures
- NSM XDR package exists at internal/protocol/nsm/xdr/ with encode/decode functions
- ClientRegistration struct extended with MonName, Priv, SMState, CallbackInfo fields
- NSMCallback struct defined for callback RPC details
- ConnectionTracker has UpdateNSMInfo, UpdateSMState, GetNSMClients methods
- ClientRegistrationStore interface defined with CRUD operations
- All packages compile without errors
- Existing lock tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-nsm-protocol/03-01-SUMMARY.md`
</output>
