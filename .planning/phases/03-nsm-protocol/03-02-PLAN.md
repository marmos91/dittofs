---
phase: 03-nsm-protocol
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - internal/protocol/nsm/handlers/handler.go
  - internal/protocol/nsm/handlers/null.go
  - internal/protocol/nsm/handlers/stat.go
  - internal/protocol/nsm/handlers/mon.go
  - internal/protocol/nsm/handlers/unmon.go
  - internal/protocol/nsm/handlers/unmon_all.go
  - internal/protocol/nsm/dispatch.go
  - pkg/adapter/nfs/nfs_adapter.go
  - pkg/metadata/store/memory/clients.go
  - pkg/metadata/store/badger/clients.go
  - pkg/metadata/store/postgres/clients.go
  - pkg/metadata/store/postgres/migrations/000003_clients.up.sql
  - pkg/metadata/store/postgres/migrations/000003_clients.down.sql
autonomous: true

must_haves:
  truths:
    - "NSM program (100024) is routed to NSM handlers"
    - "SM_NULL responds to ping requests"
    - "SM_STAT returns current server state"
    - "SM_MON registers client for crash notification"
    - "SM_UNMON unregisters a specific monitored host"
    - "SM_UNMON_ALL unregisters all hosts from a caller"
    - "Client registrations persist in metadata store"
  artifacts:
    - path: "internal/protocol/nsm/handlers/handler.go"
      provides: "NSM handler struct with dependencies"
      exports: ["Handler", "NewHandler"]
    - path: "internal/protocol/nsm/handlers/mon.go"
      provides: "SM_MON implementation"
      exports: ["Mon"]
    - path: "internal/protocol/nsm/dispatch.go"
      provides: "NSM procedure dispatch table"
      exports: ["NSMDispatchTable"]
    - path: "pkg/metadata/store/memory/clients.go"
      provides: "In-memory client registration storage"
      contains: "ClientRegistrationStore"
    - path: "pkg/metadata/store/badger/clients.go"
      provides: "BadgerDB client registration storage"
      contains: "ClientRegistrationStore"
    - path: "pkg/metadata/store/postgres/clients.go"
      provides: "PostgreSQL client registration storage"
      contains: "ClientRegistrationStore"
  key_links:
    - from: "pkg/adapter/nfs/nfs_adapter.go"
      to: "internal/protocol/nsm/dispatch.go"
      via: "Program number routing"
      pattern: "ProgramNSM"
    - from: "internal/protocol/nsm/handlers/mon.go"
      to: "pkg/metadata/lock/connection.go"
      via: "ConnectionTracker.RegisterClient and UpdateNSMInfo"
      pattern: "tracker\\.(RegisterClient|UpdateNSMInfo)"
---

<objective>
Implement NSM dispatcher, core handlers (SM_NULL, SM_STAT, SM_MON, SM_UNMON, SM_UNMON_ALL), and client registration persistence

Purpose: Enable clients to register for crash monitoring and persist registrations across server restarts
Output: NSM protocol handlers integrated with NFS adapter, client registration storage in all metadata store backends
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-nsm-protocol/03-CONTEXT.md
@.planning/phases/03-nsm-protocol/03-RESEARCH.md
@.planning/phases/03-nsm-protocol/03-01-SUMMARY.md
@internal/protocol/nlm/handlers/handler.go
@internal/protocol/nlm/dispatch.go
@pkg/adapter/nfs/nfs_adapter.go
@pkg/metadata/store/memory/locks.go
@pkg/metadata/store/badger/locks.go
@pkg/metadata/store/postgres/locks.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create NSM handler struct and dispatch table</name>
  <files>
    internal/protocol/nsm/handlers/handler.go
    internal/protocol/nsm/handlers/context.go
    internal/protocol/nsm/dispatch.go
  </files>
  <action>
Create `internal/protocol/nsm/handlers/` directory mirroring NLM handler structure.

**handlers/context.go** - Handler context for NSM procedures:
```go
package handlers

import "context"

// NSMHandlerContext contains context for NSM procedure handlers.
type NSMHandlerContext struct {
    // Context is the Go context for cancellation and timeouts
    Context context.Context

    // ClientAddr is the remote client IP address
    ClientAddr string

    // ClientName is the client hostname (from RPC auth or request)
    ClientName string
}
```

**handlers/handler.go** - Main handler struct:
```go
package handlers

import (
    "sync/atomic"

    "github.com/marmos91/dittofs/pkg/metadata/lock"
)

// Handler handles NSM protocol requests.
type Handler struct {
    // tracker is the connection tracker for client registration
    tracker *lock.ConnectionTracker

    // clientStore persists client registrations
    clientStore lock.ClientRegistrationStore

    // serverState is the current NSM state counter (odd=up, even=down)
    // Incremented on each server restart
    serverState atomic.Int32

    // serverName is this server's hostname for SM_NOTIFY
    serverName string

    // maxClients is the maximum number of monitored clients (default 10000)
    maxClients int
}

// HandlerConfig configures the NSM handler.
type HandlerConfig struct {
    // Tracker is the connection tracker (required)
    Tracker *lock.ConnectionTracker

    // ClientStore persists registrations (required)
    ClientStore lock.ClientRegistrationStore

    // ServerName is this server's hostname (required)
    ServerName string

    // InitialState is the starting NSM state (default: 1 = up)
    InitialState int32

    // MaxClients limits monitored clients (default: 10000)
    MaxClients int
}

// NewHandler creates a new NSM handler.
func NewHandler(config HandlerConfig) *Handler {
    if config.MaxClients == 0 {
        config.MaxClients = 10000
    }
    if config.InitialState == 0 {
        config.InitialState = 1 // Default: odd = up
    }

    h := &Handler{
        tracker:     config.Tracker,
        clientStore: config.ClientStore,
        serverName:  config.ServerName,
        maxClients:  config.MaxClients,
    }
    h.serverState.Store(config.InitialState)
    return h
}

// GetServerState returns the current NSM state counter.
func (h *Handler) GetServerState() int32 {
    return h.serverState.Load()
}

// IncrementServerState increments the state counter (called on restart).
func (h *Handler) IncrementServerState() int32 {
    return h.serverState.Add(1)
}

// GetTracker returns the connection tracker for external access.
func (h *Handler) GetTracker() *lock.ConnectionTracker {
    return h.tracker
}
```

**dispatch.go** - NSM procedure dispatch table:
```go
package nsm

import (
    "github.com/marmos91/dittofs/internal/protocol/nsm/handlers"
    "github.com/marmos91/dittofs/internal/protocol/nsm/types"
)

// NSMProcedureHandler defines the signature for NSM handlers.
type NSMProcedureHandler func(
    ctx *handlers.NSMHandlerContext,
    handler *handlers.Handler,
    data []byte,
) ([]byte, error)

// NSMProcedure contains metadata about an NSM procedure.
type NSMProcedure struct {
    Name    string
    Handler NSMProcedureHandler
}

// NSMDispatchTable maps NSM procedure numbers to handlers.
var NSMDispatchTable map[uint32]*NSMProcedure

func init() {
    NSMDispatchTable = map[uint32]*NSMProcedure{
        types.SMProcNull: {
            Name:    "NULL",
            Handler: handleNull,
        },
        types.SMProcStat: {
            Name:    "STAT",
            Handler: handleStat,
        },
        types.SMProcMon: {
            Name:    "MON",
            Handler: handleMon,
        },
        types.SMProcUnmon: {
            Name:    "UNMON",
            Handler: handleUnmon,
        },
        types.SMProcUnmonAll: {
            Name:    "UNMON_ALL",
            Handler: handleUnmonAll,
        },
        types.SMProcNotify: {
            Name:    "NOTIFY",
            Handler: handleNotify,
        },
    }
}

// Dispatch wrapper functions that delegate to handler methods
func handleNull(ctx *handlers.NSMHandlerContext, h *handlers.Handler, data []byte) ([]byte, error) {
    return h.Null(ctx)
}

func handleStat(ctx *handlers.NSMHandlerContext, h *handlers.Handler, data []byte) ([]byte, error) {
    return h.Stat(ctx, data)
}

func handleMon(ctx *handlers.NSMHandlerContext, h *handlers.Handler, data []byte) ([]byte, error) {
    return h.Mon(ctx, data)
}

func handleUnmon(ctx *handlers.NSMHandlerContext, h *handlers.Handler, data []byte) ([]byte, error) {
    return h.Unmon(ctx, data)
}

func handleUnmonAll(ctx *handlers.NSMHandlerContext, h *handlers.Handler, data []byte) ([]byte, error) {
    return h.UnmonAll(ctx, data)
}

func handleNotify(ctx *handlers.NSMHandlerContext, h *handlers.Handler, data []byte) ([]byte, error) {
    return h.Notify(ctx, data)
}
```
  </action>
  <verify>
```bash
go build ./internal/protocol/nsm/...
```
  </verify>
  <done>NSM handler struct and dispatch table created</done>
</task>

<task type="auto">
  <name>Task 2: Implement NSM handlers (NULL, STAT, MON, UNMON, UNMON_ALL, NOTIFY)</name>
  <files>
    internal/protocol/nsm/handlers/null.go
    internal/protocol/nsm/handlers/stat.go
    internal/protocol/nsm/handlers/mon.go
    internal/protocol/nsm/handlers/unmon.go
    internal/protocol/nsm/handlers/unmon_all.go
    internal/protocol/nsm/handlers/notify.go
  </files>
  <action>
**handlers/null.go** - SM_NULL (ping):
```go
package handlers

// Null handles SM_NULL (procedure 0) - simple ping.
func (h *Handler) Null(ctx *NSMHandlerContext) ([]byte, error) {
    // SM_NULL has no arguments and returns void
    return []byte{}, nil
}
```

**handlers/stat.go** - SM_STAT (query status):
```go
package handlers

import (
    "bytes"
    "fmt"

    "github.com/marmos91/dittofs/internal/logger"
    "github.com/marmos91/dittofs/internal/protocol/nsm/types"
    "github.com/marmos91/dittofs/internal/protocol/nsm/xdr"
)

// Stat handles SM_STAT (procedure 1) - query host status.
// Returns current server state. Does NOT register for monitoring.
func (h *Handler) Stat(ctx *NSMHandlerContext, data []byte) ([]byte, error) {
    // Decode sm_name (host to query)
    r := bytes.NewReader(data)
    smName, err := xdr.DecodeSmName(r)
    if err != nil {
        logger.Warn("SM_STAT: failed to decode request", "error", err)
        return h.encodeStatFail()
    }

    logger.Debug("SM_STAT", "mon_name", smName.Name, "client", ctx.ClientAddr)

    // Return current server state
    res := &types.SMStatRes{
        Result: types.StatSucc,
        State:  h.GetServerState(),
    }

    return xdr.EncodeSMStatRes(res)
}

func (h *Handler) encodeStatFail() ([]byte, error) {
    res := &types.SMStatRes{
        Result: types.StatFail,
        State:  h.GetServerState(),
    }
    return xdr.EncodeSMStatRes(res)
}
```

**handlers/mon.go** - SM_MON (register for monitoring):
```go
package handlers

import (
    "bytes"
    "context"
    "time"

    "github.com/marmos91/dittofs/internal/logger"
    "github.com/marmos91/dittofs/internal/protocol/nsm/types"
    "github.com/marmos91/dittofs/internal/protocol/nsm/xdr"
    "github.com/marmos91/dittofs/pkg/metadata/lock"
)

// Mon handles SM_MON (procedure 2) - register for crash notification.
// Per CONTEXT.md: Update existing on duplicate SM_MON (idempotent).
func (h *Handler) Mon(ctx *NSMHandlerContext, data []byte) ([]byte, error) {
    // Decode mon structure
    r := bytes.NewReader(data)
    mon, err := xdr.DecodeMon(r)
    if err != nil {
        logger.Warn("SM_MON: failed to decode request", "error", err, "client", ctx.ClientAddr)
        return h.encodeStatFail()
    }

    monName := mon.MonID.MonName
    myID := mon.MonID.MyID

    logger.Debug("SM_MON",
        "mon_name", monName,
        "callback_host", myID.MyName,
        "callback_prog", myID.MyProg,
        "client", ctx.ClientAddr)

    // Check client limit (per CONTEXT.md: configurable, default 10000)
    currentCount := h.tracker.GetClientCount("")
    if currentCount >= h.maxClients {
        // Check if this is an update to existing registration
        if _, exists := h.tracker.GetClient(monName); !exists {
            logger.Warn("SM_MON: client limit reached",
                "limit", h.maxClients,
                "current", currentCount,
                "client", ctx.ClientAddr)
            return h.encodeStatFail()
        }
        // Existing client - allow update
    }

    // Register or update client in ConnectionTracker
    // Per CONTEXT.md: extend existing ConnectionTracker, NSM uses TTL=0
    err = h.tracker.RegisterClient(monName, "nsm", ctx.ClientAddr, 0)
    if err != nil {
        logger.Error("SM_MON: failed to register client",
            "mon_name", monName,
            "error", err)
        return h.encodeStatFail()
    }

    // Update NSM-specific fields
    callback := &lock.NSMCallback{
        Hostname: myID.MyName,
        Program:  myID.MyProg,
        Version:  myID.MyVers,
        Proc:     myID.MyProc,
    }
    h.tracker.UpdateNSMInfo(monName, monName, mon.Priv, callback)

    // Persist registration to metadata store
    if h.clientStore != nil {
        persistCtx, cancel := context.WithTimeout(ctx.Context, 5*time.Second)
        defer cancel()

        persisted := &lock.PersistedClientRegistration{
            ClientID:     monName,
            MonName:      monName,
            Priv:         mon.Priv,
            CallbackHost: myID.MyName,
            CallbackProg: myID.MyProg,
            CallbackVers: myID.MyVers,
            CallbackProc: myID.MyProc,
            RegisteredAt: time.Now(),
            ServerEpoch:  uint64(h.GetServerState()),
        }

        if err := h.clientStore.PutClientRegistration(persistCtx, persisted); err != nil {
            // Log but don't fail - in-memory registration is still valid
            logger.Warn("SM_MON: failed to persist registration",
                "mon_name", monName,
                "error", err)
        }
    }

    logger.Info("SM_MON: client registered",
        "mon_name", monName,
        "callback", myID.MyName)

    // Return success with current server state
    res := &types.SMStatRes{
        Result: types.StatSucc,
        State:  h.GetServerState(),
    }
    return xdr.EncodeSMStatRes(res)
}
```

**handlers/unmon.go** - SM_UNMON (unregister single host):
```go
package handlers

import (
    "bytes"
    "context"
    "time"

    "github.com/marmos91/dittofs/internal/logger"
    "github.com/marmos91/dittofs/internal/protocol/nsm/types"
    "github.com/marmos91/dittofs/internal/protocol/nsm/xdr"
)

// Unmon handles SM_UNMON (procedure 3) - unregister single monitored host.
// Note: This removes NSM registration only, NOT locks (per CONTEXT.md pitfall 5).
func (h *Handler) Unmon(ctx *NSMHandlerContext, data []byte) ([]byte, error) {
    // Decode mon_id (same structure as SM_MON but we only need mon_name)
    r := bytes.NewReader(data)
    monID, err := xdr.DecodeMonID(r)
    if err != nil {
        logger.Warn("SM_UNMON: failed to decode request", "error", err, "client", ctx.ClientAddr)
        return h.encodeStatFail()
    }

    monName := monID.MonName

    logger.Debug("SM_UNMON", "mon_name", monName, "client", ctx.ClientAddr)

    // Unregister from ConnectionTracker
    h.tracker.UnregisterClient(monName)

    // Remove from persistent store
    if h.clientStore != nil {
        persistCtx, cancel := context.WithTimeout(ctx.Context, 5*time.Second)
        defer cancel()

        if err := h.clientStore.DeleteClientRegistration(persistCtx, monName); err != nil {
            logger.Warn("SM_UNMON: failed to delete persisted registration",
                "mon_name", monName,
                "error", err)
        }
    }

    logger.Info("SM_UNMON: client unregistered", "mon_name", monName)

    // Return success with current state
    res := &types.SMStatRes{
        Result: types.StatSucc,
        State:  h.GetServerState(),
    }
    return xdr.EncodeSMStatRes(res)
}
```

**handlers/unmon_all.go** - SM_UNMON_ALL (unregister all hosts):
```go
package handlers

import (
    "bytes"
    "context"
    "time"

    "github.com/marmos91/dittofs/internal/logger"
    "github.com/marmos91/dittofs/internal/protocol/nsm/types"
    "github.com/marmos91/dittofs/internal/protocol/nsm/xdr"
)

// UnmonAll handles SM_UNMON_ALL (procedure 4) - unregister all monitored hosts.
// Called by caller_name to remove all its registrations.
// Note: This removes NSM registrations only, NOT locks (per CONTEXT.md pitfall 5).
func (h *Handler) UnmonAll(ctx *NSMHandlerContext, data []byte) ([]byte, error) {
    // Decode my_id (caller's identity)
    r := bytes.NewReader(data)
    myID, err := xdr.DecodeMyID(r)
    if err != nil {
        logger.Warn("SM_UNMON_ALL: failed to decode request", "error", err, "client", ctx.ClientAddr)
        return h.encodeStatFail()
    }

    callerName := myID.MyName

    logger.Debug("SM_UNMON_ALL", "caller", callerName, "client", ctx.ClientAddr)

    // Find all clients registered by this caller (matching callback hostname)
    clients := h.tracker.GetNSMClients()
    removedCount := 0

    for _, client := range clients {
        if client.CallbackInfo != nil && client.CallbackInfo.Hostname == callerName {
            h.tracker.UnregisterClient(client.ClientID)
            removedCount++
        }
    }

    // Remove from persistent store
    if h.clientStore != nil {
        persistCtx, cancel := context.WithTimeout(ctx.Context, 5*time.Second)
        defer cancel()

        // Delete all registrations for this caller
        registrations, err := h.clientStore.ListClientRegistrations(persistCtx)
        if err == nil {
            for _, reg := range registrations {
                if reg.CallbackHost == callerName {
                    _ = h.clientStore.DeleteClientRegistration(persistCtx, reg.ClientID)
                }
            }
        }
    }

    logger.Info("SM_UNMON_ALL: removed registrations",
        "caller", callerName,
        "count", removedCount)

    // Return success with current state
    res := &types.SMStatRes{
        Result: types.StatSucc,
        State:  h.GetServerState(),
    }
    return xdr.EncodeSMStatRes(res)
}
```

**handlers/notify.go** - SM_NOTIFY (incoming notification from another NSM):
```go
package handlers

import (
    "bytes"

    "github.com/marmos91/dittofs/internal/logger"
    "github.com/marmos91/dittofs/internal/protocol/nsm/xdr"
)

// Notify handles SM_NOTIFY (procedure 6) - incoming state change notification.
// This is called when ANOTHER server sends us a notification about a host state change.
// We process this by triggering lock cleanup for the crashed host.
func (h *Handler) Notify(ctx *NSMHandlerContext, data []byte) ([]byte, error) {
    // Decode stat_chge
    r := bytes.NewReader(data)
    statChge, err := xdr.DecodeStatChge(r)
    if err != nil {
        logger.Warn("SM_NOTIFY: failed to decode request", "error", err, "client", ctx.ClientAddr)
        // SM_NOTIFY has no response per spec, just return empty
        return []byte{}, nil
    }

    logger.Info("SM_NOTIFY: received state change notification",
        "mon_name", statChge.MonName,
        "state", statChge.State,
        "from", ctx.ClientAddr)

    // The actual crash handling (lock cleanup) is done by the callback/notifier
    // component in Plan 03. SM_NOTIFY handler just acknowledges receipt.
    // Lock cleanup will be triggered through the onClientCrash callback.

    // SM_NOTIFY has no response body
    return []byte{}, nil
}
```
  </action>
  <verify>
```bash
go build ./internal/protocol/nsm/...
```
  </verify>
  <done>All NSM handlers implemented: NULL, STAT, MON, UNMON, UNMON_ALL, NOTIFY</done>
</task>

<task type="auto">
  <name>Task 3: Implement client registration storage in all metadata store backends</name>
  <files>
    pkg/metadata/store/memory/clients.go
    pkg/metadata/store/badger/clients.go
    pkg/metadata/store/postgres/clients.go
    pkg/metadata/store/postgres/migrations/000003_clients.up.sql
    pkg/metadata/store/postgres/migrations/000003_clients.down.sql
  </files>
  <action>
**memory/clients.go** - In-memory client registration storage:
```go
package memory

import (
    "context"
    "sync"

    "github.com/marmos91/dittofs/pkg/metadata/lock"
)

// clientStore implements lock.ClientRegistrationStore for in-memory storage.
type clientStore struct {
    mu      sync.RWMutex
    clients map[string]*lock.PersistedClientRegistration
}

// newClientStore creates a new in-memory client registration store.
func newClientStore() *clientStore {
    return &clientStore{
        clients: make(map[string]*lock.PersistedClientRegistration),
    }
}

// PutClientRegistration stores or updates a client registration.
func (s *clientStore) PutClientRegistration(ctx context.Context, reg *lock.PersistedClientRegistration) error {
    s.mu.Lock()
    defer s.mu.Unlock()

    // Store a copy to prevent external modification
    copy := *reg
    s.clients[reg.ClientID] = &copy
    return nil
}

// GetClientRegistration retrieves a registration by client ID.
func (s *clientStore) GetClientRegistration(ctx context.Context, clientID string) (*lock.PersistedClientRegistration, error) {
    s.mu.RLock()
    defer s.mu.RUnlock()

    reg, exists := s.clients[clientID]
    if !exists {
        return nil, nil // Not found is not an error
    }

    // Return a copy
    copy := *reg
    return &copy, nil
}

// DeleteClientRegistration removes a registration.
func (s *clientStore) DeleteClientRegistration(ctx context.Context, clientID string) error {
    s.mu.Lock()
    defer s.mu.Unlock()

    delete(s.clients, clientID)
    return nil
}

// ListClientRegistrations returns all stored registrations.
func (s *clientStore) ListClientRegistrations(ctx context.Context) ([]*lock.PersistedClientRegistration, error) {
    s.mu.RLock()
    defer s.mu.RUnlock()

    result := make([]*lock.PersistedClientRegistration, 0, len(s.clients))
    for _, reg := range s.clients {
        copy := *reg
        result = append(result, &copy)
    }
    return result, nil
}

// DeleteAllClientRegistrations removes all registrations.
func (s *clientStore) DeleteAllClientRegistrations(ctx context.Context) (int, error) {
    s.mu.Lock()
    defer s.mu.Unlock()

    count := len(s.clients)
    s.clients = make(map[string]*lock.PersistedClientRegistration)
    return count, nil
}
```

Also add to the memory Store struct a `clientStore *clientStore` field and initialize in `NewStore()`:
```go
// In store.go or wherever Store is defined:
clientStore: newClientStore(),

// Add method to expose the client store:
func (s *Store) ClientRegistrationStore() lock.ClientRegistrationStore {
    return s.clientStore
}
```

**badger/clients.go** - BadgerDB client registration storage:
```go
package badger

import (
    "context"
    "encoding/json"
    "fmt"

    "github.com/dgraph-io/badger/v4"
    "github.com/marmos91/dittofs/pkg/metadata/lock"
)

const clientRegistrationKeyPrefix = "nsm:client:"

// PutClientRegistration stores or updates a client registration.
func (s *Store) PutClientRegistration(ctx context.Context, reg *lock.PersistedClientRegistration) error {
    key := []byte(clientRegistrationKeyPrefix + reg.ClientID)

    data, err := json.Marshal(reg)
    if err != nil {
        return fmt.Errorf("marshal registration: %w", err)
    }

    return s.db.Update(func(txn *badger.Txn) error {
        return txn.Set(key, data)
    })
}

// GetClientRegistration retrieves a registration by client ID.
func (s *Store) GetClientRegistration(ctx context.Context, clientID string) (*lock.PersistedClientRegistration, error) {
    key := []byte(clientRegistrationKeyPrefix + clientID)
    var reg lock.PersistedClientRegistration

    err := s.db.View(func(txn *badger.Txn) error {
        item, err := txn.Get(key)
        if err == badger.ErrKeyNotFound {
            return nil // Not found is not an error, reg will be zero-valued
        }
        if err != nil {
            return err
        }

        return item.Value(func(val []byte) error {
            return json.Unmarshal(val, &reg)
        })
    })

    if err != nil {
        return nil, err
    }
    if reg.ClientID == "" {
        return nil, nil // Not found
    }
    return &reg, nil
}

// DeleteClientRegistration removes a registration.
func (s *Store) DeleteClientRegistration(ctx context.Context, clientID string) error {
    key := []byte(clientRegistrationKeyPrefix + clientID)

    return s.db.Update(func(txn *badger.Txn) error {
        err := txn.Delete(key)
        if err == badger.ErrKeyNotFound {
            return nil // Already deleted
        }
        return err
    })
}

// ListClientRegistrations returns all stored registrations.
func (s *Store) ListClientRegistrations(ctx context.Context) ([]*lock.PersistedClientRegistration, error) {
    var result []*lock.PersistedClientRegistration
    prefix := []byte(clientRegistrationKeyPrefix)

    err := s.db.View(func(txn *badger.Txn) error {
        opts := badger.DefaultIteratorOptions
        opts.Prefix = prefix
        it := txn.NewIterator(opts)
        defer it.Close()

        for it.Seek(prefix); it.ValidForPrefix(prefix); it.Next() {
            item := it.Item()
            err := item.Value(func(val []byte) error {
                var reg lock.PersistedClientRegistration
                if err := json.Unmarshal(val, &reg); err != nil {
                    return err
                }
                result = append(result, &reg)
                return nil
            })
            if err != nil {
                return err
            }
        }
        return nil
    })

    return result, err
}

// DeleteAllClientRegistrations removes all registrations.
func (s *Store) DeleteAllClientRegistrations(ctx context.Context) (int, error) {
    prefix := []byte(clientRegistrationKeyPrefix)
    count := 0

    err := s.db.Update(func(txn *badger.Txn) error {
        opts := badger.DefaultIteratorOptions
        opts.Prefix = prefix
        it := txn.NewIterator(opts)
        defer it.Close()

        var keysToDelete [][]byte
        for it.Seek(prefix); it.ValidForPrefix(prefix); it.Next() {
            key := it.Item().KeyCopy(nil)
            keysToDelete = append(keysToDelete, key)
        }

        for _, key := range keysToDelete {
            if err := txn.Delete(key); err != nil {
                return err
            }
            count++
        }
        return nil
    })

    return count, err
}
```

**postgres/migrations/000003_clients.up.sql**:
```sql
-- NSM client registrations for crash recovery
CREATE TABLE IF NOT EXISTS nsm_client_registrations (
    client_id VARCHAR(1024) PRIMARY KEY,
    mon_name VARCHAR(1024) NOT NULL,
    priv BYTEA NOT NULL CHECK (length(priv) = 16),
    callback_host VARCHAR(1024) NOT NULL,
    callback_prog INTEGER NOT NULL,
    callback_vers INTEGER NOT NULL,
    callback_proc INTEGER NOT NULL,
    registered_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    server_epoch BIGINT NOT NULL
);

CREATE INDEX idx_nsm_clients_callback_host ON nsm_client_registrations(callback_host);
CREATE INDEX idx_nsm_clients_registered_at ON nsm_client_registrations(registered_at);
```

**postgres/migrations/000003_clients.down.sql**:
```sql
DROP TABLE IF EXISTS nsm_client_registrations;
```

**postgres/clients.go** - PostgreSQL client registration storage:
```go
package postgres

import (
    "context"
    "fmt"

    "github.com/marmos91/dittofs/pkg/metadata/lock"
)

// PutClientRegistration stores or updates a client registration.
func (s *Store) PutClientRegistration(ctx context.Context, reg *lock.PersistedClientRegistration) error {
    query := `
        INSERT INTO nsm_client_registrations (
            client_id, mon_name, priv, callback_host, callback_prog,
            callback_vers, callback_proc, registered_at, server_epoch
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
        ON CONFLICT (client_id) DO UPDATE SET
            mon_name = EXCLUDED.mon_name,
            priv = EXCLUDED.priv,
            callback_host = EXCLUDED.callback_host,
            callback_prog = EXCLUDED.callback_prog,
            callback_vers = EXCLUDED.callback_vers,
            callback_proc = EXCLUDED.callback_proc,
            registered_at = EXCLUDED.registered_at,
            server_epoch = EXCLUDED.server_epoch
    `

    _, err := s.db.ExecContext(ctx, query,
        reg.ClientID,
        reg.MonName,
        reg.Priv[:],
        reg.CallbackHost,
        reg.CallbackProg,
        reg.CallbackVers,
        reg.CallbackProc,
        reg.RegisteredAt,
        reg.ServerEpoch,
    )
    if err != nil {
        return fmt.Errorf("put client registration: %w", err)
    }
    return nil
}

// GetClientRegistration retrieves a registration by client ID.
func (s *Store) GetClientRegistration(ctx context.Context, clientID string) (*lock.PersistedClientRegistration, error) {
    query := `
        SELECT client_id, mon_name, priv, callback_host, callback_prog,
               callback_vers, callback_proc, registered_at, server_epoch
        FROM nsm_client_registrations
        WHERE client_id = $1
    `

    var reg lock.PersistedClientRegistration
    var privBytes []byte

    err := s.db.QueryRowContext(ctx, query, clientID).Scan(
        &reg.ClientID,
        &reg.MonName,
        &privBytes,
        &reg.CallbackHost,
        &reg.CallbackProg,
        &reg.CallbackVers,
        &reg.CallbackProc,
        &reg.RegisteredAt,
        &reg.ServerEpoch,
    )
    if err != nil {
        if err == sql.ErrNoRows {
            return nil, nil
        }
        return nil, fmt.Errorf("get client registration: %w", err)
    }

    copy(reg.Priv[:], privBytes)
    return &reg, nil
}

// DeleteClientRegistration removes a registration.
func (s *Store) DeleteClientRegistration(ctx context.Context, clientID string) error {
    query := `DELETE FROM nsm_client_registrations WHERE client_id = $1`
    _, err := s.db.ExecContext(ctx, query, clientID)
    if err != nil {
        return fmt.Errorf("delete client registration: %w", err)
    }
    return nil
}

// ListClientRegistrations returns all stored registrations.
func (s *Store) ListClientRegistrations(ctx context.Context) ([]*lock.PersistedClientRegistration, error) {
    query := `
        SELECT client_id, mon_name, priv, callback_host, callback_prog,
               callback_vers, callback_proc, registered_at, server_epoch
        FROM nsm_client_registrations
        ORDER BY registered_at
    `

    rows, err := s.db.QueryContext(ctx, query)
    if err != nil {
        return nil, fmt.Errorf("list client registrations: %w", err)
    }
    defer rows.Close()

    var result []*lock.PersistedClientRegistration
    for rows.Next() {
        var reg lock.PersistedClientRegistration
        var privBytes []byte

        if err := rows.Scan(
            &reg.ClientID,
            &reg.MonName,
            &privBytes,
            &reg.CallbackHost,
            &reg.CallbackProg,
            &reg.CallbackVers,
            &reg.CallbackProc,
            &reg.RegisteredAt,
            &reg.ServerEpoch,
        ); err != nil {
            return nil, fmt.Errorf("scan client registration: %w", err)
        }

        copy(reg.Priv[:], privBytes)
        result = append(result, &reg)
    }

    return result, rows.Err()
}

// DeleteAllClientRegistrations removes all registrations.
func (s *Store) DeleteAllClientRegistrations(ctx context.Context) (int, error) {
    query := `DELETE FROM nsm_client_registrations`
    result, err := s.db.ExecContext(ctx, query)
    if err != nil {
        return 0, fmt.Errorf("delete all client registrations: %w", err)
    }

    count, _ := result.RowsAffected()
    return int(count), nil
}
```

Add `database/sql` import to postgres/clients.go for sql.ErrNoRows.
  </action>
  <verify>
```bash
go build ./pkg/metadata/store/memory/...
go build ./pkg/metadata/store/badger/...
go build ./pkg/metadata/store/postgres/...
```
  </verify>
  <done>Client registration storage implemented in memory, badger, and postgres backends</done>
</task>

<task type="auto">
  <name>Task 4: Integrate NSM dispatcher with NFS adapter</name>
  <files>pkg/adapter/nfs/nfs_adapter.go</files>
  <action>
Add NSM program routing to the NFS adapter's RPC dispatch logic.

Find the section where programs are routed (likely near NLM routing added in Phase 2) and add NSM routing:

```go
import (
    // Add to imports
    "github.com/marmos91/dittofs/internal/protocol/nsm"
    nsmHandlers "github.com/marmos91/dittofs/internal/protocol/nsm/handlers"
    nsmTypes "github.com/marmos91/dittofs/internal/protocol/nsm/types"
)

// In the adapter struct, add:
nsmHandler *nsmHandlers.Handler

// In the adapter initialization (NewNFSAdapter or similar), create the NSM handler:
// After creating connectionTracker and before serving...

// Get or create ClientRegistrationStore from metadata store
// (The exact method depends on how stores are accessed in the adapter)
var clientStore lock.ClientRegistrationStore
if store, ok := metadataStore.(interface{ ClientRegistrationStore() lock.ClientRegistrationStore }); ok {
    clientStore = store.ClientRegistrationStore()
}

nsmHandler := nsmHandlers.NewHandler(nsmHandlers.HandlerConfig{
    Tracker:      connectionTracker,
    ClientStore:  clientStore,
    ServerName:   hostname,  // From config or os.Hostname()
    InitialState: serverEpoch,  // Reuse server epoch from lock persistence
    MaxClients:   10000,
})

adapter.nsmHandler = nsmHandler

// In the RPC dispatch switch statement (handleProgram or similar):
case nsmTypes.ProgramNSM:
    if call.Version != nsmTypes.SMVersion1 {
        return c.handleUnsupportedVersion(call, nsmTypes.SMVersion1, "NSM", clientAddr)
    }
    return c.handleNSMProcedure(ctx, call, procedureData, clientAddr)

// Add handleNSMProcedure method:
func (c *Connection) handleNSMProcedure(
    ctx context.Context,
    call *rpc.RPCCallMessage,
    data []byte,
    clientAddr string,
) ([]byte, error) {
    proc := call.Procedure

    // Look up procedure in dispatch table
    procInfo, ok := nsm.NSMDispatchTable[proc]
    if !ok {
        logger.Debug("NSM: unsupported procedure", "procedure", proc)
        return nil, fmt.Errorf("unsupported NSM procedure: %d", proc)
    }

    logger.Debug("NSM procedure", "name", procInfo.Name, "client", clientAddr)

    // Create handler context
    handlerCtx := &nsmHandlers.NSMHandlerContext{
        Context:    ctx,
        ClientAddr: clientAddr,
        ClientName: "", // Could extract from auth if available
    }

    // Invoke handler
    return procInfo.Handler(handlerCtx, c.adapter.nsmHandler, data)
}
```

The exact integration depends on the adapter's structure. Mirror how NLM was integrated in Phase 2.
  </action>
  <verify>
```bash
go build ./pkg/adapter/nfs/...
```
  </verify>
  <done>NSM program (100024) routed to NSM handlers in NFS adapter</done>
</task>

</tasks>

<verification>
```bash
# Build all packages
go build ./internal/protocol/nsm/...
go build ./pkg/metadata/store/...
go build ./pkg/adapter/nfs/...

# Run tests
go test ./pkg/metadata/lock/...
go test ./pkg/metadata/store/memory/...
go test ./pkg/metadata/store/badger/...
```
</verification>

<success_criteria>
- NSM handler struct created with ConnectionTracker and ClientRegistrationStore dependencies
- NSM dispatch table maps procedures to handlers
- SM_NULL, SM_STAT, SM_MON, SM_UNMON, SM_UNMON_ALL, SM_NOTIFY handlers implemented
- Memory, BadgerDB, and PostgreSQL client registration stores implemented
- PostgreSQL migration creates nsm_client_registrations table
- NFS adapter routes NSM program (100024) to NSM handlers
- All packages compile without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-nsm-protocol/03-02-SUMMARY.md`
</output>
