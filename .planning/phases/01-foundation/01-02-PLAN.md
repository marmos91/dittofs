---
phase: 01-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - test/e2e/helpers/environment.go
  - test/e2e/helpers/scope.go
  - test/e2e/main_test.go
autonomous: true

must_haves:
  truths:
    - "Test suite starts Postgres container automatically via Testcontainers"
    - "Test suite starts S3/Localstack container automatically via Testcontainers"
    - "Tests can run in parallel with isolated namespaces"
    - "Container cleanup happens even on test failure or interrupt"
    - "Shared containers are reused within a single test run"
  artifacts:
    - path: "test/e2e/helpers/environment.go"
      provides: "TestEnvironment struct wrapping existing framework helpers"
      exports: ["TestEnvironment", "NewTestEnvironment"]
      min_lines: 60
    - path: "test/e2e/helpers/scope.go"
      provides: "TestScope struct for per-test isolation"
      exports: ["TestScope"]
      min_lines: 60
    - path: "test/e2e/main_test.go"
      provides: "TestMain using new helpers package"
      contains: "func TestMain"
      min_lines: 30
  key_links:
    - from: "test/e2e/main_test.go"
      to: "test/e2e/helpers/environment.go"
      via: "NewTestEnvironment call in TestMain"
      pattern: "helpers\\.NewTestEnvironment"
    - from: "test/e2e/helpers/scope.go"
      to: "test/e2e/helpers/environment.go"
      via: "TestScope references TestEnvironment"
      pattern: "env.*TestEnvironment"
    - from: "test/e2e/helpers/environment.go"
      to: "test/e2e/framework/containers.go"
      via: "Wraps existing NewPostgresHelper/NewLocalstackHelper"
      pattern: "framework\\.New(Postgres|Localstack)Helper"
---

<objective>
Create the E2E test framework infrastructure with Testcontainers for Postgres and S3.

Purpose: Enable parallel test execution with per-test isolation through unique Postgres schemas and S3 prefixes. Wrap existing framework/containers.go pattern for consistency.

Output: Helper package in `test/e2e/helpers/` with TestEnvironment and TestScope, plus updated TestMain.

**Note on FRM-04 (Container reuse):** This plan implements within-run container reuse - shared containers for all tests in one `go test` invocation. Cross-run persistence (keeping containers alive between separate test invocations) is out of scope as it would require Ryuk/reaper configuration which adds complexity without significant benefit for our use case.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md

# Reference existing framework (to be wrapped, not replaced)
@test/e2e/framework/containers.go
@test/e2e/framework/mount.go
@test/e2e/main_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TestEnvironment and TestScope helpers</name>
  <files>
    test/e2e/helpers/environment.go
    test/e2e/helpers/scope.go
  </files>
  <action>
Create `test/e2e/helpers/` package that wraps the existing `test/e2e/framework/containers.go` pattern:

**1. Create test/e2e/helpers/environment.go:**

```go
//go:build e2e

package helpers

// TestEnvironment wraps the existing framework helpers for container management.
// It uses the shared singleton pattern from framework/containers.go.
type TestEnvironment struct {
    ctx            context.Context
    pgHelper       *framework.PostgresHelper   // From framework.NewPostgresHelper
    lsHelper       *framework.LocalstackHelper // From framework.NewLocalstackHelper
}
```

- **NewTestEnvironment(t *testing.T) *TestEnvironment:**
  1. Call `framework.NewPostgresHelper(t)` - this starts OR reuses the shared Postgres container
  2. Call `framework.NewLocalstackHelper(t)` - this starts OR reuses the shared Localstack container
  3. Both helpers use the existing singleton pattern (sharedPostgresHelper, sharedLocalstackHelper)
  4. Return TestEnvironment wrapping both helpers
  5. Fail fast with t.Fatal if either helper fails (existing behavior)

- **Cleanup():**
  1. Call `framework.CleanupSharedContainers()` - terminates both shared containers

- **NewScope(t *testing.T) *TestScope:**
  Create and return a new TestScope (delegates to scope.go)

- **Helper accessors:**
  - `PostgresHelper() *framework.PostgresHelper` - returns underlying Postgres helper
  - `LocalstackHelper() *framework.LocalstackHelper` - returns underlying Localstack helper
  - `PostgresConnectionString() string` - returns connection string
  - `S3Client() *s3.Client` - returns S3 client from LocalstackHelper
  - `S3Endpoint() string` - returns LocalStack endpoint

**Key design decision:** This wraps existing framework/containers.go rather than replacing it. The existing GenericContainer pattern with singleton reuse is preserved. This honors the user decision of "Shared containers started in TestMain."

**2. Create test/e2e/helpers/scope.go:**

```go
//go:build e2e

package helpers

// TestScope provides per-test isolation (unique schema, S3 prefix)
type TestScope struct {
    t          *testing.T
    env        *TestEnvironment
    schemaName string
    s3Prefix   string
    db         *pgxpool.Pool  // Scoped to test schema
    cleanup    []func()
}
```

- **NewScope implementation (called from TestEnvironment.NewScope):**
  1. Generate unique schema name: `test_<sanitized_test_name>_<uuid8>`
  2. Create schema: `CREATE SCHEMA <schema_name>`
  3. Create scoped connection with search_path set to schema
  4. Generate unique S3 prefix: `test-<uuid8>/`
  5. Register cleanup via t.Cleanup()

- **Cleanup():**
  1. Close scoped db connection
  2. Drop schema: `DROP SCHEMA IF EXISTS <schema_name> CASCADE`
  3. Delete all S3 objects with prefix (use LocalstackHelper.CleanupBucket pattern)
  4. Run any registered cleanup functions

- **Helper methods:**
  - `DB() *pgxpool.Pool` - returns scoped database connection
  - `SchemaName() string` - returns unique schema name
  - `S3Prefix() string` - returns unique S3 prefix
  - `S3Client() *s3.Client` - returns S3 client (from env)
  - `Env() *TestEnvironment` - returns parent environment
  - `RegisterCleanup(fn func())` - register additional cleanup

**Important patterns from CONTEXT.md:**
- Use `t.Helper()` in all helper functions
- Use `require.NoError()` for setup failures (fail fast)
- Sanitize test names for schema (replace invalid chars with underscore)
- Use UUID v4 shortened to 8 chars for uniqueness
  </action>
  <verify>
1. `go build -tags=e2e ./test/e2e/helpers/...` succeeds
2. Package compiles without import errors
3. TestEnvironment and TestScope types are exported
4. TestEnvironment wraps framework helpers (grep for "framework.NewPostgresHelper")
  </verify>
  <done>
- environment.go exists with TestEnvironment struct wrapping framework helpers
- scope.go exists with TestScope struct
- TestEnvironment delegates to existing framework.NewPostgresHelper/NewLocalstackHelper
- Singleton reuse pattern preserved (not replaced with module functions)
- Per-test schema isolation implemented
- Per-test S3 prefix isolation implemented
- t.Cleanup() used for automatic cleanup
  </done>
</task>

<task type="auto">
  <name>Task 2: Update TestMain to use helpers package</name>
  <files>
    test/e2e/main_test.go
  </files>
  <action>
Update test/e2e/main_test.go to use the new helpers package while preserving existing behavior:

```go
//go:build e2e

package e2e

import (
    "context"
    "os"
    "os/signal"
    "syscall"
    "testing"

    "github.com/marmos91/dittofs/test/e2e/framework"
    "github.com/marmos91/dittofs/test/e2e/helpers"
)

// Global test environment (shared containers)
var testEnv *helpers.TestEnvironment

func TestMain(m *testing.M) {
    // Setup signal handler for graceful shutdown on CTRL+C
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()

    sigChan := make(chan os.Signal, 1)
    signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

    go func() {
        <-sigChan
        // Cleanup on interrupt
        framework.CleanupAllContexts()      // Clean up cached test contexts (mounts, servers)
        if testEnv != nil {
            testEnv.Cleanup()               // Clean up Docker containers via helpers
        }
        cancel()
        os.Exit(1)
    }()

    // Cleanup any stale mounts from previous failed runs before starting
    framework.CleanupStaleMounts()

    // Initialize test environment (starts shared containers)
    // Note: We use a sentinel *testing.T since TestMain doesn't have one
    // The helpers will fail fast via log.Fatal if containers don't start
    testEnv = helpers.NewTestEnvironmentForMain(ctx)

    // Run tests
    code := m.Run()

    // Cleanup after all tests complete
    framework.CleanupAllContexts()      // Clean up cached test contexts (mounts, servers)
    if testEnv != nil {
        testEnv.Cleanup()               // Clean up Docker containers
    }

    // Exit with context awareness
    select {
    case <-ctx.Done():
        os.Exit(1)
    default:
        os.Exit(code)
    }
}

// GetTestEnv returns the global test environment for use in tests.
// Tests should call env.NewScope(t) to get per-test isolation.
func GetTestEnv() *helpers.TestEnvironment {
    return testEnv
}
```

**Add to environment.go - TestMain variant:**

```go
// NewTestEnvironmentForMain creates a TestEnvironment from TestMain context.
// Unlike NewTestEnvironment, this doesn't require a *testing.T since TestMain
// doesn't have one. Failures will log.Fatal instead of t.Fatal.
func NewTestEnvironmentForMain(ctx context.Context) *TestEnvironment {
    // Start containers using a sentinel pattern or direct container calls
    // The framework helpers have fallback logging when t is nil
    // ...
}
```

**Why this approach:**
- Preserves existing framework.CleanupAllContexts() and CleanupStaleMounts() calls
- Adds testEnv for new helpers package integration
- Exposes GetTestEnv() for tests to get scoped access
- Maintains signal handling and cleanup behavior
  </action>
  <verify>
1. `go build -tags=e2e ./test/e2e/...` succeeds
2. `go test -tags=e2e -v -run=TestNonExistent ./test/e2e/` runs TestMain (container startup visible)
3. Signal handling works (Ctrl+C during container startup triggers cleanup)
4. GetTestEnv() is exported and returns *helpers.TestEnvironment
  </verify>
  <done>
- main_test.go updated to use helpers.TestEnvironment
- testEnv variable exported via GetTestEnv()
- Signal handler cleans up via testEnv.Cleanup()
- Existing framework.CleanupAllContexts() and CleanupStaleMounts() preserved
- NewTestEnvironmentForMain added to environment.go for TestMain usage
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Build verification:
   ```bash
   go build -tags=e2e ./test/e2e/helpers/...
   go build -tags=e2e ./test/e2e/...
   ```

2. Import verification:
   ```bash
   go list -tags=e2e ./test/e2e/helpers
   ```

3. Pattern verification (wraps existing framework):
   ```bash
   grep -n "framework.NewPostgresHelper\|framework.NewLocalstackHelper" test/e2e/helpers/environment.go
   ```
   Expected: References to existing framework helper functions

4. Container startup test (requires Docker running):
   ```bash
   # This will start containers and exit - verifies TestMain works
   go test -tags=e2e -v -run=TestNonExistent ./test/e2e/ 2>&1 | head -30
   ```
   Expected: See container startup logs or "no tests to run"

5. Verify exports:
   ```bash
   go doc -tags=e2e github.com/marmos91/dittofs/test/e2e/helpers
   ```
   Expected: TestEnvironment, TestScope, NewTestEnvironment listed
</verification>

<success_criteria>
1. `test/e2e/helpers/` package exists with environment.go and scope.go
2. TestEnvironment wraps existing framework/containers.go helpers (NOT replaces them)
3. Singleton container reuse pattern preserved from framework.NewPostgresHelper/NewLocalstackHelper
4. TestScope provides unique Postgres schema and S3 prefix per test
5. TestMain updated to use helpers package while preserving existing cleanup calls
6. `go build -tags=e2e ./test/e2e/...` passes
7. Container reuse is within-run only (cross-run persistence explicitly out of scope)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
