---
phase: 02-nlm-protocol
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - internal/protocol/nfs/rpc/constants.go
  - internal/protocol/nlm/handlers/context.go
  - internal/protocol/nlm/handlers/handler.go
  - internal/protocol/nlm/handlers/null.go
  - internal/protocol/nlm/handlers/test.go
  - internal/protocol/nlm/handlers/lock.go
  - internal/protocol/nlm/handlers/unlock.go
  - internal/protocol/nlm/handlers/cancel.go
  - internal/protocol/nlm/dispatch.go
  - pkg/adapter/nfs/nfs_connection.go
  - pkg/adapter/nfs/nfs_adapter.go
  - pkg/metadata/service.go
autonomous: true

must_haves:
  truths:
    - "NLM requests on port 12049 are dispatched to NLM handlers"
    - "NLM_NULL returns success (ping/health check)"
    - "NLM_TEST returns NLM4_GRANTED when lock available, NLM4_DENIED with holder info when conflict exists"
    - "NLM_LOCK returns NLM4_GRANTED when lock acquired successfully"
    - "NLM_UNLOCK returns NLM4_GRANTED (including for non-existent locks per idempotency)"
    - "NLM_CANCEL returns NLM4_GRANTED when cancellation processed"
  artifacts:
    - path: "internal/protocol/nlm/handlers/handler.go"
      provides: "NLM Handler struct with MetadataService reference"
      exports: ["Handler", "NewHandler"]
    - path: "internal/protocol/nlm/dispatch.go"
      provides: "NLM dispatch table mapping procedures to handlers"
      exports: ["NLMDispatchTable", "NLMProcedure"]
    - path: "pkg/adapter/nfs/nfs_connection.go"
      provides: "NLM program routing in handleRPCCall"
      contains: "case rpc.ProgramNLM"
    - path: "pkg/metadata/service.go"
      provides: "NLM-specific lock methods"
      exports: ["LockFileNLM", "UnlockFileNLM", "TestLockNLM", "CancelBlockingLock"]
  key_links:
    - from: "internal/protocol/nlm/handlers/handler.go"
      to: "pkg/metadata"
      via: "MetadataService reference"
      pattern: "metadataService.*MetadataService"
    - from: "pkg/adapter/nfs/nfs_adapter.go"
      to: "internal/protocol/nlm/handlers"
      via: "nlm.NewHandler(metadataService) initialization"
      pattern: "nlm.*NewHandler"
    - from: "pkg/adapter/nfs/nfs_connection.go"
      to: "internal/protocol/nlm"
      via: "dispatch to NLM handlers"
      pattern: "handleNLMProcedure"
    - from: "internal/protocol/nlm/handlers/lock.go"
      to: "pkg/metadata/service"
      via: "LockFileNLM call"
      pattern: "LockFileNLM"
---

<objective>
Implement NLM dispatcher integration and synchronous lock operations.

Purpose: Enable NFSv3 clients to acquire, test, release, and cancel byte-range locks via the NLM protocol. This integrates with the unified lock manager from Phase 1.

Output:
- NLM handlers for NULL, TEST, LOCK, UNLOCK, CANCEL procedures
- NLM dispatch table and routing in NFS connection handler
- MetadataService NLM-specific methods for lock operations
- Owner ID construction per CONTEXT.md format
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-nlm-protocol/02-CONTEXT.md
@.planning/phases/02-nlm-protocol/02-RESEARCH.md
@.planning/phases/02-nlm-protocol/02-01-SUMMARY.md
@internal/protocol/nfs/dispatch.go
@pkg/adapter/nfs/nfs_connection.go
@pkg/adapter/nfs/nfs_adapter.go
@pkg/metadata/service.go
@pkg/metadata/lock/manager.go
@pkg/metadata/lock/types.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add NLM program constant and create NLM handlers structure</name>
  <files>
    internal/protocol/nfs/rpc/constants.go
    internal/protocol/nlm/handlers/context.go
    internal/protocol/nlm/handlers/handler.go
  </files>
  <action>
1. In internal/protocol/nfs/rpc/constants.go, add NLM program constant:
```go
const (
    // Existing constants...
    ProgramNLM    uint32 = 100021
    NLMVersion4   uint32 = 4
)
```

2. Create internal/protocol/nlm/handlers/context.go:
```go
package handlers

import "context"

// NLMHandlerContext contains context for NLM procedure handlers.
type NLMHandlerContext struct {
    // Context is the Go context for cancellation/timeout
    Context context.Context

    // ClientAddr is the remote address of the NLM client
    ClientAddr string

    // AuthFlavor is the RPC authentication flavor (AUTH_UNIX, AUTH_NULL)
    AuthFlavor uint32

    // UID is the Unix user ID (from AUTH_UNIX, nil if not available)
    UID *uint32

    // GID is the Unix primary group ID (from AUTH_UNIX, nil if not available)
    GID *uint32

    // GIDs is the list of supplementary group IDs
    GIDs []uint32
}
```

3. Create internal/protocol/nlm/handlers/handler.go:
```go
package handlers

import (
    "github.com/marmos91/dittofs/pkg/metadata"
)

// Handler processes NLM procedure calls.
type Handler struct {
    metadataService *metadata.MetadataService
}

// NewHandler creates a new NLM handler with the given metadata service.
func NewHandler(metadataService *metadata.MetadataService) *Handler {
    return &Handler{
        metadataService: metadataService,
    }
}
```
  </action>
  <verify>
Run: `go build ./internal/protocol/nlm/handlers/...` - compiles without errors
  </verify>
  <done>
NLM handler structure exists with MetadataService reference and context type.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement NLM procedure handlers</name>
  <files>
    internal/protocol/nlm/handlers/null.go
    internal/protocol/nlm/handlers/test.go
    internal/protocol/nlm/handlers/lock.go
    internal/protocol/nlm/handlers/unlock.go
    internal/protocol/nlm/handlers/cancel.go
    internal/protocol/nlm/dispatch.go
  </files>
  <action>
Create NLM procedure handlers following the pattern from internal/protocol/nfs/v3/handlers/:

1. Create internal/protocol/nlm/handlers/null.go:
   - NullRequest/NullResponse types (minimal - just for ping)
   - DecodeNullRequest, EncodeNullResponse functions
   - Handler.Null(ctx *NLMHandlerContext, req *NullRequest) (*NullResponse, error)
   - Returns NLM4Granted status (success)

2. Create internal/protocol/nlm/handlers/test.go:
   - TestRequest/TestResponse types
   - DecodeTestRequest using nlm/xdr package
   - EncodeTestResponse with optional holder info
   - Handler.Test(ctx *NLMHandlerContext, req *TestRequest) (*TestResponse, error)
   - Calls metadataService.TestLockNLM()
   - Returns NLM4Granted if lock would succeed, NLM4Denied with holder info if conflict
   - TEST should be allowed during grace period per Phase 1 decision

3. Create internal/protocol/nlm/handlers/lock.go:
   - LockRequest/LockResponse types
   - DecodeLockRequest using nlm/xdr package
   - EncodeLockResponse
   - Handler.Lock(ctx *NLMHandlerContext, req *LockRequest) (*LockResponse, error)
   - Build owner ID: fmt.Sprintf("nlm:%s:%d:%s", callerName, svid, hex.EncodeToString(oh))
   - For non-blocking: Call metadataService.LockFileNLM(), return NLM4Granted or NLM4Denied
   - For blocking: Return NLM4Blocked (actual blocking handled in Plan 02-03)
   - Handle grace period: if reclaim=true use reclaim path, else deny during grace

4. Create internal/protocol/nlm/handlers/unlock.go:
   - UnlockRequest/UnlockResponse types
   - DecodeUnlockRequest, EncodeUnlockResponse
   - Handler.Unlock(ctx *NLMHandlerContext, req *UnlockRequest) (*UnlockResponse, error)
   - Calls metadataService.UnlockFileNLM()
   - Per CONTEXT.md: unlock of non-existent lock silently succeeds (NLM4Granted)
   - Ignore exclusive flag on unlock per CONTEXT.md

5. Create internal/protocol/nlm/handlers/cancel.go:
   - CancelRequest/CancelResponse types
   - DecodeCancelRequest, EncodeCancelResponse
   - Handler.Cancel(ctx *NLMHandlerContext, req *CancelRequest) (*CancelResponse, error)
   - Calls metadataService.CancelBlockingLock()
   - Returns NLM4Granted if cancellation succeeds

6. Create internal/protocol/nlm/dispatch.go:
```go
package nlm

import (
    "github.com/marmos91/dittofs/internal/protocol/nlm/handlers"
    "github.com/marmos91/dittofs/pkg/controlplane/runtime"
)

// NLMProcedure contains metadata about an NLM procedure for dispatch.
type NLMProcedure struct {
    Name      string
    Handler   NLMProcedureHandler
    NeedsAuth bool
}

type NLMProcedureHandler func(
    ctx *handlers.NLMHandlerContext,
    handler *handlers.Handler,
    reg *runtime.Runtime,
    data []byte,
) (*HandlerResult, error)

// NLMDispatchTable maps NLM procedure numbers to their handlers.
var NLMDispatchTable map[uint32]*NLMProcedure

func init() {
    initNLMDispatchTable()
}

func initNLMDispatchTable() {
    NLMDispatchTable = map[uint32]*NLMProcedure{
        NLMProcNull:   {Name: "NULL", Handler: handleNLMNull, NeedsAuth: false},
        NLMProcTest:   {Name: "TEST", Handler: handleNLMTest, NeedsAuth: true},
        NLMProcLock:   {Name: "LOCK", Handler: handleNLMLock, NeedsAuth: true},
        NLMProcCancel: {Name: "CANCEL", Handler: handleNLMCancel, NeedsAuth: true},
        NLMProcUnlock: {Name: "UNLOCK", Handler: handleNLMUnlock, NeedsAuth: true},
    }
}
```

Implement wrapper functions (handleNLMNull, handleNLMTest, etc.) following the pattern from internal/protocol/nfs/dispatch.go.
  </action>
  <verify>
Run: `go build ./internal/protocol/nlm/...` - compiles without errors
Run: `go vet ./internal/protocol/nlm/...` - no issues
  </verify>
  <done>
All NLM procedure handlers implemented with dispatch table.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add MetadataService NLM methods and integrate dispatcher</name>
  <files>
    pkg/metadata/service.go
    pkg/adapter/nfs/nfs_connection.go
    pkg/adapter/nfs/nfs_adapter.go
  </files>
  <action>
1. Add NLM-specific lock methods to pkg/metadata/service.go:

```go
// LockFileNLM acquires a lock for NLM protocol.
// Unlike LockFile, this:
// - Takes ownerID string directly (NLM handler constructs it)
// - Returns detailed conflict info for NLM_DENIED responses
// - Supports blocking semantics (returns should-wait indication)
func (s *MetadataService) LockFileNLM(
    ctx context.Context,
    handle FileHandle,
    owner lock.LockOwner,
    offset, length uint64,
    exclusive bool,
    reclaim bool,
) (*lock.LockResult, error) {
    // Get lock manager for the handle's share
    lm, err := s.lockManagerForHandle(handle)
    if err != nil {
        return nil, err
    }

    // Verify file exists
    store, err := s.storeForHandle(handle)
    if err != nil {
        return nil, err
    }
    _, err = store.GetFile(ctx, handle)
    if err != nil {
        return nil, err // Will map to NLM4_STALE_FH
    }

    // Create enhanced lock
    lockType := lock.LockTypeShared
    if exclusive {
        lockType = lock.LockTypeExclusive
    }
    enhancedLock := lock.NewEnhancedLock(owner, lock.FileHandle(handle), offset, length, lockType)
    enhancedLock.Reclaim = reclaim

    // Try to acquire
    handleKey := string(handle)
    err = lm.AddEnhancedLock(handleKey, enhancedLock)
    if err != nil {
        // Check if it's a conflict error
        if conflictErr, ok := err.(*lock.LockConflictError); ok {
            return &lock.LockResult{
                Success:  false,
                Conflict: conflictErr.Conflict,
            }, nil
        }
        return nil, err
    }

    return &lock.LockResult{
        Success: true,
        Lock:    enhancedLock,
    }, nil
}

// TestLockNLM tests lock without acquiring.
// Returns (granted, conflict, error) where conflict is non-nil if denied.
func (s *MetadataService) TestLockNLM(
    ctx context.Context,
    handle FileHandle,
    owner lock.LockOwner,
    offset, length uint64,
    exclusive bool,
) (bool, *lock.EnhancedLockConflict, error) {
    // Get lock manager and verify file exists
    lm, err := s.lockManagerForHandle(handle)
    if err != nil {
        return false, nil, err
    }
    store, err := s.storeForHandle(handle)
    if err != nil {
        return false, nil, err
    }
    _, err = store.GetFile(ctx, handle)
    if err != nil {
        return false, nil, err
    }

    // Test the lock
    lockType := lock.LockTypeShared
    if exclusive {
        lockType = lock.LockTypeExclusive
    }
    testLock := lock.NewEnhancedLock(owner, lock.FileHandle(handle), offset, length, lockType)

    handleKey := string(handle)
    existing := lm.ListEnhancedLocks(handleKey)
    for _, el := range existing {
        if lock.IsEnhancedLockConflicting(el, testLock) {
            return false, &lock.EnhancedLockConflict{Lock: el, Reason: "conflict"}, nil
        }
    }
    return true, nil, nil
}

// UnlockFileNLM releases a lock for NLM protocol.
// Per CONTEXT.md: silently succeeds if lock doesn't exist (idempotency).
func (s *MetadataService) UnlockFileNLM(
    ctx context.Context,
    handle FileHandle,
    ownerID string,
    offset, length uint64,
) error {
    lm, err := s.lockManagerForHandle(handle)
    if err != nil {
        return nil // No lock manager = no locks = success
    }

    handleKey := string(handle)
    err = lm.RemoveEnhancedLock(handleKey, lock.LockOwner{OwnerID: ownerID}, offset, length)
    if err != nil {
        // Per CONTEXT.md: unlock of non-existent lock silently succeeds
        if _, ok := err.(*lock.LockNotFoundError); ok {
            return nil
        }
        return err
    }
    return nil
}

// CancelBlockingLock cancels a pending blocking lock request.
// This will be fully implemented in Plan 02-03 with blocking queue.
func (s *MetadataService) CancelBlockingLock(
    ctx context.Context,
    handle FileHandle,
    ownerID string,
    offset, length uint64,
) error {
    // Stub for now - blocking queue in Plan 02-03
    return nil
}
```

2. Integrate NLM dispatcher in pkg/adapter/nfs/nfs_connection.go:

In handleRPCCall(), add case for NLM program:
```go
case rpc.ProgramNLM:
    // NLM v4 only per CONTEXT.md
    if call.Version != rpc.NLMVersion4 {
        return c.handleUnsupportedVersion(call, rpc.NLMVersion4, "NLM", clientAddr)
    }
    replyData, err = c.handleNLMProcedure(ctx, call, procedureData, clientAddr)
```

Add handleNLMProcedure() method following the pattern of handleNFSProcedure():
- Look up procedure in nlm.NLMDispatchTable
- Extract NLM handler context
- Get NLM handler from adapter (c.adapter.nlmHandler)
- Invoke handler
- Record metrics with "NLM_" prefix

3. In pkg/adapter/nfs/nfs_adapter.go:
- Add nlmHandler *nlm_handlers.Handler field to NFSAdapter struct
- In SetRuntime() method, after runtime is set:
  ```go
  // Initialize NLM handler with MetadataService from runtime
  metadataService := a.runtime.GetMetadataService()
  a.nlmHandler = nlm_handlers.NewHandler(metadataService)
  ```
- Add accessor method: GetNLMHandler() *nlm_handlers.Handler
- nfs_connection.go calls c.adapter.GetNLMHandler() to pass to dispatch
  </action>
  <verify>
Run: `go build ./pkg/metadata/...` - compiles
Run: `go build ./pkg/adapter/nfs/...` - compiles
Run: `go test ./...` - all tests pass
  </verify>
  <done>
MetadataService has NLM lock methods. NFS adapter initializes NLM handler with MetadataService from runtime. NFS connection dispatches NLM requests to NLM handlers.
  </done>
</task>

</tasks>

<verification>
Overall verification for Plan 02-02:

1. NLM handlers exist:
   - `ls internal/protocol/nlm/handlers/` shows context.go, handler.go, null.go, test.go, lock.go, unlock.go, cancel.go
   - `go build ./internal/protocol/nlm/...` compiles

2. Dispatch integration:
   - `grep "ProgramNLM" pkg/adapter/nfs/nfs_connection.go` shows NLM routing
   - `grep "handleNLMProcedure" pkg/adapter/nfs/nfs_connection.go` shows handler method

3. MetadataService methods:
   - `grep "LockFileNLM" pkg/metadata/service.go` shows NLM lock method
   - `grep "TestLockNLM" pkg/metadata/service.go` shows NLM test method
   - `grep "UnlockFileNLM" pkg/metadata/service.go` shows NLM unlock method

4. NLM handler initialization:
   - `grep "nlmHandler" pkg/adapter/nfs/nfs_adapter.go` shows handler field
   - `grep "NewHandler" pkg/adapter/nfs/nfs_adapter.go` shows initialization in SetRuntime

5. Full test suite:
   - `go test ./...` passes
</verification>

<success_criteria>
- NLM program (100021) dispatched to NLM handlers on same port as NFS
- NLM_NULL responds with success (ping works)
- NLM_TEST returns lock conflict info when lock would fail
- NLM_LOCK acquires non-blocking locks through unified lock manager
- NLM_UNLOCK releases locks idempotently (non-existent unlock succeeds)
- NLM_CANCEL stub exists for blocking queue integration
- Owner ID format matches CONTEXT.md: nlm:{hostname}:{svid}:{oh_hex}
- NLM handler initialized with MetadataService from runtime.GetMetadataService()
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-nlm-protocol/02-02-SUMMARY.md`
</output>
