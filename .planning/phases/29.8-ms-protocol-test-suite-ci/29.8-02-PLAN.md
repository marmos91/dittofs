---
phase: 29.8-ms-protocol-test-suite-ci
plan: 02
type: execute
wave: 2
depends_on: ["29.8-01"]
files_modified:
  - test/smb-conformance/run.sh
  - test/smb-conformance/parse-results.sh
  - test/smb-conformance/Makefile
  - test/smb-conformance/KNOWN_FAILURES.md
  - test/smb-conformance/README.md
  - .github/workflows/smb-conformance.yml
autonomous: true
requirements:
  - WIN-00

must_haves:
  truths:
    - "run.sh orchestrates full test lifecycle: render ptfconfig, start containers, bootstrap, run WPTS, collect results, report pass/fail"
    - "parse-results.sh reads TRX XML and produces colored summary table distinguishing passes, known failures, and new failures"
    - "CI exits 0 when only known failures exist; exits non-zero on new unexpected failures"
    - "GitHub Actions workflow triggers on PRs touching SMB adapter paths, runs memory profile on PR, full matrix on develop push"
    - "KNOWN_FAILURES.md documents expected test failures with reasons and issue references"
  artifacts:
    - path: "test/smb-conformance/run.sh"
      provides: "Main test orchestrator with --profile, --mode, --filter, --keep, --dry-run flags"
      contains: "docker compose"
    - path: "test/smb-conformance/parse-results.sh"
      provides: "TRX XML parser producing colored terminal summary"
      contains: "xmlstarlet"
    - path: ".github/workflows/smb-conformance.yml"
      provides: "CI workflow with path-scoped triggers, tiered profiles, weekly cron"
      contains: "smb-conformance"
    - path: "test/smb-conformance/KNOWN_FAILURES.md"
      provides: "Machine-readable list of expected test failures"
      contains: "Encryption"
    - path: "test/smb-conformance/Makefile"
      provides: "Convenience targets for common invocations"
      contains: "run.sh"
    - path: "test/smb-conformance/README.md"
      provides: "Setup guide, local run instructions, dev guide for iterating on failures"
      contains: "WPTS"
  key_links:
    - from: "test/smb-conformance/run.sh"
      to: "test/smb-conformance/docker-compose.yml"
      via: "docker compose up/down commands"
      pattern: "docker compose"
    - from: "test/smb-conformance/run.sh"
      to: "test/smb-conformance/bootstrap.sh"
      via: "exec bootstrap after DittoFS healthy"
      pattern: "bootstrap.sh"
    - from: "test/smb-conformance/run.sh"
      to: "test/smb-conformance/parse-results.sh"
      via: "parse TRX results after WPTS completes"
      pattern: "parse-results.sh"
    - from: ".github/workflows/smb-conformance.yml"
      to: "test/smb-conformance/run.sh"
      via: "CI job executes run.sh"
      pattern: "run.sh"
    - from: "test/smb-conformance/parse-results.sh"
      to: "test/smb-conformance/KNOWN_FAILURES.md"
      via: "reads known failures to classify test outcomes"
      pattern: "KNOWN_FAILURES"
---

<objective>
Create the test runner script, TRX result parser, known failures tracking, CI workflow, Makefile, and documentation for the WPTS SMB conformance testing infrastructure.

Purpose: Provides the orchestration layer that ties together the Docker infrastructure (Plan 01) into a complete, CI-integrated SMB conformance test suite with intelligent failure classification.
Output: Complete test runner, result parser, CI workflow, and documentation enabling both local and CI execution of WPTS BVT tests.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29.8-ms-protocol-test-suite-ci/29.8-RESEARCH.md
@.planning/phases/29.8-ms-protocol-test-suite-ci/29.8-01-SUMMARY.md

Key reference files:
@test/posix/setup-posix.sh (bootstrap pattern)
@test/posix/run-posix.sh (test runner pattern)
@test/posix/known_failures.txt (known failures pattern)
@.github/workflows/posix-tests.yml (CI workflow pattern)

<interfaces>
<!-- From Plan 01 artifacts: -->

test/smb-conformance/docker-compose.yml:
- Services: dittofs (build from Dockerfile.dittofs), wpts (profiles: test), localstack (profiles: s3), postgres (profiles: postgres)
- dittofs service has healthcheck on /health/ready
- wpts service uses network_mode: "service:dittofs" (shares network namespace)
- wpts volume: ./ptfconfig-generated:/data/fileserver
- WPTS output: .trx files in /data/fileserver
- Environment: PROFILE, DITTOFS_CONTROLPLANE_SECRET, WPTS_FILTER

test/smb-conformance/bootstrap.sh:
- Env vars: DFSCTL, API_URL, ADMIN_PASSWORD, TEST_PASSWORD, PROFILE
- Creates stores, shares (SMBBasic, SMBEncrypted), users (wpts-admin, nonadmin), SMB adapter
- Waits for API ready + SMB port ready

test/smb-conformance/ptfconfig/*.template:
- Uses ${VARIABLE} placeholders rendered with envsubst
- Key vars: DITTOFS_HOST, SMB_PORT, CLIENT_IP, ADMIN_USER, TEST_USER, TEST_PASSWORD

test/smb-conformance/configs/*.yaml:
- memory.yaml, memory-fs.yaml, badger-fs.yaml, badger-s3.yaml, postgres-s3.yaml

<!-- WPTS TRX output format (from research):
<TestRun xmlns="http://microsoft.com/schemas/VisualStudio/TeamTest/2010">
  <ResultSummary outcome="Failed">
    <Counters total="N" passed="N" failed="N" error="N" timeout="N" aborted="N" inconclusive="N"/>
  </ResultSummary>
  <Results>
    <UnitTestResult testName="..." outcome="Passed|Failed|NotExecuted" duration="...">
      <Output><ErrorInfo><Message>...</Message></ErrorInfo></Output>
    </UnitTestResult>
  </Results>
</TestRun>
-->
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create run.sh orchestrator and parse-results.sh TRX parser</name>
  <files>
    test/smb-conformance/run.sh
    test/smb-conformance/parse-results.sh
  </files>
  <action>
    **run.sh** — Create `test/smb-conformance/run.sh` (chmod +x), the main orchestrator:

    ```
    #!/usr/bin/env bash
    # SMB Conformance Test Runner
    # Orchestrates WPTS FileServer BVT tests against DittoFS
    ```

    **Flags:**
    - `--profile PROFILE` (env fallback: `PROFILE`, default: `memory`). Valid values: `memory`, `memory-fs`, `badger-fs`, `badger-s3`, `postgres-s3`
    - `--mode MODE` (default: `compose`). Valid values: `compose`, `local`
    - `--filter FILTER` (default: `TestCategory=BVT`). Passed to WPTS container as test filter
    - `--category CATEGORY` — alias for `--filter "TestCategory=$CATEGORY"`
    - `--keep` — leave containers running after tests for debugging
    - `--dry-run` — show configuration and exit without running
    - `--verbose` — enable verbose output
    - `--help` — usage information

    **Script structure (compose mode):**

    1. **Setup**: Set `SCRIPT_DIR`, `REPO_ROOT`, parse args, set defaults. Create timestamped results dir: `results/$(date +%Y-%m-%d_%H%M%S)/`

    2. **Render ptfconfig**: Set environment variables for template rendering:
       - `DITTOFS_HOST=localhost` (network_mode: service:dittofs means localhost works)
       - `SMB_PORT=12445`
       - `CLIENT_IP=127.0.0.1`
       - `ADMIN_USER=wpts-admin`
       - `TEST_USER=nonadmin`
       - `TEST_PASSWORD=TestPassword01!`
       Create `ptfconfig-generated/` directory, run `envsubst` on each `.template` file to produce the final `.ptfconfig` files

    3. **Dry-run check**: If `--dry-run`, print config summary (profile, mode, filter, ptfconfig values, compose services) and exit 0

    4. **Start infrastructure**: Determine which compose profiles to activate based on storage profile:
       - `*-s3` profiles: activate `s3` profile (`--profile s3`)
       - `postgres-*` profiles: activate `postgres` profile (`--profile postgres`)
       Run `docker compose build dittofs` then `docker compose up -d dittofs` (plus localstack/postgres if needed). Wait for DittoFS healthcheck via `docker compose exec dittofs wget -q --spider http://localhost:8080/health/ready` (or just rely on compose healthcheck)

    5. **Bootstrap**: Run bootstrap.sh inside the DittoFS container: `docker compose exec dittofs /app/dfsctl ...` — OR — copy bootstrap.sh into the container and execute it. The cleaner approach: since dfsctl is in the container, exec the bootstrap commands directly. Set `DFSCTL="/app/dfsctl"`, `API_URL="http://localhost:8080"`, `ADMIN_PASSWORD="${DITTOFS_CONTROLPLANE_SECRET:-TestPassword01!}"` and source/exec `bootstrap.sh` inside the container via `docker compose exec -e ... dittofs bash /path/to/bootstrap.sh`. Mount `bootstrap.sh` as a volume or copy it in.

       Simpler approach: Mount `./bootstrap.sh:/app/bootstrap.sh:ro` in the docker-compose.yml dittofs service, then `docker compose exec dittofs bash /app/bootstrap.sh`.

       **NOTE**: Update docker-compose.yml (from Plan 01) to also mount `./bootstrap.sh:/app/bootstrap.sh:ro` in the dittofs service volumes. This is a small amendment.

    6. **Run WPTS**: `docker compose run --rm wpts "${WPTS_FILTER}" ""` — this starts the WPTS container which connects to DittoFS via shared network namespace.

    7. **Collect results**: Find `.trx` file in `ptfconfig-generated/` (WPTS writes output there). Copy to results dir. Copy DittoFS logs: `docker compose logs dittofs > ${RESULTS_DIR}/dittofs.log 2>&1`

    8. **Parse results**: Call `./parse-results.sh "${RESULTS_DIR}/${TRX_FILE}" KNOWN_FAILURES.md`. Capture exit code.

    9. **Cleanup**: If not `--keep`, run `docker compose down -v` to stop all containers and remove volumes.

    10. **Exit**: Print results directory path. Exit with parse-results.sh exit code (0 = all failures are known, non-zero = new failures).

    **Local mode:** Similar flow but:
    - Build DittoFS natively: `go build -o "${SCRIPT_DIR}/dfs" ../../cmd/dfs/main.go && go build -o "${SCRIPT_DIR}/dfsctl" ../../cmd/dfsctl/main.go`
    - Start DittoFS in background: `"${SCRIPT_DIR}/dfs" start --foreground --config "configs/${PROFILE}.yaml" > "${RESULTS_DIR}/dittofs.log" 2>&1 &`
    - Wait for health, run bootstrap.sh locally
    - Run WPTS via `docker run` (not compose): `docker run --rm --network host -v "${SCRIPT_DIR}/ptfconfig-generated:/data/fileserver" mcr.microsoft.com/windowsprotocoltestsuites:fileserver-v8 "${WPTS_FILTER}" ""`
    - Set `DITTOFS_HOST` to `host.docker.internal` (macOS) or `172.17.0.1` (Linux) for local mode. Actually, with `--network host`, localhost works on Linux. On macOS, Docker Desktop maps `host.docker.internal`. Detect platform and set accordingly.

    **parse-results.sh** — Create `test/smb-conformance/parse-results.sh` (chmod +x):

    ```
    #!/usr/bin/env bash
    # Parses WPTS TRX output and produces colored summary table
    ```

    Args: `$1` = TRX file path, `$2` = KNOWN_FAILURES.md path (default: `KNOWN_FAILURES.md`)

    **Logic:**
    1. Check xmlstarlet is available: `command -v xmlstarlet || { echo "ERROR: xmlstarlet required"; exit 1; }`
    2. Define TRX namespace: `NS="http://microsoft.com/schemas/VisualStudio/TeamTest/2010"`
    3. Extract counters: total, passed, failed, error, notExecuted using xmlstarlet
    4. Print header: `"=== SMB Conformance Results ===" / "Total: N  Passed: N  Failed: N  Skipped: N"`
    5. Load known failures: Read KNOWN_FAILURES.md, extract test names from the markdown table (column 1, skip header rows). Store in an associative array.
    6. Extract per-test results: Use xmlstarlet to get testName + outcome for each UnitTestResult
    7. Print per-test results with color coding:
       - GREEN (`PASS`) for outcome=Passed
       - YELLOW (`KNOWN`) for outcome=Failed AND test name is in known failures
       - RED (`FAIL`) for outcome=Failed AND test name is NOT in known failures
       - GRAY/DIM (`SKIP`) for outcome=NotExecuted
    8. Count new (unexpected) failures
    9. Print summary: "New failures: N" (if any)
    10. Exit with count of new failures (0 = CI green, >0 = CI red)

    **TRX parsing with xmlstarlet:**
    ```bash
    xmlstarlet sel -N t="$NS" -t -m "//t:UnitTestResult" \
      -v "@testName" -o "|" -v "@outcome" -n "$TRX_FILE"
    ```

    **Handle missing TRX file**: If no `.trx` file found, print error and exit 1.
    **Handle empty results**: If total=0, print warning and exit 1.
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs-smb-suite && test -x test/smb-conformance/run.sh && test -x test/smb-conformance/parse-results.sh && grep -q '\-\-profile' test/smb-conformance/run.sh && grep -q '\-\-mode' test/smb-conformance/run.sh && grep -q '\-\-keep' test/smb-conformance/run.sh && grep -q '\-\-dry-run' test/smb-conformance/run.sh && grep -q 'xmlstarlet' test/smb-conformance/parse-results.sh && grep -q 'KNOWN_FAILURES' test/smb-conformance/parse-results.sh && echo "PASS"</automated>
  </verify>
  <done>run.sh supports compose and local modes with --profile, --filter, --keep, --dry-run flags. parse-results.sh reads TRX XML via xmlstarlet, classifies test outcomes against KNOWN_FAILURES.md, and exits non-zero only on new unexpected failures.</done>
</task>

<task type="auto">
  <name>Task 2: Create KNOWN_FAILURES.md, Makefile, README.md, and GitHub Actions workflow</name>
  <files>
    test/smb-conformance/KNOWN_FAILURES.md
    test/smb-conformance/Makefile
    test/smb-conformance/README.md
    .github/workflows/smb-conformance.yml
  </files>
  <action>
    **KNOWN_FAILURES.md** — Create `test/smb-conformance/KNOWN_FAILURES.md`:

    Machine-readable markdown table format (matching pattern from posix known_failures.txt but as markdown for readability):

    ```markdown
    # Known Failures - SMB Conformance (WPTS BVT)

    Tests listed here are expected to fail. CI will pass (exit 0) as long as
    all failures are in this list. New failures not listed here will cause CI to fail.

    The `parse-results.sh` script reads test names from the first column.

    | Test Name | Category | Reason | Issue |
    |-----------|----------|--------|-------|
    ```

    Initial entries (based on research — DittoFS is SMB 2.1, many BVT tests target SMB 3.x):
    - Encryption category tests: "SMB3 encryption not implemented (Phase 39)"
    - SMB 3.0/3.0.2/3.1.1 negotiate tests: "DittoFS supports SMB 2.1 only (Phase 39 for SMB3)"
    - Multi-channel tests: "Multi-channel not supported"
    - Durable handle v2 tests: "Durable handles not implemented (Phase 42)"
    - QUIC transport tests: "QUIC transport not supported"

    NOTE: The exact test names are not known until the first run. Add a comment at the top: "Populate this table after the first WPTS run. Use `./run.sh --dry-run` or check the TRX output for exact test names."

    **Makefile** — Create `test/smb-conformance/Makefile`:

    ```makefile
    .PHONY: test test-quick test-full build clean dry-run help

    PROFILE ?= memory

    help:  ## Show this help
    	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-20s\033[0m %s\n", $$1, $$2}'

    test: ## Run BVT tests with current profile (default: memory)
    	./run.sh --profile $(PROFILE)

    test-quick: ## Run BVT tests with memory profile (fastest)
    	./run.sh --profile memory

    test-full: ## Run BVT tests across all profiles
    	@for p in memory memory-fs badger-fs badger-s3 postgres-s3; do \
    		echo "=== Profile: $$p ==="; \
    		./run.sh --profile $$p || exit 1; \
    	done

    build: ## Build DittoFS Docker image only
    	docker compose build dittofs

    dry-run: ## Show configuration without running tests
    	./run.sh --profile $(PROFILE) --dry-run

    clean: ## Remove results and generated ptfconfig
    	rm -rf results/ ptfconfig-generated/
    	docker compose down -v 2>/dev/null || true

    local: ## Run in local mode (DittoFS native, WPTS in Docker)
    	./run.sh --profile $(PROFILE) --mode local

    keep: ## Run tests and keep containers for debugging
    	./run.sh --profile $(PROFILE) --keep
    ```

    **README.md** — Create `test/smb-conformance/README.md`:

    Sections:
    1. **Overview**: What this does (runs Microsoft WPTS FileServer BVT tests against DittoFS SMB adapter)
    2. **Prerequisites**: Docker + Docker Compose V2, xmlstarlet (`apt install xmlstarlet` / `brew install xmlstarlet`), Go 1.25+ (for local mode only)
    3. **Quick Start**: `make test` or `./run.sh --profile memory`
    4. **Profiles**: Table of 5 profiles with metadata/payload store types and required services
    5. **Running Locally**: Instructions for compose mode and local mode
    6. **Flags Reference**: Table of all run.sh flags
    7. **Understanding Results**: How to read the summary table (PASS/KNOWN/FAIL/SKIP colors)
    8. **Known Failures**: How KNOWN_FAILURES.md works, how to add new entries
    9. **Iterating on Failures**: Dev workflow for fixing a failing test (keep containers, check DittoFS logs, inspect ptfconfig)
    10. **CI Integration**: How the GitHub Actions workflow works, tiered matrix, weekly cron
    11. **Architecture**: Directory structure diagram
    12. **Extending for SMB3**: Note that Phase 44 will extend this infrastructure with SMB3-specific test categories

    **GitHub Actions workflow** — Create `.github/workflows/smb-conformance.yml`:

    ```yaml
    name: SMB Conformance Tests

    on:
      push:
        branches: [develop]
        paths:
          - 'pkg/adapter/smb/**'
          - 'internal/adapter/smb/**'
          - 'test/smb-conformance/**'
          - 'pkg/adapter/base.go'
          - '.github/workflows/smb-conformance.yml'
      pull_request:
        branches: [develop, main]
        paths:
          - 'pkg/adapter/smb/**'
          - 'internal/adapter/smb/**'
          - 'test/smb-conformance/**'
          - 'pkg/adapter/base.go'
          - '.github/workflows/smb-conformance.yml'
      schedule:
        - cron: '0 3 * * 1'  # Weekly Monday 3 AM UTC
      workflow_dispatch:
        inputs:
          profile:
            description: 'Storage profile to test'
            required: false
            default: 'memory'
            type: choice
            options: [memory, memory-fs, badger-fs, badger-s3, postgres-s3]

    concurrency:
      group: smb-conformance-${{ github.ref }}
      cancel-in-progress: true
    ```

    **Jobs:**

    1. `smb-conformance`:
       - `runs-on: ubuntu-latest`
       - `timeout-minutes: 30`
       - Strategy matrix:
         - For `pull_request`: only `memory` profile
         - For `push` to develop and `schedule`: all 5 profiles
         - Use `include/exclude` or conditional matrix to achieve tiered profiles
       - Steps:
         1. Checkout
         2. Install xmlstarlet: `sudo apt-get update && sudo apt-get install -y xmlstarlet`
         3. Set up Docker Buildx (for layer caching)
         4. Docker layer cache: use `actions/cache@v4` with `path: /tmp/.buildx-cache` and `key: docker-smb-${{ hashFiles('**/go.sum', 'Dockerfile') }}`
         5. Run tests: `cd test/smb-conformance && ./run.sh --profile ${{ matrix.profile }}`
         6. Upload results: `actions/upload-artifact@v4` with `path: test/smb-conformance/results/` (retention 30 days)
         7. Add summary to `$GITHUB_STEP_SUMMARY`
         8. On failure for `schedule` event: create GitHub issue via `gh issue create --title "SMB Conformance Regression" --body "..."` (only if new failures detected)
         9. On failure for `pull_request`: comment on PR with failure summary via `peter-evans/create-or-update-comment@v4` (or simpler: just rely on the step summary)

    **Tiered matrix approach:**
    Use two separate jobs or a conditional matrix:
    ```yaml
    strategy:
      fail-fast: false
      matrix:
        profile: ${{ github.event_name == 'pull_request' && fromJson('["memory"]') || fromJson('["memory", "memory-fs", "badger-fs", "badger-s3", "postgres-s3"]') }}
    ```

    Also update the ROADMAP.md Phase 44 entry to add a note: "Extends Phase 29.8 WPTS infrastructure with SMB3-specific test categories and filter configurations."
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs-smb-suite && test -f test/smb-conformance/KNOWN_FAILURES.md && test -f test/smb-conformance/Makefile && test -f test/smb-conformance/README.md && test -f .github/workflows/smb-conformance.yml && grep -q 'TestCategory=BVT' test/smb-conformance/KNOWN_FAILURES.md || grep -q 'Encryption' test/smb-conformance/KNOWN_FAILURES.md && grep -q 'smb-conformance' .github/workflows/smb-conformance.yml && grep -q 'pkg/adapter/smb' .github/workflows/smb-conformance.yml && grep -q 'schedule' .github/workflows/smb-conformance.yml && echo "PASS"</automated>
  </verify>
  <done>KNOWN_FAILURES.md has initial expected failure entries. Makefile provides convenience targets (test, test-quick, test-full, build, clean, dry-run, local, keep). README.md documents setup, profiles, flags, results interpretation, and CI integration. GitHub Actions workflow triggers on SMB-related paths, runs memory profile on PRs, full matrix on develop push, and weekly cron with regression detection.</done>
</task>

</tasks>

<verification>
1. `run.sh --dry-run --profile memory` exits 0 and prints configuration summary without starting containers
2. `parse-results.sh` can handle a sample TRX file (create minimal test TRX with xmlstarlet)
3. GitHub Actions workflow YAML is valid (no syntax errors)
4. Makefile targets listed with `make help`
5. KNOWN_FAILURES.md is parseable by parse-results.sh (grep test names from table)
6. README.md covers prerequisites, quick start, profiles, flags, results, CI
</verification>

<success_criteria>
- Complete test orchestration: run.sh handles both compose and local modes with all flags
- Intelligent failure classification: parse-results.sh distinguishes new failures from known ones
- CI integration: workflow runs on PRs (fast), develop (full), weekly (regression detection)
- Documentation: README explains everything needed for local and CI usage
- Known failures tracking: KNOWN_FAILURES.md ready for population after first run
</success_criteria>

<output>
After completion, create `.planning/phases/29.8-ms-protocol-test-suite-ci/29.8-02-SUMMARY.md`
</output>
