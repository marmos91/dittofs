---
phase: 05-status-lifecycle
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - k8s/dittofs-operator/api/v1alpha1/dittoserver_types.go
  - k8s/dittofs-operator/internal/controller/dittoserver_controller.go
  - k8s/dittofs-operator/internal/controller/dittoserver_controller_test.go
autonomous: true

must_haves:
  truths:
    - "kubectl get dittofs shows READY column with replica counts (e.g., 1/1)"
    - "kubectl get dittofs -o yaml shows conditions: Ready, Available, ConfigReady, DatabaseReady (when Percona enabled)"
    - "Status includes observedGeneration, replicas, readyReplicas, availableReplicas"
    - "Status includes configHash for debugging pod restarts"
    - "Status includes perconaClusterName when Percona is enabled"
  artifacts:
    - path: "k8s/dittofs-operator/api/v1alpha1/dittoserver_types.go"
      provides: "Enhanced DittoServerStatus struct with all status fields"
      contains: "ObservedGeneration"
    - path: "k8s/dittofs-operator/internal/controller/dittoserver_controller.go"
      provides: "Status condition updates during reconciliation"
      contains: "ConditionConfigReady"
  key_links:
    - from: "k8s/dittofs-operator/internal/controller/dittoserver_controller.go"
      to: "k8s/dittofs-operator/api/v1alpha1/dittoserver_types.go"
      via: "Status field assignments"
      pattern: "dittoServerCopy\\.Status\\."
---

<objective>
Implement comprehensive status conditions and enhanced status fields for DittoServer CRD.

Purpose: Enable operators and users to monitor DittoServer health through kubectl and automation tools. Status conditions provide machine-readable health signals; enhanced status fields provide debugging context.

Output: Updated CRD types with full status struct, controller logic to compute and update all conditions, kubectl print columns showing READY (1/1 format), STATUS, AGE.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-status-lifecycle/05-CONTEXT.md
@.planning/phases/05-status-conditions-and-lifecycle/05-RESEARCH.md
@k8s/dittofs-operator/api/v1alpha1/dittoserver_types.go
@k8s/dittofs-operator/internal/controller/dittoserver_controller.go
@k8s/dittofs-operator/utils/conditions/conditions.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance DittoServerStatus struct and condition constants</name>
  <files>k8s/dittofs-operator/api/v1alpha1/dittoserver_types.go</files>
  <action>
Update DittoServerStatus struct with all fields from RESEARCH.md:

```go
// Condition type constants
const (
    ConditionReady         = "Ready"
    ConditionAvailable     = "Available"
    ConditionConfigReady   = "ConfigReady"
    ConditionDatabaseReady = "DatabaseReady"
    ConditionProgressing   = "Progressing"
)

// DittoServerStatus defines the observed state of DittoServer
type DittoServerStatus struct {
    // ObservedGeneration is the generation last processed by the controller
    ObservedGeneration int64 `json:"observedGeneration,omitempty"`

    // Replicas is the desired number of replicas
    Replicas int32 `json:"replicas,omitempty"`

    // ReadyReplicas is the number of pods with Ready condition
    ReadyReplicas int32 `json:"readyReplicas,omitempty"`

    // AvailableReplicas is the number of pods ready for at least minReadySeconds
    AvailableReplicas int32 `json:"availableReplicas,omitempty"`

    // NFSEndpoint that clients should use to mount
    NFSEndpoint string `json:"nfsEndpoint,omitempty"`

    // Phase of the DittoServer (Pending, Running, Failed, Stopped, Deleting)
    // +kubebuilder:validation:Enum=Pending;Running;Failed;Stopped;Deleting
    Phase string `json:"phase,omitempty"`

    // ConfigHash is the hash of current configuration (for debugging)
    ConfigHash string `json:"configHash,omitempty"`

    // PerconaClusterName is the name of the owned PerconaPGCluster (when enabled)
    // +optional
    PerconaClusterName string `json:"perconaClusterName,omitempty"`

    // Conditions represent the latest available observations
    // +listType=map
    // +listMapKey=type
    // +optional
    Conditions []metav1.Condition `json:"conditions,omitempty"`
}
```

Update kubebuilder print columns for kubectl output showing READY as "x/y" format:

```go
// +kubebuilder:printcolumn:name="READY",type=string,JSONPath=`.status.readyReplicas`,description="Ready replicas"
// +kubebuilder:printcolumn:name="DESIRED",type=integer,JSONPath=`.status.replicas`,description="Desired replicas"
// +kubebuilder:printcolumn:name="STATUS",type=string,JSONPath=`.status.phase`
// +kubebuilder:printcolumn:name="AGE",type=date,JSONPath=`.metadata.creationTimestamp`
```

Note: The READY column shows just the count since JSONPath can't concatenate. Users can see desired from DESIRED column.

Run `make generate manifests` after changes.
  </action>
  <verify>
```bash
cd /Users/marmos91/Projects/dittofs/k8s/dittofs-operator && make generate manifests && go build ./...
```
Verify CRD in config/crd/bases/ has updated status fields and print columns.
  </verify>
  <done>
DittoServerStatus struct has all fields: ObservedGeneration, Replicas, ReadyReplicas, AvailableReplicas, ConfigHash, PerconaClusterName. Condition constants defined. Print columns show READY, DESIRED, STATUS, AGE.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement status condition updates in reconciler</name>
  <files>k8s/dittofs-operator/internal/controller/dittoserver_controller.go</files>
  <action>
Refactor the Reconcile function to update all status conditions:

1. At start of reconciliation, set Progressing=True with reason "Reconciling"

2. After ConfigMap reconciliation succeeds, set ConfigReady=True; on error set ConfigReady=False with error message

3. When Percona is enabled:
   - If PerconaPGCluster not found or not ready: DatabaseReady=False with "WaitingForPercona" reason
   - If PerconaPGCluster ready: DatabaseReady=True with "PerconaReady" reason
   - Skip DatabaseReady condition entirely when Percona not enabled

4. After StatefulSet reconciliation:
   - Set Available=True if readyReplicas >= 1 (or if replicas=0 with "Stopped" reason)
   - Set Available=False if readyReplicas < spec.replicas

5. Compute overall Ready condition:
   - Ready=True only if: ConfigReady=True AND (DatabaseReady=True OR Percona disabled) AND Available=True
   - Ready=False otherwise with appropriate reason

6. At end of reconciliation, set Progressing=False with reason "ReconcileComplete"

7. Update status fields:
   - ObservedGeneration = dittoServer.Generation
   - Replicas = spec.replicas (or default 1)
   - ReadyReplicas = statefulSet.Status.ReadyReplicas
   - AvailableReplicas = statefulSet.Status.AvailableReplicas
   - ConfigHash = computed hash
   - PerconaClusterName = percona.ClusterName(dittoServer.Name) when Percona enabled

Use the existing `utils/conditions.SetCondition` helper which already handles observedGeneration correctly.

Extract condition logic to helper functions for cleanliness:
- `updateConfigReadyCondition()`
- `updateDatabaseReadyCondition()`
- `updateAvailableCondition()`
- `updateReadyCondition()` (computes from other conditions)
- `updateProgressingCondition()`
  </action>
  <verify>
```bash
cd /Users/marmos91/Projects/dittofs/k8s/dittofs-operator && go build ./... && go test ./internal/controller/... -v -run TestDittoServer
```
  </verify>
  <done>
Reconciler updates all five conditions (Ready, Available, ConfigReady, DatabaseReady, Progressing) with correct status, reason, and message. Status fields populated with observedGeneration, replicas, configHash, perconaClusterName.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for status conditions</name>
  <files>k8s/dittofs-operator/internal/controller/dittoserver_controller_test.go</files>
  <action>
Add/update tests to verify status condition behavior:

1. Test ConfigReady condition:
   - Verify ConfigReady=True after successful ConfigMap creation

2. Test Available condition:
   - Create DittoServer, mock StatefulSet with ReadyReplicas=1 -> Available=True
   - Create DittoServer with replicas=0 -> Available=True with reason "Stopped"

3. Test DatabaseReady condition (Percona scenarios):
   - With Percona disabled: DatabaseReady condition should NOT be set
   - With Percona enabled, cluster not ready: DatabaseReady=False
   - With Percona enabled, cluster ready: DatabaseReady=True

4. Test Ready aggregation:
   - All conditions met -> Ready=True
   - ConfigReady=False -> Ready=False
   - DatabaseReady=False (Percona enabled) -> Ready=False
   - Available=False -> Ready=False

5. Test status fields:
   - Verify ObservedGeneration matches resource Generation
   - Verify ConfigHash is populated
   - Verify PerconaClusterName is set when Percona enabled

Use envtest framework already in place for controller tests.
  </action>
  <verify>
```bash
cd /Users/marmos91/Projects/dittofs/k8s/dittofs-operator && go test ./internal/controller/... -v -count=1
```
All tests pass including new condition tests.
  </verify>
  <done>
Test coverage for all five conditions, status field population, and condition aggregation logic. Tests verify conditions reflect actual resource states.
  </done>
</task>

</tasks>

<verification>
```bash
# Full build and test
cd /Users/marmos91/Projects/dittofs/k8s/dittofs-operator
make generate manifests
go build ./...
go test ./... -v

# Verify CRD has updated status schema
grep -A 20 "status:" config/crd/bases/dittofs.dittofs.com_dittoservers.yaml | head -30

# Verify print columns
grep "printcolumn" config/crd/bases/dittofs.dittofs.com_dittoservers.yaml
```
</verification>

<success_criteria>
1. CRD status schema includes all new fields (observedGeneration, replicas, readyReplicas, availableReplicas, configHash, perconaClusterName)
2. Five conditions (Ready, Available, ConfigReady, DatabaseReady, Progressing) updated during reconciliation
3. Ready condition aggregates other conditions correctly
4. DatabaseReady only present when Percona enabled
5. kubectl print columns show READY, DESIRED, STATUS, AGE
6. All existing and new tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-status-lifecycle/05-01-SUMMARY.md`
</output>
