---
phase: 05-status-lifecycle
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - k8s/dittofs-operator/api/v1alpha1/dittoserver_types.go
  - k8s/dittofs-operator/internal/controller/dittoserver_controller.go
  - k8s/dittofs-operator/internal/controller/dittoserver_controller_test.go
autonomous: true

must_haves:
  truths:
    - "Deleting DittoServer CR triggers finalizer cleanup before resource deletion"
    - "With spec.percona.deleteWithServer=true, PerconaPGCluster is deleted on DittoServer deletion"
    - "With spec.percona.deleteWithServer=false (default), PerconaPGCluster is orphaned on deletion"
    - "Finalizer is automatically added to new DittoServer resources"
    - "DittoServer cannot be stuck in Terminating state indefinitely (timeout)"
  artifacts:
    - path: "k8s/dittofs-operator/api/v1alpha1/dittoserver_types.go"
      provides: "PerconaConfig.DeleteWithServer field"
      contains: "DeleteWithServer"
    - path: "k8s/dittofs-operator/internal/controller/dittoserver_controller.go"
      provides: "Finalizer implementation with cleanup logic"
      contains: "finalizerName"
  key_links:
    - from: "k8s/dittofs-operator/internal/controller/dittoserver_controller.go"
      to: "controllerutil"
      via: "Finalizer helpers"
      pattern: "controllerutil\\.ContainsFinalizer|AddFinalizer|RemoveFinalizer"
---

<objective>
Implement finalizers for DittoServer resource cleanup on deletion.

Purpose: Ensure clean resource deletion with proper cleanup coordination. When a DittoServer is deleted, the finalizer allows the operator to perform pre-deletion tasks (optionally deleting Percona cluster, updating Phase to Deleting, waiting for pods to terminate gracefully).

Output: Finalizer implementation using controller-runtime controllerutil helpers, deleteWithServer field for Percona, cleanup logic with timeout.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-status-lifecycle/05-CONTEXT.md
@.planning/phases/05-status-conditions-and-lifecycle/05-RESEARCH.md
@k8s/dittofs-operator/api/v1alpha1/dittoserver_types.go
@k8s/dittofs-operator/internal/controller/dittoserver_controller.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DeleteWithServer field to PerconaConfig</name>
  <files>k8s/dittofs-operator/api/v1alpha1/dittoserver_types.go</files>
  <action>
Add DeleteWithServer field to PerconaConfig struct per CONTEXT.md decision:

```go
// PerconaConfig configures auto-creation of PerconaPGCluster for PostgreSQL metadata store
type PerconaConfig struct {
    // Enabled triggers auto-creation of PerconaPGCluster
    // +kubebuilder:default=false
    Enabled bool `json:"enabled,omitempty"`

    // DeleteWithServer controls whether PerconaPGCluster is deleted when DittoServer is deleted
    // If false (default), the database is orphaned for data protection
    // If true, the database is deleted along with DittoServer
    // +kubebuilder:default=false
    // +optional
    DeleteWithServer bool `json:"deleteWithServer,omitempty"`

    // ... existing fields ...
}
```

Run `make generate manifests` after changes.
  </action>
  <verify>
```bash
cd /Users/marmos91/Projects/dittofs/k8s/dittofs-operator && make generate manifests && go build ./...
```
Verify CRD has deleteWithServer field in spec.percona.
  </verify>
  <done>
PerconaConfig has DeleteWithServer field with default=false. CRD updated with new field.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement finalizer logic in reconciler</name>
  <files>k8s/dittofs-operator/internal/controller/dittoserver_controller.go</files>
  <action>
Implement finalizer pattern from RESEARCH.md:

1. Add constant for finalizer name:
```go
const finalizerName = "dittofs.dittofs.com/finalizer"
```

2. At the start of Reconcile, after fetching DittoServer:
```go
// Handle deletion
if !dittoServer.ObjectMeta.DeletionTimestamp.IsZero() {
    return r.handleDeletion(ctx, dittoServer)
}

// Add finalizer if not present
if !controllerutil.ContainsFinalizer(dittoServer, finalizerName) {
    logger.Info("Adding finalizer")
    controllerutil.AddFinalizer(dittoServer, finalizerName)
    if err := r.Update(ctx, dittoServer); err != nil {
        return ctrl.Result{}, err
    }
    // Re-fetch after update to avoid stale data
    return ctrl.Result{Requeue: true}, nil
}
```

3. Implement handleDeletion method:
```go
func (r *DittoServerReconciler) handleDeletion(ctx context.Context, ds *dittoiov1alpha1.DittoServer) (ctrl.Result, error) {
    logger := logf.FromContext(ctx)

    if !controllerutil.ContainsFinalizer(ds, finalizerName) {
        return ctrl.Result{}, nil
    }

    logger.Info("Processing deletion")

    // Update phase to Deleting (best effort, don't fail on this)
    dsCopy := ds.DeepCopy()
    dsCopy.Status.Phase = "Deleting"
    _ = r.Status().Update(ctx, dsCopy)

    // Perform cleanup with timeout
    ctx, cancel := context.WithTimeout(ctx, 60*time.Second)
    defer cancel()

    if err := r.performCleanup(ctx, ds); err != nil {
        if ctx.Err() == context.DeadlineExceeded {
            logger.Error(err, "Cleanup timeout exceeded, forcing finalizer removal")
            // Don't return error - allow deletion to proceed
        } else {
            return ctrl.Result{RequeueAfter: 10 * time.Second}, err
        }
    }

    // Remove finalizer
    logger.Info("Removing finalizer")
    controllerutil.RemoveFinalizer(ds, finalizerName)
    if err := r.Update(ctx, ds); err != nil {
        return ctrl.Result{}, err
    }

    return ctrl.Result{}, nil
}
```

4. Implement performCleanup method:
```go
func (r *DittoServerReconciler) performCleanup(ctx context.Context, ds *dittoiov1alpha1.DittoServer) error {
    logger := logf.FromContext(ctx)

    // Handle Percona cleanup if enabled and deleteWithServer is true
    if ds.Spec.Percona != nil && ds.Spec.Percona.Enabled && ds.Spec.Percona.DeleteWithServer {
        clusterName := percona.ClusterName(ds.Name)
        pgCluster := &pgv2.PerconaPGCluster{}
        err := r.Get(ctx, client.ObjectKey{
            Namespace: ds.Namespace,
            Name:      clusterName,
        }, pgCluster)

        if err == nil {
            // Remove owner reference to allow orphaning if needed
            // Actually, since we set deleteWithServer=true, we want cascade delete
            // Owner reference already triggers cascade, just log
            logger.Info("PerconaPGCluster will be deleted via owner reference", "name", clusterName)
        } else if !apierrors.IsNotFound(err) {
            return fmt.Errorf("failed to check PerconaPGCluster: %w", err)
        }
    } else if ds.Spec.Percona != nil && ds.Spec.Percona.Enabled && !ds.Spec.Percona.DeleteWithServer {
        // Orphan the database - remove owner reference
        clusterName := percona.ClusterName(ds.Name)
        pgCluster := &pgv2.PerconaPGCluster{}
        err := r.Get(ctx, client.ObjectKey{
            Namespace: ds.Namespace,
            Name:      clusterName,
        }, pgCluster)

        if err == nil && len(pgCluster.OwnerReferences) > 0 {
            logger.Info("Orphaning PerconaPGCluster (deleteWithServer=false)", "name", clusterName)
            pgCluster.OwnerReferences = nil
            if err := r.Update(ctx, pgCluster); err != nil {
                return fmt.Errorf("failed to orphan PerconaPGCluster: %w", err)
            }
        }
    }

    // Wait briefly for StatefulSet pods to start terminating
    // The StatefulSet will be deleted via owner reference, but we give pods
    // a chance to start graceful shutdown
    time.Sleep(5 * time.Second)

    return nil
}
```

Note: The owner reference on StatefulSet, Services, ConfigMap already ensures cascade deletion. The finalizer's main job is:
1. Optionally orphan or delete Percona cluster based on deleteWithServer flag
2. Update Phase to "Deleting" for visibility
3. Allow brief graceful shutdown window
  </action>
  <verify>
```bash
cd /Users/marmos91/Projects/dittofs/k8s/dittofs-operator && go build ./...
```
  </verify>
  <done>
Finalizer implementation complete: finalizerName constant, handleDeletion method, performCleanup method with Percona orphaning/deletion logic, 60-second timeout.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add finalizer tests</name>
  <files>k8s/dittofs-operator/internal/controller/dittoserver_controller_test.go</files>
  <action>
Add tests for finalizer behavior:

1. Test finalizer is added on create:
```go
func TestFinalizerAddedOnCreate(t *testing.T) {
    // Create DittoServer without finalizer
    // Reconcile
    // Verify finalizer is present
}
```

2. Test deletion with deleteWithServer=false (default):
```go
func TestDeletionOrphansPercona(t *testing.T) {
    // Create DittoServer with Percona enabled, deleteWithServer=false
    // Create mock PerconaPGCluster with owner reference
    // Set DeletionTimestamp on DittoServer
    // Reconcile
    // Verify PerconaPGCluster owner reference removed (orphaned)
    // Verify finalizer removed
}
```

3. Test deletion with deleteWithServer=true:
```go
func TestDeletionDeletesPercona(t *testing.T) {
    // Create DittoServer with Percona enabled, deleteWithServer=true
    // Create mock PerconaPGCluster with owner reference
    // Set DeletionTimestamp on DittoServer
    // Reconcile
    // Verify PerconaPGCluster owner reference NOT removed (cascade delete)
    // Verify finalizer removed
}
```

4. Test deletion without Percona:
```go
func TestDeletionWithoutPercona(t *testing.T) {
    // Create DittoServer without Percona
    // Set DeletionTimestamp
    // Reconcile
    // Verify finalizer removed quickly
}
```

5. Test Phase is set to Deleting:
```go
func TestDeletingPhase(t *testing.T) {
    // Create DittoServer
    // Set DeletionTimestamp
    // Reconcile
    // Verify Status.Phase = "Deleting"
}
```
  </action>
  <verify>
```bash
cd /Users/marmos91/Projects/dittofs/k8s/dittofs-operator && go test ./internal/controller/... -v -count=1
```
All finalizer tests pass.
  </verify>
  <done>
Test coverage for finalizer addition, deletion with orphaning, deletion with cascade, Phase update to Deleting.
  </done>
</task>

</tasks>

<verification>
```bash
# Full build and test
cd /Users/marmos91/Projects/dittofs/k8s/dittofs-operator
make generate manifests
go build ./...
go test ./... -v

# Verify CRD has deleteWithServer field
grep -A 5 "deleteWithServer" config/crd/bases/dittofs.dittofs.com_dittoservers.yaml
```
</verification>

<success_criteria>
1. PerconaConfig has DeleteWithServer field with default=false
2. Finalizer automatically added to new DittoServer resources
3. Deletion triggers handleDeletion -> performCleanup -> finalizer removal
4. With deleteWithServer=false, PerconaPGCluster owner reference removed (orphaned)
5. With deleteWithServer=true, PerconaPGCluster deleted via cascade
6. Phase set to "Deleting" during deletion
7. 60-second timeout prevents stuck Terminating state
8. All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-status-lifecycle/05-02-SUMMARY.md`
</output>
