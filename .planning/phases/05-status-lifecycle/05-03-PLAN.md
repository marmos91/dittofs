---
phase: 05-status-lifecycle
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - k8s/dittofs-operator/internal/controller/dittoserver_controller.go
  - k8s/dittofs-operator/cmd/main.go
  - k8s/dittofs-operator/internal/controller/dittoserver_controller_test.go
autonomous: true

must_haves:
  truths:
    - "kubectl describe dittofs <name> shows events for state changes"
    - "DittoFS pod has HTTP-based liveness probe against /health endpoint"
    - "DittoFS pod has HTTP-based readiness probe against /health/ready endpoint"
    - "DittoFS pod has startup probe to handle slow database migrations"
    - "DittoFS pod has preStop hook for graceful connection draining"
  artifacts:
    - path: "k8s/dittofs-operator/internal/controller/dittoserver_controller.go"
      provides: "EventRecorder usage, HTTP probes, preStop hook"
      contains: "r.Recorder.Event"
    - path: "k8s/dittofs-operator/cmd/main.go"
      provides: "EventRecorder initialization"
      contains: "GetEventRecorderFor"
  key_links:
    - from: "k8s/dittofs-operator/cmd/main.go"
      to: "k8s/dittofs-operator/internal/controller/dittoserver_controller.go"
      via: "Recorder field injection"
      pattern: "Recorder.*GetEventRecorderFor"
---

<objective>
Implement Kubernetes events for debugging, HTTP-based health probes, and graceful shutdown handling.

Purpose: Provide operational visibility through events (visible via kubectl describe), accurate health checks via DittoFS's built-in health endpoints, and clean shutdown behavior via preStop hooks.

Output: EventRecorder wired into controller, events emitted for major state changes, HTTP probes replacing TCP probes, startup probe for slow startup, preStop lifecycle hook.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-status-lifecycle/05-CONTEXT.md
@.planning/phases/05-status-conditions-and-lifecycle/05-RESEARCH.md
@k8s/dittofs-operator/internal/controller/dittoserver_controller.go
@k8s/dittofs-operator/cmd/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire EventRecorder into controller</name>
  <files>k8s/dittofs-operator/internal/controller/dittoserver_controller.go, k8s/dittofs-operator/cmd/main.go</files>
  <action>
1. Update DittoServerReconciler struct to include EventRecorder:
```go
import "k8s.io/client-go/tools/record"

type DittoServerReconciler struct {
    client.Client
    Scheme   *runtime.Scheme
    Recorder record.EventRecorder
}
```

2. Update main.go to inject EventRecorder:
```go
if err := (&controller.DittoServerReconciler{
    Client:   mgr.GetClient(),
    Scheme:   mgr.GetScheme(),
    Recorder: mgr.GetEventRecorderFor("dittoserver-controller"),
}).SetupWithManager(mgr); err != nil {
    setupLog.Error(err, "unable to create controller", "controller", "DittoServer")
    os.Exit(1)
}
```

3. Add events throughout reconciliation (moderate verbosity per CONTEXT.md):

In reconcileConfigMap on success:
```go
r.Recorder.Eventf(dittoServer, corev1.EventTypeNormal, "ConfigUpdated",
    "ConfigMap %s-config reconciled", dittoServer.Name)
```

In reconcilePerconaPGCluster when creating:
```go
r.Recorder.Eventf(dittoServer, corev1.EventTypeNormal, "PerconaCreated",
    "Created PerconaPGCluster %s", clusterName)
```

When Percona becomes ready (transition):
```go
r.Recorder.Eventf(dittoServer, corev1.EventTypeNormal, "DatabaseReady",
    "PostgreSQL cluster %s is ready", clusterName)
```

When waiting for Percona:
```go
r.Recorder.Eventf(dittoServer, corev1.EventTypeWarning, "DatabaseNotReady",
    "Waiting for PostgreSQL cluster %s to become ready", clusterName)
```

In handleDeletion:
```go
r.Recorder.Event(dittoServer, corev1.EventTypeNormal, "Deleting",
    "DittoServer is being deleted, cleaning up resources")
```

On errors (major ones only):
```go
r.Recorder.Eventf(dittoServer, corev1.EventTypeWarning, "ReconcileError",
    "Failed to reconcile: %v", err)
```

When StatefulSet becomes ready:
```go
r.Recorder.Eventf(dittoServer, corev1.EventTypeNormal, "Ready",
    "DittoServer is ready with %d replica(s)", replicas)
```

Note: Events API RBAC marker already exists in controller (events verbs=create;patch).
  </action>
  <verify>
```bash
cd /Users/marmos91/Projects/dittofs/k8s/dittofs-operator && go build ./...
```
  </verify>
  <done>
EventRecorder injected via main.go, used throughout reconciler for major state changes (ConfigUpdated, PerconaCreated, DatabaseReady, DatabaseNotReady, Deleting, Ready, ReconcileError).
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace TCP probes with HTTP probes and add lifecycle hooks</name>
  <files>k8s/dittofs-operator/internal/controller/dittoserver_controller.go</files>
  <action>
Update reconcileStatefulSet to use HTTP probes from RESEARCH.md:

Replace current TCP probes with:

```go
LivenessProbe: &corev1.Probe{
    ProbeHandler: corev1.ProbeHandler{
        HTTPGet: &corev1.HTTPGetAction{
            Path: "/health",
            Port: intstr.FromInt32(getAPIPort(dittoServer)),
        },
    },
    InitialDelaySeconds: 15,
    PeriodSeconds:       10,
    TimeoutSeconds:      5,
    FailureThreshold:    3,
},
ReadinessProbe: &corev1.Probe{
    ProbeHandler: corev1.ProbeHandler{
        HTTPGet: &corev1.HTTPGetAction{
            Path: "/health/ready",
            Port: intstr.FromInt32(getAPIPort(dittoServer)),
        },
    },
    InitialDelaySeconds: 10,
    PeriodSeconds:       5,
    TimeoutSeconds:      5,
    FailureThreshold:    3,
},
StartupProbe: &corev1.Probe{
    ProbeHandler: corev1.ProbeHandler{
        HTTPGet: &corev1.HTTPGetAction{
            Path: "/health",
            Port: intstr.FromInt32(getAPIPort(dittoServer)),
        },
    },
    InitialDelaySeconds: 0,
    PeriodSeconds:       5,
    TimeoutSeconds:      5,
    FailureThreshold:    30, // 30 * 5s = 150s max startup time
},
```

Add Lifecycle with preStop hook:
```go
Lifecycle: &corev1.Lifecycle{
    PreStop: &corev1.LifecycleHandler{
        Exec: &corev1.ExecAction{
            Command: []string{"/bin/sh", "-c", "sleep 5"},
        },
    },
},
```

The preStop hook gives DittoFS 5 seconds before SIGTERM to drain connections. DittoFS then handles SIGTERM for additional graceful shutdown (per CONTEXT.md).

Health endpoints:
- `/health` - Liveness (returns 200 if server running)
- `/health/ready` - Readiness (checks registry, shares, adapters)

Both are on the API port (default 8080).
  </action>
  <verify>
```bash
cd /Users/marmos91/Projects/dittofs/k8s/dittofs-operator && go build ./...
```
  </verify>
  <done>
HTTP probes configured: liveness at /health, readiness at /health/ready, startup probe with 150s max. PreStop hook with 5s sleep for connection draining before SIGTERM.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests and verify integration</name>
  <files>k8s/dittofs-operator/internal/controller/dittoserver_controller_test.go</files>
  <action>
Add tests to verify:

1. Test HTTP probes are configured correctly:
```go
func TestHTTPProbesConfigured(t *testing.T) {
    // Create DittoServer
    // Reconcile
    // Get StatefulSet
    // Verify container has HTTPGet liveness probe on /health
    // Verify container has HTTPGet readiness probe on /health/ready
    // Verify container has HTTPGet startup probe on /health
}
```

2. Test preStop hook is configured:
```go
func TestPreStopHookConfigured(t *testing.T) {
    // Create DittoServer
    // Reconcile
    // Get StatefulSet
    // Verify container has Lifecycle.PreStop with sleep 5
}
```

3. Test probes use correct port:
```go
func TestProbesUseAPIPort(t *testing.T) {
    // Create DittoServer with custom controlPlane.port = 9090
    // Reconcile
    // Get StatefulSet
    // Verify all probes use port 9090
}
```

4. Update any existing tests that check for TCP probes to expect HTTP probes.

Note: EventRecorder usage is difficult to unit test directly. The RBAC and wiring can be verified via build success and manual testing on a cluster.
  </action>
  <verify>
```bash
cd /Users/marmos91/Projects/dittofs/k8s/dittofs-operator && go test ./internal/controller/... -v -count=1
```
All tests pass including new probe tests.
  </verify>
  <done>
Tests verify HTTP probes on correct paths and ports, preStop hook configuration. Existing tests updated for HTTP probe expectations.
  </done>
</task>

</tasks>

<verification>
```bash
# Full build and test
cd /Users/marmos91/Projects/dittofs/k8s/dittofs-operator
make generate manifests
go build ./...
go test ./... -v

# Verify EventRecorder import
grep -n "record.EventRecorder" internal/controller/dittoserver_controller.go

# Verify HTTP probes
grep -A 5 "HTTPGet" internal/controller/dittoserver_controller.go | head -20

# Verify preStop hook
grep -A 3 "PreStop" internal/controller/dittoserver_controller.go
```
</verification>

<success_criteria>
1. EventRecorder injected into controller via main.go
2. Events emitted for: ConfigUpdated, PerconaCreated, DatabaseReady/NotReady, Deleting, Ready, ReconcileError
3. HTTP liveness probe at /health on API port
4. HTTP readiness probe at /health/ready on API port
5. Startup probe with 150s max startup time (30 * 5s)
6. PreStop hook with 5s sleep before SIGTERM
7. All tests pass
8. Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/05-status-lifecycle/05-03-SUMMARY.md`
</output>
