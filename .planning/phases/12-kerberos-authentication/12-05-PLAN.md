---
phase: 12-kerberos-authentication
plan: 05
type: execute
wave: 5
depends_on: ["12-04"]
files_modified:
  - pkg/auth/kerberos/keytab.go
  - pkg/auth/kerberos/keytab_test.go
  - pkg/auth/kerberos/kerberos.go
  - internal/protocol/nfs/rpc/gss/framework.go
  - internal/protocol/nfs/rpc/gss/framework_test.go
  - internal/protocol/nfs/rpc/gss/metrics.go
autonomous: true

must_haves:
  truths:
    - "Keytab file loads from path or DITTOFS_KERBEROS_KEYTAB env var"
    - "Service principal configurable via config or DITTOFS_KERBEROS_PRINCIPAL env var"
    - "Keytab hot-reload works without disrupting active GSS contexts"
    - "GSS metrics track context creation, destruction, and auth failures"
    - "Full RPCSEC_GSS lifecycle tested: INIT -> DATA -> DESTROY"
  artifacts:
    - path: "pkg/auth/kerberos/keytab.go"
      provides: "Keytab file management with hot-reload"
      contains: "func.*ReloadKeytab"
    - path: "internal/protocol/nfs/rpc/gss/metrics.go"
      provides: "Prometheus metrics for RPCSEC_GSS operations"
      contains: "type GSSMetrics struct"
  key_links:
    - from: "pkg/auth/kerberos/keytab.go"
      to: "pkg/auth/kerberos/kerberos.go"
      via: "ReloadKeytab atomically swaps keytab in Provider"
      pattern: "provider\\.mu\\.Lock"
    - from: "internal/protocol/nfs/rpc/gss/metrics.go"
      to: "internal/protocol/nfs/rpc/gss/framework.go"
      via: "GSSProcessor records metrics on INIT/DATA/DESTROY"
      pattern: "metrics\\.Record"
---

<objective>
Complete keytab management with hot-reload, add Prometheus metrics, and create integration tests for the full RPCSEC_GSS lifecycle.

Purpose: This final plan ensures production-readiness: keytab files can be rotated without server restart (critical for security operations), metrics provide observability into Kerberos auth operations, and integration tests verify the complete INIT -> DATA -> DESTROY lifecycle works correctly.

Output: Hot-reloadable keytab, GSS Prometheus metrics, full lifecycle integration test
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-kerberos-authentication/12-RESEARCH.md
@.planning/phases/12-kerberos-authentication/12-01-SUMMARY.md
@.planning/phases/12-kerberos-authentication/12-02-SUMMARY.md
@.planning/phases/12-kerberos-authentication/12-03-SUMMARY.md
@.planning/phases/12-kerberos-authentication/12-04-SUMMARY.md
@pkg/auth/kerberos/kerberos.go
@pkg/auth/kerberos/config.go
@internal/protocol/nfs/rpc/gss/framework.go
@internal/protocol/nfs/rpc/gss/context.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Keytab Hot-Reload and Environment Variables</name>
  <files>
    pkg/auth/kerberos/keytab.go
    pkg/auth/kerberos/keytab_test.go
    pkg/auth/kerberos/kerberos.go
  </files>
  <action>
Implement keytab file management with hot-reload support and env var overrides.

**keytab.go:**
- KeytabManager struct:
  - path string (file path to watch)
  - provider *Provider (back-reference for atomic swap)
  - stopCh chan struct{}
  - mu sync.Mutex

- NewKeytabManager(path string, provider *Provider) *KeytabManager

- loadKeytab(path string) (*keytab.Keytab, error):
  Read file at path, call keytab.Parse(). Return parsed keytab.
  If path is empty, return error "keytab path not configured".

- Start() error:
  Validate keytab file exists and is readable.
  Start a goroutine that polls the keytab file every 60 seconds for modification (check os.Stat ModTime).
  On change: call provider.ReloadKeytab() which re-reads and atomically swaps.
  NOTE: fsnotify is already in go.mod (used by other deps), but simple polling is more reliable across platforms for keytab files. Use polling.
  Log at INFO level: "Keytab reloaded successfully" or "Keytab reload failed: <error>".

- Stop():
  Close stopCh to stop polling goroutine.

- resolveKeytabPath(configPath string) string:
  1. Check DITTOFS_KERBEROS_KEYTAB env var first (highest priority, per JuiceFS lesson)
  2. Fall back to configPath
  3. Return resolved path

- resolveServicePrincipal(configPrincipal string) string:
  1. Check DITTOFS_KERBEROS_PRINCIPAL env var first
  2. Fall back to configPrincipal
  3. Return resolved principal

**Update kerberos.go -- Provider:**
- In NewProvider: use resolveKeytabPath and resolveServicePrincipal for env var overrides
- ReloadKeytab() error:
  1. Lock mu (write lock)
  2. Re-read keytab file from path
  3. If parse succeeds: swap p.keytab atomically, unlock, return nil
  4. If parse fails: unlock, return error (keep old keytab)
  Old contexts continue using their established session keys (they don't reference the keytab).

- Add keytabManager *KeytabManager field to Provider
- In NewProvider: create and start KeytabManager
- In Close(): stop KeytabManager

**keytab_test.go:**
- Test resolveKeytabPath uses env var when set (use t.Setenv)
- Test resolveKeytabPath falls back to config when env not set
- Test resolveServicePrincipal uses env var when set
- Test loadKeytab with a real keytab file (create a minimal test keytab using gokrb5 keytab.New() and keytab.Marshal(), write to temp file, then parse)
- Test ReloadKeytab atomically swaps without affecting existing sessions
- Test ReloadKeytab keeps old keytab on parse failure
  </action>
  <verify>cd /Users/marmos91/Projects/dittofs && go test ./pkg/auth/kerberos/... -race -count=1</verify>
  <done>Keytab loads from file, env var overrides work, hot-reload swaps atomically, parse failures keep old keytab, tests pass with -race</done>
</task>

<task type="auto">
  <name>Task 2: GSS Prometheus Metrics and Lifecycle Integration Test</name>
  <files>
    internal/protocol/nfs/rpc/gss/metrics.go
    internal/protocol/nfs/rpc/gss/framework.go
    internal/protocol/nfs/rpc/gss/framework_test.go
  </files>
  <action>
Add Prometheus metrics for RPCSEC_GSS operations and create a lifecycle integration test.

**metrics.go:**
- GSSMetrics struct wrapping Prometheus collectors:
  - ContextCreations *prometheus.CounterVec (labels: result=[success, failure])
  - ContextDestructions prometheus.Counter
  - ActiveContexts prometheus.Gauge
  - AuthFailures *prometheus.CounterVec (labels: reason=[credential_problem, context_problem, sequence_violation, integrity_failure, privacy_failure])
  - DataRequests *prometheus.CounterVec (labels: service=[none, integrity, privacy])
  - RequestDuration *prometheus.HistogramVec (labels: operation=[init, data, destroy])

- NewGSSMetrics(registerer prometheus.Registerer) *GSSMetrics:
  Register all metrics with "dittofs_gss_" prefix.
  If registerer is nil, use prometheus.DefaultRegisterer.
  Follow existing pattern from other metrics in the project.

- RecordContextCreation(success bool)
- RecordContextDestruction()
- RecordAuthFailure(reason string)
- RecordDataRequest(service string, duration time.Duration)

**Update framework.go:**
- Add metrics *GSSMetrics field to GSSProcessor (optional, nil = no metrics)
- Accept metrics via NewGSSProcessor parameter (use variadic option pattern or add to params):
  NewGSSProcessor(provider, mapper, maxContexts, contextTTL, ...GSSProcessorOption)
  type GSSProcessorOption func(*GSSProcessor)
  func WithMetrics(m *GSSMetrics) GSSProcessorOption

- In handleInit: record ContextCreation (success/failure) and ActiveContexts
- In handleDestroy: record ContextDestruction and ActiveContexts
- In handleData: record DataRequest with service label and duration
- On sequence violation: record AuthFailure("sequence_violation")
- On context not found: record AuthFailure("context_problem")
- On integrity failure: record AuthFailure("integrity_failure")
- On privacy failure: record AuthFailure("privacy_failure")

**Update framework_test.go -- Lifecycle Integration Test:**
- TestGSSLifecycle_Full: Tests the complete RPCSEC_GSS lifecycle using mock components:
  1. Create a GSSProcessor with a mock Verifier (from Plan 02's interface)
  2. Build an RPCSEC_GSS_INIT call (construct RPCCallMessage with auth flavor 6, credential body with GSSProc=1, procedure args containing a mock GSS token)
  3. Call Process() -- expect IsControl=true, GSSReply with handle
  4. Extract handle from reply
  5. Build an RPCSEC_GSS_DATA call (GSSProc=0, SeqNum=1, Service=RPCGSSSvcNone, Handle=extracted_handle)
  6. Call Process() -- expect IsControl=false, ProcessedData matching procedure args, Identity populated
  7. Build second DATA call with SeqNum=2 -- expect success
  8. Build duplicate DATA call with SeqNum=1 -- expect SilentDiscard=true (duplicate)
  9. Build RPCSEC_GSS_DESTROY call
  10. Call Process() -- expect IsControl=true
  11. Build DATA call with old handle -- expect error (context gone)

- TestGSSMetrics: Verify metric counters increment correctly through lifecycle

NOTE: This test does NOT require a real KDC. The mock Verifier returns a synthetic VerifiedContext with a known session key. This tests the RPCSEC_GSS state machine and wire protocol handling, not the Kerberos cryptography (which is tested by gokrb5 itself).
  </action>
  <verify>cd /Users/marmos91/Projects/dittofs && go test ./internal/protocol/nfs/rpc/gss/... -race -count=1 -v</verify>
  <done>GSS Prometheus metrics record context lifecycle and auth failures. Full RPCSEC_GSS lifecycle test passes: INIT -> DATA (success + duplicate rejection) -> DESTROY -> DATA (context gone). All tests pass with -race.</done>
</task>

</tasks>

<verification>
1. `go test ./pkg/auth/kerberos/... -race -count=1` -- keytab tests pass
2. `go test ./internal/protocol/nfs/rpc/gss/... -race -count=1 -v` -- all GSS tests pass including lifecycle
3. `go build ./...` -- full project builds
4. `go vet ./...` -- no issues
5. `go test ./... -count=1` -- no regressions anywhere
</verification>

<success_criteria>
- Keytab loads from file path or DITTOFS_KERBEROS_KEYTAB env var
- Service principal from config or DITTOFS_KERBEROS_PRINCIPAL env var
- Keytab hot-reload swaps atomically, parse failures keep old keytab
- Prometheus metrics track: context creations, destructions, active count, auth failures, data requests by service level
- Full lifecycle test: INIT creates context, DATA validates sequence + maps identity, duplicate rejected, DESTROY removes context, stale handle returns error
- All existing project tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/12-kerberos-authentication/12-05-SUMMARY.md`
</output>
