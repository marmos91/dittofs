---
phase: 12-kerberos-authentication
plan: 04
type: execute
wave: 4
depends_on: ["12-03"]
files_modified:
  - internal/protocol/nfs/rpc/gss/integrity.go
  - internal/protocol/nfs/rpc/gss/privacy.go
  - internal/protocol/nfs/rpc/gss/framework.go
  - internal/protocol/nfs/rpc/gss/integrity_test.go
  - internal/protocol/nfs/rpc/gss/privacy_test.go
  - pkg/adapter/nfs/nfs_connection.go
  - internal/protocol/nfs/v4/handlers/secinfo.go
autonomous: true

must_haves:
  truths:
    - "krb5i requests have integrity verified via MIC before NFS dispatch"
    - "krb5i replies include MIC checksum over response body"
    - "krb5p requests are decrypted before NFS dispatch"
    - "krb5p replies are encrypted before sending to client"
    - "SECINFO returns RPCSEC_GSS pseudo-flavors when Kerberos configured"
    - "Dual sequence number validation for krb5i/krb5p (credential AND body)"
  artifacts:
    - path: "internal/protocol/nfs/rpc/gss/integrity.go"
      provides: "krb5i unwrap/wrap for rpc_gss_integ_data"
      contains: "func UnwrapIntegrity"
    - path: "internal/protocol/nfs/rpc/gss/privacy.go"
      provides: "krb5p unwrap/wrap for rpc_gss_priv_data"
      contains: "func UnwrapPrivacy"
    - path: "internal/protocol/nfs/v4/handlers/secinfo.go"
      provides: "SECINFO with RPCSEC_GSS krb5/krb5i/krb5p entries"
      contains: "PseudoFlavorKrb5"
  key_links:
    - from: "internal/protocol/nfs/rpc/gss/integrity.go"
      to: "internal/protocol/nfs/rpc/gss/types.go"
      via: "Uses key usage constants for MIC verification"
      pattern: "KeyUsageInitiatorSign"
    - from: "internal/protocol/nfs/rpc/gss/privacy.go"
      to: "internal/protocol/nfs/rpc/gss/types.go"
      via: "Uses key usage constants for Wrap/Unwrap"
      pattern: "KeyUsageInitiatorSeal"
    - from: "pkg/adapter/nfs/nfs_connection.go"
      to: "internal/protocol/nfs/rpc/gss/integrity.go"
      via: "Wraps reply body with MIC for krb5i"
      pattern: "WrapIntegrity"
---

<objective>
Implement krb5i (integrity) and krb5p (privacy) security services and upgrade SECINFO.

Purpose: krb5i adds MIC verification to ensure request/response authenticity. krb5p adds encryption to protect data confidentiality. Both are mandatory for NFSv4 compliance per RFC 7530. SECINFO must advertise these pseudo-flavors so clients can negotiate the correct security level.

Output: Full krb5/krb5i/krb5p support for RPCSEC_GSS DATA path, SECINFO returns RPCSEC_GSS entries
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-kerberos-authentication/12-RESEARCH.md
@.planning/phases/12-kerberos-authentication/12-01-SUMMARY.md
@.planning/phases/12-kerberos-authentication/12-02-SUMMARY.md
@.planning/phases/12-kerberos-authentication/12-03-SUMMARY.md
@internal/protocol/nfs/rpc/gss/framework.go
@internal/protocol/nfs/rpc/gss/types.go
@internal/protocol/nfs/rpc/gss/verifier.go
@internal/protocol/nfs/v4/handlers/secinfo.go
@pkg/adapter/nfs/nfs_connection.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: krb5i Integrity and krb5p Privacy</name>
  <files>
    internal/protocol/nfs/rpc/gss/integrity.go
    internal/protocol/nfs/rpc/gss/privacy.go
    internal/protocol/nfs/rpc/gss/framework.go
    internal/protocol/nfs/rpc/gss/integrity_test.go
    internal/protocol/nfs/rpc/gss/privacy_test.go
  </files>
  <action>
Implement integrity (krb5i) and privacy (krb5p) wrapping/unwrapping.

**integrity.go -- krb5i (RFC 2203 Section 5.3.3.4.2):**
- UnwrapIntegrity(ctx *GSSContext, requestBody []byte) (procedureArgs []byte, seqNum uint32, err error):
  1. Decode rpc_gss_integ_data from requestBody:
     - databody_integ []byte (XDR opaque -- contains XDR(seq_num + args))
     - checksum []byte (XDR opaque -- MIC of databody_integ)
  2. Verify MIC: Use gokrb5 gssapi.MICToken. The checksum bytes are the raw MIC token.
     Create a MICToken, set Payload=databody_integ, parse the checksum as the MIC.
     Verify with ctx.SessionKey using KeyUsageInitiatorSign (23).
     NOTE: The exact gokrb5 API for MIC verification may require constructing the token differently.
     Use crypto.VerifyChecksum from gokrb5 with the session key, key usage 23, databody_integ, and checksum.
     If verification fails, return error.
  3. Extract seq_num from databody_integ: first 4 bytes (uint32 big-endian)
  4. Validate that seq_num matches the credential's seq_num (dual validation per RFC 2203)
  5. Return remaining bytes as procedure arguments

- WrapIntegrity(ctx *GSSContext, seqNum uint32, replyBody []byte) ([]byte, error):
  1. Build databody_integ: XDR(seq_num) + replyBody
  2. Compute MIC over databody_integ using ctx.SessionKey with KeyUsageAcceptorSign (25)
     Use gokrb5 crypto.GetChecksumHash or similar to compute the checksum.
  3. Encode rpc_gss_integ_data: XDR opaque(databody_integ) + XDR opaque(checksum)
  4. Return the encoded bytes

**privacy.go -- krb5p (RFC 2203 Section 5.3.3.4.3):**
- UnwrapPrivacy(ctx *GSSContext, requestBody []byte) (procedureArgs []byte, seqNum uint32, err error):
  1. Decode rpc_gss_priv_data from requestBody:
     - databody_priv []byte (XDR opaque -- Wrap token containing encrypted data)
  2. Unwrap using gokrb5 gssapi.WrapToken:
     Parse databody_priv as a WrapToken. Call Unwrap with ctx.SessionKey and KeyUsageInitiatorSeal (24).
     This decrypts the data and verifies integrity.
  3. The decrypted payload is XDR(seq_num + args)
  4. Extract seq_num (first 4 bytes)
  5. Validate seq_num matches credential (dual validation)
  6. Return remaining bytes as procedure arguments

- WrapPrivacy(ctx *GSSContext, seqNum uint32, replyBody []byte) ([]byte, error):
  1. Build plaintext: XDR(seq_num) + replyBody
  2. Wrap using gokrb5: create a WrapToken, encrypt with ctx.SessionKey using KeyUsageAcceptorSeal (26)
  3. Encode as rpc_gss_priv_data: XDR opaque(wrap_token_bytes)
  4. Return the encoded bytes

**Update framework.go -- handleData:**
- Replace the "not yet implemented" stubs for integrity and privacy:
  - Service=RPCGSSSvcIntegrity: call UnwrapIntegrity(ctx, requestBody). Validate dual seq_num.
  - Service=RPCGSSSvcPrivacy: call UnwrapPrivacy(ctx, requestBody). Validate dual seq_num.
- Set GSSProcessResult.Service so the reply path knows which wrapping to apply

**Update nfs_connection.go reply path:**
- In the handleRPCCall GSS reply section (from Plan 03), after getting replyData from the NFS handler:
  - If gssResult.Service == RPCGSSSvcIntegrity: replyData = WrapIntegrity(ctx, seqNum, replyData)
  - If gssResult.Service == RPCGSSSvcPrivacy: replyData = WrapPrivacy(ctx, seqNum, replyData)
  - Then use MakeGSSSuccessReply with the GSS verifier as before
- Need to pass the GSSContext (with session key) to the reply wrapping. Add SessionKey to GSSProcessResult.

**integrity_test.go:**
- Test UnwrapIntegrity with a valid MIC (create test data using WrapIntegrity, then verify roundtrip)
- Test UnwrapIntegrity rejects tampered data (flip a byte in databody)
- Test UnwrapIntegrity rejects wrong seq_num in body vs credential
- Test WrapIntegrity produces valid rpc_gss_integ_data format

**privacy_test.go:**
- Test UnwrapPrivacy with valid encrypted data (create using WrapPrivacy, roundtrip)
- Test UnwrapPrivacy rejects corrupted encrypted data
- Test WrapPrivacy produces valid rpc_gss_priv_data format

NOTE on testing: MIC and Wrap operations require a valid Kerberos session key. For tests, create a synthetic session key using gokrb5 types.EncryptionKey with a known key value and encryption type (e.g., AES256-CTS-HMAC-SHA1-96, etype 18). Use gokrb5 crypto package to perform the operations. If the gokrb5 MIC/Wrap API doesn't easily support creating test tokens, use the lower-level crypto functions directly with known key material.
  </action>
  <verify>cd /Users/marmos91/Projects/dittofs && go test ./internal/protocol/nfs/rpc/gss/... -race -count=1</verify>
  <done>krb5i verifies MIC on request and adds MIC on reply. krb5p decrypts request and encrypts reply. Dual seq_num validation enforced. Roundtrip tests pass for both modes.</done>
</task>

<task type="auto">
  <name>Task 2: SECINFO Upgrade with RPCSEC_GSS Pseudo-Flavors</name>
  <files>
    internal/protocol/nfs/v4/handlers/secinfo.go
    pkg/adapter/nfs/nfs_adapter.go
  </files>
  <action>
Update SECINFO to advertise Kerberos security mechanisms when configured.

**Update secinfo.go:**
- Import the gss types package for pseudo-flavor constants
- The handler needs to know whether Kerberos is enabled. Access this via the Handler struct (which has a Runtime reference). Add a KerberosEnabled bool or a reference to the adapter config.
  Simplest approach: Add a SecurityFlavors field to the v4 Handler struct that is set during initialization. This avoids the handler needing to know about Kerberos config directly.
  OR: Add a method to the Handler: func (h *Handler) GetSecurityFlavors() []uint32 that returns the configured flavors.

- Modify handleSecInfo response encoding:
  When Kerberos is enabled, return RPCSEC_GSS entries. Per RFC 7530 Section 16.31:
  Each RPCSEC_GSS entry has: flavor (uint32 = 6), then secinfo4_gss_info:
    - oid (XDR opaque: KRB5 OID 1.2.840.113554.1.2.2 encoded as DER)
    - qop (uint32 = 0)
    - service (uint32: 1=none, 2=integrity, 3=privacy)

  DER encoding of OID 1.2.840.113554.1.2.2: 0x06 0x09 0x2a 0x86 0x48 0x86 0xf7 0x12 0x01 0x02 0x02
  (OID tag=0x06, length=9, then the OID bytes)
  BUT: in XDR, the OID is encoded as an opaque<> (length-prefixed byte array), and the content is the raw OID value bytes (not ASN.1 tagged). Per RFC 2203/RFC 7530, the sec_oid4 type is opaque<>. The content should be the GSS-API OID in DER format: 0x06 0x09 0x2a 0x86 0x48 0x86 0xf7 0x12 0x01 0x02 0x02.

  Entry order (most secure first per RFC 7530 convention):
  1. krb5p: flavor=6, oid=KRB5_OID_DER, qop=0, service=3 (privacy)
  2. krb5i: flavor=6, oid=KRB5_OID_DER, qop=0, service=2 (integrity)
  3. krb5:  flavor=6, oid=KRB5_OID_DER, qop=0, service=1 (none)
  4. AUTH_SYS: flavor=1 (if AUTH_SYS fallback enabled for this share)
  5. AUTH_NONE: flavor=0

  When Kerberos NOT enabled: keep current behavior (AUTH_SYS + AUTH_NONE only)

- Add the KRB5 OID DER bytes as a package-level variable:
  var krb5OIDDER = []byte{0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x12, 0x01, 0x02, 0x02}

- Helper function encodeSecInfoGSSEntry(buf *bytes.Buffer, service uint32):
  Write flavor (uint32 = 6)
  Write OID as XDR opaque (length + bytes + padding)
  Write qop (uint32 = 0)
  Write service (uint32)

**Update nfs_adapter.go:**
- When initializing the v4Handler, pass Kerberos enabled status so SECINFO knows whether to advertise RPCSEC_GSS flavors. Add a KerberosEnabled bool to the v4 Handler or pass via a config struct.

**Update log message:**
- Change "SECINFO: returning AUTH_SYS + AUTH_NONE" to include Kerberos flavors when enabled
  </action>
  <verify>cd /Users/marmos91/Projects/dittofs && go test ./internal/protocol/nfs/v4/handlers/... -race -count=1 && go build ./pkg/adapter/nfs/...</verify>
  <done>SECINFO returns krb5p, krb5i, krb5 RPCSEC_GSS entries when Kerberos enabled. AUTH_SYS fallback configurable per share. Existing SECINFO tests still pass. Builds cleanly.</done>
</task>

</tasks>

<verification>
1. `go test ./internal/protocol/nfs/rpc/gss/... -race -count=1` -- integrity and privacy tests pass
2. `go test ./internal/protocol/nfs/v4/handlers/... -race -count=1` -- SECINFO tests pass
3. `go build ./...` -- full build succeeds
4. `go vet ./...` -- no issues
</verification>

<success_criteria>
- krb5i: MIC verified on incoming requests, MIC added to outgoing replies
- krb5p: Payload decrypted on incoming requests, encrypted on outgoing replies
- Dual sequence number validation (credential + body) for krb5i and krb5p
- SECINFO returns RPCSEC_GSS entries with KRB5 OID when Kerberos enabled
- SECINFO entries ordered: krb5p > krb5i > krb5 > AUTH_SYS > AUTH_NONE
- AUTH_SYS fallback controlled by share configuration
- All existing tests pass (no regression)
</success_criteria>

<output>
After completion, create `.planning/phases/12-kerberos-authentication/12-04-SUMMARY.md`
</output>
