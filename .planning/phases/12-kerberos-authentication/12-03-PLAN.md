---
phase: 12-kerberos-authentication
plan: 03
type: execute
wave: 3
depends_on: ["12-02"]
files_modified:
  - internal/protocol/nfs/rpc/gss/framework.go
  - internal/protocol/nfs/rpc/gss/verifier.go
  - internal/protocol/nfs/rpc/auth.go
  - internal/protocol/nfs/rpc/parser.go
  - pkg/adapter/nfs/nfs_connection.go
  - pkg/adapter/nfs/nfs_adapter.go
  - internal/protocol/nfs/dispatch.go
  - internal/protocol/nfs/v4/handlers/handler.go
  - internal/protocol/nfs/v4/handlers/compound.go
  - internal/protocol/nfs/rpc/gss/verifier_test.go
autonomous: true

must_haves:
  truths:
    - "RPCSEC_GSS DATA requests are unwrapped and dispatched to NFS handlers"
    - "NFS handlers receive Identity from GSS context (same as AUTH_UNIX path)"
    - "Reply verifier is MIC of sequence number for RPCSEC_GSS replies"
    - "AUTH_SYS and AUTH_NULL continue to work unchanged"
    - "NULL procedure accepts AUTH_NONE regardless of Kerberos config"
  artifacts:
    - path: "internal/protocol/nfs/rpc/gss/verifier.go"
      provides: "Reply verifier computation (MIC of seq_num)"
      contains: "func ComputeReplyVerifier"
    - path: "internal/protocol/nfs/rpc/gss/framework.go"
      provides: "handleData implementation for krb5 svc_none"
      contains: "func.*handleData"
    - path: "pkg/adapter/nfs/nfs_connection.go"
      provides: "GSS intercept before NFS dispatch"
      contains: "GSSProcessor"
  key_links:
    - from: "pkg/adapter/nfs/nfs_connection.go"
      to: "internal/protocol/nfs/rpc/gss/framework.go"
      via: "Calls GSSProcessor.Process() before handleRPCCall dispatch"
      pattern: "gssProcessor\\.Process"
    - from: "internal/protocol/nfs/rpc/gss/framework.go"
      to: "pkg/auth/kerberos/identity.go"
      via: "Maps principal to Identity via IdentityMapper"
      pattern: "mapper\\.MapPrincipal"
    - from: "internal/protocol/nfs/rpc/parser.go"
      to: "internal/protocol/nfs/rpc/gss/verifier.go"
      via: "MakeGSSSuccessReply uses GSS verifier"
      pattern: "MakeGSSSuccessReply"
---

<objective>
Integrate RPCSEC_GSS into the NFS connection handler for krb5 (authentication-only) DATA path.

Purpose: This is the core integration plan. After context creation (Plan 02), clients send DATA requests with auth flavor 6. The GSSProcessor must: (1) validate the sequence number, (2) verify the header verifier (MIC of RPC header), (3) extract identity from the GSS context, (4) unwrap procedure arguments (for svc_none, args are unmodified), and (5) build the reply with a GSS verifier (MIC of seq_num). The NFS connection handler is modified to intercept auth flavor 6 before dispatching to program handlers.

Output: Working krb5 (auth-only) authentication for both NFSv3 and NFSv4 operations
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-kerberos-authentication/12-RESEARCH.md
@.planning/phases/12-kerberos-authentication/12-01-SUMMARY.md
@.planning/phases/12-kerberos-authentication/12-02-SUMMARY.md
@internal/protocol/nfs/rpc/gss/types.go
@internal/protocol/nfs/rpc/gss/framework.go
@internal/protocol/nfs/rpc/gss/context.go
@internal/protocol/nfs/rpc/gss/sequence.go
@pkg/adapter/nfs/nfs_connection.go
@pkg/adapter/nfs/nfs_adapter.go
@internal/protocol/nfs/rpc/parser.go
@internal/protocol/nfs/rpc/auth.go
@internal/protocol/nfs/dispatch.go
@internal/protocol/nfs/v4/handlers/handler.go
@internal/protocol/nfs/v4/handlers/compound.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: handleData Implementation and Reply Verifier</name>
  <files>
    internal/protocol/nfs/rpc/gss/framework.go
    internal/protocol/nfs/rpc/gss/verifier.go
    internal/protocol/nfs/rpc/gss/verifier_test.go
    internal/protocol/nfs/rpc/parser.go
    internal/protocol/nfs/rpc/auth.go
  </files>
  <action>
Implement the DATA path in GSSProcessor and reply verifier computation.

**Update framework.go -- handleData implementation:**
- handleData(cred *RPCGSSCredV1, requestBody []byte) *GSSProcessResult:
  1. Lookup context by cred.Handle. If not found, return error (RPCSEC_GSS_CREDPROBLEM)
  2. Validate sequence number: ctx.SeqWindow.Accept(cred.SeqNum). If rejected, return nil (silent discard per RFC 2203 Section 5.3.3.1 -- set a SilentDiscard bool in result)
  3. Check if cred.SeqNum >= MAXSEQ: if so, context must be destroyed per RFC 2203
  4. For Service=RPCGSSSvcNone (krb5 auth-only): requestBody IS the procedure arguments, no unwrapping needed. Set ProcessedData = requestBody
  5. For Service=RPCGSSSvcIntegrity/Privacy: return error "not yet implemented" (Plan 04)
  6. Map principal to Identity using mapper.MapPrincipal(ctx.Principal, ctx.Realm)
  7. Update ctx.LastUsed
  8. Return GSSProcessResult with ProcessedData, Identity, SeqNum, Service, IsControl=false

**verifier.go:**
- ComputeReplyVerifier(sessionKey types.EncryptionKey, seqNum uint32) ([]byte, error):
  XDR-encode seqNum as uint32 (4 bytes big-endian).
  Compute MIC using gokrb5: create a gssapi.MICToken with the encoded seqNum as payload.
  Use KeyUsageAcceptorSign (25) for the MIC computation.
  Return the MIC token bytes.
  Note: The reply verifier flavor is RPCSEC_GSS (6), and the body is the MIC.

- WrapReplyVerifier(mic []byte) rpc.OpaqueAuth:
  Returns OpaqueAuth{Flavor: AuthRPCSECGSS, Body: mic}

**Update rpc/parser.go:**
- Add MakeGSSSuccessReply(xid uint32, data []byte, verifier OpaqueAuth) ([]byte, error):
  Same as MakeSuccessReply but uses the provided verifier instead of AUTH_NULL.
  Copy the MakeSuccessReply function, replace the hardcoded AUTH_NULL Verf with the provided verifier parameter.

**Update rpc/auth.go:**
- Add AuthRPCSECGSS uint32 = 6 to the auth flavor constants (alongside AuthNull=0, AuthUnix=1, AuthShort=2, AuthDES=3)

**Add GSSProcessResult.SilentDiscard bool:**
- When true, the connection handler should silently drop the request (no reply sent)

**verifier_test.go:**
- Test ComputeReplyVerifier produces non-empty MIC bytes
- Test WrapReplyVerifier sets flavor to 6
- Test MakeGSSSuccessReply includes provided verifier (not AUTH_NULL)
  </action>
  <verify>cd /Users/marmos91/Projects/dittofs && go test ./internal/protocol/nfs/rpc/gss/... -race -count=1 && go test ./internal/protocol/nfs/rpc/... -race -count=1</verify>
  <done>handleData validates sequence, looks up context, maps identity. Reply verifier computes MIC of seq_num. MakeGSSSuccessReply uses GSS verifier. Tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: NFS Connection Handler GSS Integration</name>
  <files>
    pkg/adapter/nfs/nfs_connection.go
    pkg/adapter/nfs/nfs_adapter.go
    internal/protocol/nfs/dispatch.go
    internal/protocol/nfs/v4/handlers/handler.go
    internal/protocol/nfs/v4/handlers/compound.go
  </files>
  <action>
Wire GSSProcessor into the NFS connection handler at the RPC level.

**Update nfs_adapter.go (NFSAdapter struct):**
- Add gssProcessor *gss.GSSProcessor field
- In the initialization path (wherever NFS handlers are created, likely in SetRuntime or constructor): if config.Kerberos.Enabled, create the GSSProcessor:
  1. Create kerberos.Provider from config
  2. Create kerberos.StaticMapper from config.Kerberos.IdentityMapping
  3. Create gss.NewGSSProcessor(provider, mapper, config.Kerberos.MaxContexts, config.Kerberos.ContextTTL)
  4. Store in server.gssProcessor
- In Stop(): if gssProcessor != nil, call gssProcessor.Stop()

**Update nfs_connection.go -- handleRPCCall method:**
The key integration point is in handleRPCCall, BEFORE the program/version switch.

Add GSS interception at the top of handleRPCCall:
```
// RPCSEC_GSS interception (before program dispatch)
if call.GetAuthFlavor() == rpc.AuthRPCSECGSS && c.server.gssProcessor != nil {
    gssResult := c.server.gssProcessor.Process(call, procedureData)

    if gssResult.Err != nil {
        // Send AUTH_ERROR reply (MSG_DENIED with AUTH_TOOWEAK or similar)
        // Use MakeAuthErrorReply (new helper)
        ...
        return ...
    }

    if gssResult.SilentDiscard {
        // RFC 2203: silent discard for sequence violations
        return nil
    }

    if gssResult.IsControl {
        // INIT/DESTROY: send reply directly (no NFS dispatch)
        reply := rpc.MakeGSSSuccessReply(call.XID, gssResult.GSSReply, ...)
        return c.writeReply(call.XID, reply)
    }

    // DATA: replace procedureData with unwrapped data, continue dispatch
    procedureData = gssResult.ProcessedData

    // Store GSS identity in connection-scoped variable for auth extraction
    // Need to pass the Identity through to ExtractHandlerContext
    // Add gssIdentity to the connection scope or pass via context
}
```

The cleanest approach for passing Identity to handlers:
- Add a `gssIdentity *metadata.Identity` field to the connection or pass it via context.WithValue
- In ExtractHandlerContext and ExtractV4HandlerContext: if authFlavor==AuthRPCSECGSS and gssIdentity is set, use its UID/GID/GIDs instead of parsing AUTH_UNIX

**Update dispatch.go -- ExtractHandlerContext:**
- Add a gssIdentity parameter (use variadic option pattern for backward compatibility, matching the existing pattern with StateManager in v4 Handler):
  `func ExtractHandlerContext(ctx context.Context, call *rpc.RPCCallMessage, clientAddr string, share string, procedure string, opts ...HandlerContextOption) *nfs.NFSHandlerContext`
  OR simpler: pass the resolved Identity via context.Value with a package-level key.

  Recommended approach: Use context.Value. Define a contextKey in the gss package:
  ```
  type gssIdentityKey struct{}
  func ContextWithIdentity(ctx context.Context, id *metadata.Identity) context.Context
  func IdentityFromContext(ctx context.Context) *metadata.Identity
  ```
  In handleRPCCall, after GSS DATA processing: ctx = gss.ContextWithIdentity(ctx, gssResult.Identity)
  In ExtractHandlerContext: check for gss.IdentityFromContext(ctx). If present AND authFlavor==AuthRPCSECGSS, use that identity.

**Update v4/handlers/compound.go -- ExtractV4HandlerContext:**
- Same pattern: check gss.IdentityFromContext(ctx). If present AND authFlavor==AuthRPCSECGSS, populate CompoundContext UID/GID/GIDs from the GSS identity.

**Update v4/handlers/handler.go:**
- No structural changes needed. The Handler already receives CompoundContext which will now have GSS-provided credentials.

**Reply handling in sendReply:**
- After GSS DATA processing, the reply needs a GSS verifier (not AUTH_NULL).
  Modify the reply path: if the request was GSS-authenticated, use MakeGSSSuccessReply instead of MakeSuccessReply.
  Store the GSS context info (session key, seq_num) in a per-request scope so sendReply can access it.

  Simplest approach: In handleRPCCall, for GSS DATA requests, intercept the reply before calling sendReply.
  After the program handler returns replyData:
  1. Compute reply verifier: gss.ComputeReplyVerifier(gssResult.SessionKey, gssResult.SeqNum)
  2. Use rpc.MakeGSSSuccessReply(call.XID, replyData, verifier) instead of sendReply
  3. Write directly via writeReply

**Add MakeAuthErrorReply to rpc/parser.go:**
- MakeAuthErrorReply(xid uint32, authStat uint32) ([]byte, error):
  Creates MSG_DENIED reply with ReplyState=1 (MSG_DENIED), reject_stat=1 (AUTH_ERROR), auth_stat=authStat.
  Auth stat values: RPCSEC_GSS_CREDPROBLEM=13, RPCSEC_GSS_CTXPROBLEM=14
  Add these constants to rpc/constants.go.

**NULL procedure exemption:**
Per RFC 2623 Section 2.3.1: NULL procedure MUST accept AUTH_NONE regardless of security settings. This is already the case since NULL has NeedsAuth=false in the dispatch table. No changes needed, but verify this is preserved.
  </action>
  <verify>cd /Users/marmos91/Projects/dittofs && go build ./pkg/adapter/nfs/... && go build ./internal/protocol/nfs/... && go vet ./pkg/adapter/nfs/... ./internal/protocol/nfs/... && go test ./internal/protocol/nfs/rpc/... -race -count=1</verify>
  <done>GSS interception in handleRPCCall works for INIT/DESTROY/DATA. NFS handlers receive Identity from GSS context via context.Value. Replies include GSS verifier. AUTH_SYS/AUTH_NULL paths unchanged. Builds and tests pass.</done>
</task>

</tasks>

<verification>
1. `go build ./...` -- full project builds with GSS integration
2. `go test ./internal/protocol/nfs/rpc/... -race -count=1` -- RPC parser tests pass including new MakeGSSSuccessReply
3. `go test ./internal/protocol/nfs/rpc/gss/... -race -count=1` -- all GSS tests pass
4. `go vet ./...` -- no issues
5. Existing NFS/v4 tests still pass (AUTH_UNIX path unchanged): `go test ./internal/protocol/nfs/v4/... -race -count=1`
</verification>

<success_criteria>
- RPCSEC_GSS auth flavor 6 intercepted before NFS program dispatch
- INIT creates context and returns handle (control path, no NFS dispatch)
- DESTROY removes context (control path)
- DATA validates sequence, maps principal to Identity, passes to NFS handler
- Reply includes GSS verifier (MIC of seq_num) for GSS-authenticated requests
- AUTH_SYS and AUTH_NULL continue working unchanged
- NULL procedure accepts AUTH_NONE per RFC 2623
- Silent discard for sequence violations (no reply sent)
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/12-kerberos-authentication/12-03-SUMMARY.md`
</output>
