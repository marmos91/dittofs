---
phase: 12-kerberos-authentication
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - internal/protocol/nfs/rpc/gss/context.go
  - internal/protocol/nfs/rpc/gss/framework.go
  - internal/protocol/nfs/rpc/gss/context_test.go
  - internal/protocol/nfs/rpc/gss/framework_test.go
autonomous: true

must_haves:
  truths:
    - "GSS context is created from AP-REQ token and stored before reply is sent"
    - "Context store provides O(1) lookup by handle and TTL-based cleanup"
    - "RPCSEC_GSS_INIT returns context handle, sequence window, and AP-REP token"
    - "RPCSEC_GSS_DESTROY removes context from store"
    - "GSSProcessor intercepts auth flavor 6 and routes INIT/DESTROY without NFS dispatch"
  artifacts:
    - path: "internal/protocol/nfs/rpc/gss/context.go"
      provides: "GSSContext struct and ContextStore with TTL cleanup"
      contains: "type ContextStore struct"
    - path: "internal/protocol/nfs/rpc/gss/framework.go"
      provides: "GSSProcessor orchestrating RPCSEC_GSS lifecycle"
      contains: "type GSSProcessor struct"
  key_links:
    - from: "internal/protocol/nfs/rpc/gss/framework.go"
      to: "pkg/auth/kerberos/kerberos.go"
      via: "Uses Provider for AP-REQ verification"
      pattern: "provider\\.Keytab"
    - from: "internal/protocol/nfs/rpc/gss/context.go"
      to: "internal/protocol/nfs/rpc/gss/sequence.go"
      via: "Each context owns a SeqWindow"
      pattern: "SeqWindow"
---

<objective>
Implement the GSS context state machine and the GSSProcessor that orchestrates RPCSEC_GSS context creation, destruction, and DATA routing.

Purpose: The GSSProcessor is the central component that intercepts auth flavor 6 (RPCSEC_GSS) at the RPC layer. It handles context creation via gokrb5 AP-REQ verification, stores contexts with TTL-based cleanup, and routes INIT/CONTINUE_INIT/DESTROY control messages. This plan does NOT yet integrate with the NFS connection handler -- that happens in Plan 03.

Output: Context store with O(1) lookup, GSSProcessor with handleInit/handleDestroy, AP-REP generation for mutual auth
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-kerberos-authentication/12-RESEARCH.md
@.planning/phases/12-kerberos-authentication/12-01-SUMMARY.md
@internal/protocol/nfs/rpc/gss/types.go
@internal/protocol/nfs/rpc/gss/sequence.go
@pkg/auth/kerberos/kerberos.go
@internal/auth/spnego/spnego.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: GSS Context Store with TTL Cleanup</name>
  <files>
    internal/protocol/nfs/rpc/gss/context.go
    internal/protocol/nfs/rpc/gss/context_test.go
  </files>
  <action>
Create the GSS context struct and thread-safe context store.

**context.go:**
- GSSContext struct:
  - Handle []byte (unique context identifier, crypto/rand generated, 16 bytes)
  - Principal string (Kerberos principal name, e.g. "alice@EXAMPLE.COM")
  - Realm string
  - SessionKey types.EncryptionKey (from gokrb5 -- use the key from the decrypted ticket)
  - SeqWindow *SeqWindow (per-context sequence tracking)
  - Service uint32 (RPCGSSSvcNone/Integrity/Privacy -- set during INIT from client request)
  - CreatedAt time.Time
  - LastUsed time.Time (updated on each DATA request for LRU)
  - mu sync.Mutex (protects LastUsed updates)

- generateHandle() []byte: 16 bytes from crypto/rand

- ContextStore struct:
  - contexts sync.Map (key=string(handle), value=*GSSContext)
  - maxContexts int
  - contextTTL time.Duration
  - cleanupTicker *time.Ticker
  - stopCh chan struct{}

- NewContextStore(maxContexts int, contextTTL time.Duration) *ContextStore: starts background cleanup goroutine (runs every 5 minutes)

- Store(ctx *GSSContext): stores context by handle. CRITICAL per NFS-Ganesha lesson: this MUST be called BEFORE the INIT reply is sent to the client. If maxContexts exceeded, evict oldest (LRU) context first.

- Lookup(handle []byte) (*GSSContext, bool): O(1) lookup via sync.Map. Updates LastUsed on hit.

- Delete(handle []byte): removes context. Called on RPCSEC_GSS_DESTROY.

- cleanup(): iterates contexts, removes any where time.Since(LastUsed) > contextTTL. Log evictions at DEBUG level.

- Stop(): stops cleanup ticker, closes stopCh

- Count() int: returns number of active contexts (for metrics)

**context_test.go:**
- Test Store and Lookup roundtrip
- Test Lookup returns false for unknown handle
- Test Delete removes context
- Test TTL cleanup removes expired contexts (use short TTL like 10ms)
- Test concurrent Store/Lookup/Delete (goroutine safety)
- Test maxContexts eviction (store maxContexts+1, oldest gets evicted)
  </action>
  <verify>cd /Users/marmos91/Projects/dittofs && go test ./internal/protocol/nfs/rpc/gss/... -run TestContext -race -count=1</verify>
  <done>ContextStore provides O(1) lookup, TTL cleanup, LRU eviction, thread-safe operations, all tests pass</done>
</task>

<task type="auto">
  <name>Task 2: GSSProcessor with INIT and DESTROY Handling</name>
  <files>
    internal/protocol/nfs/rpc/gss/framework.go
    internal/protocol/nfs/rpc/gss/framework_test.go
  </files>
  <action>
Create the GSSProcessor that orchestrates RPCSEC_GSS lifecycle.

**framework.go:**
- GSSProcessResult struct:
  - ProcessedData []byte (unwrapped procedure args for DATA requests)
  - Identity *metadata.Identity (resolved identity for DATA requests)
  - GSSReply []byte (reply data for INIT/DESTROY control messages)
  - ReplyVerifier []byte (GSS verifier for reply -- MIC of seq_num)
  - IsControl bool (true for INIT/CONTINUE_INIT/DESTROY, false for DATA)
  - SeqNum uint32 (sequence number from credential, needed for reply verifier)
  - Service uint32 (service level from context, needed for reply wrapping)
  - Err error

- GSSProcessor struct:
  - contexts *ContextStore
  - provider *kerberos.Provider (from pkg/auth/kerberos)
  - mapper kerberos.IdentityMapper (or the identity mapper interface)
  - mu sync.RWMutex (for provider hot-swap)

- NewGSSProcessor(provider *kerberos.Provider, mapper IdentityMapper, maxContexts int, contextTTL time.Duration) *GSSProcessor

- Process(call *rpc.RPCCallMessage, requestBody []byte) *GSSProcessResult:
  Main entry point. Decode the credential body as RPCGSSCredV1.
  Switch on cred.GSSProc:
    - RPCGSSInit / RPCGSSContinueInit: return handleInit(cred, verifierBody)
    - RPCGSSData: return handleData(cred, requestBody)
    - RPCGSSDestroy: return handleDestroy(cred)
    - default: return error result

- handleInit(cred *RPCGSSCredV1, gssToken []byte) *GSSProcessResult:
  1. The GSS token is in the call's VERIFIER body (not credential body) for INIT.
     Actually per RFC 2203: for RPCSEC_GSS_INIT, the GSS token is in the "call body" after credential/verifier. The verifier is AUTH_NULL during INIT. The token is passed as the procedure args.
     Wait -- re-reading RFC 2203 Section 5.2.2: "The actual GSS-API token is passed as an argument to the RPC call." So the gssToken comes from the requestBody (procedure arguments).
  2. Extract the AP-REQ from the GSS token. The GSS-API token wraps the AP-REQ in an application tag with the KRB5 OID. Use the existing internal/auth/spnego OIDKerberosV5 for comparison. Parse using gokrb5.
  3. Verify using gokrb5 service.VerifyAPREQ with provider.Keytab(), service settings (RequireHostAddr=false, MaxClockSkew from provider). Handle the case where VerifyAPREQ returns the decrypted credentials.
  4. Extract session key from the verified ticket
  5. Create GSSContext with handle, principal, realm, session key, SeqWindow(128)
  6. CRITICAL: Store context BEFORE building reply (NFS-Ganesha bug lesson)
  7. Build RPCGSSInitRes with handle, GSSComplete status, SeqWindow=128
  8. For mutual auth: build AP-REP token from session key (or leave empty initially if gokrb5 does not easily expose AP-REP building -- document this limitation)
  9. Encode result and return as GSSReply with IsControl=true

- handleDestroy(cred *RPCGSSCredV1) *GSSProcessResult:
  1. Lookup context by cred.Handle
  2. If not found, return error (but still send reply per RFC)
  3. Delete context from store
  4. Return empty reply with IsControl=true

- handleData: stub for now that returns error "not implemented" (Plan 03 implements)

- Stop(): calls contexts.Stop()

**framework_test.go:**
- Test Process with RPCSEC_GSS_INIT returns IsControl=true (mock the gokrb5 verification by injecting a test provider with a known keytab -- or test the decode path only and mock VerifyAPREQ)
- Test Process with RPCSEC_GSS_DESTROY removes context
- Test Process with RPCSEC_GSS_DATA returns not-implemented for now
- Test Process with invalid credential version returns error
- Test handleInit stores context before reply (verify context is in store)
- Note: Full integration testing of AP-REQ verification requires a real keytab and KDC. For unit tests, either:
  a) Extract the AP-REQ parsing into a verifiable interface and mock it, OR
  b) Test the wire format handling and context lifecycle separately from gokrb5 verification
  Prefer (a): create a Verifier interface { VerifyToken(gssToken []byte) (*VerifiedContext, error) } that can be mocked in tests.
  </action>
  <verify>cd /Users/marmos91/Projects/dittofs && go test ./internal/protocol/nfs/rpc/gss/... -race -count=1</verify>
  <done>GSSProcessor handles INIT (context creation + store-before-reply), DESTROY (context removal), credential decode, and context lifecycle. Tests pass with -race. DATA path is stubbed for Plan 03.</done>
</task>

</tasks>

<verification>
1. `go test ./internal/protocol/nfs/rpc/gss/... -race -count=1` -- all tests pass
2. `go build ./internal/protocol/nfs/rpc/gss/...` -- compiles
3. `go vet ./internal/protocol/nfs/rpc/gss/...` -- no issues
4. Context store-before-reply ordering verified in test
</verification>

<success_criteria>
- GSSContext created with session key, principal, sequence window
- ContextStore provides O(1) lookup with TTL-based cleanup and LRU eviction
- GSSProcessor routes INIT to context creation, DESTROY to context removal
- Context stored BEFORE reply data is generated (NFS-Ganesha race prevention)
- AP-REQ verification uses gokrb5 VerifyAPREQ (or mockable interface)
- Thread-safe under concurrent access
</success_criteria>

<output>
After completion, create `.planning/phases/12-kerberos-authentication/12-02-SUMMARY.md`
</output>
