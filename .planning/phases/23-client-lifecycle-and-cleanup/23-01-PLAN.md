---
phase: 23-client-lifecycle-and-cleanup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/protocol/nfs/v4/state/v41_client.go
  - internal/protocol/nfs/v4/state/stateid.go
  - internal/protocol/nfs/v4/state/grace.go
  - internal/protocol/nfs/v4/state/v41_client_test.go
  - internal/protocol/nfs/v4/state/stateid_test.go
  - internal/protocol/nfs/v4/state/grace_test.go
autonomous: true
requirements:
  - LIFE-01
  - LIFE-02
  - LIFE-03
  - LIFE-04

must_haves:
  truths:
    - "DestroyV41ClientID rejects with NFS4ERR_CLIENTID_BUSY when sessions remain"
    - "DestroyV41ClientID purges all v4.1 client state synchronously"
    - "FreeStateid releases lock, open, and delegation stateids with proper guards"
    - "TestStateids returns per-stateid error codes without lease renewal side effects"
    - "GraceStatus returns structured info about active grace period with remaining time"
    - "ForceEndGrace immediately ends the grace period and invokes callback"
    - "RECLAIM_COMPLETE per-client tracking returns NFS4ERR_COMPLETE_ALREADY on duplicate"
    - "All state tests pass with -race flag"
  artifacts:
    - path: "internal/protocol/nfs/v4/state/v41_client.go"
      provides: "DestroyV41ClientID method on StateManager"
      contains: "func (sm *StateManager) DestroyV41ClientID"
    - path: "internal/protocol/nfs/v4/state/stateid.go"
      provides: "FreeStateid and TestStateids methods on StateManager"
      contains: "func (sm *StateManager) FreeStateid"
    - path: "internal/protocol/nfs/v4/state/grace.go"
      provides: "GraceStatusInfo, GraceStatus, ForceEndGrace, ReclaimComplete tracking"
      contains: "GraceStatusInfo"
  key_links:
    - from: "internal/protocol/nfs/v4/state/v41_client.go"
      to: "internal/protocol/nfs/v4/state/manager.go"
      via: "StateManager methods using sm.mu lock and existing purgeV41Client"
      pattern: "sm\\.purgeV41Client"
    - from: "internal/protocol/nfs/v4/state/stateid.go"
      to: "internal/protocol/nfs/v4/state/manager.go"
      via: "StateManager lock-state and open-state maps"
      pattern: "sm\\.mu\\.Lock"
---

<objective>
Implement all StateManager methods for Phase 23 client lifecycle operations: DestroyV41ClientID (LIFE-01), per-client RECLAIM_COMPLETE tracking (LIFE-02), FreeStateid (LIFE-03), TestStateids (LIFE-04), plus GraceStatus and ForceEndGrace for grace period API (needed by Plan 03). All methods tested with real StateManager (no mocks) and race detection.

Purpose: State methods are the foundation for all handler and API work in subsequent plans. Implementing and testing them first ensures correct behavior before wiring to protocol handlers.
Output: Extended state package with 6 new StateManager methods and comprehensive tests.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-client-lifecycle-and-cleanup/23-RESEARCH.md

# Key source files to read:
@internal/protocol/nfs/v4/state/v41_client.go
@internal/protocol/nfs/v4/state/stateid.go
@internal/protocol/nfs/v4/state/grace.go
@internal/protocol/nfs/v4/state/manager.go
@internal/protocol/nfs/v4/state/v41_client_test.go
@internal/protocol/nfs/v4/state/stateid_test.go
@internal/protocol/nfs/v4/state/grace_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DestroyV41ClientID, FreeStateid, and TestStateids state methods</name>
  <files>
    internal/protocol/nfs/v4/state/v41_client.go
    internal/protocol/nfs/v4/state/stateid.go
    internal/protocol/nfs/v4/state/grace.go
  </files>
  <action>
**Read first:** `state/v41_client.go`, `state/stateid.go`, `state/grace.go`, `state/manager.go`, `state/session.go`, `state/delegation.go` to understand existing structures and lock ordering.

**1. DestroyV41ClientID in v41_client.go:**

Add `DestroyV41ClientID(clientID uint64) error` method on `*StateManager`:
- Acquire `sm.mu.Lock()` (full write lock).
- Look up `v41ClientsByID[clientID]`. If not found, return `NFS4StateError{Status: NFS4ERR_STALE_CLIENTID}`.
- Check `sessionsByClientID[clientID]`. If `len(sessions) > 0`, return `NFS4StateError{Status: NFS4ERR_CLIENTID_BUSY}` (locked decision: strict RFC compliance).
- Call `sm.purgeV41Client(record)` to synchronously purge all state (delegations, open state, lock state, backchannel). This is sync per RFC requirement (after NFS4_OK, client ID must be immediately invalid).
- If grace period is active and this client was expected, call `sm.grace.ClientReclaimed(clientID)` to prevent grace period from hanging (Pitfall 6 from research).
- Log structured event at INFO level: "DESTROY_CLIENTID: client destroyed" with client_id, client_addr (locked decision).
- Return nil on success.

**2. FreeStateid in stateid.go:**

Add `FreeStateid(clientID uint64, stateid *types.Stateid4) error` method on `*StateManager`:
- Check if stateid is a special stateid (all-zeros or all-ones) -- return `NFS4ERR_BAD_STATEID` if so.
- Acquire `sm.mu.Lock()`.
- Look up the stateid in existing maps. Use the `Other` field to determine type. The existing stateid allocation uses type prefixes in `Other[0]`.
- For lock stateids: find the lock state in `lockStateByOther` map, remove it. Return `NFS4ERR_BAD_STATEID` if not found.
- For open stateids: find the open state in `openStateByOther` map. Check if any lock stateids reference it -- if so, return `NFS4ERR_LOCKS_HELD`. Otherwise remove it.
- For delegation stateids: find in `delegByOther` map, remove it.
- Do NOT trigger cache flush (locked decision: trust existing COMMIT/cache/WAL flow).
- Log at INFO level with stateid details, client ID, type freed.
- Return nil on success.

Also add `TestStateids(stateids []types.Stateid4) []uint32` method:
- Acquire `sm.mu.RLock()` (read lock only -- TEST is read-only, no side effects).
- Iterate stateids, for each call internal `testSingleStateid()` method.
- `testSingleStateid` validates the stateid WITHOUT lease renewal (Pitfall 5 from research). Check boot epoch, look up in appropriate map based on type byte, validate seqid if applicable.
- Return array of per-stateid NFS4 status codes (NFS4_OK for valid, NFS4ERR_BAD_STATEID/NFS4ERR_OLD_STATEID/NFS4ERR_EXPIRED as appropriate).
- Log at DEBUG level with count of stateids tested.

**3. Grace period enrichment in grace.go:**

Add `GraceStatusInfo` struct with fields: `Active bool`, `RemainingSeconds float64`, `TotalDuration time.Duration`, `ExpectedClients int`, `ReclaimedClients int`, `StartedAt time.Time`.

Add `Status() GraceStatusInfo` method on `*GracePeriodState`:
- Acquire `g.mu.Lock()`, read state, unlock.
- If active, compute remaining seconds from `startedAt + duration - now`.
- Return populated GraceStatusInfo.

Add `startedAt time.Time` field to `GracePeriodState` struct, set it in `StartGrace()`.

Add `ForceEnd()` method on `*GracePeriodState`:
- Same as `endGrace()` but callable externally (public method).
- Log "NFSv4 grace period force-ended" at INFO level.

Add per-client RECLAIM_COMPLETE tracking:
- Add `reclaimCompleted map[uint64]bool` field to `GracePeriodState`.
- Add `ReclaimComplete(clientID uint64) error` method:
  - If client already completed reclaim, return `NFS4StateError{Status: NFS4ERR_COMPLETE_ALREADY}`.
  - Mark client as reclaim-complete.
  - Call existing `ClientReclaimed(clientID)` for grace period early-exit tracking.
  - Log at INFO level with client_id, reclaim_duration (time since grace start).
  - If NOT in grace period, return NFS4_OK (not an error, per RFC 8881).
  - Return nil on success.
- Initialize `reclaimCompleted` in `NewGracePeriodState` and `StartGrace`.

Add `GraceStatus()` method on `*StateManager` that delegates to `sm.grace.Status()`.
Add `ForceEndGrace()` method on `*StateManager` that delegates to `sm.grace.ForceEnd()`.
  </action>
  <verify>
Run `go build ./internal/protocol/nfs/v4/state/...` -- must compile with no errors.
Run `go vet ./internal/protocol/nfs/v4/state/...` -- must pass clean.
  </verify>
  <done>
DestroyV41ClientID, FreeStateid, TestStateids, GraceStatusInfo, GraceStatus, ForceEndGrace, and ReclaimComplete are all implemented and compile. Methods follow existing lock ordering (sm.mu before connMu). DestroyV41ClientID rejects with NFS4ERR_CLIENTID_BUSY when sessions exist. FreeStateid guards against NFS4ERR_LOCKS_HELD. TestStateids uses read-only validation without lease renewal.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add state method tests with race detection</name>
  <files>
    internal/protocol/nfs/v4/state/v41_client_test.go
    internal/protocol/nfs/v4/state/stateid_test.go
    internal/protocol/nfs/v4/state/grace_test.go
  </files>
  <action>
**Read first:** Existing test files `v41_client_test.go`, `stateid_test.go`, `grace_test.go` to follow established test patterns (real StateManager, table-driven tests).

**1. DESTROY_CLIENTID tests in v41_client_test.go:**

Add test function `TestDestroyV41ClientID` with subtests:
- `success`: Register v4.1 client via ExchangeID, destroy it, verify NFS4_OK, verify client no longer exists (second destroy returns NFS4ERR_STALE_CLIENTID).
- `clientid_busy`: Register client, create session, attempt destroy -- verify NFS4ERR_CLIENTID_BUSY. Destroy session, then destroy client -- verify NFS4_OK.
- `stale_clientid`: Destroy non-existent client ID -- verify NFS4ERR_STALE_CLIENTID.
- `idempotent_after_destroy`: Destroy client, destroy again -- verify NFS4ERR_STALE_CLIENTID (not a crash).
- `during_grace_period`: Start grace period with client, destroy client, verify grace period accounts for destroyed client (does not hang).

Add `TestDestroyV41ClientID_Concurrent` (locked decision: race condition tests required):
- Spawn 10 goroutines each attempting to destroy the same client ID.
- Exactly one should succeed, others get NFS4ERR_STALE_CLIENTID or NFS4ERR_CLIENTID_BUSY.
- Run with `-race` flag.

**2. FreeStateid and TestStateids tests in stateid_test.go:**

Add `TestFreeStateid` with subtests:
- `free_lock_stateid`: Create open state + lock state, free lock stateid, verify lock released.
- `free_open_stateid`: Create open state (no locks), free it, verify removed.
- `free_open_with_locks_held`: Create open + lock, attempt free open -- verify NFS4ERR_LOCKS_HELD.
- `free_delegation_stateid`: Create delegation state, free it, verify removed.
- `bad_stateid`: Free non-existent stateid -- verify NFS4ERR_BAD_STATEID.
- `special_stateid`: Free all-zeros or all-ones stateid -- verify NFS4ERR_BAD_STATEID.

Add `TestTestStateids` with subtests:
- `all_valid`: Create several stateids, test them, verify all NFS4_OK.
- `mixed_valid_invalid`: Mix valid and invalid stateids, verify per-stateid error codes.
- `empty_list`: Test empty array, verify empty result.
- `expired_stateid`: Create stateid, expire its lease, test -- verify NFS4ERR_EXPIRED.
- `no_lease_renewal`: Test a stateid, verify the client's lease is NOT renewed (read-only operation).

Add `TestFreeStateid_Concurrent` (locked decision: race condition tests required):
- Create multiple stateids, spawn goroutines freeing them concurrently.
- Verify no crashes, each stateid freed exactly once.

**3. Grace period tests in grace_test.go:**

Add `TestGraceStatus` with subtests:
- `active_grace`: Start grace, check status -- verify Active=true, RemainingSeconds>0, correct counts.
- `inactive_grace`: Check status before starting grace -- verify Active=false.
- `after_all_reclaimed`: Start grace, reclaim all clients, check status -- verify Active=false.

Add `TestForceEndGrace`:
- Start grace period, force end, verify Active=false and callback invoked.

Add `TestReclaimComplete` with subtests:
- `success`: Start grace, reclaim complete for a client, verify NFS4_OK.
- `complete_already`: Reclaim complete twice for same client -- verify NFS4ERR_COMPLETE_ALREADY.
- `outside_grace`: Send reclaim complete when not in grace -- verify NFS4_OK (not an error per RFC).
- `all_clients_reclaim`: Start grace with 3 clients, each sends reclaim complete, verify grace ends early.
  </action>
  <verify>
Run `go test -race -v ./internal/protocol/nfs/v4/state/... -run "TestDestroyV41ClientID|TestFreeStateid|TestTestStateids|TestGraceStatus|TestForceEndGrace|TestReclaimComplete"` -- all tests pass with race detection enabled.
Run `go test -race ./internal/protocol/nfs/v4/state/...` -- full state package test suite passes (no regressions).
  </verify>
  <done>
All state method tests pass with -race flag. DestroyV41ClientID tested for success, NFS4ERR_CLIENTID_BUSY, NFS4ERR_STALE_CLIENTID, grace period interaction, and concurrent access. FreeStateid tested for lock/open/delegation types, NFS4ERR_LOCKS_HELD guard, and concurrent access. TestStateids verified per-stateid error codes and no lease renewal. Grace period tested for status, force-end, and RECLAIM_COMPLETE tracking including NFS4ERR_COMPLETE_ALREADY.
  </done>
</task>

</tasks>

<verification>
1. `go build ./internal/protocol/nfs/v4/state/...` compiles without errors
2. `go vet ./internal/protocol/nfs/v4/state/...` passes clean
3. `go test -race -v ./internal/protocol/nfs/v4/state/...` -- all tests pass including new ones
4. No regressions: existing state tests still pass
5. grep confirms new methods exist: DestroyV41ClientID, FreeStateid, TestStateids, GraceStatusInfo, ForceEnd, ReclaimComplete
</verification>

<success_criteria>
- DestroyV41ClientID correctly rejects with NFS4ERR_CLIENTID_BUSY when sessions exist and purges synchronously on success
- FreeStateid handles lock/open/delegation types with proper guards (NFS4ERR_LOCKS_HELD, NFS4ERR_BAD_STATEID)
- TestStateids returns per-stateid error codes without side effects (no lease renewal)
- GraceStatusInfo provides remaining seconds, client counts, and active status
- ForceEndGrace immediately ends grace period
- ReclaimComplete tracks per-client completion with NFS4ERR_COMPLETE_ALREADY on duplicate
- All tests pass with -race flag (concurrent DESTROY and FREE tests included)
</success_criteria>

<output>
After completion, create `.planning/phases/23-client-lifecycle-and-cleanup/23-01-SUMMARY.md`
</output>
