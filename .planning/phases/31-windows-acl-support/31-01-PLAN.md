---
phase: 31-windows-acl-support
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/auth/sid/sid.go
  - pkg/auth/sid/mapper.go
  - pkg/auth/sid/wellknown.go
  - pkg/auth/sid/sid_test.go
  - internal/adapter/smb/v2/handlers/security.go
  - internal/adapter/smb/v2/handlers/security_test.go
  - pkg/controlplane/runtime/lifecycle/lifecycle.go
autonomous: true
requirements:
  - SD-07

must_haves:
  truths:
    - "SID types and encode/decode live in shared pkg/auth/sid/ package"
    - "Machine SID is generated on first boot and persisted in SettingsStore"
    - "User UID 1000 and group GID 1000 produce different SIDs (no collision)"
    - "UID 0 (root) maps to BUILTIN\\Administrators S-1-5-32-544"
    - "Anonymous/guest connections use S-1-5-7"
    - "Existing security.go tests still pass after refactoring to use pkg/auth/sid/"
  artifacts:
    - path: "pkg/auth/sid/sid.go"
      provides: "SID struct, Encode, Decode, Format, Parse functions"
      exports: ["SID", "EncodeSID", "DecodeSID", "FormatSID", "ParseSIDString", "SIDSize"]
    - path: "pkg/auth/sid/mapper.go"
      provides: "SIDMapper with machine SID, RID mapping, reverse mapping"
      exports: ["SIDMapper", "NewSIDMapper", "NewSIDMapperFromString"]
    - path: "pkg/auth/sid/wellknown.go"
      provides: "Well-known SID constants and lookup table"
      exports: ["WellKnownSystem", "WellKnownAdministrators", "WellKnownEveryone", "WellKnownAnonymous", "WellKnownCreatorOwner", "WellKnownCreatorGroup"]
    - path: "pkg/auth/sid/sid_test.go"
      provides: "Tests for SID encode/decode round-trip, RID mapping, collision prevention"
  key_links:
    - from: "internal/adapter/smb/v2/handlers/security.go"
      to: "pkg/auth/sid/"
      via: "import and function calls"
      pattern: "sid\\.EncodeSID|sid\\.DecodeSID|sid\\.FormatSID"
    - from: "pkg/controlplane/runtime/lifecycle/lifecycle.go"
      to: "pkg/controlplane/store/ SettingsStore"
      via: "GetSetting/SetSetting for machine_sid"
      pattern: "machine_sid"
---

<objective>
Refactor SID types and functions from SMB handlers to shared `pkg/auth/sid/` package, add machine SID generation with persistence, and implement Samba-style RID mapping that prevents user/group SID collisions.

Purpose: Enables cross-protocol SID reuse (both SMB and NFS adapters) and fixes the SID collision bug (SD-07) where UID 1000 and GID 1000 produced identical SIDs.
Output: Shared SID package with mapper, machine SID persistence, and updated SMB handlers.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-windows-acl-support/31-CONTEXT.md
@.planning/phases/31-windows-acl-support/31-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From internal/adapter/smb/v2/handlers/security.go (to be refactored OUT):
```go
// SID struct (lines 82-109), currently in handlers package
type SID struct {
    Revision            uint8
    SubAuthorityCount   uint8
    IdentifierAuthority [6]byte
    SubAuthorities      []uint32
}

// Functions to MOVE to pkg/auth/sid/:
func SIDSize(sid *SID) int
func EncodeSID(buf *bytes.Buffer, sid *SID)
func DecodeSID(data []byte) (*SID, int, error)
func FormatSID(sid *SID) string
func ParseSIDString(s string) (*SID, error)
func makeDittoFSUserSID(uid uint32) *SID   // REPLACE with SIDMapper.UserSID
func makeDittoFSGroupSID(gid uint32) *SID  // REPLACE with SIDMapper.GroupSID
func PrincipalToSID(who string, fileOwnerUID, fileOwnerGID uint32) *SID  // REFACTOR to use SIDMapper
func isDittoFSUserSID(sid *SID) (rid uint32, ok bool)  // REPLACE with SIDMapper.UIDFromSID
func SIDToPrincipal(sid *SID) string  // REFACTOR to use SIDMapper
func sidToUID(sid *SID) uint32  // REPLACE with SIDMapper.UIDFromSID
```

From pkg/controlplane/store/interface.go:
```go
type SettingsStore interface {
    GetSetting(ctx context.Context, key string) (string, error)
    SetSetting(ctx context.Context, key, value string) error
    DeleteSetting(ctx context.Context, key string) error
    ListSettings(ctx context.Context) ([]*models.Setting, error)
}
```

Well-known SIDs currently hardcoded in security.go (lines 220-237):
```go
var wellKnownSIDs = map[string]*SID{
    "EVERYONE@": parseSIDMust("S-1-1-0"),
    "OWNER@":    parseSIDMust("S-1-3-0"),
    "GROUP@":    parseSIDMust("S-1-3-1"),
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pkg/auth/sid/ package with SID types, mapper, and well-known SIDs</name>
  <files>
    pkg/auth/sid/sid.go
    pkg/auth/sid/mapper.go
    pkg/auth/sid/wellknown.go
    pkg/auth/sid/sid_test.go
  </files>
  <action>
Create the shared SID package by extracting and extending code from `internal/adapter/smb/v2/handlers/security.go`:

**pkg/auth/sid/sid.go:**
- Move `SID` struct (Revision, SubAuthorityCount, IdentifierAuthority, SubAuthorities) from security.go
- Move `SIDSize`, `EncodeSID`, `DecodeSID`, `FormatSID`, `ParseSIDString` functions from security.go
- Keep the same implementation — these are tested and working. Only change the package declaration.
- Add `Equal(other *SID) bool` method for SID comparison (will be needed by Plan 03).

**pkg/auth/sid/mapper.go:**
- Create `SIDMapper` struct with `machineSID [3]uint32` field for the three sub-authorities of the domain SID.
- `NewSIDMapper(a, b, c uint32) *SIDMapper` — creates mapper from explicit sub-authority values.
- `NewSIDMapperFromString(sidStr string) (*SIDMapper, error)` — parses a machine SID string like `S-1-5-21-{a}-{b}-{c}` and extracts the three sub-authorities.
- `GenerateMachineSID() *SIDMapper` — generates random 3x uint32 sub-authorities using `crypto/rand`.
- `MachineSIDString() string` — returns the machine SID as `S-1-5-21-{a}-{b}-{c}` for persistence.
- `UserSID(uid uint32) *SID` — if uid==0 return `WellKnownAdministrators`; otherwise RID = uid*2+1000, return full SID with machine sub-authorities + RID.
- `GroupSID(gid uint32) *SID` — RID = gid*2+1001, return full SID with machine sub-authorities + RID.
- `UIDFromSID(sid *SID) (uint32, bool)` — check if SID matches machine domain, RID >= 1000, (RID-1000) is even. Return (RID-1000)/2.
- `GIDFromSID(sid *SID) (uint32, bool)` — check if SID matches machine domain, RID >= 1001, (RID-1001) is even. Return (RID-1001)/2.
- `IsDomainSID(sid *SID) bool` — check if SID has authority [0,0,0,0,0,5], sub-authority count == 5, first sub-authority == 21, and sub-authorities [1-3] match machine SID.
- `PrincipalToSID(who string, fileOwnerUID, fileOwnerGID uint32) *SID` — replacement for the function in security.go. Maps "OWNER@" -> UserSID(fileOwnerUID), "GROUP@" -> GroupSID(fileOwnerGID), "EVERYONE@" -> WellKnownEveryone. For "user@domain" strings, parse UID from the user part if numeric, otherwise return a generic SID.
- `SIDToPrincipal(sid *SID) string` — reverse: check well-known SIDs first, then UIDFromSID -> "OWNER@" or numeric user, GIDFromSID -> "GROUP@", else format as SID string.

**pkg/auth/sid/wellknown.go:**
- Define well-known SID constants as package-level variables:
  - `WellKnownEveryone` = S-1-1-0 (maps to EVERYONE@)
  - `WellKnownCreatorOwner` = S-1-3-0 (maps to OWNER@)
  - `WellKnownCreatorGroup` = S-1-3-1 (maps to GROUP@)
  - `WellKnownAnonymous` = S-1-5-7 (anonymous/guest connections)
  - `WellKnownSystem` = S-1-5-18 (NT AUTHORITY\SYSTEM)
  - `WellKnownAdministrators` = S-1-5-32-544 (BUILTIN\Administrators)
  - `WellKnownAuthenticatedUsers` = S-1-5-11 (optional, for future use)
- `WellKnownName(sid *SID) (string, bool)` — returns display name for well-known SIDs (e.g., "Everyone", "NT AUTHORITY\\SYSTEM", "BUILTIN\\Administrators").
- Move the `wellKnownSIDs` map from security.go and extend it.

**pkg/auth/sid/sid_test.go:**
- Port existing tests from `security_test.go` (TestSIDEncodeDecodeRoundTrip, TestPrincipalToSID, TestSIDToPrincipal) to use the new package.
- Add tests for SIDMapper:
  - `TestUserSIDRIDMapping`: UID 1000 -> RID 3000, UID 0 -> Administrators.
  - `TestGroupSIDRIDMapping`: GID 1000 -> RID 3001 (different from user RID 3000).
  - `TestNoCollision`: verify UserSID(n).Equal(GroupSID(n)) == false for various n.
  - `TestUIDFromSIDRoundTrip`: UserSID(uid) -> UIDFromSID -> same uid.
  - `TestGIDFromSIDRoundTrip`: GroupSID(gid) -> GIDFromSID -> same gid.
  - `TestUIDFromSIDRejectsGroupSID`: UIDFromSID(GroupSID(1000)) returns false.
  - `TestGIDFromSIDRejectsUserSID`: GIDFromSID(UserSID(1000)) returns false.
  - `TestMachineSIDPersistence`: GenerateMachineSID -> MachineSIDString -> NewSIDMapperFromString -> verify UserSID produces same result.
  - `TestAnonymousMapping`: verify guest/anonymous uses WellKnownAnonymous.
  - `TestWellKnownNames`: verify WellKnownName returns correct display names.
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs-phase-30 && go test ./pkg/auth/sid/ -v -count=1</automated>
  </verify>
  <done>
    - pkg/auth/sid/ package exists with SID, SIDMapper, well-known SIDs
    - All tests pass including RID collision prevention
    - Machine SID generation and persistence round-trip works
    - UID 0 maps to BUILTIN\Administrators
    - UserSID(1000) != GroupSID(1000)
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor security.go to use pkg/auth/sid/ and persist machine SID at startup</name>
  <files>
    internal/adapter/smb/v2/handlers/security.go
    internal/adapter/smb/v2/handlers/security_test.go
    pkg/controlplane/runtime/lifecycle/lifecycle.go
  </files>
  <action>
**Refactor security.go:**
- Remove the `SID` struct and all SID-related functions (EncodeSID, DecodeSID, FormatSID, ParseSIDString, SIDSize, PrincipalToSID, SIDToPrincipal, makeDittoFSUserSID, makeDittoFSGroupSID, isDittoFSUserSID, sidToUID, parseSIDMust, wellKnownSIDs map) from security.go.
- Add import for `"github.com/marmos91/dittofs/pkg/auth/sid"`.
- Replace all internal references:
  - `SID` -> `sid.SID`
  - `EncodeSID(buf, s)` -> `sid.EncodeSID(buf, s)`
  - `DecodeSID(data)` -> `sid.DecodeSID(data)`
  - `FormatSID(s)` -> `sid.FormatSID(s)`
  - `SIDSize(s)` -> `sid.SIDSize(s)`
  - `PrincipalToSID(who, uid, gid)` -> `sidMapper.PrincipalToSID(who, uid, gid)` where sidMapper is a package-level `*sid.SIDMapper`.
  - `SIDToPrincipal(s)` -> `sidMapper.SIDToPrincipal(s)` or `sid.SIDToPrincipal(s)` if made a standalone function.
  - `makeDittoFSUserSID(uid)` -> `sidMapper.UserSID(uid)`
  - `makeDittoFSGroupSID(gid)` -> `sidMapper.GroupSID(gid)`
  - `isDittoFSUserSID(s)` -> `sidMapper.UIDFromSID(s)`
  - `sidToUID(s)` -> use `sidMapper.UIDFromSID(s)` or `sidMapper.GIDFromSID(s)`.
- The `sidMapper` needs to be accessible by the security descriptor building functions. Add a package-level `var defaultSIDMapper *sid.SIDMapper` and a `SetSIDMapper(m *sid.SIDMapper)` function that the lifecycle startup code calls.
- Keep `BuildSecurityDescriptor`, `ParseSecurityDescriptor`, `buildDACL`, `parseDACL`, and other SD functions in security.go — they are SMB-specific wire format code that stays here for now (Plan 03 will modify buildDACL to use the new synthesis).
- Remove the `wellKnownSIDs` map (now in `pkg/auth/sid/wellknown.go`). Update `PrincipalToSID` call sites to use the mapper.
- Keep the security information constants (OwnerSecurityInformation etc.) and ACE type mapping functions (nfsToWindowsACEType, windowsToNFSACEType) in security.go — they are SMB-specific.

**Update security_test.go:**
- Remove tests that are now in `pkg/auth/sid/sid_test.go` (SID round-trip, principal mapping).
- Keep tests that exercise BuildSecurityDescriptor/ParseSecurityDescriptor since those stay.
- Update remaining tests to import `sid` package types.
- Add a `TestInit` or `TestMain` that sets up a default SIDMapper for tests (using a fixed machine SID for deterministic results).

**Machine SID persistence in lifecycle.go:**
- In the `Serve()` method (or the startup sequence), BEFORE starting any adapters:
  1. Call `store.GetSetting(ctx, "machine_sid")` using the SettingsStore.
  2. If empty (first boot): call `sid.GenerateMachineSID()`, persist with `store.SetSetting(ctx, "machine_sid", mapper.MachineSIDString())`.
  3. If non-empty: call `sid.NewSIDMapperFromString(storedSID)` to reconstruct the mapper.
  4. Store the mapper on the Runtime or pass it to the SMB adapter via a method (e.g., `adapter.SetSIDMapper(mapper)`).
- The lifecycle sub-service has access to the Runtime which has access to the control plane Store. Check how lifecycle.go currently accesses the store and follow the same pattern.
- The SIDMapper must be initialized BEFORE any connections are accepted to prevent race conditions (Pitfall 4 from research).
- If the SMB adapter has a method to accept the SIDMapper, use it. Otherwise, expose the mapper via a setter on the handlers package that the adapter calls during setup. The simplest approach: package-level `handlers.SetSIDMapper(mapper)` called from the SMB adapter's `Serve()` method, which gets the mapper from the Runtime.
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs-phase-30 && go test ./internal/adapter/smb/v2/handlers/ -v -count=1 -run "Test.*Security|Test.*SID|Test.*SD"</automated>
  </verify>
  <done>
    - security.go no longer contains SID struct or SID functions (moved to pkg/auth/sid/)
    - security.go imports and uses pkg/auth/sid/ for all SID operations
    - Machine SID is generated at first boot and persisted in SettingsStore
    - On subsequent boots, machine SID is loaded from SettingsStore
    - All existing security descriptor tests still pass
    - `go build ./...` succeeds with no import cycle errors
    - `go vet ./...` passes
  </done>
</task>

</tasks>

<verification>
```bash
# All SID package tests pass
go test ./pkg/auth/sid/ -v -count=1

# Security handler tests pass after refactoring
go test ./internal/adapter/smb/v2/handlers/ -v -count=1

# No import cycles
go build ./...

# Static analysis clean
go vet ./...
```
</verification>

<success_criteria>
1. `pkg/auth/sid/` package exists and is importable by both SMB and NFS adapter code
2. SIDMapper produces different SIDs for same UID/GID value (collision fix)
3. Machine SID is persisted and stable across restarts
4. All existing tests pass after refactoring
5. No regressions in `go build ./...`
</success_criteria>

<output>
After completion, create `.planning/phases/31-windows-acl-support/31-01-SUMMARY.md`
</output>
