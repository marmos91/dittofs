---
phase: 31-windows-acl-support
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/metadata/acl/synthesize.go
  - pkg/metadata/acl/synthesize_test.go
  - pkg/metadata/acl/types.go
  - pkg/metadata/acl/flags.go
  - pkg/metadata/acl/flags_test.go
autonomous: true
requirements:
  - SD-01
  - SD-02
  - SD-03
  - SD-04
  - SD-05

must_haves:
  truths:
    - "POSIX mode 0755 directory produces DACL with deny ACEs for group/other write restrictions"
    - "ACEs are always in canonical Windows order (explicit deny -> explicit allow -> inherited deny -> inherited allow)"
    - "Well-known SIDs (SYSTEM, Administrators) get full access in synthesized DACLs"
    - "Directory ACEs have CONTAINER_INHERIT_ACE and OBJECT_INHERIT_ACE flags"
    - "ACE flag translation correctly maps NFSv4 INHERITED_ACE 0x80 to Windows 0x10 and vice versa"
    - "ACL source tracking distinguishes posix-derived, smb-explicit, and nfs-explicit origins"
  artifacts:
    - path: "pkg/metadata/acl/synthesize.go"
      provides: "SynthesizeFromMode, rwxToFullMask, DeriveMode (best-effort reverse)"
      exports: ["SynthesizeFromMode", "ACLSource", "ACLSourcePOSIXDerived", "ACLSourceSMBExplicit", "ACLSourceNFSExplicit"]
    - path: "pkg/metadata/acl/synthesize_test.go"
      provides: "Tests for POSIX-to-DACL synthesis covering mode 0755, 0750, 0644, 0000, 0777"
    - path: "pkg/metadata/acl/flags.go"
      provides: "NFSv4-to-Windows and Windows-to-NFSv4 ACE flag translation"
      exports: ["NFSv4FlagsToWindowsFlags", "WindowsFlagsToNFSv4Flags"]
    - path: "pkg/metadata/acl/types.go"
      provides: "Extended ACL type with Source field"
  key_links:
    - from: "pkg/metadata/acl/synthesize.go"
      to: "pkg/metadata/acl/types.go"
      via: "Uses ACE, ACL types and constants"
      pattern: "ACE4_ACCESS_ALLOWED|ACE4_READ_DATA|ACE4_FILE_INHERIT"
    - from: "pkg/metadata/acl/synthesize.go"
      to: "pkg/metadata/acl/validate.go"
      via: "Uses canonical ordering validation"
      pattern: "ValidateACL"
---

<objective>
Implement POSIX-to-DACL synthesis with fine-grained rights mapping, canonical ACE ordering, well-known SID ACEs, directory inheritance flags, and ACE flag translation between NFSv4 and Windows bit positions.

Purpose: Replaces the "Everyone: Full Access" fallback with proper Windows-compatible DACLs that Explorer and icacls can display meaningfully. Also fixes the ACE flag translation bug (SD-04) where INHERITED_ACE was incorrectly truncated.
Output: Extended ACL package with synthesis, flag translation, and source tracking.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-windows-acl-support/31-CONTEXT.md
@.planning/phases/31-windows-acl-support/31-RESEARCH.md

<interfaces>
<!-- Key types and contracts from existing pkg/metadata/acl/ package -->

From pkg/metadata/acl/types.go:
```go
// ACE types
const (
    ACE4_ACCESS_ALLOWED_ACE_TYPE = 0x00000000
    ACE4_ACCESS_DENIED_ACE_TYPE  = 0x00000001
)

// ACE flags
const (
    ACE4_FILE_INHERIT_ACE         = 0x00000001
    ACE4_DIRECTORY_INHERIT_ACE    = 0x00000002
    ACE4_NO_PROPAGATE_INHERIT_ACE = 0x00000004
    ACE4_INHERIT_ONLY_ACE         = 0x00000008
    ACE4_INHERITED_ACE            = 0x00000080  // NOTE: 0x80 in NFSv4, 0x10 in Windows
)

// ACE access mask bits (same bit positions as Windows ACCESS_MASK by design)
const (
    ACE4_READ_DATA         = 0x00000001
    ACE4_WRITE_DATA        = 0x00000002
    ACE4_APPEND_DATA       = 0x00000004
    ACE4_EXECUTE           = 0x00000020
    ACE4_DELETE_CHILD      = 0x00000040
    ACE4_READ_NAMED_ATTRS  = 0x00000008
    ACE4_WRITE_NAMED_ATTRS = 0x00000010
    ACE4_READ_ATTRIBUTES   = 0x00000080
    ACE4_WRITE_ATTRIBUTES  = 0x00000100
    ACE4_DELETE            = 0x00010000
    ACE4_READ_ACL          = 0x00020000
    ACE4_WRITE_ACL         = 0x00040000
    ACE4_WRITE_OWNER       = 0x00080000
    ACE4_SYNCHRONIZE       = 0x00100000
)

// Special identifiers
const (
    SpecialOwner    = "OWNER@"
    SpecialGroup    = "GROUP@"
    SpecialEveryone = "EVERYONE@"
)

type ACE struct {
    Type       uint32 `json:"type"`
    Flag       uint32 `json:"flag"`
    AccessMask uint32 `json:"access_mask"`
    Who        string `json:"who"`
}

type ACL struct {
    ACEs []ACE `json:"aces"`
}
```

From pkg/metadata/acl/validate.go (reuse for canonical ordering):
```go
func ValidateACL(acl *ACL) error  // Validates canonical ordering
// Internal: aceBucket(ace) returns 0-3 for sorting
```

From pkg/metadata/acl/mode.go (existing POSIX mode derivation):
```go
func DeriveMode(acl *ACL) uint32            // ACL -> POSIX mode
func AdjustACLForMode(acl *ACL, newMode uint32) *ACL  // Update ACL when mode changes
```

From pkg/metadata/acl/inherit.go (existing inheritance):
```go
func ComputeInheritedACL(parentACL *ACL, isDirectory bool) *ACL
func PropagateACL(parentACL, existingACL *ACL, isDirectory bool) *ACL
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ACL source tracking and extend types</name>
  <files>
    pkg/metadata/acl/types.go
  </files>
  <action>
Extend the existing `pkg/metadata/acl/types.go` with:

1. **ACLSource enum** — add to `types.go`:
```go
// ACLSource indicates how an ACL was created.
type ACLSource string

const (
    ACLSourcePOSIXDerived ACLSource = "posix-derived"
    ACLSourceSMBExplicit  ACLSource = "smb-explicit"
    ACLSourceNFSExplicit  ACLSource = "nfs-explicit"
)
```

2. **Add Source field to ACL struct** — extend the existing ACL struct:
```go
type ACL struct {
    ACEs   []ACE     `json:"aces"`
    Source ACLSource  `json:"source,omitempty"`
}
```

3. **Add MaxDACLSize constant** for the 64KB Windows DACL size limit:
```go
const MaxDACLSize = 65536 // 64KB Windows default MAX_ACL_SIZE
```

4. **Add SE_DACL_PROTECTED flag tracking** — add a `Protected` field to ACL:
```go
type ACL struct {
    ACEs      []ACE     `json:"aces"`
    Source    ACLSource  `json:"source,omitempty"`
    Protected bool       `json:"protected,omitempty"` // SE_DACL_PROTECTED - blocks inheritance
}
```

These are purely additive changes to the existing struct. The zero value of `Source` (empty string) means "unknown/legacy" which is backward compatible. The zero value of `Protected` (false) means inheritance is allowed, which is the default.

Verify no existing tests break from the struct changes (adding optional fields should not break JSON deserialization of existing data).
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs-phase-30 && go test ./pkg/metadata/acl/ -v -count=1</automated>
  </verify>
  <done>
    - ACL struct has Source and Protected fields
    - ACLSource enum with three values defined
    - MaxDACLSize constant defined
    - All existing ACL tests still pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement POSIX-to-DACL synthesis, ACE flag translation, and tests</name>
  <files>
    pkg/metadata/acl/synthesize.go
    pkg/metadata/acl/synthesize_test.go
    pkg/metadata/acl/flags.go
    pkg/metadata/acl/flags_test.go
  </files>
  <action>
**pkg/metadata/acl/flags.go — ACE flag translation:**

Create explicit bidirectional flag mapping functions. INHERITED_ACE has different bit positions in NFSv4 (0x80) vs Windows (0x10). Direct bit truncation `uint8(flag & 0xFF)` is WRONG for this flag.

```go
func NFSv4FlagsToWindowsFlags(nfsFlags uint32) uint8 {
    var winFlags uint8
    if nfsFlags&ACE4_FILE_INHERIT_ACE != 0         { winFlags |= 0x01 }  // CI
    if nfsFlags&ACE4_DIRECTORY_INHERIT_ACE != 0    { winFlags |= 0x02 }  // OI
    if nfsFlags&ACE4_NO_PROPAGATE_INHERIT_ACE != 0 { winFlags |= 0x04 }  // NP
    if nfsFlags&ACE4_INHERIT_ONLY_ACE != 0         { winFlags |= 0x08 }  // IO
    if nfsFlags&ACE4_INHERITED_ACE != 0            { winFlags |= 0x10 }  // Critical: 0x80 -> 0x10
    return winFlags
}

func WindowsFlagsToNFSv4Flags(winFlags uint8) uint32 {
    var nfsFlags uint32
    if winFlags&0x01 != 0 { nfsFlags |= ACE4_FILE_INHERIT_ACE }
    if winFlags&0x02 != 0 { nfsFlags |= ACE4_DIRECTORY_INHERIT_ACE }
    if winFlags&0x04 != 0 { nfsFlags |= ACE4_NO_PROPAGATE_INHERIT_ACE }
    if winFlags&0x08 != 0 { nfsFlags |= ACE4_INHERIT_ONLY_ACE }
    if winFlags&0x10 != 0 { nfsFlags |= ACE4_INHERITED_ACE }  // Critical: 0x10 -> 0x80
    return nfsFlags
}
```

**pkg/metadata/acl/flags_test.go:**
- Test round-trip: `NFSv4FlagsToWindowsFlags(WindowsFlagsToNFSv4Flags(x)) == x` for all valid flag combinations.
- Test critical case: INHERITED_ACE: `NFSv4FlagsToWindowsFlags(ACE4_INHERITED_ACE)` must equal `0x10`, NOT `0x80`.
- Test combined flags: `ACE4_FILE_INHERIT_ACE | ACE4_DIRECTORY_INHERIT_ACE | ACE4_INHERITED_ACE` -> `0x01 | 0x02 | 0x10 = 0x13`.

**pkg/metadata/acl/synthesize.go — POSIX-to-DACL synthesis:**

Implement the following functions:

1. `rwxToFullMask(rwx uint32, isDirectory bool) uint32` — maps 3-bit rwx to full Windows access rights:
   - Read (4): READ_DATA | READ_ATTRIBUTES | READ_NAMED_ATTRS | READ_ACL | SYNCHRONIZE
   - Write (2): WRITE_DATA | APPEND_DATA | WRITE_ATTRIBUTES | WRITE_NAMED_ATTRS (+ DELETE_CHILD for directories)
   - Execute (1): EXECUTE | READ_ATTRIBUTES | SYNCHRONIZE
   Note: READ_ACL is included in read for consistent permission display.

2. `alwaysGrantedMask` constant: READ_ACL | WRITE_ACL | WRITE_OWNER | DELETE | SYNCHRONIZE (always granted to owner).

3. `SynthesizeFromMode(mode uint32, ownerUID, ownerGID uint32, isDirectory bool) *ACL`:
   - Extract ownerRWX = (mode >> 6) & 7, groupRWX = (mode >> 3) & 7, otherRWX = mode & 7.
   - Compute inheritance flags: if isDirectory, set `ACE4_FILE_INHERIT_ACE | ACE4_DIRECTORY_INHERIT_ACE` on ALL ACEs.
   - Step 1 - DENY ACEs (canonical order: deny before allow):
     - If group has fewer rights than owner: DENY GROUP@ for `rwxToFullMask(ownerRWX &^ groupRWX, isDirectory)`.
     - If other has fewer rights than owner: DENY EVERYONE@ for `rwxToFullMask(ownerRWX &^ otherRWX, isDirectory)`.
   - Step 2 - ALLOW ACEs:
     - ALLOW OWNER@ with `rwxToFullMask(ownerRWX, isDirectory) | alwaysGrantedMask`.
     - ALLOW GROUP@ with `rwxToFullMask(groupRWX, isDirectory)` (only if groupRWX != 0).
     - ALLOW EVERYONE@ with `rwxToFullMask(otherRWX, isDirectory)` (only if otherRWX != 0).
   - Step 3 - Well-known SID ACEs (always present in synthesized DACLs):
     - ALLOW "SYSTEM@" (special identifier for NT AUTHORITY\SYSTEM) with full access mask + inheritance flags.
     - ALLOW "ADMINISTRATORS@" (special identifier for BUILTIN\Administrators) with full access mask + inheritance flags.
     Note: Use the special identifiers as string principals. The SMB translator will convert these to binary SIDs using the well-known SID table. Define `SpecialSystem = "SYSTEM@"` and `SpecialAdministrators = "ADMINISTRATORS@"` constants in types.go.
   - Set Source = ACLSourcePOSIXDerived.
   - Validate canonical ordering with `ValidateACL` before returning.

4. `FullAccessMask` constant — all read + write + execute + admin rights combined:
   ```go
   const FullAccessMask = ACE4_READ_DATA | ACE4_WRITE_DATA | ACE4_APPEND_DATA |
       ACE4_READ_NAMED_ATTRS | ACE4_WRITE_NAMED_ATTRS | ACE4_EXECUTE |
       ACE4_DELETE_CHILD | ACE4_READ_ATTRIBUTES | ACE4_WRITE_ATTRIBUTES |
       ACE4_DELETE | ACE4_READ_ACL | ACE4_WRITE_ACL | ACE4_WRITE_OWNER |
       ACE4_SYNCHRONIZE
   ```

**pkg/metadata/acl/synthesize_test.go — comprehensive test coverage:**

Test cases:
- `TestSynthesizeFromMode_0755_Directory`: Expect deny EVERYONE@ write, allow OWNER@ rwx, allow GROUP@ rx, allow EVERYONE@ rx, allow SYSTEM@ full, allow ADMIN@ full. All ACEs have CI+OI flags.
- `TestSynthesizeFromMode_0750_Directory`: Expect deny GROUP@ write, deny EVERYONE@ rwx, allow OWNER@ rwx, allow GROUP@ rx, allow SYSTEM@ full, allow ADMIN@ full. CI+OI on all.
- `TestSynthesizeFromMode_0644_File`: Expect deny GROUP@ write, deny EVERYONE@ write, allow OWNER@ rw, allow GROUP@ r, allow EVERYONE@ r, allow SYSTEM@ full, allow ADMIN@ full. No CI+OI (not a directory).
- `TestSynthesizeFromMode_0000`: Only SYSTEM@ and ADMIN@ get full access (owner/group/other all zero).
- `TestSynthesizeFromMode_0777`: No deny ACEs (everyone has same rights as owner). Allow OWNER@ rwx, allow GROUP@ rwx, allow EVERYONE@ rwx, allow SYSTEM@ full, allow ADMIN@ full.
- `TestSynthesizeFromMode_0700`: Deny GROUP@ rwx, deny EVERYONE@ rwx, allow OWNER@ rwx, allow SYSTEM@ full, allow ADMIN@ full.
- `TestCanonicalOrdering`: Verify all synthesized ACLs pass `ValidateACL()`.
- `TestInheritanceFlags`: Verify directory ACEs have CI+OI, file ACEs don't.
- `TestSourceTracking`: Verify synthesized ACL has Source = ACLSourcePOSIXDerived.
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs-phase-30 && go test ./pkg/metadata/acl/ -v -count=1</automated>
  </verify>
  <done>
    - SynthesizeFromMode produces correct DACLs for all standard permission modes
    - DENY ACEs correctly generated for restricted group/other permissions
    - Well-known SIDs (SYSTEM, Administrators) always present in synthesized DACLs
    - Directory ACEs have CI+OI inheritance flags, file ACEs do not
    - ACE flag translation correctly maps 0x80 <-> 0x10 for INHERITED_ACE
    - All synthesized ACLs pass canonical ordering validation
    - ACL source tracking works (ACLSourcePOSIXDerived)
  </done>
</task>

</tasks>

<verification>
```bash
# All ACL package tests pass (existing + new)
go test ./pkg/metadata/acl/ -v -count=1

# No import cycles or build errors
go build ./...

# Static analysis
go vet ./...
```
</verification>

<success_criteria>
1. SynthesizeFromMode produces Windows-compatible DACLs for any POSIX mode
2. Fine-grained rights mapping covers all rwx combinations
3. DENY ACEs correctly restrict group/other below owner permissions
4. Well-known SIDs always present in synthesized DACLs
5. ACE flag translation handles INHERITED_ACE bit position difference
6. All DACLs pass canonical ordering validation
7. ACL source tracking distinguishes POSIX-derived from explicit ACLs
</success_criteria>

<output>
After completion, create `.planning/phases/31-windows-acl-support/31-02-SUMMARY.md`
</output>
