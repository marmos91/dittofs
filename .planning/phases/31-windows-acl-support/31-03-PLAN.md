---
phase: 31-windows-acl-support
plan: 03
type: execute
wave: 2
depends_on: ["31-01", "31-02"]
files_modified:
  - internal/adapter/smb/v2/handlers/security.go
  - internal/adapter/smb/v2/handlers/query_info.go
  - internal/adapter/smb/v2/handlers/set_info.go
  - internal/adapter/smb/rpc/pipe.go
  - internal/adapter/smb/rpc/lsarpc.go
  - internal/adapter/smb/rpc/lsarpc_test.go
  - internal/adapter/smb/v2/handlers/security_test.go
autonomous: true
requirements:
  - SD-06
  - SD-08

must_haves:
  truths:
    - "QUERY_INFO with DACL flag returns POSIX-derived DACL instead of Everyone:Full Access when file has no explicit ACL"
    - "QUERY_INFO with SACL flag returns valid empty SACL structure (revision=2, count=0, size=8)"
    - "SE_DACL_AUTO_INHERITED flag is set in SD control when ACEs have INHERITED_ACE flag"
    - "SE_DACL_PROTECTED flag is set when ACL.Protected is true"
    - "SD field byte order follows Windows convention (SACL, DACL, Owner, Group)"
    - "lsarpc named pipe handles LookupSids2 requests and resolves well-known SIDs to display names"
    - "SET_INFO SecurityInformation writes ACL changes to metadata store"
    - "ACE flag translation uses explicit NFSv4FlagsToWindowsFlags (not direct bit truncation)"
  artifacts:
    - path: "internal/adapter/smb/v2/handlers/security.go"
      provides: "Updated BuildSecurityDescriptor with POSIX-derived DACL synthesis, SACL stub, SD control flags, flag translation"
    - path: "internal/adapter/smb/rpc/lsarpc.go"
      provides: "LSA LookupSids2 stub handler for SID-to-name resolution"
      exports: ["LSARPCHandler", "NewLSARPCHandler"]
    - path: "internal/adapter/smb/rpc/pipe.go"
      provides: "Updated IsSupportedPipe and PipeManager to support lsarpc pipe"
  key_links:
    - from: "internal/adapter/smb/v2/handlers/security.go"
      to: "pkg/metadata/acl/synthesize.go"
      via: "SynthesizeFromMode call in buildDACL"
      pattern: "acl\\.SynthesizeFromMode"
    - from: "internal/adapter/smb/v2/handlers/security.go"
      to: "pkg/metadata/acl/flags.go"
      via: "NFSv4FlagsToWindowsFlags in DACL encoding"
      pattern: "acl\\.NFSv4FlagsToWindowsFlags"
    - from: "internal/adapter/smb/v2/handlers/security.go"
      to: "pkg/auth/sid/"
      via: "SIDMapper for principal-to-SID conversion"
      pattern: "sid\\.SIDMapper|sidMapper\\."
    - from: "internal/adapter/smb/rpc/lsarpc.go"
      to: "pkg/auth/sid/"
      via: "SID resolution for LookupSids"
      pattern: "sid\\.WellKnownName|sid\\.DecodeSID"
    - from: "internal/adapter/smb/rpc/pipe.go"
      to: "internal/adapter/smb/rpc/lsarpc.go"
      via: "lsarpc pipe creation"
      pattern: "lsarpc|LSARPCHandler"
---

<objective>
Wire up the new SID mapper and ACL synthesis into SMB QUERY_INFO/SET_INFO handlers, add SD control flags (SE_DACL_AUTO_INHERITED, SE_DACL_PROTECTED), implement SACL empty stub, fix SD field byte ordering, add lsarpc named pipe for Explorer SID-to-name resolution, and add integration tests.

Purpose: Completes the Windows ACL support so Explorer Properties -> Security tab shows real permissions, icacls displays proper DACLs, and SID names are resolved.
Output: Working SMB security descriptor flow with POSIX-derived DACLs, SACL support, and LSA name resolution.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-windows-acl-support/31-CONTEXT.md
@.planning/phases/31-windows-acl-support/31-RESEARCH.md
@.planning/phases/31-windows-acl-support/31-01-SUMMARY.md
@.planning/phases/31-windows-acl-support/31-02-SUMMARY.md

<interfaces>
<!-- Key types and contracts from Plan 01 and Plan 02 outputs -->

From pkg/auth/sid/ (created in Plan 01):
```go
type SID struct { Revision uint8; SubAuthorityCount uint8; IdentifierAuthority [6]byte; SubAuthorities []uint32 }
type SIDMapper struct { machineSID [3]uint32 }
func NewSIDMapper(a, b, c uint32) *SIDMapper
func NewSIDMapperFromString(sidStr string) (*SIDMapper, error)
func (m *SIDMapper) UserSID(uid uint32) *SID
func (m *SIDMapper) GroupSID(gid uint32) *SID
func (m *SIDMapper) UIDFromSID(sid *SID) (uint32, bool)
func (m *SIDMapper) GIDFromSID(sid *SID) (uint32, bool)
func (m *SIDMapper) PrincipalToSID(who string, fileOwnerUID, fileOwnerGID uint32) *SID
func EncodeSID(buf *bytes.Buffer, sid *SID)
func DecodeSID(data []byte) (*SID, int, error)
func FormatSID(sid *SID) string
func SIDSize(sid *SID) int
func WellKnownName(sid *SID) (string, bool)

// Well-known SID constants
var WellKnownEveryone, WellKnownCreatorOwner, WellKnownCreatorGroup *SID
var WellKnownAnonymous, WellKnownSystem, WellKnownAdministrators *SID
```

From pkg/metadata/acl/ (extended in Plan 02):
```go
type ACLSource string
const ACLSourcePOSIXDerived, ACLSourceSMBExplicit, ACLSourceNFSExplicit ACLSource

type ACL struct {
    ACEs      []ACE     `json:"aces"`
    Source    ACLSource  `json:"source,omitempty"`
    Protected bool       `json:"protected,omitempty"`
}

func SynthesizeFromMode(mode uint32, ownerUID, ownerGID uint32, isDirectory bool) *ACL
func NFSv4FlagsToWindowsFlags(nfsFlags uint32) uint8
func WindowsFlagsToNFSv4Flags(winFlags uint8) uint32

const SpecialSystem = "SYSTEM@"
const SpecialAdministrators = "ADMINISTRATORS@"
const FullAccessMask = ...
```

From internal/adapter/smb/rpc/ (existing pipe framework):
```go
type PipeState struct { Name string; Bound bool; Handler *SRVSVCHandler; ReadBuffer *bytes.Buffer }
type PipeManager struct { pipes map[[16]byte]*PipeState; shares []ShareInfo1 }
func IsSupportedPipe(name string) bool  // Currently only supports "srvsvc"
func (pm *PipeManager) CreatePipe(fileID [16]byte, pipeName string) *PipeState
```

From internal/adapter/smb/rpc/srvsvc.go (reference pattern for new handler):
```go
type SRVSVCHandler struct { shares []ShareInfo1 }
func NewSRVSVCHandler(shares []ShareInfo1) *SRVSVCHandler
func (h *SRVSVCHandler) HandleBind(req *BindRequest) []byte
func (h *SRVSVCHandler) HandleRequest(req *Request) []byte
```

From internal/adapter/smb/v2/handlers/security.go (to modify):
```go
func BuildSecurityDescriptor(file *metadata.File, additionalSecInfo uint32) ([]byte, error)
func buildDACL(buf *bytes.Buffer, file *metadata.File)
func ParseSecurityDescriptor(data []byte) (ownerUID *uint32, ownerGID *uint32, fileACL *acl.ACL, err error)
func parseDACL(data []byte) (*acl.ACL, error)
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update BuildSecurityDescriptor with DACL synthesis, SACL stub, SD control flags, and flag translation</name>
  <files>
    internal/adapter/smb/v2/handlers/security.go
    internal/adapter/smb/v2/handlers/query_info.go
    internal/adapter/smb/v2/handlers/set_info.go
    internal/adapter/smb/v2/handlers/security_test.go
  </files>
  <action>
**Update BuildSecurityDescriptor:**

1. **DACL synthesis integration** — Replace the "Everyone: Full Access" fallback in `buildDACL`:
   - If `file.ACL != nil` (explicit ACL exists): encode it as before but use `acl.NFSv4FlagsToWindowsFlags()` for flag translation instead of direct bit truncation `uint8(ace.Flag & 0xFF)`.
   - If `file.ACL == nil`: call `acl.SynthesizeFromMode(file.Mode, file.UID, file.GID, file.Type == metadata.FileTypeDirectory)` to get a proper DACL.
   - When encoding ACEs, map the special principal identifiers to binary SIDs:
     - `SpecialOwner` ("OWNER@") -> `sidMapper.UserSID(file.UID)`
     - `SpecialGroup` ("GROUP@") -> `sidMapper.GroupSID(file.GID)`
     - `SpecialEveryone` ("EVERYONE@") -> `sid.WellKnownEveryone`
     - `SpecialSystem` ("SYSTEM@") -> `sid.WellKnownSystem`
     - `SpecialAdministrators` ("ADMINISTRATORS@") -> `sid.WellKnownAdministrators`
     - Other principals: use `sidMapper.PrincipalToSID(who, file.UID, file.GID)`

2. **SD control flags** — Replace the hardcoded `seSelfRelative | seDACLPresent`:
   - Add new constants:
     ```go
     const (
         seSACLPresent       = 0x0010
         seDACLAutoInherited = 0x0400
         seDACLProtected     = 0x1000
     )
     ```
   - Compute control flags dynamically:
     - Always: `seSelfRelative`
     - If DACL included: `| seDACLPresent`
     - If SACL included: `| seSACLPresent`
     - If any ACE has INHERITED_ACE flag: `| seDACLAutoInherited` (SD-06)
     - If ACL.Protected is true: `| seDACLProtected`

3. **SACL stub** (SD-08) — When `additionalSecInfo & SACLSecurityInformation != 0`:
   - Write a valid empty SACL: revision=2, sbz1=0, size=8 (uint16), count=0 (uint16), sbz2=0 (uint16)
   - Set the SACL offset in the SD header to point to the SACL bytes
   - Set `seSACLPresent` in control flags
   - When SACL not requested: set SACL offset to 0, don't set flag

4. **SD field byte ordering** — Reorder the body section of BuildSecurityDescriptor to emit:
   - SACL (if present) first
   - DACL second
   - Owner SID third
   - Group SID fourth
   - Update the offset calculations in the 20-byte header accordingly
   This matches Windows convention and prevents potential smbtorture byte-level comparison failures (Pitfall 1 from research).

5. **ACE flag translation** — In all places where ACE flags are encoded to wire format, use `acl.NFSv4FlagsToWindowsFlags(ace.Flag)` instead of `uint8(ace.Flag & 0xFF)`. In `parseDACL`, use `acl.WindowsFlagsToNFSv4Flags(winFlags)` instead of `uint32(winFlags)`.

6. **SET_INFO ACL write-back** — In `ParseSecurityDescriptor`:
   - When parsing DACL from SET_INFO, mark the resulting ACL with `Source: acl.ACLSourceSMBExplicit`.
   - When parsing ownership changes, validate the caller has WRITE_OWNER rights (basic check).
   - Use `acl.WindowsFlagsToNFSv4Flags()` for flag translation.

7. **QUERY_INFO handler update** — In `query_info.go`, verify that the QUERY_INFO handler passes the `AdditionalInformation` (secInfo) field correctly to BuildSecurityDescriptor. If it doesn't pass SACL info, update it to pass through all requested security information bits.

**Tests (security_test.go):**
- `TestBuildSD_NilACL_SynthesizesDACL`: Create a file with nil ACL, mode 0755, verify BuildSecurityDescriptor produces DACL with deny+allow ACEs (not Everyone:Full).
- `TestBuildSD_ExplicitACL_UsesExisting`: Create a file with explicit ACL, verify it's encoded directly.
- `TestBuildSD_SACL_EmptyStub`: Request with SACL flag, verify 8-byte empty SACL is present and SE_SACL_PRESENT is set.
- `TestBuildSD_SACL_NotRequested`: Request without SACL flag, verify SACL offset is 0 and flag is not set.
- `TestBuildSD_AutoInherited`: File with inherited ACEs -> SE_DACL_AUTO_INHERITED set.
- `TestBuildSD_Protected`: File with Protected=true -> SE_DACL_PROTECTED set.
- `TestBuildSD_FlagTranslation`: Verify INHERITED_ACE (NFSv4 0x80) encodes as Windows 0x10 in wire format.
- `TestParseSD_RoundTrip`: Build SD, parse it back, verify owner/group/ACL match.
- `TestBuildSD_FieldOrder`: Verify SACL appears before DACL in the binary output (check offsets).
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs-phase-30 && go test ./internal/adapter/smb/v2/handlers/ -v -count=1 -run "Test.*SD|Test.*Security|Test.*SACL|Test.*DACL"</automated>
  </verify>
  <done>
    - BuildSecurityDescriptor returns POSIX-derived DACL when file has no explicit ACL
    - SACL query returns valid 8-byte empty structure with SE_SACL_PRESENT flag
    - SD control flags computed dynamically (AUTO_INHERITED, PROTECTED)
    - ACE flags use explicit translation (INHERITED_ACE 0x80 <-> 0x10)
    - SD field order matches Windows convention (SACL, DACL, Owner, Group)
    - ParseSecurityDescriptor correctly round-trips with new format
    - All tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Add lsarpc named pipe handler and update pipe manager</name>
  <files>
    internal/adapter/smb/rpc/lsarpc.go
    internal/adapter/smb/rpc/lsarpc_test.go
    internal/adapter/smb/rpc/pipe.go
  </files>
  <action>
**internal/adapter/smb/rpc/lsarpc.go — LSA LookupSids2 stub:**

Create a handler following the same pattern as `SRVSVCHandler`:

1. **LSA interface UUID:** `12345778-1234-abcd-ef00-0123456789ab` (standard MS-LSAT UUID).

2. **LSARPCHandler struct:**
   ```go
   type LSARPCHandler struct {
       sidMapper *sid.SIDMapper  // For resolving domain SIDs to usernames
   }
   func NewLSARPCHandler(sidMapper *sid.SIDMapper) *LSARPCHandler
   ```

3. **HandleBind** — Accept the bind request and return BindAck with the LSA interface UUID. Follow the same pattern as SRVSVCHandler.HandleBind.

4. **HandleRequest** — Dispatch based on opnum:
   - **Opnum 44 (LsarOpenPolicy2):** Return a stub policy handle (16 bytes of zeros or a fixed value). Status = 0 (success). This is required before LookupSids2.
   - **Opnum 57 (LsarLookupSids2):** Parse the SID array from the request body, resolve each SID:
     - Well-known SIDs: use `sid.WellKnownName(s)` to get display name (e.g., "Everyone", "NT AUTHORITY\\SYSTEM", "BUILTIN\\Administrators")
     - Machine domain SIDs with user RID: `sidMapper.UIDFromSID(s)` -> name = `"unix_user:{uid}"`
     - Machine domain SIDs with group RID: `sidMapper.GIDFromSID(s)` -> name = `"unix_group:{gid}"`
     - Unknown SIDs: return SID_NAME_UNKNOWN type with the SID string as name
   - Return the response with:
     - ReferencedDomains array (list of domain SIDs referenced by the translated names)
     - TranslatedNames array (name, domain index, SID type for each input SID)
     - Status = 0x00000107 (STATUS_SOME_NOT_MAPPED) if any SIDs were not resolved, 0 if all resolved
   - **Opnum 76 (LsarLookupSids3):** Same as LookupSids2 but without requiring a policy handle in the request. Implement as a pass-through to the same resolution logic.
   - **Opnum 0 (LsarClose):** Return success with zeroed handle.
   - **Other opnums:** Return STATUS_NOT_IMPLEMENTED (0xC0000002) in the RPC response.

5. **Wire format details for LookupSids2 response:**
   - The response is a DCE/RPC response PDU containing:
     - Referenced domains count (uint32) + conformant array of domain entries
     - Each domain: name (NDR unicode string) + SID (NDR SID)
     - Translated names count (uint32) + conformant array of name entries
     - Each name: use type (uint16) + name (NDR unicode string) + domain index (uint32) + flags (uint32)
   - NDR unicode strings: length (uint16) + max_length (uint16) + pointer (uint32) + actual string bytes (UTF-16LE, null-terminated)
   - SID types: SidTypeUser=1, SidTypeGroup=2, SidTypeDomain=3, SidTypeAlias=4, SidTypeWellKnownGroup=5, SidTypeUnknown=8

   Note: NDR encoding is complex. For a minimal working implementation:
   - Pre-build the response bytes by hand following NDR alignment rules (4-byte alignment for pointers, 2-byte for shorts)
   - Start with a simplified response that handles the most common case: Explorer sends 1-3 SIDs for owner/group/well-known
   - Use `binary.LittleEndian` for all integer encoding
   - UTF-16LE strings: use `unicode/utf16` package

**Update pipe.go:**

1. **IsSupportedPipe** — Add lsarpc to the supported pipe names:
   ```go
   func IsSupportedPipe(name string) bool {
       switch name {
       case "srvsvc", "\\srvsvc", "\\pipe\\srvsvc":
           return true
       case "lsarpc", "\\lsarpc", "\\pipe\\lsarpc":
           return true
       default:
           return false
       }
   }
   ```

2. **PipeState** — The current PipeState has a typed `Handler *SRVSVCHandler` field. This needs to be made generic to support multiple handler types. Options:
   - **Option A (preferred):** Define a `PipeHandler` interface:
     ```go
     type PipeHandler interface {
         HandleBind(req *BindRequest) []byte
         HandleRequest(req *Request) []byte
     }
     ```
     Change `PipeState.Handler` from `*SRVSVCHandler` to `PipeHandler`. Both `SRVSVCHandler` and `LSARPCHandler` implement this interface. This is a minor breaking change but only affects `PipeState` usage.
   - Verify `SRVSVCHandler` already has `HandleBind` and `HandleRequest` methods (it does from the codebase analysis).

3. **PipeManager.CreatePipe** — Update to create the correct handler based on pipe name:
   ```go
   func (pm *PipeManager) CreatePipe(fileID [16]byte, pipeName string, sidMapper *sid.SIDMapper) *PipeState {
       var handler PipeHandler
       switch {
       case strings.Contains(pipeName, "lsarpc"):
           handler = NewLSARPCHandler(sidMapper)
       default:
           // ... existing srvsvc handler creation
           handler = NewSRVSVCHandler(sharesCopy)
       }
       pipe := NewPipeState(pipeName, handler)
       pm.pipes[fileID] = pipe
       return pipe
   }
   ```
   Note: Adding the `sidMapper` parameter changes the CreatePipe signature. Update all callers (likely in `create.go` or another handler file). If the sidMapper is not available at the call site, pass it through from the adapter or use the package-level default set in Plan 01.

**Tests (lsarpc_test.go):**
- `TestLSARPC_Bind`: Send bind request with LSA UUID, verify BindAck response.
- `TestLSARPC_OpenPolicy2`: Send OpenPolicy2 request, verify success response with handle.
- `TestLSARPC_LookupSids2_WellKnown`: Send LookupSids2 with S-1-1-0 (Everyone), verify response contains "Everyone" name.
- `TestLSARPC_LookupSids2_DomainUser`: Send with machine SID + user RID, verify "unix_user:{uid}" name.
- `TestLSARPC_LookupSids2_Unknown`: Send with unknown SID, verify SID_NAME_UNKNOWN type.
- `TestLSARPC_Close`: Send Close, verify success.
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs-phase-30 && go test ./internal/adapter/smb/rpc/ -v -count=1 && go test ./internal/adapter/smb/v2/handlers/ -v -count=1</automated>
  </verify>
  <done>
    - lsarpc pipe handler resolves well-known SIDs to display names
    - lsarpc pipe handler resolves machine domain SIDs to unix_user/unix_group names
    - PipeManager supports both srvsvc and lsarpc pipe creation
    - PipeHandler interface allows multiple handler types
    - IsSupportedPipe returns true for lsarpc variants
    - All existing pipe tests still pass
    - `go build ./...` succeeds with no import cycles
    - `go vet ./...` passes
  </done>
</task>

</tasks>

<verification>
```bash
# All handler tests pass
go test ./internal/adapter/smb/v2/handlers/ -v -count=1

# All RPC pipe tests pass
go test ./internal/adapter/smb/rpc/ -v -count=1

# All ACL package tests still pass
go test ./pkg/metadata/acl/ -v -count=1

# All SID package tests still pass
go test ./pkg/auth/sid/ -v -count=1

# Full build succeeds
go build ./...

# Static analysis
go vet ./...

# Full test suite (no regressions)
go test ./... 2>&1 | tail -20
```
</verification>

<success_criteria>
1. QUERY_INFO returns POSIX-derived DACL with proper deny/allow ACEs (not "Everyone: Full Access")
2. SACL queries return valid empty 8-byte structure with SE_SACL_PRESENT flag
3. SE_DACL_AUTO_INHERITED set when ACEs have INHERITED_ACE flag
4. SE_DACL_PROTECTED flag supported and set when ACL.Protected is true
5. ACE flag translation uses explicit mapping (not bit truncation)
6. lsarpc pipe resolves SIDs to display names for Explorer
7. SD binary format follows Windows field ordering convention
8. No regressions in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/31-windows-acl-support/31-03-SUMMARY.md`
</output>
