---
phase: 04-smb-leases
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/metadata/lock/types.go
  - pkg/metadata/lock/lease_types.go
  - pkg/metadata/lock/store.go
  - pkg/metadata/store/memory/locks.go
  - pkg/metadata/store/badger/locks.go
  - pkg/metadata/store/postgres/locks.go
autonomous: true

must_haves:
  truths:
    - "LeaseInfo struct extends EnhancedLock with R/W/H state flags"
    - "Lease state constants match MS-SMB2 spec values (0x01, 0x02, 0x04)"
    - "PersistedLock includes lease fields for persistence"
    - "To/FromPersistedLock conversion preserves lease state"
  artifacts:
    - path: "pkg/metadata/lock/lease_types.go"
      provides: "Lease constants, LeaseInfo struct, helper methods"
      contains: "LeaseStateRead"
    - path: "pkg/metadata/lock/types.go"
      provides: "EnhancedLock extension with Lease field"
      contains: "Lease *LeaseInfo"
    - path: "pkg/metadata/lock/store.go"
      provides: "PersistedLock lease fields"
      contains: "LeaseKey"
  key_links:
    - from: "pkg/metadata/lock/types.go"
      to: "pkg/metadata/lock/lease_types.go"
      via: "LeaseInfo embedded in EnhancedLock"
      pattern: "Lease \\*LeaseInfo"
    - from: "pkg/metadata/lock/store.go"
      to: "pkg/metadata/lock/lease_types.go"
      via: "ToPersistedLock/FromPersistedLock conversion"
      pattern: "lease_key"
---

<objective>
Define SMB lease types and extend the lock persistence layer

Purpose: Establish the data model for SMB2.1+ leases (R/W/H caching) that integrates with the existing unified lock manager. This is the foundation for all lease operations.

Output: LeaseInfo type with R/W/H flags embedded in EnhancedLock, persistence schema supporting lease state, and conversion functions for To/FromPersistedLock.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-smb-leases/04-CONTEXT.md
@.planning/phases/04-smb-leases/04-RESEARCH.md
@.planning/phases/01-locking-infrastructure/01-01-SUMMARY.md

# Key existing files
@pkg/metadata/lock/types.go
@pkg/metadata/lock/store.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lease types and extend EnhancedLock</name>
  <files>
    pkg/metadata/lock/lease_types.go
    pkg/metadata/lock/types.go
  </files>
  <action>
Create `pkg/metadata/lock/lease_types.go` with:

1. **Lease state constants** matching MS-SMB2 2.2.13.2.8:
```go
const (
    LeaseStateNone   uint32 = 0x00
    LeaseStateRead   uint32 = 0x01  // SMB2_LEASE_READ_CACHING
    LeaseStateWrite  uint32 = 0x02  // SMB2_LEASE_WRITE_CACHING
    LeaseStateHandle uint32 = 0x04  // SMB2_LEASE_HANDLE_CACHING
)
```

2. **Valid lease state combinations** (for validation):
- Files: 0, R, RW, RH, RWH (no W-only, no H-only, no WH)
- Directories: 0, R, RH only

3. **LeaseInfo struct**:
```go
type LeaseInfo struct {
    LeaseKey     [16]byte  // Client-generated 128-bit key
    LeaseState   uint32    // Current state (R/W/H flags)
    BreakToState uint32    // Target state during break (0 if not breaking)
    Breaking     bool      // Break in progress awaiting acknowledgment
    Epoch        uint16    // Incremented on state change (SMB3)
    BreakStarted time.Time // When break was initiated (for timeout)
}
```

4. **Helper methods** on LeaseInfo:
- `HasRead() bool` - checks LeaseStateRead flag
- `HasWrite() bool` - checks LeaseStateWrite flag
- `HasHandle() bool` - checks LeaseStateHandle flag
- `IsBreaking() bool` - returns Breaking field
- `StateString() string` - returns "R", "RW", "RWH", etc.
- `IsValidFileState(state uint32) bool` - validates file lease combinations
- `IsValidDirectoryState(state uint32) bool` - validates directory lease combinations

5. **Modify `pkg/metadata/lock/types.go`** to add Lease field to EnhancedLock:
```go
type EnhancedLock struct {
    // ... existing fields ...

    // Lease holds lease-specific state (nil for byte-range locks)
    Lease *LeaseInfo
}
```

6. **Update Clone() method** to deep-copy Lease field if non-nil.

7. **Add IsLease() method** to EnhancedLock:
```go
func (el *EnhancedLock) IsLease() bool {
    return el.Lease != nil
}
```

8. **Extend IsEnhancedLockConflicting()** to handle lease conflicts:
- Lease vs lease: Same LeaseKey = no conflict; different keys with overlapping R/W/H = check conflict matrix
- Lease vs byte-range: Lease with W blocks exclusive byte-range; byte-range exclusive blocks lease W
- Document conflict rules in comments

Do NOT modify the existing byte-range lock conflict behavior. Leases are whole-file (offset=0, length=0) and use different conflict semantics.
  </action>
  <verify>
```bash
cd /Users/marmos91/Projects/dittofs-nfs4 && go build ./pkg/metadata/lock/...
cd /Users/marmos91/Projects/dittofs-nfs4 && go test ./pkg/metadata/lock/... -v -run "Lease"
```
  </verify>
  <done>
- LeaseInfo struct with R/W/H flags exists
- EnhancedLock has Lease field
- Helper methods (HasRead, HasWrite, HasHandle, IsLease) work
- Lease conflict detection integrated
- All existing lock tests still pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend PersistedLock for lease persistence</name>
  <files>
    pkg/metadata/lock/store.go
    pkg/metadata/store/memory/locks.go
    pkg/metadata/store/badger/locks.go
    pkg/metadata/store/postgres/locks.go
  </files>
  <action>
1. **Extend PersistedLock** in `pkg/metadata/lock/store.go`:
```go
type PersistedLock struct {
    // ... existing fields ...

    // Lease fields (nil/empty for byte-range locks)
    LeaseKey     []byte `json:"lease_key,omitempty"`      // 16-byte key
    LeaseState   uint32 `json:"lease_state,omitempty"`    // R/W/H flags
    LeaseEpoch   uint16 `json:"lease_epoch,omitempty"`    // SMB3 epoch
    BreakToState uint32 `json:"break_to_state,omitempty"` // Target during break
    Breaking     bool   `json:"breaking,omitempty"`       // Break in progress
}
```

2. **Update ToPersistedLock()** to include lease fields:
```go
func ToPersistedLock(lock *EnhancedLock, epoch uint64) *PersistedLock {
    pl := &PersistedLock{
        // ... existing field mappings ...
    }

    if lock.Lease != nil {
        pl.LeaseKey = lock.Lease.LeaseKey[:]
        pl.LeaseState = lock.Lease.LeaseState
        pl.LeaseEpoch = lock.Lease.Epoch
        pl.BreakToState = lock.Lease.BreakToState
        pl.Breaking = lock.Lease.Breaking
    }

    return pl
}
```

3. **Update FromPersistedLock()** to restore lease fields:
```go
func FromPersistedLock(pl *PersistedLock) *EnhancedLock {
    el := &EnhancedLock{
        // ... existing field mappings ...
    }

    if len(pl.LeaseKey) == 16 {
        var leaseKey [16]byte
        copy(leaseKey[:], pl.LeaseKey)
        el.Lease = &LeaseInfo{
            LeaseKey:     leaseKey,
            LeaseState:   pl.LeaseState,
            Epoch:        pl.LeaseEpoch,
            BreakToState: pl.BreakToState,
            Breaking:     pl.Breaking,
        }
    }

    return el
}
```

4. **Add LockQuery.IsLease field** for filtering:
```go
type LockQuery struct {
    // ... existing fields ...
    IsLease *bool // nil=any, true=leases only, false=byte-range only
}
```

5. **Update store implementations** (memory, badger, postgres) to handle the new fields:
- Memory store: JSON encoding already handles new fields
- BadgerDB store: JSON encoding already handles new fields
- PostgreSQL store: Add columns to locks table if needed, or rely on JSONB. For simplicity, keep using JSON encoding if that's the current pattern.

6. **Write tests** in `pkg/metadata/lock/store_test.go`:
- Test lease round-trip: create lease EnhancedLock -> ToPersistedLock -> FromPersistedLock -> verify lease fields preserved
- Test non-lease lock still works (Lease field should be nil)
- Test IsLease query filter

Do NOT change existing store implementations beyond what's needed for the new fields. The existing JSON serialization pattern should handle the new optional fields automatically.
  </action>
  <verify>
```bash
cd /Users/marmos91/Projects/dittofs-nfs4 && go build ./pkg/metadata/...
cd /Users/marmos91/Projects/dittofs-nfs4 && go test ./pkg/metadata/lock/... -v
cd /Users/marmos91/Projects/dittofs-nfs4 && go test ./pkg/metadata/store/... -v -run "Lock"
```
  </verify>
  <done>
- PersistedLock has lease fields (LeaseKey, LeaseState, LeaseEpoch, BreakToState, Breaking)
- ToPersistedLock/FromPersistedLock preserve lease state
- Lease query filter works
- All lock persistence tests pass
- Existing byte-range lock tests still pass
  </done>
</task>

</tasks>

<verification>
```bash
# Full test suite for lock package
cd /Users/marmos91/Projects/dittofs-nfs4 && go test ./pkg/metadata/lock/... -v -race

# Store implementations
cd /Users/marmos91/Projects/dittofs-nfs4 && go test ./pkg/metadata/store/... -v -run "Lock"

# Verify no regressions in existing lock functionality
cd /Users/marmos91/Projects/dittofs-nfs4 && go test ./pkg/metadata/... -v -race
```
</verification>

<success_criteria>
- LeaseInfo struct with R/W/H flags and helper methods
- EnhancedLock extended with Lease *LeaseInfo field
- Lease conflict detection integrated into IsEnhancedLockConflicting
- PersistedLock extended with lease persistence fields
- Round-trip conversion (To/FromPersistedLock) preserves lease state
- All existing lock tests pass (no regressions)
- New lease-specific tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-smb-leases/04-01-SUMMARY.md`
</output>
