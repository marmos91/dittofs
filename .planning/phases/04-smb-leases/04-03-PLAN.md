---
phase: 04-smb-leases
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - internal/protocol/smb/v2/handlers/oplock.go
  - internal/protocol/nfs/v3/handlers/read.go
  - internal/protocol/nfs/v3/handlers/write.go
  - internal/protocol/smb/v2/handlers/create.go
  - internal/protocol/smb/v2/handlers/lease_context.go
autonomous: true

must_haves:
  truths:
    - "NFS WRITE triggers SMB Write lease break before proceeding"
    - "NFS READ triggers SMB Write lease break (not Read lease)"
    - "SMB CREATE with lease context requests lease through OplockManager"
    - "Lease break notification sent via SMB2 protocol wire format"
    - "Cross-protocol conflict: NLM exclusive lock blocks SMB Write lease"
  artifacts:
    - path: "internal/protocol/smb/v2/handlers/oplock.go"
      provides: "Cross-protocol break methods"
      contains: "CheckAndBreakForNFSWrite"
    - path: "internal/protocol/smb/v2/handlers/lease_context.go"
      provides: "SMB2 lease context parsing (RqLs/RsLs)"
      contains: "ParseLeaseCreateContext"
    - path: "internal/protocol/nfs/v3/handlers/write.go"
      provides: "NFS write checks for SMB leases"
      contains: "CheckAndBreakForNFSWrite"
  key_links:
    - from: "internal/protocol/nfs/v3/handlers/write.go"
      to: "internal/protocol/smb/v2/handlers/oplock.go"
      via: "OplockManager.CheckAndBreakForNFSWrite"
      pattern: "CheckAndBreakForNFS"
    - from: "internal/protocol/smb/v2/handlers/create.go"
      to: "internal/protocol/smb/v2/handlers/oplock.go"
      via: "OplockManager.RequestLease"
      pattern: "RequestLease"
---

<objective>
Implement cross-protocol break triggering and SMB CREATE lease support

Purpose: Enable cross-protocol visibility where NFS operations trigger SMB lease breaks, and SMB CREATE requests can include lease contexts per SMB2.1+ spec. This completes the lease integration with unified lock manager.

Output: NFS handlers call OplockManager before conflicting operations, SMB CREATE parses lease contexts and requests leases, lease break notifications use correct wire format.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-smb-leases/04-CONTEXT.md
@.planning/phases/04-smb-leases/04-RESEARCH.md
@.planning/phases/04-smb-leases/04-01-SUMMARY.md
@.planning/phases/04-smb-leases/04-02-SUMMARY.md

# Key existing files
@internal/protocol/smb/v2/handlers/oplock.go
@internal/protocol/smb/v2/handlers/create.go
@internal/protocol/nfs/v3/handlers/write.go
@internal/protocol/nfs/v3/handlers/read.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add cross-protocol break triggering from NFS</name>
  <files>
    internal/protocol/smb/v2/handlers/oplock.go
    internal/protocol/nfs/v3/handlers/write.go
    internal/protocol/nfs/v3/handlers/read.go
    pkg/metadata/service.go
  </files>
  <action>
**Add cross-protocol methods to OplockManager** (`internal/protocol/smb/v2/handlers/oplock.go`):

1. **CheckAndBreakForNFSWrite** - Called before NFS WRITE commits:
```go
// CheckAndBreakForNFSWrite checks for SMB leases on a file and triggers breaks.
// Called from NFS v3 WRITE handler before committing the write.
//
// Per CONTEXT.md:
// - NFS write conflicts with Write lease (client has cached writes to flush)
// - NFS write also conflicts with Read lease (cached reads now stale)
// - Returns error if write must wait for lease break acknowledgment
func (m *OplockManager) CheckAndBreakForNFSWrite(
    ctx context.Context,
    fileHandle lock.FileHandle,
) error {
    m.mu.Lock()
    defer m.mu.Unlock()

    // Find all leases on this file
    leases, err := m.findLeasesByHandle(ctx, fileHandle)
    if err != nil {
        return err
    }

    for _, lease := range leases {
        if lease.Lease == nil {
            continue
        }

        // NFS write conflicts with Write lease - client must flush
        if lease.Lease.HasWrite() {
            logger.Debug("Lease: NFS write triggers W lease break",
                "fileHandle", string(fileHandle),
                "leaseKey", fmt.Sprintf("%x", lease.Lease.LeaseKey))

            // Break to R+H (preserve read and handle caching)
            breakTo := lock.LeaseStateRead | lock.LeaseStateHandle
            m.initiateLeaseBreak(lease, breakTo)

            // Write must wait for acknowledgment (up to timeout)
            // Return special error to indicate wait needed
            return ErrLeaseBreakPending
        }

        // NFS write also invalidates Read lease (cached reads now stale)
        if lease.Lease.HasRead() && !lease.Lease.HasWrite() {
            // Read-only lease - break Read but keep Handle if present
            breakTo := lease.Lease.LeaseState &^ lock.LeaseStateRead
            if breakTo != lease.Lease.LeaseState {
                logger.Debug("Lease: NFS write triggers R lease break",
                    "fileHandle", string(fileHandle),
                    "leaseKey", fmt.Sprintf("%x", lease.Lease.LeaseKey))
                m.initiateLeaseBreak(lease, breakTo)
            }
        }
    }

    return nil
}
```

2. **CheckAndBreakForNFSRead** - Called before NFS READ:
```go
// CheckAndBreakForNFSRead checks for SMB leases and triggers breaks if needed.
// Called from NFS v3 READ handler.
//
// Per CONTEXT.md:
// - NFS read only conflicts with Write lease (uncommitted writes)
// - Read lease coexists with NFS reads (no break needed)
func (m *OplockManager) CheckAndBreakForNFSRead(
    ctx context.Context,
    fileHandle lock.FileHandle,
) error {
    m.mu.Lock()
    defer m.mu.Unlock()

    leases, err := m.findLeasesByHandle(ctx, fileHandle)
    if err != nil {
        return err
    }

    for _, lease := range leases {
        if lease.Lease == nil {
            continue
        }

        // NFS read only conflicts with Write lease
        if lease.Lease.HasWrite() {
            logger.Debug("Lease: NFS read triggers W lease break",
                "fileHandle", string(fileHandle),
                "leaseKey", fmt.Sprintf("%x", lease.Lease.LeaseKey))

            // Break W but keep R and H
            breakTo := (lease.Lease.LeaseState | lock.LeaseStateRead) &^ lock.LeaseStateWrite
            m.initiateLeaseBreak(lease, breakTo)
            return ErrLeaseBreakPending
        }

        // Read lease coexists with NFS reads - no break
    }

    return nil
}
```

3. **Add ErrLeaseBreakPending error**:
```go
var ErrLeaseBreakPending = errors.New("lease break pending, operation must wait")
```

4. **Add helper method**:
```go
func (m *OplockManager) findLeasesByHandle(ctx context.Context, fileHandle lock.FileHandle) ([]*lock.EnhancedLock, error) {
    // Check cache first
    if m.cacheValid {
        if leases, ok := m.leaseCache[string(fileHandle)]; ok {
            return leases, nil
        }
    }

    // Query from store
    pls, err := m.lockStore.ListLocks(ctx, lock.LockQuery{
        FileID: string(fileHandle),
    })
    if err != nil {
        return nil, err
    }

    var leases []*lock.EnhancedLock
    for _, pl := range pls {
        if len(pl.LeaseKey) == 16 { // Is a lease
            leases = append(leases, lock.FromPersistedLock(pl))
        }
    }

    // Update cache
    m.leaseCache[string(fileHandle)] = leases
    m.cacheValid = true

    return leases, nil
}
```

**Integrate with NFS handlers:**

5. **Update `internal/protocol/nfs/v3/handlers/write.go`**:
- Add OplockManager parameter to handler or access via runtime
- Call `CheckAndBreakForNFSWrite` before committing write
- Handle ErrLeaseBreakPending by waiting (with timeout) for break acknowledgment
- Use a simple polling approach: check, sleep 100ms, check again, up to 35s

```go
// In WRITE handler, before CommitWrite:
if oplockMgr != nil {
    err := oplockMgr.CheckAndBreakForNFSWrite(ctx, fileHandle)
    if err == handlers.ErrLeaseBreakPending {
        // Wait for lease break (max 35s)
        deadline := time.Now().Add(35 * time.Second)
        for time.Now().Before(deadline) {
            time.Sleep(100 * time.Millisecond)
            err = oplockMgr.CheckAndBreakForNFSWrite(ctx, fileHandle)
            if err != handlers.ErrLeaseBreakPending {
                break
            }
        }
        if err == handlers.ErrLeaseBreakPending {
            // Timeout - force proceed (breaks were force-revoked by scanner)
            logger.Debug("NFS WRITE: lease break timeout, proceeding anyway")
        }
    }
}
```

6. **Update `internal/protocol/nfs/v3/handlers/read.go`**:
- Similar pattern: call CheckAndBreakForNFSRead before read
- Wait for break if pending

7. **Wire OplockManager into NFS adapter**:
- The NFS adapter needs access to OplockManager from SMB
- Option A: Share OplockManager via Runtime
- Option B: Create cross-protocol lease interface in MetadataService
- Recommend Option B: Add `CheckAndBreakLeasesForWrite(ctx, fileHandle)` to MetadataService that delegates to OplockManager if configured

```go
// In pkg/metadata/service.go
type MetadataService struct {
    // ... existing fields ...
    oplockManager interface {
        CheckAndBreakForNFSWrite(ctx context.Context, fileHandle lock.FileHandle) error
        CheckAndBreakForNFSRead(ctx context.Context, fileHandle lock.FileHandle) error
    }
}

func (m *MetadataService) SetOplockManager(mgr interface{...}) {
    m.oplockManager = mgr
}

func (m *MetadataService) CheckAndBreakLeasesForWrite(ctx context.Context, fh []byte) error {
    if m.oplockManager == nil {
        return nil // No SMB adapter, no leases to break
    }
    return m.oplockManager.CheckAndBreakForNFSWrite(ctx, lock.FileHandle(fh))
}
```
  </action>
  <verify>
```bash
cd /Users/marmos91/Projects/dittofs-nfs4 && go build ./internal/protocol/nfs/...
cd /Users/marmos91/Projects/dittofs-nfs4 && go build ./internal/protocol/smb/...
cd /Users/marmos91/Projects/dittofs-nfs4 && go test ./internal/protocol/smb/v2/handlers/... -v -run "Lease"
```
  </verify>
  <done>
- CheckAndBreakForNFSWrite triggers W lease break
- CheckAndBreakForNFSRead triggers W lease break (not R)
- NFS WRITE handler calls cross-protocol check
- NFS READ handler calls cross-protocol check
- ErrLeaseBreakPending enables wait-for-acknowledgment
- MetadataService exposes cross-protocol interface
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement SMB CREATE lease context support</name>
  <files>
    internal/protocol/smb/v2/handlers/lease_context.go
    internal/protocol/smb/v2/handlers/create.go
  </files>
  <action>
**Create `internal/protocol/smb/v2/handlers/lease_context.go`:**

1. **Define lease create context structures** per MS-SMB2 2.2.13.2.8:
```go
// SMB2CreateRequestLeaseV2 is the lease create context (tag "RqLs").
// Used by clients to request a lease on file open.
type SMB2CreateRequestLeaseV2 struct {
    LeaseKey       [16]byte
    LeaseState     uint32   // Requested R/W/H flags
    Flags          uint32   // Reserved (0)
    LeaseDuration  uint64   // Reserved (0)
    ParentLeaseKey [16]byte // SMB3: parent directory lease
    Epoch          uint16   // SMB3: expected epoch
    Reserved       uint16
}

// SMB2CreateResponseLeaseV2 is the lease response context (tag "RsLs").
// Returned by server with granted lease state.
type SMB2CreateResponseLeaseV2 struct {
    LeaseKey       [16]byte
    LeaseState     uint32   // Granted R/W/H flags
    Flags          uint32   // SMB2_LEASE_FLAG_BREAK_IN_PROGRESS if breaking
    LeaseDuration  uint64   // Reserved (0)
    ParentLeaseKey [16]byte // Echoed from request
    Epoch          uint16   // Current epoch
    Reserved       uint16
}
```

2. **Parse lease create context**:
```go
const (
    LeaseContextTagRequest  = "RqLs" // Request lease
    LeaseContextTagResponse = "RsLs" // Response lease
    LeaseContextV2Size      = 52     // Bytes for V2 context
)

func ParseLeaseCreateContext(data []byte) (*SMB2CreateRequestLeaseV2, error) {
    if len(data) < LeaseContextV2Size {
        return nil, fmt.Errorf("lease context too short: %d < %d", len(data), LeaseContextV2Size)
    }

    ctx := &SMB2CreateRequestLeaseV2{
        LeaseState:    binary.LittleEndian.Uint32(data[16:20]),
        Flags:         binary.LittleEndian.Uint32(data[20:24]),
        LeaseDuration: binary.LittleEndian.Uint64(data[24:32]),
        Epoch:         binary.LittleEndian.Uint16(data[48:50]),
    }
    copy(ctx.LeaseKey[:], data[0:16])
    copy(ctx.ParentLeaseKey[:], data[32:48])

    return ctx, nil
}
```

3. **Encode lease response context**:
```go
func (r *SMB2CreateResponseLeaseV2) Encode() []byte {
    buf := make([]byte, LeaseContextV2Size)
    copy(buf[0:16], r.LeaseKey[:])
    binary.LittleEndian.PutUint32(buf[16:20], r.LeaseState)
    binary.LittleEndian.PutUint32(buf[20:24], r.Flags)
    binary.LittleEndian.PutUint64(buf[24:32], r.LeaseDuration)
    copy(buf[32:48], r.ParentLeaseKey[:])
    binary.LittleEndian.PutUint16(buf[48:50], r.Epoch)
    // bytes 50-52 reserved
    return buf
}
```

4. **Add lease break notification encoding** (MS-SMB2 2.2.23.2):
```go
const (
    SMB2NotifyBreakLeaseAckRequired uint32 = 0x01
)

type SMB2LeaseBreakNotification struct {
    StructureSize     uint16   // 44
    NewEpoch          uint16
    Flags             uint32   // SMB2_NOTIFY_BREAK_LEASE_FLAG_ACK_REQUIRED
    LeaseKey          [16]byte
    CurrentLeaseState uint32
    NewLeaseState     uint32
}

func (n *SMB2LeaseBreakNotification) Encode() []byte {
    buf := make([]byte, 44)
    binary.LittleEndian.PutUint16(buf[0:2], 44)
    binary.LittleEndian.PutUint16(buf[2:4], n.NewEpoch)
    binary.LittleEndian.PutUint32(buf[4:8], n.Flags)
    copy(buf[8:24], n.LeaseKey[:])
    binary.LittleEndian.PutUint32(buf[24:28], n.CurrentLeaseState)
    binary.LittleEndian.PutUint32(buf[28:32], n.NewLeaseState)
    // bytes 32-44 reserved
    return buf
}
```

5. **Add lease break acknowledgment parsing** (MS-SMB2 2.2.24.2):
```go
type SMB2LeaseBreakAcknowledgment struct {
    StructureSize uint16
    Reserved      uint16
    Flags         uint32
    LeaseKey      [16]byte
    LeaseState    uint32
}

func ParseLeaseBreakAcknowledgment(data []byte) (*SMB2LeaseBreakAcknowledgment, error) {
    if len(data) < 36 {
        return nil, fmt.Errorf("lease break ack too short: %d < 36", len(data))
    }

    structSize := binary.LittleEndian.Uint16(data[0:2])
    if structSize != 36 {
        return nil, fmt.Errorf("invalid lease break ack structure size: %d", structSize)
    }

    ack := &SMB2LeaseBreakAcknowledgment{
        StructureSize: structSize,
        Reserved:      binary.LittleEndian.Uint16(data[2:4]),
        Flags:         binary.LittleEndian.Uint32(data[4:8]),
        LeaseState:    binary.LittleEndian.Uint32(data[24:28]),
    }
    copy(ack.LeaseKey[:], data[8:24])

    return ack, nil
}
```

**Update `internal/protocol/smb/v2/handlers/create.go`:**

6. **Process lease create context in CREATE handler**:
- Look for "RqLs" create context in request
- If found, parse lease context
- Call OplockManager.RequestLease with parsed parameters
- Add "RsLs" response context with granted state

```go
// In handleCreate, after file is opened:
func (h *CreateHandler) handleCreate(ctx context.Context, req *CreateRequest) (*CreateResponse, error) {
    // ... existing create logic ...

    // Process lease create context
    var leaseResponse *SMB2CreateResponseLeaseV2
    if leaseCtx := findCreateContext(req.CreateContexts, LeaseContextTagRequest); leaseCtx != nil {
        leaseReq, err := ParseLeaseCreateContext(leaseCtx.Data)
        if err != nil {
            logger.Debug("CREATE: invalid lease context", "error", err)
        } else {
            // Request lease through OplockManager
            grantedState, epoch, err := h.oplockMgr.RequestLease(
                ctx,
                fileHandle,
                leaseReq.LeaseKey,
                sessionID,
                clientID,
                shareName,
                leaseReq.LeaseState,
                isDirectory,
            )
            if err != nil {
                logger.Debug("CREATE: lease request failed", "error", err)
                grantedState = lock.LeaseStateNone
            }

            // Build response context
            leaseResponse = &SMB2CreateResponseLeaseV2{
                LeaseKey:       leaseReq.LeaseKey,
                LeaseState:     grantedState,
                ParentLeaseKey: leaseReq.ParentLeaseKey,
                Epoch:          epoch,
            }
        }
    }

    // If no lease context but oplock requested, use existing oplock path
    // ... existing oplock handling ...

    // Add lease response context if present
    if leaseResponse != nil {
        resp.CreateContexts = append(resp.CreateContexts, CreateContext{
            Name: LeaseContextTagResponse,
            Data: leaseResponse.Encode(),
        })
    }

    return resp, nil
}
```

7. **Implement LeaseBreakNotifier** in SMB session/connection:
- When OplockManager calls SendLeaseBreak, encode notification and send on connection
- Handle lease break acknowledgment (SMB2_OPLOCK_BREAK with lease flag)

8. **Add tests** for lease context parsing and encoding in `internal/protocol/smb/v2/handlers/lease_context_test.go`
  </action>
  <verify>
```bash
cd /Users/marmos91/Projects/dittofs-nfs4 && go build ./internal/protocol/smb/...
cd /Users/marmos91/Projects/dittofs-nfs4 && go test ./internal/protocol/smb/v2/handlers/... -v
cd /Users/marmos91/Projects/dittofs-nfs4 && go build ./...
```
  </verify>
  <done>
- Lease create context (RqLs/RsLs) parsing and encoding works
- SMB CREATE with lease context requests lease via OplockManager
- Lease break notification encoding per MS-SMB2 2.2.23.2
- Lease break acknowledgment parsing per MS-SMB2 2.2.24.2
- CREATE response includes granted lease state
- All SMB tests pass
  </done>
</task>

</tasks>

<verification>
```bash
# Full build
cd /Users/marmos91/Projects/dittofs-nfs4 && go build ./...

# All tests with race detector
cd /Users/marmos91/Projects/dittofs-nfs4 && go test ./... -race

# Specific test suites
cd /Users/marmos91/Projects/dittofs-nfs4 && go test ./internal/protocol/nfs/... -v
cd /Users/marmos91/Projects/dittofs-nfs4 && go test ./internal/protocol/smb/... -v
cd /Users/marmos91/Projects/dittofs-nfs4 && go test ./pkg/metadata/... -v
```
</verification>

<success_criteria>
- NFS WRITE triggers SMB Write lease break before proceeding
- NFS READ triggers SMB Write lease break (Read leases coexist)
- SMB CREATE parses lease context and requests lease
- Lease break notification uses correct MS-SMB2 wire format
- Lease break acknowledgment parsed correctly
- CREATE response includes granted lease state
- Cross-protocol integration: NLM locks visible to lease conflict detection
- All tests pass with race detector
</success_criteria>

<output>
After completion, create `.planning/phases/04-smb-leases/04-03-SUMMARY.md`
</output>
