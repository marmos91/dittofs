---
phase: 04-smb-leases
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - internal/protocol/smb/v2/handlers/oplock.go
  - internal/protocol/smb/v2/handlers/lease.go
  - pkg/metadata/lock/lease_break.go
autonomous: true

must_haves:
  truths:
    - "OplockManager delegates lease acquisition to unified lock manager"
    - "Lease state tracked via EnhancedLock with Lease field, not separate map"
    - "Lease break timer scanner detects expired breaks and force-revokes"
    - "Break timeout is 35 seconds (Windows default, configurable)"
  artifacts:
    - path: "internal/protocol/smb/v2/handlers/oplock.go"
      provides: "Refactored OplockManager with lock manager delegation"
      contains: "lockManager"
    - path: "internal/protocol/smb/v2/handlers/lease.go"
      provides: "Lease-specific SMB handlers (RequestLease, AcknowledgeLeaseBreak)"
      contains: "RequestLease"
    - path: "pkg/metadata/lock/lease_break.go"
      provides: "LeaseBreakScanner for timeout management"
      contains: "LeaseBreakScanner"
  key_links:
    - from: "internal/protocol/smb/v2/handlers/oplock.go"
      to: "pkg/metadata/lock/types.go"
      via: "EnhancedLock with Lease field"
      pattern: "EnhancedLock"
    - from: "pkg/metadata/lock/lease_break.go"
      to: "internal/protocol/smb/v2/handlers/oplock.go"
      via: "Callback on break timeout"
      pattern: "notifyBreakComplete"
---

<objective>
Refactor OplockManager to delegate to unified lock manager and add lease break timer

Purpose: Convert the standalone path-based OplockManager to use the unified lock manager with FileHandle-based keys. This enables cross-protocol visibility (SMB leases visible to NLM) and consistent persistence.

Output: OplockManager refactored to delegate to lock manager, LeaseBreakScanner for timeout management, lease-specific methods (RequestLease, AcknowledgeLeaseBreak).
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-smb-leases/04-CONTEXT.md
@.planning/phases/04-smb-leases/04-RESEARCH.md
@.planning/phases/04-smb-leases/04-01-SUMMARY.md

# Key existing files
@internal/protocol/smb/v2/handlers/oplock.go
@pkg/metadata/lock/types.go
@pkg/metadata/lock/store.go
@pkg/metadata/service.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor OplockManager to delegate to unified lock manager</name>
  <files>
    internal/protocol/smb/v2/handlers/oplock.go
    internal/protocol/smb/v2/handlers/lease.go
  </files>
  <action>
**Refactor `internal/protocol/smb/v2/handlers/oplock.go`:**

1. **Add lock manager dependency** to OplockManager:
```go
type OplockManager struct {
    mu            sync.RWMutex
    lockStore     lock.LockStore         // For persistence
    notify        OplockBreakNotifier    // Existing break notification interface
    leaseNotify   LeaseBreakNotifier     // Lease-specific notifications

    // Active break tracking (for timeout management)
    activeBreaks  map[string]time.Time   // leaseKeyHex -> breakStartTime

    // Quick lookup: FileHandle -> lease EnhancedLocks
    // Populated from lock store on demand, cleared on modification
    leaseCache    map[string][]*lock.EnhancedLock
    cacheValid    bool
}
```

2. **Keep existing OplockBreakNotifier interface** but add LeaseBreakNotifier:
```go
type LeaseBreakNotifier interface {
    SendLeaseBreak(sessionID uint64, leaseKey [16]byte, currentState, newState uint32, epoch uint16) error
}
```

3. **Update NewOplockManager** to accept LockStore:
```go
func NewOplockManager(lockStore lock.LockStore) *OplockManager {
    return &OplockManager{
        lockStore:    lockStore,
        activeBreaks: make(map[string]time.Time),
        leaseCache:   make(map[string][]*lock.EnhancedLock),
    }
}
```

4. **Convert RequestOplock to use leases internally** but maintain API compatibility:
- Map oplock levels to lease states (per RESEARCH.md pattern)
- Level II -> R, Exclusive -> RW, Batch -> RWH
- Create EnhancedLock with Lease field, store via lockStore

5. **Create `internal/protocol/smb/v2/handlers/lease.go`** with lease-specific methods:

```go
// RequestLease acquires a lease through the unified lock manager.
// This is the SMB2.1+ lease API (preferred over oplocks).
func (m *OplockManager) RequestLease(
    ctx context.Context,
    fileHandle lock.FileHandle,
    leaseKey [16]byte,
    sessionID uint64,
    clientID string,
    shareName string,
    requestedState uint32,
    isDirectory bool,
) (grantedState uint32, epoch uint16, err error) {
    m.mu.Lock()
    defer m.mu.Unlock()

    // Validate requested state
    if isDirectory {
        if !lock.IsValidDirectoryLeaseState(requestedState) {
            return lock.LeaseStateNone, 0, nil
        }
    } else {
        if !lock.IsValidFileLeaseState(requestedState) {
            return lock.LeaseStateNone, 0, nil
        }
    }

    // Build owner ID for cross-protocol visibility
    ownerID := fmt.Sprintf("smb:lease:%x", leaseKey)

    // Check for existing lease with same key
    existing := m.findLeaseByKey(ctx, fileHandle, leaseKey)
    if existing != nil {
        // Same lease key - upgrade/maintain (no break to self)
        return m.upgradeLeaseState(ctx, existing, requestedState)
    }

    // Check for conflicting leases (different key)
    if conflict := m.checkLeaseConflict(ctx, fileHandle, requestedState, leaseKey); conflict != nil {
        // Initiate break to conflicting lease holder
        m.initiateLeaseBreak(conflict, m.calculateBreakToState(requestedState))
        return lock.LeaseStateNone, 0, nil // Caller retries after break
    }

    // Grant new lease
    leaseLock := lock.NewEnhancedLock(
        lock.LockOwner{
            OwnerID:   ownerID,
            ClientID:  clientID,
            ShareName: shareName,
        },
        fileHandle,
        0, 0, // Whole file
        lock.LockTypeShared, // Base type
    )
    leaseLock.Lease = &lock.LeaseInfo{
        LeaseKey:   leaseKey,
        LeaseState: requestedState,
        Epoch:      1,
    }

    // Persist
    pl := lock.ToPersistedLock(leaseLock, 0) // epoch 0 for new leases
    if err := m.lockStore.PutLock(ctx, pl); err != nil {
        return lock.LeaseStateNone, 0, err
    }

    m.invalidateCache()
    return requestedState, 1, nil
}
```

6. **Implement helper methods**:
- `findLeaseByKey(ctx, fileHandle, leaseKey)` - query lockStore
- `checkLeaseConflict(ctx, fileHandle, requestedState, excludeKey)` - find conflicting leases
- `calculateBreakToState(requestedState)` - determine break target
- `upgradeLeaseState(ctx, existing, newState)` - handle same-key upgrades/downgrades
- `initiateLeaseBreak(lease, breakToState)` - start break, notify client

7. **Implement AcknowledgeLeaseBreak**:
```go
func (m *OplockManager) AcknowledgeLeaseBreak(
    ctx context.Context,
    leaseKey [16]byte,
    acknowledgedState uint32,
) error {
    m.mu.Lock()
    defer m.mu.Unlock()

    // Find lease by key
    lease := m.findLeaseByKeyGlobal(ctx, leaseKey)
    if lease == nil {
        return fmt.Errorf("no lease with key %x", leaseKey)
    }

    if !lease.Lease.Breaking {
        return fmt.Errorf("no break pending for lease %x", leaseKey)
    }

    // Client must acknowledge to expected level or lower
    if acknowledgedState > lease.Lease.BreakToState {
        return fmt.Errorf("invalid acknowledgment: %d > expected %d",
            acknowledgedState, lease.Lease.BreakToState)
    }

    // Update lease state
    lease.Lease.LeaseState = acknowledgedState
    lease.Lease.Breaking = false
    lease.Lease.BreakToState = 0
    lease.Lease.Epoch++

    // Persist or delete
    if acknowledgedState == lock.LeaseStateNone {
        if err := m.lockStore.DeleteLock(ctx, lease.ID); err != nil {
            return err
        }
    } else {
        pl := lock.ToPersistedLock(lease, 0)
        if err := m.lockStore.PutLock(ctx, pl); err != nil {
            return err
        }
    }

    // Clear break tracking
    delete(m.activeBreaks, fmt.Sprintf("%x", leaseKey))
    m.invalidateCache()

    logger.Debug("Lease: break acknowledged",
        "leaseKey", fmt.Sprintf("%x", leaseKey),
        "newState", lock.LeaseStateString(acknowledgedState))

    return nil
}
```

8. **Keep backward compatibility** for existing oplock code paths - RequestOplock should still work by internally mapping to lease semantics.

9. **Add ReleaseLease method** for file close:
```go
func (m *OplockManager) ReleaseLease(ctx context.Context, leaseKey [16]byte) error
```
  </action>
  <verify>
```bash
cd /Users/marmos91/Projects/dittofs-nfs4 && go build ./internal/protocol/smb/...
cd /Users/marmos91/Projects/dittofs-nfs4 && go test ./internal/protocol/smb/... -v
```
  </verify>
  <done>
- OplockManager has lockStore dependency
- RequestLease creates EnhancedLock with Lease field
- AcknowledgeLeaseBreak updates lease state
- Backward compatible with existing oplock API
- Lease state persisted in LockStore
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement lease break timer scanner</name>
  <files>
    pkg/metadata/lock/lease_break.go
    internal/protocol/smb/v2/handlers/oplock.go
  </files>
  <action>
**Create `pkg/metadata/lock/lease_break.go`:**

1. **Define configuration**:
```go
const (
    // DefaultLeaseBreakTimeout is the Windows default (35 seconds)
    DefaultLeaseBreakTimeout = 35 * time.Second

    // LeaseBreakScanInterval is how often to check for expired breaks
    LeaseBreakScanInterval = 1 * time.Second
)
```

2. **Create LeaseBreakScanner**:
```go
// LeaseBreakCallback is called when a lease break times out
type LeaseBreakCallback interface {
    OnLeaseBreakTimeout(leaseKey [16]byte)
}

// LeaseBreakScanner monitors breaking leases and force-revokes on timeout.
// Per CONTEXT.md: "Force revoke on timeout - don't retry, just revoke and allow conflicting operation"
type LeaseBreakScanner struct {
    lockStore     LockStore
    callback      LeaseBreakCallback
    timeout       time.Duration
    scanInterval  time.Duration

    stop     chan struct{}
    stopped  chan struct{}
    mu       sync.Mutex
    running  bool
}

func NewLeaseBreakScanner(
    lockStore LockStore,
    callback LeaseBreakCallback,
    timeout time.Duration,
) *LeaseBreakScanner {
    if timeout == 0 {
        timeout = DefaultLeaseBreakTimeout
    }
    return &LeaseBreakScanner{
        lockStore:    lockStore,
        callback:     callback,
        timeout:      timeout,
        scanInterval: LeaseBreakScanInterval,
        stop:         make(chan struct{}),
        stopped:      make(chan struct{}),
    }
}
```

3. **Implement Start/Stop**:
```go
func (s *LeaseBreakScanner) Start() {
    s.mu.Lock()
    if s.running {
        s.mu.Unlock()
        return
    }
    s.running = true
    s.stop = make(chan struct{})
    s.stopped = make(chan struct{})
    s.mu.Unlock()

    go s.scanLoop()
}

func (s *LeaseBreakScanner) Stop() {
    s.mu.Lock()
    if !s.running {
        s.mu.Unlock()
        return
    }
    s.running = false
    close(s.stop)
    s.mu.Unlock()

    <-s.stopped
}
```

4. **Implement scan loop**:
```go
func (s *LeaseBreakScanner) scanLoop() {
    defer close(s.stopped)

    ticker := time.NewTicker(s.scanInterval)
    defer ticker.Stop()

    for {
        select {
        case <-s.stop:
            return
        case now := <-ticker.C:
            s.scanExpiredBreaks(now)
        }
    }
}

func (s *LeaseBreakScanner) scanExpiredBreaks(now time.Time) {
    ctx := context.Background()

    // Query all leases that are breaking
    leases, err := s.lockStore.ListLocks(ctx, LockQuery{})
    if err != nil {
        logger.Warn("LeaseBreakScanner: failed to list locks", "error", err)
        return
    }

    for _, pl := range leases {
        // Skip non-leases
        if len(pl.LeaseKey) != 16 {
            continue
        }

        // Skip non-breaking leases
        if !pl.Breaking {
            continue
        }

        // Check if break started time is set and expired
        // BreakStarted is stored in AcquiredAt during break initiation
        breakDeadline := pl.AcquiredAt.Add(s.timeout)
        if now.After(breakDeadline) {
            var leaseKey [16]byte
            copy(leaseKey[:], pl.LeaseKey)

            logger.Debug("LeaseBreakScanner: break timeout expired",
                "leaseKey", fmt.Sprintf("%x", leaseKey),
                "breakStarted", pl.AcquiredAt,
                "deadline", breakDeadline)

            // Force revoke - set state to NONE and clear breaking
            pl.LeaseState = LeaseStateNone
            pl.Breaking = false
            pl.BreakToState = 0

            if err := s.lockStore.DeleteLock(ctx, pl.ID); err != nil {
                logger.Warn("LeaseBreakScanner: failed to delete expired lease",
                    "leaseKey", fmt.Sprintf("%x", leaseKey),
                    "error", err)
                continue
            }

            // Notify callback (allows conflicting operation to proceed)
            if s.callback != nil {
                s.callback.OnLeaseBreakTimeout(leaseKey)
            }
        }
    }
}
```

5. **Update OplockManager to implement LeaseBreakCallback**:
```go
func (m *OplockManager) OnLeaseBreakTimeout(leaseKey [16]byte) {
    m.mu.Lock()
    defer m.mu.Unlock()

    // Remove from active breaks
    delete(m.activeBreaks, fmt.Sprintf("%x", leaseKey))

    // Invalidate cache
    m.invalidateCache()

    logger.Debug("Lease: break timeout force-revoked",
        "leaseKey", fmt.Sprintf("%x", leaseKey))
}
```

6. **Create scanner in OplockManager**:
```go
type OplockManager struct {
    // ... existing fields ...
    scanner *lock.LeaseBreakScanner
}

func (m *OplockManager) StartScanner() {
    if m.scanner == nil {
        m.scanner = lock.NewLeaseBreakScanner(m.lockStore, m, 0)
    }
    m.scanner.Start()
}

func (m *OplockManager) StopScanner() {
    if m.scanner != nil {
        m.scanner.Stop()
    }
}
```

7. **Update initiateLeaseBreak** to track break start time:
```go
func (m *OplockManager) initiateLeaseBreak(lease *lock.EnhancedLock, breakToState uint32) {
    lease.Lease.Breaking = true
    lease.Lease.BreakToState = breakToState
    lease.Lease.Epoch++

    // Track break start time (stored in BreakStarted, persisted via AcquiredAt reuse for simplicity)
    // Actually, let's add BreakStarted to LeaseInfo
    lease.Lease.BreakStarted = time.Now()

    // Persist the breaking state
    pl := lock.ToPersistedLock(lease, 0)
    if err := m.lockStore.PutLock(context.Background(), pl); err != nil {
        logger.Warn("Lease: failed to persist break state", "error", err)
    }

    // Track in active breaks map
    keyHex := fmt.Sprintf("%x", lease.Lease.LeaseKey)
    m.activeBreaks[keyHex] = time.Now()

    // Send break notification async
    if m.leaseNotify != nil {
        go func() {
            if err := m.leaseNotify.SendLeaseBreak(
                // Need sessionID - get from somewhere
                0, // TODO: need to track sessionID in lease
                lease.Lease.LeaseKey,
                lease.Lease.LeaseState,
                breakToState,
                lease.Lease.Epoch,
            ); err != nil {
                logger.Warn("Lease: failed to send break notification", "error", err)
            }
        }()
    }

    m.invalidateCache()
}
```

8. **Add tests** for LeaseBreakScanner in `pkg/metadata/lock/lease_break_test.go`:
- Test scanner starts and stops cleanly
- Test expired break triggers callback
- Test non-breaking leases are not affected
- Test timeout respects configured value
  </action>
  <verify>
```bash
cd /Users/marmos91/Projects/dittofs-nfs4 && go build ./pkg/metadata/lock/...
cd /Users/marmos91/Projects/dittofs-nfs4 && go test ./pkg/metadata/lock/... -v -run "LeaseBreak"
cd /Users/marmos91/Projects/dittofs-nfs4 && go build ./internal/protocol/smb/...
```
  </verify>
  <done>
- LeaseBreakScanner exists with configurable timeout (default 35s)
- Scanner detects breaking leases and force-revokes on timeout
- OplockManager integrates scanner and implements callback
- Break start time tracked for timeout calculation
- Tests verify timeout behavior
  </done>
</task>

</tasks>

<verification>
```bash
# Lock package with lease break
cd /Users/marmos91/Projects/dittofs-nfs4 && go test ./pkg/metadata/lock/... -v -race

# SMB handlers
cd /Users/marmos91/Projects/dittofs-nfs4 && go test ./internal/protocol/smb/... -v

# Full build
cd /Users/marmos91/Projects/dittofs-nfs4 && go build ./...
```
</verification>

<success_criteria>
- OplockManager delegates to unified lock manager via LockStore
- RequestLease creates EnhancedLock with Lease field
- AcknowledgeLeaseBreak transitions state correctly
- LeaseBreakScanner detects expired breaks and force-revokes
- Break timeout configurable (default 35 seconds per Windows behavior)
- Backward compatibility with existing oplock API
- All tests pass with race detector
</success_criteria>

<output>
After completion, create `.planning/phases/04-smb-leases/04-02-SUMMARY.md`
</output>
