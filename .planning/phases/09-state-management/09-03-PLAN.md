---
phase: 09-state-management
plan: 03
type: execute
wave: 3
depends_on: ["09-02"]
files_modified:
  - internal/protocol/nfs/v4/state/lease.go
  - internal/protocol/nfs/v4/state/lease_test.go
  - internal/protocol/nfs/v4/state/manager.go
  - internal/protocol/nfs/v4/handlers/renew.go
  - internal/protocol/nfs/v4/handlers/read.go
  - internal/protocol/nfs/v4/handlers/write.go
  - internal/protocol/nfs/v4/handlers/getattr.go
autonomous: true

must_haves:
  truths:
    - "RENEW extends a client's lease lifetime when called with a valid client ID"
    - "READ/WRITE with non-special stateids implicitly renew the client's lease"
    - "Expired leases trigger cleanup of all client state (client record, open-owners, stateids)"
    - "RENEW with invalid client ID returns NFS4ERR_STALE_CLIENTID"
    - "GETATTR for lease_time attribute returns the configured lease duration"
  artifacts:
    - path: "internal/protocol/nfs/v4/state/lease.go"
      provides: "LeaseState with timer-based expiration and renewal"
      exports: ["LeaseState", "NewLeaseState", "Renew", "IsExpired"]
    - path: "internal/protocol/nfs/v4/state/lease_test.go"
      provides: "Tests for lease renewal, expiration, and cleanup"
      contains: "TestLeaseExpiration"
  key_links:
    - from: "internal/protocol/nfs/v4/handlers/renew.go"
      to: "internal/protocol/nfs/v4/state/manager.go"
      via: "h.StateManager.RenewLease(clientID)"
      pattern: "StateManager\\.RenewLease"
    - from: "internal/protocol/nfs/v4/state/manager.go"
      to: "internal/protocol/nfs/v4/state/lease.go"
      via: "LeaseState created per confirmed client, timer calls onLeaseExpired"
      pattern: "NewLeaseState|onLeaseExpired"
    - from: "internal/protocol/nfs/v4/handlers/read.go"
      to: "internal/protocol/nfs/v4/state/manager.go"
      via: "ValidateStateid implicitly renews lease"
      pattern: "StateManager\\.ValidateStateid"
---

<objective>
Implement lease management with configurable timers, explicit RENEW, implicit renewal on stateid-carrying operations, and automatic state cleanup on expiration.

Purpose: Without lease management, disconnected clients leave stale state forever. Lease timers enable the server to reclaim resources from unresponsive clients after a configurable timeout (default 90s matching Linux nfsd). This also prevents READ-only clients from having their state expire (implicit renewal, per Pitfall 3).

Output: LeaseState type, upgraded RENEW handler, stateid validation with implicit renewal in READ/WRITE, lease_time in GETATTR.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-state-management/09-RESEARCH.md
@.planning/phases/09-state-management/09-02-SUMMARY.md

@internal/protocol/nfs/v4/state/manager.go
@internal/protocol/nfs/v4/state/stateid.go
@internal/protocol/nfs/v4/handlers/renew.go
@internal/protocol/nfs/v4/handlers/read.go
@internal/protocol/nfs/v4/handlers/write.go
@internal/protocol/nfs/v4/handlers/getattr.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement LeaseState and integrate into StateManager</name>
  <files>
    internal/protocol/nfs/v4/state/lease.go
    internal/protocol/nfs/v4/state/manager.go
    internal/protocol/nfs/v4/state/lease_test.go
  </files>
  <action>
**state/lease.go** -- Lease timer and renewal:
- `LeaseState` struct:
  - `ClientID uint64`
  - `Duration time.Duration`
  - `LastRenew time.Time`
  - `Timer *time.Timer`
  - `onExpire func(clientID uint64)` -- callback for cleanup
  - `mu sync.Mutex` -- protects timer reset (separate from StateManager lock to avoid lock ordering issues during timer callback)
- `NewLeaseState(clientID uint64, duration time.Duration, onExpire func(uint64)) *LeaseState`:
  - Creates LeaseState with timer set to fire after `duration`
  - Timer callback calls `onExpire(clientID)`
  - Sets LastRenew to time.Now()
- `Renew()` method:
  - Updates LastRenew to time.Now()
  - Resets timer to fire after Duration
  - Thread-safe (takes mu lock)
- `IsExpired() bool`:
  - Returns `time.Since(ls.LastRenew) > ls.Duration`
- `Stop()` method:
  - Stops the timer (for clean shutdown)
- `RemainingTime() time.Duration`:
  - Returns how much time remains on the lease

**state/manager.go** modifications:
- Add lease creation to `ConfirmClientID()`: after promoting client to confirmed, create `NewLeaseState(clientID, sm.leaseDuration, sm.onLeaseExpired)` and store in `client.Lease`
- Add `onLeaseExpired(clientID uint64)` method on StateManager:
  - Takes the StateManager write lock
  - Looks up client by ID
  - Removes all OpenStates for all owners (delete from openStateByOther map)
  - Removes all OpenOwners (delete from openOwners map)
  - Removes client from clientsByID and clientsByName
  - Logs at INFO level: "NFSv4 client lease expired, cleaning up state"
  - IMPORTANT: The timer goroutine must NOT hold the lease.mu when calling into StateManager (avoid deadlock). The timer callback should be a simple function that calls sm.onLeaseExpired.
- Add `RenewLease(clientID uint64) error` method:
  - Look up client by clientsByID
  - If not found -> NFS4ERR_STALE_CLIENTID (via NFS4StateError)
  - If found and lease exists -> call lease.Renew()
  - Return nil on success
- Modify `ValidateStateid()` (from Plan 09-02) to add lease integration:
  - After successful validation, if the open state has an owner with a client record that has a lease, call `lease.Renew()`. This implements implicit lease renewal (per Pitfall 3).
  - If the lease is expired, return NFS4ERR_EXPIRED
- Add `GetLeaseDuration() time.Duration` getter (for GETATTR)
- Add `Shutdown()` method: stops all active lease timers (for graceful server shutdown)

**state/lease_test.go** tests:
- `TestLeaseRenewal` -- Renew() resets LastRenew timestamp and timer
- `TestLeaseExpiration` -- after duration, onExpire callback fires (use short duration like 50ms for test speed)
- `TestLeaseExpiration_CleansUpAllState` -- verify that open states, owners, and client record are all removed
- `TestLeaseRenewal_PreventsExpiry` -- renew before expiry, verify callback does NOT fire
- `TestRenewLease_StaleClientID` -- unknown client ID returns error
- `TestRenewLease_ValidClient` -- confirmed client lease is renewed
- `TestImplicitRenewal_ViaValidateStateid` -- ValidateStateid on a tracked stateid renews the lease
- `TestLeaseExpired_ReturnsError` -- ValidateStateid on expired client returns NFS4ERR_EXPIRED
- `TestShutdown_StopsTimers` -- Shutdown() stops all active lease timers
- `TestConcurrentRenew` -- multiple goroutines renewing same lease concurrently

All tests use `go test -race -v ./internal/protocol/nfs/v4/state/`.
  </action>
  <verify>
Run `go test -race -v ./internal/protocol/nfs/v4/state/` -- all lease tests pass.
Run `go build ./internal/protocol/nfs/v4/state/` -- compiles.
  </verify>
  <done>LeaseState with timer-based expiration and renewal exists. StateManager creates leases on ConfirmClientID, cleans up all state on expiry. ValidateStateid implicitly renews leases. Shutdown stops all timers.</done>
</task>

<task type="auto">
  <name>Task 2: Upgrade RENEW, READ, WRITE handlers and add lease_time to GETATTR</name>
  <files>
    internal/protocol/nfs/v4/handlers/renew.go
    internal/protocol/nfs/v4/handlers/read.go
    internal/protocol/nfs/v4/handlers/write.go
    internal/protocol/nfs/v4/handlers/getattr.go
  </files>
  <action>
**handlers/renew.go** modifications:
- Replace the stub that always returns NFS4_OK
- Keep existing XDR decode (clientID uint64)
- Call `h.StateManager.RenewLease(clientID)`
- On error (NFS4StateError), return the embedded status code (NFS4ERR_STALE_CLIENTID, NFS4ERR_EXPIRED)
- On success, return NFS4_OK
- Update log: DEBUG for successful renew, INFO for failed renew

**handlers/read.go** modifications:
- Add stateid validation BEFORE the existing read logic:
  1. The handler already decodes stateid4 -- after decoding, call `h.StateManager.ValidateStateid(stateid, ctx.CurrentFH)`
  2. If ValidateStateid returns error, map to NFS4ERR_* and return
  3. If ValidateStateid returns nil, nil (special stateid), proceed with existing logic unchanged
  4. If ValidateStateid returns openState, proceed (the lease was implicitly renewed inside ValidateStateid)
- The existing read logic (PayloadService.ReadAt) remains unchanged
- IMPORTANT per Pitfall 4: special stateids (anonymous, read-bypass) must continue to work. The IsSpecialStateid check inside ValidateStateid handles this.

**handlers/write.go** modifications:
- Same pattern as read.go: add stateid validation after decoding stateid4
- Call `h.StateManager.ValidateStateid(stateid, ctx.CurrentFH)`
- If error, return NFS4ERR_*
- If special stateid (nil, nil return), proceed with existing logic
- If valid openState, check that ShareAccess includes WRITE (OPEN4_SHARE_ACCESS_WRITE=0x02 or OPEN4_SHARE_ACCESS_BOTH=0x03): if read-only open, return NFS4ERR_OPENMODE
- Existing write logic (PrepareWrite/WriteAt/CommitWrite) remains unchanged

**handlers/getattr.go** modifications:
- Find where FATTR4_LEASE_TIME (bit 10) is handled in the attribute encoder
- If the attribute is currently hardcoded or skipped, update it to read from `h.StateManager.GetLeaseDuration()` and encode as uint32 seconds
- The lease_time encoding is: `xdr.WriteUint32(buf, uint32(leaseDuration.Seconds()))`
- Check both pseudo-fs and real-FS attribute encoding paths for this bit
- If `h.StateManager` is nil (test environments without state), use default 90 seconds

Run all handler tests to make sure existing functionality is preserved.
  </action>
  <verify>
Run `go test -race ./internal/protocol/nfs/v4/handlers/` -- all handler tests pass.
Run `go test -race ./internal/protocol/nfs/v4/state/` -- all state tests pass.
Run `go build ./...` -- entire project compiles.
  </verify>
  <done>RENEW validates client ID and renews lease; READ/WRITE validate stateids (special stateids still work, bad stateids rejected); WRITE checks share access mode; GETATTR returns configured lease_time; all existing tests pass.</done>
</task>

</tasks>

<verification>
1. `go test -race ./internal/protocol/nfs/v4/state/` -- all state tests pass (client + stateid + openowner + lease)
2. `go test -race ./internal/protocol/nfs/v4/handlers/` -- all handler tests pass
3. `go build ./...` -- entire project compiles
4. RENEW stub replaced with real lease renewal
5. READ/WRITE with special stateids still work (no regression)
6. Lease expiration cleans up all client state
</verification>

<success_criteria>
- LeaseState fires expiration callback after configured duration
- Renew() resets timer and prevents expiration
- RENEW handler returns NFS4ERR_STALE_CLIENTID for unknown clients
- READ/WRITE validate stateids and implicitly renew leases
- WRITE returns NFS4ERR_OPENMODE for read-only opens
- Special stateids bypass all validation (no regression)
- GETATTR lease_time reflects configured duration
- All lease timer callbacks are race-free
- 10+ lease tests pass with race detection
</success_criteria>

<output>
After completion, create `.planning/phases/09-state-management/09-03-SUMMARY.md`
</output>
