---
phase: 09-state-management
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - internal/protocol/nfs/v4/state/stateid.go
  - internal/protocol/nfs/v4/state/openowner.go
  - internal/protocol/nfs/v4/state/stateid_test.go
  - internal/protocol/nfs/v4/state/openowner_test.go
  - internal/protocol/nfs/v4/state/manager.go
  - internal/protocol/nfs/v4/handlers/open.go
  - internal/protocol/nfs/v4/handlers/close.go
  - internal/protocol/nfs/v4/handlers/stubs.go
autonomous: true

must_haves:
  truths:
    - "OPEN returns a tracked stateid with type-tagged 'other' field"
    - "CLOSE cleans up open state and returns zeroed stateid"
    - "OPEN_CONFIRM promotes unconfirmed open-owner and increments seqid"
    - "Open-owner seqid validation rejects bad seqid and replays cached result for retransmits"
    - "Multiple OPENs from same owner on same file accumulate share_access/share_deny"
  artifacts:
    - path: "internal/protocol/nfs/v4/state/stateid.go"
      provides: "Stateid generation with type-tagged other field, validation, lookup"
      exports: ["GenerateOpenStateid", "ValidateStateid", "GetOpenState"]
    - path: "internal/protocol/nfs/v4/state/openowner.go"
      provides: "OpenOwner with seqid tracking, replay cache, OpenState with share access"
      exports: ["OpenOwner", "OpenState", "CachedResult", "ValidateSeqID"]
    - path: "internal/protocol/nfs/v4/state/stateid_test.go"
      provides: "Tests for stateid generation, validation, special stateid bypass"
      contains: "TestValidateStateid"
    - path: "internal/protocol/nfs/v4/state/openowner_test.go"
      provides: "Tests for seqid validation and replay cache"
      contains: "TestOpenOwnerSeqID"
  key_links:
    - from: "internal/protocol/nfs/v4/handlers/open.go"
      to: "internal/protocol/nfs/v4/state/manager.go"
      via: "h.StateManager.OpenFile() creating tracked state"
      pattern: "StateManager\\.OpenFile|StateManager\\.CreateOpenState"
    - from: "internal/protocol/nfs/v4/handlers/close.go"
      to: "internal/protocol/nfs/v4/state/manager.go"
      via: "h.StateManager.CloseFile() cleaning up state"
      pattern: "StateManager\\.CloseFile|StateManager\\.RemoveOpenState"
---

<objective>
Implement stateid generation/validation and open-owner tracking with seqid validation, then upgrade OPEN/CLOSE/OPEN_CONFIRM handlers to use real state management.

Purpose: Replace Phase 7 placeholder stateids (random bytes, no tracking) and blind OPEN_CONFIRM with proper stateid lifecycle: generation on OPEN, validation on use, cleanup on CLOSE, and per-open-owner seqid validation with replay detection.

Output: Stateid and open-owner types in state package, plus upgraded OPEN/CLOSE/OPEN_CONFIRM/OPEN_DOWNGRADE handlers.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-state-management/09-RESEARCH.md
@.planning/phases/09-state-management/09-01-SUMMARY.md

@internal/protocol/nfs/v4/state/manager.go
@internal/protocol/nfs/v4/state/client.go
@internal/protocol/nfs/v4/handlers/open.go
@internal/protocol/nfs/v4/handlers/close.go
@internal/protocol/nfs/v4/handlers/stubs.go
@internal/protocol/nfs/v4/types/types.go
@internal/protocol/nfs/v4/types/constants.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement stateid generation, OpenState, and OpenOwner with seqid tracking</name>
  <files>
    internal/protocol/nfs/v4/state/stateid.go
    internal/protocol/nfs/v4/state/openowner.go
    internal/protocol/nfs/v4/state/manager.go
  </files>
  <action>
**state/stateid.go** -- Stateid generation and validation:
- Define state type constants: `StateTypeOpen = 0x01`, `StateTypeLock = 0x02`, `StateTypeDeleg = 0x03` (only Open used in Phase 9; Lock and Deleg reserved for Phase 10/11)
- `generateStateidOther(stateType byte) [types.NFS4_OTHER_SIZE]byte` -- type tag (byte 0) + boot epoch fragment (bytes 1-3) + atomic sequence counter (bytes 4-11)
- `ValidateStateid(stateid *types.Stateid4, currentFH []byte) (*OpenState, error)` on StateManager:
  1. Check `IsSpecialStateid()` -- return nil, nil (bypass, per Pitfall 4)
  2. Look up in `openStateByOther` map
  3. If not found -> NFS4ERR_BAD_STATEID
  4. Check boot epoch in "other" field matches current (bytes 1-3) -> NFS4ERR_STALE_STATEID if mismatch
  5. Compare seqid: < current -> NFS4ERR_OLD_STATEID; > current -> NFS4ERR_BAD_STATEID; == current -> OK
  6. Verify filehandle matches open state's FileHandle (if currentFH provided and non-nil) -> NFS4ERR_BAD_STATEID if mismatch
  7. If client lease exists and is expired -> NFS4ERR_EXPIRED (lease integration placeholder -- check if client.Lease != nil and client.Lease.IsExpired(), otherwise skip)
  8. If lease exists and valid, call Renew() for implicit renewal
  9. Return the OpenState
- `isCurrentEpoch(other [NFS4_OTHER_SIZE]byte) bool` helper
- Define `NFS4StateError` struct implementing `error` with `Status uint32` field for handler error mapping

**state/openowner.go** -- OpenOwner and OpenState structs:
- `OpenOwner` struct (expand from Plan 09-01 placeholder):
  - ClientID (uint64), OwnerData ([]byte), LastSeqID (uint32), LastResult (*CachedResult), Confirmed (bool), OpenStates ([]*OpenState), ClientRecord (*ClientRecord)
- `CachedResult` struct: Status (uint32), Data ([]byte) -- for replay cache
- `OpenState` struct:
  - Stateid (types.Stateid4), Owner (*OpenOwner), FileHandle ([]byte), ShareAccess (uint32), ShareDeny (uint32), Confirmed (bool), LockStates (slice, empty for Phase 9)
- `ValidateSeqID(seqid uint32) SeqIDValidation` on OpenOwner:
  - Expected = LastSeqID + 1 (with wrap-around: if LastSeqID == 0xFFFFFFFF, expected = 1, per Pitfall 2)
  - seqid == expected -> SeqIDOK
  - seqid == LastSeqID -> SeqIDReplay
  - else -> SeqIDBad
- `SeqIDValidation` enum type (SeqIDOK, SeqIDReplay, SeqIDBad)
- Helper `nextSeqID(current uint32) uint32` -- handles wrap-around (0xFFFFFFFF wraps to 1, not 0)
- `openOwnerKey` type for map keys: composite of ClientID + hex(OwnerData)
- `makeOwnerKey(clientID uint64, ownerData []byte) openOwnerKey`

**state/manager.go** additions:
- Add fields: `openStateByOther map[[types.NFS4_OTHER_SIZE]byte]*OpenState`, `openOwners map[openOwnerKey]*OpenOwner`, `nextStateSeq uint64`
- Initialize new maps in NewStateManager
- `OpenFile(clientID uint64, ownerData []byte, seqid uint32, fileHandle []byte, shareAccess, shareDeny uint32, claimType uint32) (*OpenFileResult, error)`:
  1. Look up or create OpenOwner for (clientID, ownerData)
  2. Validate seqid (if existing owner): SeqIDReplay -> return cached result; SeqIDBad -> NFS4ERR_BAD_SEQID
  3. Check if owner already has OpenState for this fileHandle: if yes, update share_access |= new, share_deny |= new (accumulation per Pitfall 7)
  4. If new: generate stateid, create OpenState, add to maps
  5. Set OPEN4_RESULT_CONFIRM flag ONLY if owner is not yet confirmed (per RFC 7530 and Research Open Question 2)
  6. Cache result in OpenOwner.LastResult, update LastSeqID
  7. Return OpenFileResult with stateid, rflags, change info
- `ConfirmOpen(stateid *types.Stateid4, seqid uint32) error`:
  1. Look up OpenState by stateid.Other
  2. Validate seqid on the owner
  3. Set OpenState.Confirmed = true, OpenOwner.Confirmed = true
  4. Update seqid and cache
- `CloseFile(stateid *types.Stateid4, seqid uint32) (*types.Stateid4, error)`:
  1. Look up OpenState by stateid.Other
  2. Validate seqid on the owner
  3. Remove OpenState from all maps (openStateByOther, owner's OpenStates list)
  4. If owner has no more OpenStates, clean up owner
  5. Return zeroed stateid
- `DowngradeOpen(stateid *types.Stateid4, seqid uint32, newShareAccess, newShareDeny uint32) error`:
  1. Validate stateid, validate seqid
  2. Verify new access <= existing (can only remove bits, not add)
  3. Update ShareAccess and ShareDeny
  4. Increment stateid seqid
- `OpenFileResult` struct: Stateid (types.Stateid4), RFlags (uint32), ChangeInfo (struct), IsReplay (bool), CachedStatus (uint32), CachedData ([]byte)
  </action>
  <verify>
Run `go build ./internal/protocol/nfs/v4/state/` -- compiles without errors.
Run `go vet ./internal/protocol/nfs/v4/state/` -- no issues.
  </verify>
  <done>StateManager has OpenFile, ConfirmOpen, CloseFile, DowngradeOpen, ValidateStateid methods. Stateids are type-tagged with boot epoch. OpenOwner tracks seqid with replay cache. Special stateids bypass validation.</done>
</task>

<task type="auto">
  <name>Task 2: Upgrade OPEN/CLOSE/OPEN_CONFIRM/OPEN_DOWNGRADE handlers and add tests</name>
  <files>
    internal/protocol/nfs/v4/handlers/open.go
    internal/protocol/nfs/v4/handlers/close.go
    internal/protocol/nfs/v4/handlers/stubs.go
    internal/protocol/nfs/v4/state/stateid_test.go
    internal/protocol/nfs/v4/state/openowner_test.go
  </files>
  <action>
**handlers/open.go** modifications:
- Replace the random stateid generation with `h.StateManager.OpenFile(clientID, ownerData, seqid, fileHandle, shareAccess, shareDeny, claimType)`
- The handler already decodes seqid, share_access, share_deny, owner (clientid + owner opaque), and claim type -- preserve that decode logic
- On replay (IsReplay=true), return the cached result directly
- On error, map NFS4StateError.Status to the response
- Build response with real stateid from OpenFileResult
- Set rflags from OpenFileResult (OPEN4_RESULT_CONFIRM only for new unconfirmed owners)
- Keep existing file creation logic (OPEN4_CREATE with UNCHECKED4/GUARDED4/EXCLUSIVE4)
- Keep existing delegation_type = OPEN_DELEGATE_NONE (Phase 11)

**handlers/open.go** -- handleOpenConfirm modifications:
- Replace the blind seqid+1 echo with `h.StateManager.ConfirmOpen(stateid, seqid)`
- On error, return appropriate NFS4ERR_* status
- On success, encode response with the confirmed stateid (seqid incremented by ConfirmOpen)

**handlers/close.go** modifications:
- Replace the accept-any-stateid + zeroed-response with `h.StateManager.CloseFile(stateid, seqid)`
- On error, map state error to NFS4ERR_*
- On success, return the zeroed stateid from CloseFile

**handlers/stubs.go** modifications:
- Upgrade OPEN_DOWNGRADE from NFS4ERR_NOTSUPP stub to real implementation:
  1. Decode args: stateid4, seqid, share_access, share_deny
  2. Call `h.StateManager.DowngradeOpen(stateid, seqid, newShareAccess, newShareDeny)`
  3. Return updated stateid on success
  4. Return NFS4ERR_INVAL if attempting to add access bits

**state/stateid_test.go** tests:
- `TestGenerateStateidOther_TypeTag` -- type tag byte is correct
- `TestGenerateStateidOther_Uniqueness` -- sequential calls produce unique others
- `TestGenerateStateidOther_BootEpoch` -- bytes 1-3 match boot epoch
- `TestValidateStateid_SpecialBypass` -- anonymous and read-bypass stateids return nil, nil
- `TestValidateStateid_ValidStateid` -- known stateid validates successfully
- `TestValidateStateid_BadStateid` -- unknown other returns NFS4ERR_BAD_STATEID
- `TestValidateStateid_OldSeqid` -- old seqid returns NFS4ERR_OLD_STATEID
- `TestValidateStateid_StaleStateid` -- wrong boot epoch returns NFS4ERR_STALE_STATEID
- `TestValidateStateid_FileHandleMismatch` -- wrong FH returns NFS4ERR_BAD_STATEID

**state/openowner_test.go** tests:
- `TestOpenOwnerSeqID_Increment` -- seqid+1 accepted, others rejected
- `TestOpenOwnerSeqID_Replay` -- same seqid returns SeqIDReplay
- `TestOpenOwnerSeqID_BadSeqid` -- gap in seqid returns SeqIDBad
- `TestOpenOwnerSeqID_WrapAround` -- 0xFFFFFFFF wraps to 1
- `TestOpenFile_NewOwner` -- first OPEN creates owner and state
- `TestOpenFile_ExistingOwnerSameFile` -- share_access OR'd together
- `TestOpenFile_ConfirmFlag` -- first open sets CONFIRM, subsequent don't
- `TestConfirmOpen` -- promotes owner to confirmed
- `TestCloseFile_CleansUp` -- removes from all maps
- `TestCloseFile_LastState_RemovesOwner` -- owner removed when no states left
- `TestDowngradeOpen_RemoveBits` -- successfully downgrades
- `TestDowngradeOpen_AddBits_Fails` -- adding bits returns error

All tests must pass with `go test -race -v ./internal/protocol/nfs/v4/state/`.
Also run `go test -race ./internal/protocol/nfs/v4/handlers/` to verify existing tests still pass.
  </action>
  <verify>
Run `go test -race -v ./internal/protocol/nfs/v4/state/` -- all stateid + openowner tests pass.
Run `go test -race ./internal/protocol/nfs/v4/handlers/` -- all existing handler tests pass (OPEN/CLOSE/io_test.go may need minor updates if they relied on random stateids -- update to create proper state first).
Run `go build ./...` -- entire project compiles.
  </verify>
  <done>OPEN generates tracked stateids via StateManager; CLOSE cleans up state; OPEN_CONFIRM validates and promotes owner; OPEN_DOWNGRADE properly downgrades share access; seqid validation with replay cache works; 20+ state tests pass with race detection; all existing handler tests pass.</done>
</task>

</tasks>

<verification>
1. `go test -race ./internal/protocol/nfs/v4/state/` -- all stateid and openowner tests pass
2. `go test -race ./internal/protocol/nfs/v4/handlers/` -- all handler tests pass (including io_test.go)
3. `go build ./...` -- entire project compiles
4. No random stateid generation remains in open.go
5. OPEN_CONFIRM is no longer a blind seqid echo
6. CLOSE removes state from maps (not just returns zeros)
</verification>

<success_criteria>
- Stateids have type-tagged "other" field with boot epoch
- ValidateStateid rejects stale, old, and bad stateids; accepts special stateids
- OpenOwner tracks seqid with wrap-around at 0xFFFFFFFF
- Replay detection returns cached result for retransmitted operations
- OPEN_CONFIRM only required for first use of an open-owner
- share_access/share_deny accumulate across multiple OPENs on same file
- OPEN_DOWNGRADE can only remove access bits, not add
- 20+ unit tests pass with race detection
</success_criteria>

<output>
After completion, create `.planning/phases/09-state-management/09-02-SUMMARY.md`
</output>
