---
phase: 09-state-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/protocol/nfs/v4/state/manager.go
  - internal/protocol/nfs/v4/state/client.go
  - internal/protocol/nfs/v4/state/client_test.go
  - internal/protocol/nfs/v4/handlers/handler.go
  - internal/protocol/nfs/v4/handlers/setclientid.go
  - internal/protocol/nfs/v4/types/types.go
autonomous: true

must_haves:
  truths:
    - "SETCLIENTID creates an unconfirmed client record with server-generated client ID and confirm verifier"
    - "SETCLIENTID_CONFIRM promotes unconfirmed to confirmed when verifier matches"
    - "Client reboot (same id string, different verifier) replaces confirmed record"
    - "Re-SETCLIENTID (same id string, same verifier) reuses confirmed client"
    - "Replacing unconfirmed record removes previous unconfirmed"
  artifacts:
    - path: "internal/protocol/nfs/v4/state/manager.go"
      provides: "StateManager central coordinator with client tables and boot epoch"
      exports: ["StateManager", "NewStateManager", "SetClientID", "ConfirmClientID"]
    - path: "internal/protocol/nfs/v4/state/client.go"
      provides: "ClientRecord struct and CallbackInfo"
      exports: ["ClientRecord", "CallbackInfo", "SetClientIDResult"]
    - path: "internal/protocol/nfs/v4/state/client_test.go"
      provides: "Unit tests for all five SETCLIENTID cases"
      contains: "TestSetClientID"
  key_links:
    - from: "internal/protocol/nfs/v4/handlers/setclientid.go"
      to: "internal/protocol/nfs/v4/state/manager.go"
      via: "h.StateManager.SetClientID() and h.StateManager.ConfirmClientID()"
      pattern: "StateManager\\.SetClientID|StateManager\\.ConfirmClientID"
    - from: "internal/protocol/nfs/v4/handlers/handler.go"
      to: "internal/protocol/nfs/v4/state/manager.go"
      via: "Handler.StateManager field initialized in NewHandler"
      pattern: "StateManager.*\\*state\\.StateManager"
---

<objective>
Create the NFSv4 StateManager foundation and implement proper SETCLIENTID/SETCLIENTID_CONFIRM with the RFC 7530 five-case algorithm.

Purpose: Replace Phase 6 SETCLIENTID stubs (atomic counter + no-validation confirm) with a real state management layer that tracks client identity, supports reboot detection, and serves as the foundation for all Phase 9 state tracking.

Output: New `internal/protocol/nfs/v4/state/` package with StateManager and ClientRecord types, plus upgraded SETCLIENTID/SETCLIENTID_CONFIRM handlers.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-state-management/09-RESEARCH.md

@internal/protocol/nfs/v4/handlers/handler.go
@internal/protocol/nfs/v4/handlers/setclientid.go
@internal/protocol/nfs/v4/types/types.go
@internal/protocol/nfs/v4/types/constants.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create state package with StateManager and ClientRecord</name>
  <files>
    internal/protocol/nfs/v4/state/manager.go
    internal/protocol/nfs/v4/state/client.go
  </files>
  <action>
Create new package `internal/protocol/nfs/v4/state/` with two files:

**state/client.go** - Client record and related types:
- `ClientRecord` struct: ClientID (uint64), ClientIDString (string), Verifier ([8]byte), ConfirmVerifier ([8]byte), Confirmed (bool), Callback (CallbackInfo), ClientAddr (string), CreatedAt (time.Time), OpenOwners (map[string]*OpenOwner -- empty for now, Phase 09-02 fills in)
- `CallbackInfo` struct: Program (uint32), NetID (string), Addr (string)
- `SetClientIDResult` struct: ClientID (uint64), ConfirmVerifier ([8]byte)
- `VerifierMatches(v [8]byte) bool` method on ClientRecord
- Define `OpenOwner` as a placeholder struct in this file (OwnerData []byte) -- full implementation in Plan 09-02

**state/manager.go** - Central state coordinator:
- `StateManager` struct with:
  - `mu sync.RWMutex` (single lock for all state, per research anti-pattern advice)
  - `clientsByID map[uint64]*ClientRecord`
  - `clientsByName map[string]*ClientRecord` (confirmed clients keyed by nfs_client_id4.id)
  - `unconfirmedByName map[string]*ClientRecord` (pending SETCLIENTID_CONFIRM)
  - `bootEpoch uint32` (from time.Now().Unix() truncated, or passed in)
  - `nextClientSeq uint32` (atomic counter for client IDs)
  - `leaseDuration time.Duration` (default 90s, configurable)
- `NewStateManager(leaseDuration time.Duration) *StateManager` constructor -- generates bootEpoch from time.Now()
- `generateClientID() uint64` -- combines bootEpoch (high 32) + atomic counter (low 32)
- `generateConfirmVerifier() [8]byte` -- uses `crypto/rand.Read()` (NOT timestamp, per Pitfall 6)
- `SetClientID(clientIDStr string, verifier [8]byte, callback CallbackInfo, clientAddr string) (*SetClientIDResult, error)` -- implements the five-case algorithm from RFC 7530 Section 9.1.1:
  - Case 1: No confirmed, no unconfirmed -> create new unconfirmed record
  - Case 2: Confirmed exists + unconfirmed exists -> replace unconfirmed
  - Case 3: Confirmed exists, different verifier -> client reboot, create new unconfirmed
  - Case 4: No confirmed, unconfirmed exists -> replace unconfirmed
  - Case 5: Confirmed exists, same verifier -> re-SETCLIENTID (callback update)
- `ConfirmClientID(clientID uint64, confirmVerifier [8]byte) error` -- validates confirm verifier, promotes to confirmed, removes old confirmed for same name if exists
- `GetClient(clientID uint64) *ClientRecord` -- lookup by ID (used by RENEW, etc.)
- `RemoveClient(clientID uint64)` -- cleanup (used by lease expiry in Plan 09-03)

Error types to define:
- `ErrStaleClientID` (maps to NFS4ERR_STALE_CLIENTID)
- `ErrClientIDInUse` (maps to NFS4ERR_CLID_INUSE)
- Custom error with NFS4 status code for handler mapping

Note: The existing `nextClientID` global atomic in setclientid.go will be REMOVED.
  </action>
  <verify>
Run `go build ./internal/protocol/nfs/v4/state/` to verify the package compiles.
Run `go vet ./internal/protocol/nfs/v4/state/` for static analysis.
  </verify>
  <done>StateManager and ClientRecord types exist with full five-case SetClientID algorithm and crypto/rand confirm verifier generation.</done>
</task>

<task type="auto">
  <name>Task 2: Upgrade SETCLIENTID/SETCLIENTID_CONFIRM handlers and add tests</name>
  <files>
    internal/protocol/nfs/v4/handlers/handler.go
    internal/protocol/nfs/v4/handlers/setclientid.go
    internal/protocol/nfs/v4/types/types.go
    internal/protocol/nfs/v4/state/client_test.go
  </files>
  <action>
**handlers/handler.go** modifications:
- Add `StateManager *state.StateManager` field to Handler struct
- Update `NewHandler` signature to accept `*state.StateManager` parameter (add after `pfs *pseudofs.PseudoFS`)
- Store the StateManager in the Handler struct
- Add import for `internal/protocol/nfs/v4/state`

**handlers/setclientid.go** modifications:
- Remove the `var nextClientID uint64` global atomic
- Update `handleSetClientID` to:
  1. Decode XDR args (keep existing decode logic -- it's correct)
  2. Capture callback fields (program, netid, addr) into a `state.CallbackInfo` struct instead of discarding
  3. Call `h.StateManager.SetClientID(clientIDStr, verifier, callback, ctx.ClientAddr)`
  4. On error, map state errors to NFS4 status codes (ErrStaleClientID -> NFS4ERR_STALE_CLIENTID, ErrClientIDInUse -> NFS4ERR_CLID_INUSE)
  5. Encode response: NFS4_OK + clientID (uint64) + confirmVerifier (8 bytes)
  6. Update log to INFO level for new clients, DEBUG for re-SETCLIENTID
- Update `handleSetClientIDConfirm` to:
  1. Keep existing XDR decode (clientID uint64, confirmVerf [8]byte)
  2. Call `h.StateManager.ConfirmClientID(clientID, confirmVerifier)`
  3. On error, return NFS4ERR_STALE_CLIENTID or NFS4ERR_CLID_INUSE
  4. On success, return NFS4_OK

**types/types.go** modifications:
- Extend `V4ClientState` with `ClientID uint64` field (so CompoundContext can carry the client ID for later plans)

**state/client_test.go** -- comprehensive unit tests:
- `TestSetClientID_NewClient` -- Case 1: brand new client creates unconfirmed record
- `TestSetClientID_ClientReboot` -- Case 3: same id string, different verifier
- `TestSetClientID_SameVerifier` -- Case 5: re-SETCLIENTID with same verifier (callback update)
- `TestSetClientID_ReplaceUnconfirmed` -- Case 4: no confirmed, replace unconfirmed
- `TestSetClientID_ConfirmedAndUnconfirmed` -- Case 2: both exist, replace unconfirmed
- `TestConfirmClientID_Success` -- correct verifier promotes to confirmed
- `TestConfirmClientID_WrongVerifier` -- wrong verifier returns error
- `TestConfirmClientID_StaleClientID` -- unknown client ID returns STALE_CLIENTID
- `TestConfirmClientID_AfterReboot` -- confirm after client reboot replaces old confirmed
- `TestClientIDUniqueness` -- multiple clients get unique IDs
- `TestConfirmVerifierUnpredictable` -- two calls produce different confirm verifiers
- `TestGenerateClientID_BootEpoch` -- high 32 bits match boot epoch
- `TestConcurrentSetClientID` -- concurrent SETCLIENTID from multiple goroutines

All tests use table-driven style where appropriate. All tests must pass with `go test -race ./internal/protocol/nfs/v4/state/`.

Also update any callers of `NewHandler` to pass the StateManager (search for NewHandler calls in test files and production code). In tests, create a StateManager with `state.NewStateManager(90 * time.Second)`. In production code (likely in the NFS adapter or dispatch.go), create the StateManager during initialization.
  </action>
  <verify>
Run `go test -race -v ./internal/protocol/nfs/v4/state/` -- all client tests pass.
Run `go test -race ./internal/protocol/nfs/v4/handlers/` -- existing handler tests still pass.
Run `go build ./...` -- entire project compiles.
  </verify>
  <done>SETCLIENTID uses five-case algorithm via StateManager; SETCLIENTID_CONFIRM validates confirm verifier; global nextClientID removed; all handler tests pass; 13+ state/client tests pass with race detection.</done>
</task>

</tasks>

<verification>
1. `go test -race ./internal/protocol/nfs/v4/state/` passes all client record tests
2. `go test -race ./internal/protocol/nfs/v4/handlers/` passes all existing handler tests
3. `go build ./...` compiles the entire project without errors
4. `go vet ./...` passes static analysis
5. No global atomic counter `nextClientID` remains in setclientid.go
</verification>

<success_criteria>
- StateManager package exists at internal/protocol/nfs/v4/state/
- Five-case SETCLIENTID algorithm correctly handles all client lifecycle scenarios
- SETCLIENTID_CONFIRM validates confirm verifier (rejects wrong verifier)
- Client IDs use boot epoch + counter scheme (unique across restarts)
- Confirm verifiers use crypto/rand (not timestamps)
- 13+ unit tests pass with race detection
- All existing handler tests remain green
</success_criteria>

<output>
After completion, create `.planning/phases/09-state-management/09-01-SUMMARY.md`
</output>
