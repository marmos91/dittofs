---
phase: 04-security-hardening
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - k8s/dittofs-operator/internal/controller/networkpolicy_reconciler.go
  - k8s/dittofs-operator/internal/controller/networkpolicy_reconciler_test.go
  - k8s/dittofs-operator/internal/controller/dittoserver_controller.go
autonomous: true

must_haves:
  truths:
    - "For each running adapter, a NetworkPolicy exists allowing TCP ingress only on that adapter's port"
    - "When an adapter is stopped, its NetworkPolicy is deleted within one polling cycle"
    - "When an adapter is removed, its NetworkPolicy is deleted within one polling cycle"
    - "NetworkPolicies are garbage-collected when the DittoServer CR is deleted"
    - "Operator has RBAC permission to manage NetworkPolicies"
    - "NetworkPolicy changes do not affect adapter Services or container ports"
  artifacts:
    - path: "k8s/dittofs-operator/internal/controller/networkpolicy_reconciler.go"
      provides: "Per-adapter NetworkPolicy lifecycle management"
      min_lines: 120
      exports: ["reconcileNetworkPolicies"]
    - path: "k8s/dittofs-operator/internal/controller/networkpolicy_reconciler_test.go"
      provides: "Comprehensive tests for NetworkPolicy reconciler"
      min_lines: 150
  key_links:
    - from: "k8s/dittofs-operator/internal/controller/dittoserver_controller.go"
      to: "k8s/dittofs-operator/internal/controller/networkpolicy_reconciler.go"
      via: "r.reconcileNetworkPolicies(ctx, dittoServer) call in Reconcile loop"
      pattern: "reconcileNetworkPolicies"
    - from: "k8s/dittofs-operator/internal/controller/networkpolicy_reconciler.go"
      to: "lastKnownAdapters"
      via: "r.getLastKnownAdapters(ds) for desired state"
      pattern: "getLastKnownAdapters"
    - from: "k8s/dittofs-operator/internal/controller/dittoserver_controller.go"
      to: "networkingv1.NetworkPolicy"
      via: "Owns(&networkingv1.NetworkPolicy{}) in SetupWithManager"
      pattern: "Owns.*NetworkPolicy"
---

<objective>
Implement per-adapter NetworkPolicy lifecycle management. For each enabled+running adapter, a NetworkPolicy is created allowing TCP ingress only on that adapter's port. When an adapter is stopped or removed, its NetworkPolicy is deleted.

Purpose: Satisfies SECU-03 (create NetworkPolicy per active adapter) and SECU-04 (delete NetworkPolicy when adapter stops). Restricts network access to only active adapter ports, reducing attack surface.
Output: NetworkPolicy reconciler, integration into controller, comprehensive tests.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-security-hardening/04-RESEARCH.md
@.planning/phases/04-security-hardening/04-01-SUMMARY.md
@k8s/dittofs-operator/internal/controller/service_reconciler.go
@k8s/dittofs-operator/internal/controller/service_reconciler_test.go
@k8s/dittofs-operator/internal/controller/dittoserver_controller.go
@k8s/dittofs-operator/internal/controller/adapter_reconciler.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement NetworkPolicy reconciler and integrate into controller</name>
  <files>
    k8s/dittofs-operator/internal/controller/networkpolicy_reconciler.go
    k8s/dittofs-operator/internal/controller/dittoserver_controller.go
  </files>
  <action>
**Create `networkpolicy_reconciler.go`** following the exact same pattern as `service_reconciler.go`. This is a direct clone of that pattern, adapted for NetworkPolicy resources.

1. **Constants and helpers:**
```go
const (
    adapterNetworkPolicyLabel = "dittofs.io/adapter-networkpolicy"
)
```
Reuse `adapterTypeLabel` from `service_reconciler.go` (already in same package).

Helper functions:
- `networkPolicyName(crName, adapterType string) string` -- returns `fmt.Sprintf("%s-adapter-%s", crName, adapterType)` (same naming convention as adapter Services)
- `networkPolicyLabels(crName, adapterType string) map[string]string` -- returns labels: `app: dittofs-server`, `instance: crName`, `adapterNetworkPolicyLabel: "true"`, `adapterTypeLabel: adapterType`

2. **Main reconciler function `reconcileNetworkPolicies(ctx, ds)`:**
Follow the exact structure of `reconcileAdapterServices`:
- DISC-03 safety: if `r.getLastKnownAdapters(ds)` returns nil, skip and return nil
- Build `desired` map: only enabled AND running adapters
- List existing NetworkPolicies using `client.MatchingLabels{adapterNetworkPolicyLabel: "true", "instance": ds.Name}`
- Build `actual` map keyed by adapter type from labels
- Create NetworkPolicies for desired adapters not yet present
- Update NetworkPolicies when port changes (compare spec.Ingress[0].Ports[0].Port)
- Delete NetworkPolicies for adapters no longer desired
- Return nil on success; errors are returned directly (not best-effort like Services -- NetworkPolicies are security-critical)

3. **NetworkPolicy construction (`buildAdapterNetworkPolicy`):**
```go
func buildAdapterNetworkPolicy(crName, namespace, adapterType string, port int32) *networkingv1.NetworkPolicy
```
Build a NetworkPolicy with:
- Name: `networkPolicyName(crName, adapterType)`
- Labels: `networkPolicyLabels(crName, adapterType)`
- PodSelector matching `app: dittofs-server`, `instance: crName`
- PolicyTypes: `[Ingress]`
- Single Ingress rule allowing TCP on the adapter port
- Use `intstr.FromInt32(port)` for the port value
- Use a `protocolPtr` helper that returns `*corev1.ProtocolTCP`

4. **Create, update, delete functions:**
- `createAdapterNetworkPolicy(ctx, ds, adapterType, info)` -- creates the NetworkPolicy with owner reference (`controllerutil.SetControllerReference`), emits event `AdapterNetworkPolicyCreated`
- `updateAdapterNetworkPolicyIfNeeded(ctx, ds, existing, info)` -- checks if port changed, re-fetches fresh copy, updates ingress port, emits event `AdapterNetworkPolicyUpdated`
- `deleteAdapterNetworkPolicy(ctx, ds, np, adapterType)` -- deletes, emits event `AdapterNetworkPolicyDeleted`

5. **Imports needed:**
```go
import (
    networkingv1 "k8s.io/api/networking/v1"
    "k8s.io/apimachinery/pkg/util/intstr"
)
```

**In `dittoserver_controller.go`:**

1. **Add RBAC marker** (near the other RBAC markers, before the `Reconcile` function):
```go
// +kubebuilder:rbac:groups=networking.k8s.io,resources=networkpolicies,verbs=get;list;watch;create;update;patch;delete
```

2. **Add NetworkPolicy to `SetupWithManager`**: Add `.Owns(&networkingv1.NetworkPolicy{})` to the builder chain, after the existing `.Owns(&corev1.Secret{})` line.

3. **Add import**: `networkingv1 "k8s.io/api/networking/v1"` in the import block.

4. **Integrate into Reconcile loop**: Inside the `if conditions.IsConditionTrue(...)` block (authenticated gate), after the `reconcileAdapterServices` call, add:
```go
// NetworkPolicy reconciliation: restrict ingress to active adapter ports
if err := r.reconcileNetworkPolicies(ctx, dittoServer); err != nil {
    logger.Error(err, "Failed to reconcile adapter network policies")
    r.Recorder.Eventf(dittoServer, corev1.EventTypeWarning, "NetworkPolicyFailed",
        "Failed to reconcile adapter network policies: %v", err)
    // NetworkPolicies are security-critical, propagate error
    return ctrl.Result{}, err
}
```
Note: Unlike adapter Services (which are best-effort), NetworkPolicy errors are propagated because they are security-critical.

5. **Regenerate RBAC manifests:**
```bash
cd k8s/dittofs-operator && make manifests
```
  </action>
  <verify>
```bash
cd k8s/dittofs-operator && go build ./...
```
Build succeeds. Verify:
- `networkpolicy_reconciler.go` exists and contains `reconcileNetworkPolicies`, `createAdapterNetworkPolicy`, `deleteAdapterNetworkPolicy`
- `dittoserver_controller.go` contains `reconcileNetworkPolicies` call
- `dittoserver_controller.go` contains `Owns(&networkingv1.NetworkPolicy{})`
- RBAC config contains `networking.k8s.io` permission
  </verify>
  <done>
NetworkPolicy reconciler is implemented with create/update/delete lifecycle. RBAC markers added. Integrated into Reconcile loop after adapter Service reconciliation. `Owns` watch configured.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add comprehensive tests for NetworkPolicy reconciler</name>
  <files>
    k8s/dittofs-operator/internal/controller/networkpolicy_reconciler_test.go
  </files>
  <action>
Create `networkpolicy_reconciler_test.go` following the exact same test patterns as `service_reconciler_test.go`. Use the same test helpers (`setupServiceReconciler` or equivalent for NetworkPolicy).

**Test setup helper:**
Create a helper `setupNetworkPolicyReconciler` that:
- Creates a fake client with scheme registered for `networkingv1.NetworkPolicy` (in addition to existing types)
- Creates a `DittoServerReconciler` with the fake client
- Returns the reconciler, context, and a DittoServer CR fixture

**Required test cases (minimum 8 tests):**

1. **TestReconcileNetworkPolicies_NilAdapters_Skips** -- When `lastKnownAdapters` is nil (no poll yet), reconciliation is a no-op, no NetworkPolicies are created.

2. **TestReconcileNetworkPolicies_EmptyAdapters_DeletesOrphans** -- When adapter list is empty (successful poll, no adapters), any existing NetworkPolicies are deleted.

3. **TestReconcileNetworkPolicies_CreatesForRunningAdapter** -- When one adapter is enabled+running (type "nfs", port 12049), a NetworkPolicy is created with the correct name (`<cr>-adapter-nfs`), labels, podSelector, and ingress rule allowing TCP on port 12049.

4. **TestReconcileNetworkPolicies_MultipleAdapters** -- When two adapters are running (nfs on 12049, smb on 12445), two separate NetworkPolicies are created, one per adapter.

5. **TestReconcileNetworkPolicies_DeletesWhenAdapterStops** -- Pre-create a NetworkPolicy for adapter "nfs". Run reconciliation with empty adapter list. Verify the NetworkPolicy is deleted.

6. **TestReconcileNetworkPolicies_UpdatesWhenPortChanges** -- Pre-create a NetworkPolicy for adapter "nfs" with port 12049. Run reconciliation with adapter "nfs" at port 2049. Verify the NetworkPolicy ingress port is updated to 2049.

7. **TestReconcileNetworkPolicies_IgnoresDisabledAdapters** -- When adapter is enabled=false or running=false, no NetworkPolicy is created for it.

8. **TestReconcileNetworkPolicies_DoesNotTouchStaticResources** -- Pre-create a NetworkPolicy without the `adapterNetworkPolicyLabel`. Run reconciliation. Verify the unlabeled NetworkPolicy is untouched.

9. **TestReconcileNetworkPolicies_OwnerReferenceSet** -- After creating a NetworkPolicy, verify it has an OwnerReference pointing to the DittoServer CR.

**Assertions for each NetworkPolicy created:**
- Name matches `<cr>-adapter-<type>` pattern
- Has label `dittofs.io/adapter-networkpolicy: "true"`
- Has label `dittofs.io/adapter-type: <type>`
- PodSelector matches `app: dittofs-server`, `instance: <cr>`
- PolicyTypes contains only `Ingress`
- Ingress rules have exactly one rule with one port (TCP, correct port number)

Register `networkingv1.AddToScheme` in the test scheme setup.
  </action>
  <verify>
```bash
cd k8s/dittofs-operator && go test ./internal/controller/ -run TestReconcileNetworkPolicies -v
```
All tests pass. Count test functions to confirm at least 8 are defined.
  </verify>
  <done>
All NetworkPolicy reconciler tests pass. Tests cover: nil safety, creation, deletion on adapter stop, port update, multiple adapters, disabled adapter exclusion, static resource safety, and owner reference verification.
  </done>
</task>

</tasks>

<verification>
1. `cd k8s/dittofs-operator && go build ./...` -- zero compilation errors
2. `cd k8s/dittofs-operator && go test ./...` -- all tests pass (including new NetworkPolicy tests)
3. `grep -n "adapterNetworkPolicyLabel" k8s/dittofs-operator/internal/controller/networkpolicy_reconciler.go` -- file exists with label constant
4. `grep -n "reconcileNetworkPolicies" k8s/dittofs-operator/internal/controller/dittoserver_controller.go` -- integrated into Reconcile loop
5. `grep -n "networking.k8s.io" k8s/dittofs-operator/internal/controller/dittoserver_controller.go` -- RBAC marker present
6. `grep -n "Owns.*NetworkPolicy" k8s/dittofs-operator/internal/controller/dittoserver_controller.go` -- watch configured
7. NetworkPolicy reconciler tests: `go test ./internal/controller/ -run TestReconcileNetworkPolicies -v` shows 8+ test cases passing
</verification>

<success_criteria>
- SECU-03: A NetworkPolicy per running adapter is created allowing TCP ingress only on the adapter's port
- SECU-04: NetworkPolicy is deleted when the corresponding adapter is stopped or removed
- NetworkPolicies are owned by the DittoServer CR (garbage collection on CR deletion)
- RBAC permissions for networking.k8s.io/networkpolicies are configured
- Controller watches owned NetworkPolicies for drift detection
- All existing tests continue to pass, 8+ new tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-security-hardening/04-02-SUMMARY.md`
</output>
