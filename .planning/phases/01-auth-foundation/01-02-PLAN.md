---
phase: 01-auth-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - k8s/dittofs-operator/internal/controller/dittoserver_controller.go
  - k8s/dittofs-operator/internal/controller/auth_reconciler.go
  - k8s/dittofs-operator/internal/controller/dittofs_client.go
  - k8s/dittofs-operator/utils/conditions/conditions.go
  - k8s/dittofs-operator/api/v1alpha1/helpers.go
  - k8s/dittofs-operator/internal/controller/auth_reconciler_test.go
autonomous: true

must_haves:
  truths:
    - "When the operator starts and DittoFS StatefulSet is ready, a service account with operator role exists and its JWT is stored in a K8s Secret named {cr-name}-operator-credentials"
    - "When the operator-credentials Secret already exists with valid credentials, the operator reuses it without recreating the service account"
    - "When the stored JWT is expired or invalid, the operator re-logs in using the stored password and updates the Secret"
    - "When the DittoFS API is unreachable, the operator logs warnings, sets Authenticated condition to False, and requeues with exponential backoff without deleting any K8s resources"
    - "The operator's JWT token is proactively refreshed before expiry (at ~80% TTL) via reconcile RequeueAfter"
    - "On DittoServer CR deletion, the operator attempts to delete the DittoFS service account as best-effort cleanup"
    - "The Authenticated condition is included in the Ready condition aggregate -- operator is not-ready until authenticated"
    - "Admin credentials are auto-generated in a K8s Secret and injected into the DittoFS pod as DITTOFS_ADMIN_INITIAL_PASSWORD env var"
  artifacts:
    - path: "k8s/dittofs-operator/internal/controller/auth_reconciler.go"
      provides: "Auth reconciliation: provision, refresh, and cleanup of operator service account"
      contains: "reconcileAuth"
    - path: "k8s/dittofs-operator/internal/controller/dittofs_client.go"
      provides: "Minimal DittoFS API client for Login, CreateUser, RefreshToken, DeleteUser"
      contains: "DittoFSClient"
    - path: "k8s/dittofs-operator/internal/controller/dittoserver_controller.go"
      provides: "Integration of auth reconciliation into main Reconcile loop, admin credentials Secret, and cleanup"
      contains: "reconcileAuth"
    - path: "k8s/dittofs-operator/utils/conditions/conditions.go"
      provides: "ConditionAuthenticated constant"
      contains: "ConditionAuthenticated"
    - path: "k8s/dittofs-operator/api/v1alpha1/helpers.go"
      provides: "Operator credential secret name, service account username, API URL helpers"
      contains: "operator-credentials"
    - path: "k8s/dittofs-operator/internal/controller/auth_reconciler_test.go"
      provides: "Unit tests for auth reconciliation flows"
      contains: "TestReconcileAuth"
  key_links:
    - from: "k8s/dittofs-operator/internal/controller/auth_reconciler.go"
      to: "k8s/dittofs-operator/internal/controller/dittofs_client.go"
      via: "DittoFSClient for Login, CreateUser, RefreshToken, DeleteUser API calls"
      pattern: "DittoFSClient"
    - from: "k8s/dittofs-operator/internal/controller/auth_reconciler.go"
      to: "k8s/dittofs-operator/internal/controller/dittoserver_controller.go"
      via: "reconcileAuth called from Reconcile loop after StatefulSet ready"
      pattern: "reconcileAuth"
    - from: "k8s/dittofs-operator/internal/controller/dittoserver_controller.go"
      to: "k8s/dittofs-operator/utils/conditions/conditions.go"
      via: "SetCondition for ConditionAuthenticated in Ready aggregate"
      pattern: "ConditionAuthenticated"
    - from: "k8s/dittofs-operator/internal/controller/dittoserver_controller.go"
      to: "k8s/dittofs-operator/api/v1alpha1/helpers.go"
      via: "GetOperatorCredentialsSecretName and GetAPIServiceURL for Secret naming and API discovery"
      pattern: "GetOperatorCredentialsSecretName"
---

<objective>
Implement operator service account provisioning, credential storage in K8s Secrets, token lifecycle management, and graceful error handling in the K8s operator.

Purpose: The operator needs to authenticate to the DittoFS API using a dedicated service account with operator role. This plan adds the full auth lifecycle: auto-provisioning the service account on first boot, storing credentials in a K8s Secret, proactively refreshing tokens at ~80% TTL, handling API unavailability with exponential backoff, and cleaning up on CR deletion.

Output: Fully functional auth reconciliation that provisions credentials, handles token refresh, and survives DittoFS API outages without deleting K8s resources.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-auth-foundation/01-RESEARCH.md
@.planning/phases/01-auth-foundation/01-01-SUMMARY.md
@k8s/dittofs-operator/internal/controller/dittoserver_controller.go
@k8s/dittofs-operator/api/v1alpha1/dittoserver_types.go
@k8s/dittofs-operator/api/v1alpha1/helpers.go
@k8s/dittofs-operator/utils/conditions/conditions.go
@pkg/apiclient/client.go
@pkg/apiclient/auth.go
@pkg/apiclient/users.go
@pkg/apiclient/errors.go
@pkg/controlplane/models/admin.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add infrastructure: conditions, helpers, and minimal DittoFS API client</name>
  <files>
    k8s/dittofs-operator/utils/conditions/conditions.go
    k8s/dittofs-operator/api/v1alpha1/helpers.go
    k8s/dittofs-operator/internal/controller/dittofs_client.go
  </files>
  <action>
  In `k8s/dittofs-operator/utils/conditions/conditions.go`:
  1. Add `ConditionAuthenticated = "Authenticated"` to the condition type constants block.

  In `k8s/dittofs-operator/api/v1alpha1/helpers.go`:
  1. Add these constants:
     - `OperatorCredentialsSecretSuffix = "-operator-credentials"` (naming convention for credentials Secret)
     - `AdminCredentialsSecretSuffix = "-admin-credentials"` (naming convention for admin bootstrap Secret)
     - `OperatorServiceAccountUsername = "k8s-operator"` (fixed username per user decision)
  2. Add helper method `GetOperatorCredentialsSecretName() string` on `*DittoServer` that returns `ds.Name + OperatorCredentialsSecretSuffix`.
  3. Add helper method `GetAdminCredentialsSecretName() string` on `*DittoServer` that returns `ds.Name + AdminCredentialsSecretSuffix`.
  4. Add helper method `GetAPIServiceURL() string` on `*DittoServer` that returns the in-cluster API URL: `fmt.Sprintf("http://%s-api.%s.svc.cluster.local:%d", ds.Name, ds.Namespace, apiPort)`. For `apiPort`: check `ds.Spec.ControlPlane != nil && ds.Spec.ControlPlane.Port > 0`, else default to 8080.

  Create `k8s/dittofs-operator/internal/controller/dittofs_client.go`:
  The operator module (`k8s/dittofs-operator`) is a separate Go module from the main DittoFS module and does NOT import `pkg/apiclient`. Rather than adding complex Go workspace or replace directives, create a minimal DittoFS API client within the operator that implements the 4 HTTP+JSON methods needed. This is cleaner because:
  - The apiclient is simple HTTP+JSON (no complex dependencies)
  - Only 4 methods needed: Login, CreateUser, RefreshToken, DeleteUser
  - Avoids coupling operator module to the entire DittoFS dependency tree

  The client should contain:
  1. `DittoFSClient` struct with `baseURL string`, `httpClient *http.Client`, `token string`
  2. `NewDittoFSClient(baseURL string) *DittoFSClient` constructor with 10-second timeout (operator context, shorter than interactive client)
  3. `SetToken(token string)` method
  4. Private `do(method, path string, body, result any) error` method -- same pattern as pkg/apiclient/client.go: marshal body, create request, set Content-Type/Accept/Authorization headers, make request, check status >= 400, unmarshal error or result.
  5. `DittoFSAPIError` struct with `Code`, `Message`, `Details` fields and `Error()`, `IsConflict()`, `IsAuthError()`, `IsNotFound()` methods.
  6. `LoginRequest` struct with `Username`, `Password` fields.
  7. `TokenResponse` struct with `AccessToken`, `RefreshToken`, `TokenType`, `ExpiresIn int64`, `ExpiresAt time.Time` fields, and `ExpiresInDuration() time.Duration` helper.
  8. `Login(username, password string) (*TokenResponse, error)` -- POST /api/v1/auth/login
  9. `RefreshToken(refreshToken string) (*TokenResponse, error)` -- POST /api/v1/auth/refresh with `{"refresh_token": refreshToken}`
  10. `CreateUser(username, password, role string) error` -- POST /api/v1/users with `{"username": username, "password": password, "role": role}`. Only needs to return error (we don't use the response body).
  11. `DeleteUser(username string) error` -- DELETE /api/v1/users/{username}

  Mirror the wire format exactly from `pkg/apiclient` (same JSON field names, same endpoint paths) to ensure compatibility. The types are intentionally duplicated to keep the operator module self-contained.
  </action>
  <verify>
  Run: `cd k8s/dittofs-operator && go build ./...`
  Confirm: ConditionAuthenticated constant exists, helper methods compile, DittoFSClient compiles.
  </verify>
  <done>
  ConditionAuthenticated is available, helper methods provide secret names and API URL, DittoFSClient provides Login/CreateUser/RefreshToken/DeleteUser against the DittoFS REST API.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement auth reconciler and integrate into controller lifecycle</name>
  <files>
    k8s/dittofs-operator/internal/controller/auth_reconciler.go
    k8s/dittofs-operator/internal/controller/dittoserver_controller.go
    k8s/dittofs-operator/internal/controller/auth_reconciler_test.go
  </files>
  <action>
  Create `k8s/dittofs-operator/internal/controller/auth_reconciler.go`:

  This file implements the full auth lifecycle as methods on `DittoServerReconciler`. It contains the following functions:

  **reconcileAdminCredentials(ctx, dittoServer) error**:
  - Auto-generates an admin credentials Secret (`{cr-name}-admin-credentials`) if it doesn't already exist.
  - Secret contains keys: `username` ("admin"), `password` (random 24-char string via crypto/rand + base64.URLEncoding, same pattern as `models.GenerateRandomPassword()`).
  - Sets ownerReference to the DittoServer CR via `controllerutil.SetControllerReference`.
  - Uses `controllerutil.CreateOrUpdate` pattern (same as reconcileJWTSecret). Only generates password if Secret data is nil or empty.
  - If Secret already exists with data: do nothing (reuse, don't rotate).
  - This function exists to provide the plaintext admin password that gets injected into the DittoFS pod as `DITTOFS_ADMIN_INITIAL_PASSWORD` env var. The operator also reads this Secret to bootstrap the service account.

  **reconcileAuth(ctx, dittoServer) (ctrl.Result, error)**:
  - Main auth reconciliation entry point. Called after StatefulSet is ready.
  - Build API URL via `dittoServer.GetAPIServiceURL()`.
  - Check if `{cr-name}-operator-credentials` Secret exists.
  - If NOT found: call `provisionOperatorAccount(ctx, ds, apiURL)`.
  - If found: call `refreshOperatorToken(ctx, ds, secret, apiURL)`.
  - On success: set `ConditionAuthenticated` to True with reason "AuthenticationSucceeded" and message "Operator service account authenticated successfully". Return `ctrl.Result{RequeueAfter: refreshInterval}`.
  - On transient failure (API unreachable -- any net.Error or connection refused or HTTP 502/503/504): set `ConditionAuthenticated` to False with reason "APIUnreachable", log warning, emit K8s Event (once, on first failure), return `ctrl.Result{RequeueAfter: backoffDuration}`. Use exponential backoff: start 2s, double each retry, cap at 5 minutes (300s). Track retry count via annotation `dittofs.dittofs.com/auth-retry-count` on the CR. IMPORTANT: Never delete existing K8s resources when API is unreachable.
  - On permanent failure (wrong credentials, 401/403 after re-login attempt): set condition False with reason "AuthenticationFailed", log error, return error to trigger standard controller-runtime backoff.

  **provisionOperatorAccount(ctx, ds, apiURL) (ctrl.Result, error)**:
  - Read admin credentials from `{cr-name}-admin-credentials` Secret.
  - Create DittoFSClient, login as admin.
  - Generate random password for operator service account (18 bytes of randomness encoded as URL-safe base64, yielding 24 chars -- same as `models.GenerateRandomPassword()`).
  - Call `client.CreateUser("k8s-operator", password, "operator")`.
  - If user already exists (the client returns `DittoFSAPIError` with `IsConflict() == true`): log info "Operator service account already exists, proceeding to login", and proceed to login as operator. This handles the case where provisioning succeeded previously but Secret creation failed.
  - Login as operator with the generated password to get JWT tokens.
  - Create `{cr-name}-operator-credentials` Secret with keys: `username` ("k8s-operator"), `password` (the generated password), `access-token`, `refresh-token`, `server-url` (the API URL). Set ownerReference to DittoServer CR.
  - Return `ctrl.Result{RequeueAfter: tokenResponse.ExpiresInDuration() * 80 / 100}` for proactive refresh.

  **refreshOperatorToken(ctx, ds, secret, apiURL) (ctrl.Result, error)**:
  - Read access-token and refresh-token from the existing operator credentials Secret.
  - Create DittoFSClient with the API URL.
  - Try `client.RefreshToken(refreshToken)` first (cheapest operation, no password needed).
  - If refresh succeeds: update Secret data with new access-token and refresh-token (read-modify-update pattern using `r.Update(ctx, secret)`), return `ctrl.Result{RequeueAfter: newTokenTTL * 80 / 100}`.
  - If refresh fails (expired/invalid -- any error from refresh endpoint): fall back to re-login with stored password from Secret. Read `password` key from Secret, call `client.Login("k8s-operator", password)`.
  - If re-login succeeds: update Secret with new tokens, return `ctrl.Result{RequeueAfter: newTokenTTL * 80 / 100}`.
  - If re-login also fails: return error with descriptive message. This indicates the stored credentials are invalid (server-side change).
  - Reset the auth-retry-count annotation to "0" on success (clears backoff).

  **cleanupOperatorServiceAccount(ctx, ds) error**:
  - Read admin credentials from `{cr-name}-admin-credentials` Secret.
  - If Secret not found: return nil (nothing to do, admin credentials already cleaned up).
  - Create DittoFSClient, login as admin.
  - Call `client.DeleteUser("k8s-operator")`.
  - Best-effort: if any step fails (API unreachable, login fails, delete fails), log warning and return nil. Do NOT return errors -- this is cleanup during CR deletion and must not block finalizer removal.

  **Helper: computeBackoff(retryCount int) time.Duration**:
  - `base := 2 * time.Second`
  - `backoff := base * time.Duration(1 << retryCount)` (2s, 4s, 8s, 16s, 32s, 64s, 128s, 256s...)
  - `if backoff > 5 * time.Minute { backoff = 5 * time.Minute }` (cap)
  - Return backoff

  Modify `k8s/dittofs-operator/internal/controller/dittoserver_controller.go`:

  1. Add `reconcileAdminCredentials()` call in `Reconcile()` BEFORE `reconcileConfigMap()` (line ~151). This ensures the admin credentials Secret exists before the StatefulSet is created, so the env var injection works on first boot.

  2. Add admin password env var injection. In `buildSecretEnvVars()`, after the existing admin password hash block (lines 1169-1178), add logic to ALSO inject `DITTOFS_ADMIN_INITIAL_PASSWORD` from the auto-generated admin credentials Secret. The env var should use `secretEnvVar("DITTOFS_ADMIN_INITIAL_PASSWORD", ds.GetAdminCredentialsSecretName(), "password", true)`. Mark as optional=true so the pod doesn't fail if the Secret is manually deleted. Only add this env var if the user has NOT provided `spec.identity.admin.passwordSecretRef` (i.e., the operator is managing admin credentials automatically).

  3. After the StatefulSet reconciliation and `updateStatus()` call, but BEFORE the final `return ctrl.Result{}, nil`, add auth reconciliation:
     ```go
     // Auth reconciliation: only when StatefulSet has at least one ready replica
     if statefulSet.Status.ReadyReplicas >= 1 {
         authResult, authErr := r.reconcileAuth(ctx, dittoServer)
         if authErr != nil {
             logger.Error(authErr, "Auth reconciliation failed")
             r.Recorder.Eventf(dittoServer, corev1.EventTypeWarning, "AuthFailed",
                 "Failed to authenticate with DittoFS API: %v", authErr)
             // Don't return error -- auth failure should not block infrastructure reconciliation
             // The Authenticated condition will reflect the failure
         }
         if authResult.RequeueAfter > 0 {
             return authResult, nil
         }
     }
     ```

  4. In `performCleanup()`, add call to `cleanupOperatorServiceAccount()` AFTER the existing Percona cleanup block (line ~497):
     ```go
     // Best-effort: delete DittoFS operator service account
     if err := r.cleanupOperatorServiceAccount(ctx, dittoServer); err != nil {
         logger.Error(err, "Failed to delete operator service account (best-effort)")
         // Don't return error -- best-effort cleanup
     }
     ```

  5. In `updateReadyCondition()` (line ~360), add `ConditionAuthenticated` to the aggregate Ready check. After the `databaseReady` variable:
     ```go
     authenticated := conditions.IsConditionTrue(status.Conditions, conditions.ConditionAuthenticated)
     ```
     Update the allReady computation:
     ```go
     allReady := configReady && available && !progressing && databaseReady && authenticated
     ```
     Update `collectNotReadyReasons()` to include `!authenticated`:
     ```go
     if !authenticated {
         reasons = append(reasons, "NotAuthenticated")
     }
     ```

  6. In `SetupWithManager()` (line ~534), add `Owns(&corev1.Secret{})` to the builder chain. The operator already manages Secrets (JWT auto-generation), so watching owned Secrets is consistent. The extra reconcile when the credentials Secret is updated is harmless (auth is already valid, reconcile is a no-op).

  Create `k8s/dittofs-operator/internal/controller/auth_reconciler_test.go`:
  Use `fake.NewClientBuilder().WithScheme(scheme).Build()` for K8s client operations and `httptest.NewServer` to mock the DittoFS API.

  Tests:
  1. **TestProvisionOperatorAccount_Success**: Mock DittoFS API server that accepts admin login, accepts CreateUser, accepts operator login. Verify that:
     - Operator credentials Secret is created with correct keys (username, password, access-token, refresh-token, server-url)
     - Secret has ownerReference to the DittoServer CR
     - Result has RequeueAfter > 0 (for token refresh)

  2. **TestProvisionOperatorAccount_UserAlreadyExists**: Mock API returns 409 Conflict on CreateUser. Verify operator proceeds to login and creates the Secret successfully.

  3. **TestRefreshOperatorToken_RefreshSuccess**: Create an existing credentials Secret, mock API accepts refresh. Verify Secret is updated with new tokens.

  4. **TestRefreshOperatorToken_RefreshFails_ReloginSuccess**: Mock API rejects refresh but accepts login. Verify fallback works and Secret is updated.

  5. **TestReconcileAuth_APIUnreachable**: Use a non-existent URL. Verify:
     - ConditionAuthenticated is set to False
     - Result has RequeueAfter with backoff
     - No K8s resources are deleted

  6. **TestCleanupOperatorServiceAccount_BestEffort**: Mock API that fails on delete. Verify the function returns nil (best-effort).

  7. **TestReconcileAdminCredentials_AutoGenerate**: Verify admin credentials Secret is created with username and password keys. Verify it's idempotent (calling again doesn't change the password).

  **Important implementation notes:**
  - The `collectSecretData()` function in the controller should be updated to include the admin credentials Secret in the config hash (so pod restarts if admin password changes). Add the admin credentials Secret data to the hash computation. Only include if operator manages admin credentials (user hasn't provided `spec.identity.admin.passwordSecretRef`).
  - For the auth retry annotation approach: use `metav1.SetMetaDataAnnotation` pattern. Read the current retry count, increment on failure, reset on success. Parse with `strconv.Atoi` with default 0.
  - The reconcileAuth function should be called in Reconcile() even when updateStatus() has already run. The status update for Authenticated condition happens inside reconcileAuth itself via a separate `r.Status().Update()` call, or alternatively, restructure so the Authenticated condition is set before the main updateStatus() call by doing a pre-check. Simpler approach: have reconcileAuth set the condition directly using `r.Status().Update()` on its own copy, accepting a potential double-write on the status subresource (idempotent).
  - When adding `authenticated` to the Ready aggregate in `updateReadyCondition()`, also update the `collectNotReadyReasons()` helper function signature to accept the new `authenticated bool` parameter, and add `if !authenticated { reasons = append(reasons, "NotAuthenticated") }` inside it.
  - Verify that the DittoFS server supports the `DITTOFS_ADMIN_INITIAL_PASSWORD` env var for bootstrapping the admin password. Check `pkg/controlplane/models/admin.go` or `cmd/dittofs/` for env var handling. If not supported, add support in the DittoFS server as part of this task.
  </action>
  <verify>
  Run: `cd k8s/dittofs-operator && go build ./...`
  Run: `cd k8s/dittofs-operator && go test ./internal/controller/... ./utils/conditions/... ./api/v1alpha1/...`
  Verify: auth_reconciler.go compiles, DittoFS client compiles, tests pass, ConditionAuthenticated integrates into Ready aggregate.
  </verify>
  <done>
  Auth reconciler provisions operator service account on first boot, stores credentials in K8s Secret with ownerReference, proactively refreshes tokens at 80% TTL via RequeueAfter, handles API unavailability with exponential backoff (2s to 5min cap) without deleting resources, cleans up service account on CR deletion (best-effort), and Authenticated condition is part of the Ready aggregate making the operator not-ready until authenticated. Admin credentials are auto-generated and injected as env var.
  </done>
</task>

</tasks>

<verification>
1. Operator builds: `cd k8s/dittofs-operator && go build ./...`
2. All operator tests pass: `cd k8s/dittofs-operator && go test ./...`
3. Auth reconciler creates operator credentials Secret with structure: username, password, access-token, refresh-token, server-url
4. Secret has ownerReference to DittoServer CR (GC'd on CR deletion)
5. Token refresh scheduled proactively at 80% of access token TTL
6. API unavailability: Authenticated=False, exponential backoff, no resource deletion
7. CR deletion: operator service account deleted (best-effort, errors swallowed)
8. Ready condition includes Authenticated in its aggregate
9. Admin credentials Secret auto-generated on first run
10. DittoFS pod receives DITTOFS_ADMIN_INITIAL_PASSWORD env var from auto-generated Secret
</verification>

<success_criteria>
- `{cr-name}-operator-credentials` Secret created with username, password, access-token, refresh-token, server-url keys
- `{cr-name}-admin-credentials` Secret auto-generated with admin username and random password
- Secret has ownerReference to DittoServer CR
- Token refresh scheduled at 80% of access token TTL (default: ~12 minutes for 15-minute token)
- API unreachable: Authenticated condition False, exponential backoff (2s-5min), no resource deletion
- CR deletion: operator service account deleted (best-effort)
- ConditionAuthenticated exists and feeds into Ready aggregate
- Admin credentials auto-generated and injected as DITTOFS_ADMIN_INITIAL_PASSWORD env var
- DittoFSClient within operator module provides Login/CreateUser/RefreshToken/DeleteUser
- All operator tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-auth-foundation/01-02-SUMMARY.md`
</output>
