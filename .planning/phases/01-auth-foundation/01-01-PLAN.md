---
phase: 01-auth-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/controlplane/models/user.go
  - internal/controlplane/api/auth/claims.go
  - internal/controlplane/api/middleware/auth.go
  - internal/controlplane/api/middleware/auth_test.go
  - pkg/controlplane/api/router.go
  - internal/controlplane/api/handlers/users.go
autonomous: true

must_haves:
  truths:
    - "A user with role 'operator' can GET /api/v1/adapters and receive adapter list data"
    - "A user with role 'operator' gets 403 Forbidden when calling POST/PUT/DELETE on /api/v1/adapters"
    - "A user with role 'operator' gets 403 Forbidden on GET /api/v1/adapters/{type}"
    - "A user with role 'operator' gets 403 Forbidden on all other admin endpoints (users, groups, shares, settings, stores)"
    - "Existing admin and user roles continue to work exactly as before"
    - "Creating a user with role 'operator' does NOT set MustChangePassword to true"
  artifacts:
    - path: "pkg/controlplane/models/user.go"
      provides: "RoleOperator constant and updated IsValid()"
      contains: "RoleOperator"
    - path: "internal/controlplane/api/middleware/auth.go"
      provides: "RequireRole middleware (fail-closed, parameterized)"
      contains: "RequireRole"
    - path: "pkg/controlplane/api/router.go"
      provides: "Split adapter routes: GET / accessible to admin+operator, all other routes admin-only"
      contains: "RequireRole"
    - path: "internal/controlplane/api/auth/claims.go"
      provides: "HasRole and IsOperator helpers on Claims"
      contains: "IsOperator"
    - path: "internal/controlplane/api/middleware/auth_test.go"
      provides: "Unit tests for RequireRole middleware"
      contains: "TestRequireRole"
  key_links:
    - from: "pkg/controlplane/api/router.go"
      to: "internal/controlplane/api/middleware/auth.go"
      via: "RequireRole middleware applied to adapter GET / route group"
      pattern: "RequireRole.*admin.*operator"
    - from: "internal/controlplane/api/middleware/auth.go"
      to: "internal/controlplane/api/auth/claims.go"
      via: "GetClaimsFromContext reads claims.Role in RequireRole"
      pattern: "claims\\.Role"
    - from: "internal/controlplane/api/handlers/users.go"
      to: "pkg/controlplane/models/user.go"
      via: "Role validation uses IsValid() which now includes operator"
      pattern: "IsValid"
---

<objective>
Add the "operator" role to DittoFS server with central authorization middleware, enabling least-privilege API access for the K8s operator service account.

Purpose: The K8s operator needs read-only access to the adapter list endpoint. This plan adds the operator role, implements a generalized RequireRole middleware (fail-closed), and splits the adapter routes so GET /api/v1/adapters is accessible to both admin and operator roles while all write operations and all other endpoints remain admin-only.

Output: DittoFS server accepts operator-role users and enforces strict role-based access on adapter endpoints.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-auth-foundation/01-RESEARCH.md
@pkg/controlplane/models/user.go
@internal/controlplane/api/auth/claims.go
@internal/controlplane/api/middleware/auth.go
@pkg/controlplane/api/router.go
@internal/controlplane/api/handlers/users.go
@internal/controlplane/api/handlers/adapters.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add operator role to DittoFS model and claims</name>
  <files>
    pkg/controlplane/models/user.go
    internal/controlplane/api/auth/claims.go
    internal/controlplane/api/handlers/users.go
  </files>
  <action>
  In `pkg/controlplane/models/user.go`:
  1. Add `RoleOperator UserRole = "operator"` to the const block alongside RoleUser and RoleAdmin.
  2. Update `IsValid()` to include RoleOperator: `return r == RoleUser || r == RoleAdmin || r == RoleOperator`

  In `internal/controlplane/api/auth/claims.go`:
  1. Add `IsOperator() bool` method on `*Claims`: returns `c.Role == "operator"`
  2. Add `HasRole(role string) bool` method on `*Claims`: returns `c.Role == role`

  In `internal/controlplane/api/handlers/users.go`:
  1. In the `Create` handler (line ~92), update the role validation error message from `"Invalid role. Must be 'user' or 'admin'"` to `"Invalid role. Must be 'user', 'admin', or 'operator'"`.
  2. In the `Update` handler (line ~222), make the same error message change.
  3. Verify that operator role users do NOT get `MustChangePassword: true`. Line 99 is `mustChangePassword := role == models.RoleAdmin` -- this already evaluates to false for operator role. No code change needed, but confirm this logic is correct during implementation.
  </action>
  <verify>
  Run: `go build ./pkg/controlplane/models/ && go build ./internal/controlplane/api/auth/ && go build ./internal/controlplane/api/handlers/`
  Run: `go test ./pkg/controlplane/models/... ./internal/controlplane/api/auth/...`
  Confirm RoleOperator is exported and IsValid() accepts it.
  </verify>
  <done>
  RoleOperator constant exists with value "operator", IsValid() accepts "operator", Claims has IsOperator() and HasRole() methods, user creation/update handlers accept "operator" role and do not force password change for operator users.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement RequireRole middleware and split adapter routes</name>
  <files>
    internal/controlplane/api/middleware/auth.go
    internal/controlplane/api/middleware/auth_test.go
    pkg/controlplane/api/router.go
  </files>
  <action>
  In `internal/controlplane/api/middleware/auth.go`:
  1. Add `RequireRole(allowedRoles ...string) func(http.Handler) http.Handler` middleware function.
     - Build a `map[string]bool` from allowedRoles for O(1) lookup.
     - Extract claims via `GetClaimsFromContext(r.Context())`.
     - If claims is nil, return 401 "Authentication required".
     - If `!roleSet[claims.Role]`, return 403 "Insufficient permissions".
     - Otherwise, call `next.ServeHTTP(w, r)`.
     - This is the central, fail-closed authorization middleware per user decision. If no roles are passed, ALL requests are denied (fail-closed).

  Create `internal/controlplane/api/middleware/auth_test.go`:
  1. Add unit tests for RequireRole:
     - `TestRequireRole_AdminOnly`: RequireRole("admin") allows admin claims, returns 403 for user and operator claims.
     - `TestRequireRole_AdminAndOperator`: RequireRole("admin", "operator") allows both admin and operator claims, returns 403 for user claims.
     - `TestRequireRole_NilClaims`: Returns 401 when no claims in context.
     - `TestRequireRole_EmptyRoles`: RequireRole() with no arguments returns 403 for all claims (fail-closed behavior).
     - `TestRequireRole_UserOnly`: RequireRole("user") allows user claims, returns 403 for admin and operator.
  2. Use `httptest.NewRecorder` and manually set claims in context via `context.WithValue`. Pattern:
     ```go
     claims := &auth.Claims{Role: "operator"}
     ctx := context.WithValue(r.Context(), claimsContextKey, claims)
     ```
     Note: You will need to export or expose claimsContextKey for testing, OR create a helper like `ContextWithClaims(ctx, claims)` in the middleware package. Choose the approach that minimizes public API surface -- a test helper function within the test file that creates the context value directly is simplest. Since `claimsContextKey` is unexported, create a test-only helper in the test file that builds a context with claims using the same key type and value.

  In `pkg/controlplane/api/router.go`:
  1. Split the adapter route group (currently lines 180-189) from a single `RequireAdmin()` block into two groups:
     ```go
     // Adapter configuration - split read/write access
     r.Route("/adapters", func(r chi.Router) {
         adapterHandler := handlers.NewAdapterHandler(rt)

         // Read endpoint: admin + operator (per user decision: strictly GET /api/v1/adapters list only)
         r.Group(func(r chi.Router) {
             r.Use(apiMiddleware.RequireRole("admin", "operator"))
             r.Get("/", adapterHandler.List)
         })

         // Write endpoints + individual get: admin only
         r.Group(func(r chi.Router) {
             r.Use(apiMiddleware.RequireAdmin())
             r.Post("/", adapterHandler.Create)
             r.Get("/{type}", adapterHandler.Get)
             r.Put("/{type}", adapterHandler.Update)
             r.Delete("/{type}", adapterHandler.Delete)
         })
     })
     ```
  2. Note: `adapterHandler` must be created outside the subgroups so both groups can reference it. Move it to the Route level as shown above.
  3. Per user decision: strictly GET /api/v1/adapters (list) only for operator. GET /{type} stays admin-only. This is the absolute minimum privilege.
  4. All other route groups (users, groups, shares, settings, metadata-stores, payload-stores) remain unchanged with RequireAdmin().
  </action>
  <verify>
  Run: `go build ./internal/controlplane/api/middleware/ && go build ./pkg/controlplane/api/`
  Run: `go test ./internal/controlplane/api/middleware/...`
  Run: `go test ./...` to verify no regressions across the entire project.
  Manually verify in the router code that:
  - GET /api/v1/adapters uses RequireRole("admin", "operator")
  - POST/PUT/DELETE /api/v1/adapters/* and GET /api/v1/adapters/{type} use RequireAdmin()
  - All other protected routes still use RequireAdmin()
  </verify>
  <done>
  RequireRole middleware exists and is tested with fail-closed behavior. Adapter GET /api/v1/adapters allows admin+operator, all write endpoints and individual GET are admin-only. All existing tests pass. No regressions in other endpoints.
  </done>
</task>

</tasks>

<verification>
1. Build passes: `go build ./...`
2. All existing tests pass: `go test ./...`
3. New middleware tests pass: `go test ./internal/controlplane/api/middleware/...`
4. The operator role is a valid role in the model: `RoleOperator` exported, `IsValid()` returns true
5. Router correctly splits adapter read (admin+operator) from write (admin-only)
6. No other routes are affected (all still use RequireAdmin())
7. User creation with role "operator" does not set MustChangePassword
</verification>

<success_criteria>
- `RoleOperator` constant exists in models with value "operator"
- `IsValid()` returns true for "operator"
- `RequireRole` middleware exists and is tested (fail-closed behavior verified)
- Adapter list endpoint (`GET /api/v1/adapters`) accepts operator role
- All adapter mutation endpoints and GET /{type} reject operator role with 403
- All existing admin/user functionality is unchanged
- All tests pass including new middleware tests
</success_criteria>

<output>
After completion, create `.planning/phases/01-auth-foundation/01-01-SUMMARY.md`
</output>
