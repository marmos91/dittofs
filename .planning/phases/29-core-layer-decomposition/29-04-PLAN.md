---
phase: 29-core-layer-decomposition
plan: 04
type: execute
wave: 2
depends_on:
  - 29-01
files_modified:
  - pkg/controlplane/store/interface.go
  - pkg/controlplane/store/adapter_configs.go
  - pkg/controlplane/store/adapter_settings.go
  - pkg/controlplane/store/metadata.go
  - pkg/controlplane/store/payload.go
  - pkg/controlplane/store/identity.go
  - internal/controlplane/api/handlers/users.go
  - internal/controlplane/api/handlers/groups.go
  - internal/controlplane/api/handlers/shares.go
  - internal/controlplane/api/handlers/adapters.go
  - internal/controlplane/api/handlers/adapter_settings.go
  - internal/controlplane/api/handlers/metadata_stores.go
  - internal/controlplane/api/handlers/payload_stores.go
  - internal/controlplane/api/handlers/settings.go
  - internal/controlplane/api/handlers/health.go
  - internal/controlplane/api/handlers/identity_mappings.go
  - internal/controlplane/api/handlers/netgroups.go
  - internal/controlplane/api/handlers/mounts.go
  - pkg/controlplane/api/router.go
autonomous: true
requirements:
  - REF-05.1
  - REF-05.2
must_haves:
  truths:
    - "Store interface is decomposed into ~9 named sub-interfaces with composite Store embedding all"
    - "Each API handler accepts only the narrowest sub-interface it needs"
    - "Router receives full Store and passes narrow sub-interfaces to handler constructors"
    - "GORMStore satisfies the composite Store interface (compile-time assertion)"
    - "Underscore files renamed per CONTEXT.md decisions"
  artifacts:
    - path: "pkg/controlplane/store/interface.go"
      provides: "Sub-interfaces (UserStore, GroupStore, ShareStore, etc.) + composite Store"
      contains: "type UserStore interface"
    - path: "pkg/controlplane/api/router.go"
      provides: "Router passing narrow sub-interfaces to handler constructors"
      contains: "store\\.UserStore|store\\.GroupStore"
  key_links:
    - from: "internal/controlplane/api/handlers/users.go"
      to: "pkg/controlplane/store/interface.go"
      via: "handler accepts store.UserStore instead of store.Store"
      pattern: "store\\.UserStore"
    - from: "pkg/controlplane/api/router.go"
      to: "internal/controlplane/api/handlers/"
      via: "passes narrow interfaces to handler constructors"
      pattern: "NewUserHandler|NewGroupHandler"
---

<objective>
Decompose the ControlPlane Store interface into ~9 named sub-interfaces and narrow all API handlers to accept only the specific sub-interface they need.

Purpose: The current Store interface has ~70 methods. Every handler receives the full interface even though it uses only 5-10 methods. Decomposing into focused sub-interfaces (UserStore, GroupStore, ShareStore, etc.) improves testability and makes dependencies explicit. API handlers become independently testable with minimal in-memory store implementations.

Output: Restructured interface.go with sub-interfaces + composite, all handlers narrowed, router updated, underscore files renamed.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-core-layer-decomposition/29-CONTEXT.md
@.planning/phases/29-core-layer-decomposition/29-RESEARCH.md

<interfaces>
<!-- Sub-interface groupings from research -->

UserStore (10 methods):
  GetUser, GetUserByID, GetUserByUID, ListUsers, CreateUser, UpdateUser,
  DeleteUser, UpdatePassword, UpdateLastLogin, ValidateCredentials

GroupStore (9 methods):
  GetGroup, GetGroupByID, ListGroups, CreateGroup, UpdateGroup, DeleteGroup,
  GetUserGroups, AddUserToGroup, RemoveUserFromGroup, GetGroupMembers,
  EnsureDefaultGroups

MetadataStoreConfigStore (7 methods):
  GetMetadataStore, GetMetadataStoreByID, ListMetadataStores,
  CreateMetadataStore, UpdateMetadataStore, DeleteMetadataStore,
  GetSharesByMetadataStore

PayloadStoreConfigStore (7 methods):
  GetPayloadStore, GetPayloadStoreByID, ListPayloadStores,
  CreatePayloadStore, UpdatePayloadStore, DeletePayloadStore,
  GetSharesByPayloadStore

ShareStore (11+ methods):
  GetShare, GetShareByID, ListShares, CreateShare, UpdateShare, DeleteShare,
  GetUserAccessibleShares, GetShareAccessRules, SetShareAccessRules,
  AddShareAccessRule, RemoveShareAccessRule
  + GetShareAdapterConfig, SetShareAdapterConfig, DeleteShareAdapterConfig,
    ListShareAdapterConfigs (from adapter_configs.go)

PermissionStore (9 methods):
  GetUserSharePermission, SetUserSharePermission, DeleteUserSharePermission,
  GetUserSharePermissions, GetGroupSharePermission, SetGroupSharePermission,
  DeleteGroupSharePermission, GetGroupSharePermissions,
  ResolveSharePermission

AdapterStore (10+ methods):
  GetAdapter, ListAdapters, CreateAdapter, UpdateAdapter, DeleteAdapter,
  EnsureDefaultAdapters
  + GetNFSAdapterSettings, UpdateNFSAdapterSettings, ResetNFSAdapterSettings,
    GetSMBAdapterSettings, UpdateSMBAdapterSettings, ResetSMBAdapterSettings,
    EnsureAdapterSettings (from adapter_settings.go)

SettingsStore (4 methods):
  GetSetting, SetSetting, DeleteSetting, ListSettings

AdminStore (2 methods):
  EnsureAdminUser, IsAdminInitialized

HealthStore (2 methods):
  Healthcheck, Close

IdentityMappingStore: (identity mapping methods)
NetgroupStore: (netgroup methods)

File renames per CONTEXT.md:
  adapter_configs.go → methods absorbed into shares.go
  adapter_settings.go → merged into adapters.go
  metadata_stores.go → metadata.go
  payload_stores.go → payload.go
  identity_mappings.go → identity.go
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Decompose Store interface into sub-interfaces + rename files</name>
  <files>
    pkg/controlplane/store/interface.go
    pkg/controlplane/store/adapter_configs.go
    pkg/controlplane/store/adapter_settings.go
    pkg/controlplane/store/shares.go
    pkg/controlplane/store/adapters.go
    pkg/controlplane/store/metadata.go
    pkg/controlplane/store/payload.go
    pkg/controlplane/store/identity.go
  </files>
  <action>
1. **Rename files** per CONTEXT.md decisions:
   - Move `adapter_configs.go` methods into `shares.go` (ShareAdapterConfig is share-scoped). Then delete `adapter_configs.go`.
   - Merge `adapter_settings.go` content into `adapters.go` (adapter CRUD + global adapter settings). Then delete `adapter_settings.go`. Also merge `adapter_settings_test.go` into an appropriate test file or rename it.
   - Rename `metadata_stores.go` to `metadata.go`.
   - Rename `payload_stores.go` to `payload.go`.
   - Rename `identity_mappings.go` to `identity.go`.

2. **Restructure interface.go**:
   - Replace the single giant `Store` interface with named sub-interfaces:
     - `UserStore` — all user CRUD + credentials methods
     - `GroupStore` — all group CRUD + membership methods
     - `ShareStore` — all share CRUD + access rules + ShareAdapterConfig methods
     - `PermissionStore` — user/group share permissions + resolution
     - `MetadataStoreConfigStore` — metadata store config CRUD
     - `PayloadStoreConfigStore` — payload store config CRUD
     - `AdapterStore` — adapter CRUD + adapter settings (NFS/SMB settings)
     - `SettingsStore` — generic key-value settings
     - `AdminStore` — EnsureAdminUser, IsAdminInitialized
     - `HealthStore` — Healthcheck, Close
     - `IdentityMappingStore` — identity mapping operations
     - `NetgroupStore` — netgroup operations
   - Create composite `Store` interface that embeds all sub-interfaces
   - GuestStore methods (GetGuestUser, IsGuestEnabled): fold into UserStore per research recommendation (they return *User)

3. **Add compile-time assertion**: `var _ Store = (*GORMStore)(nil)` to verify GORMStore satisfies the full composite interface.

4. **Add compile-time assertions for each sub-interface**: `var _ UserStore = (*GORMStore)(nil)`, etc. Place in `gorm.go` or a dedicated `assertions.go` file.

5. Ensure all method signatures in sub-interfaces exactly match the GORMStore method signatures (copy from current interface.go, do not re-type).

6. Add Godoc comments on each sub-interface explaining its responsibility.
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs && go build ./pkg/controlplane/store/... && go vet ./pkg/controlplane/store/...</automated>
  </verify>
  <done>Store interface decomposed into ~12 named sub-interfaces with composite Store embedding all; underscore files renamed; compile-time assertions pass; GORMStore satisfies all sub-interfaces.</done>
</task>

<task type="auto">
  <name>Task 2: Narrow API handlers to accept specific sub-interfaces</name>
  <files>
    internal/controlplane/api/handlers/users.go
    internal/controlplane/api/handlers/groups.go
    internal/controlplane/api/handlers/shares.go
    internal/controlplane/api/handlers/adapters.go
    internal/controlplane/api/handlers/adapter_settings.go
    internal/controlplane/api/handlers/metadata_stores.go
    internal/controlplane/api/handlers/payload_stores.go
    internal/controlplane/api/handlers/settings.go
    internal/controlplane/api/handlers/health.go
    internal/controlplane/api/handlers/identity_mappings.go
    internal/controlplane/api/handlers/netgroups.go
    internal/controlplane/api/handlers/mounts.go
    pkg/controlplane/api/router.go
  </files>
  <action>
1. **Audit each handler** — for every handler struct, grep for `h.store.XXX` or `h.cpStore.XXX` calls to determine exactly which store methods it uses.

2. **Update handler structs** — change the store field from `store.Store` to the narrowest sub-interface:
   - `UserHandler` → `store store.UserStore`
   - `GroupHandler` → `store store.GroupStore`
   - `ShareHandler` → `shareStore store.ShareStore, permStore store.PermissionStore` (shares handler needs both)
   - `AdapterHandler` → `store store.AdapterStore`
   - `AdapterSettingsHandler` → `store store.AdapterStore` (settings are part of AdapterStore)
   - `MetadataStoreHandler` → `store store.MetadataStoreConfigStore`
   - `PayloadStoreHandler` → `store store.PayloadStoreConfigStore`
   - `SettingsHandler` → `store store.SettingsStore`
   - `HealthHandler` → `store store.HealthStore`
   - `IdentityMappingHandler` → `store store.IdentityMappingStore`
   - `NetgroupHandler` → `store store.NetgroupStore`
   - `MountsHandler` → uses runtime, not store directly (verify and narrow if applicable)

3. **Update constructors** — each `NewXXXHandler(store store.Store, ...)` becomes `NewXXXHandler(store store.UserStore, ...)` with the narrow type.

4. **Update router** — `pkg/controlplane/api/router.go` receives the full `store.Store` and passes narrow sub-interfaces to each handler constructor. Since the composite `Store` satisfies all sub-interfaces, this is just: `NewUserHandler(cpStore, ...)` where `cpStore` is `store.Store` (Go's implicit interface satisfaction handles the narrowing).

5. **Update handler tests** — handler tests that create mock/in-memory stores need their setup updated to match the new narrower interface types. If tests construct a full `GORMStore`, they can pass it unchanged (it satisfies all sub-interfaces).

6. **Auth handler**: The auth handler likely needs both `UserStore` (for credential validation) and possibly `AdminStore`. Audit carefully and accept the narrowest combination.

7. Verify no handler accidentally uses a method not in its declared sub-interface. The compiler will catch this — run `go build ./...` after each handler update.
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs && go build ./... && go test ./internal/controlplane/api/handlers/... -count=1 2>&1 | tail -20</automated>
  </verify>
  <done>All API handlers accept narrowest sub-interface; router passes narrow interfaces from full Store; all handler tests pass; go build ./... succeeds; no handler uses methods outside its declared interface.</done>
</task>

</tasks>

<verification>
```bash
# Full build succeeds
cd /Users/marmos91/Projects/dittofs && go build ./...

# All tests pass
go test ./pkg/controlplane/store/... ./internal/controlplane/api/handlers/... -count=1

# No vet issues
go vet ./...

# Verify no underscore files remain (except test files)
ls pkg/controlplane/store/adapter_configs.go pkg/controlplane/store/adapter_settings.go pkg/controlplane/store/metadata_stores.go pkg/controlplane/store/payload_stores.go pkg/controlplane/store/identity_mappings.go 2>&1
# All should show "No such file or directory"
```
</verification>

<success_criteria>
- Store interface decomposed into ~12 named sub-interfaces
- Composite Store embeds all sub-interfaces
- Compile-time assertions verify GORMStore satisfies all interfaces
- All API handlers accept narrowest possible sub-interface
- Underscore files renamed or absorbed
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/29-core-layer-decomposition/29-04-SUMMARY.md`
</output>
