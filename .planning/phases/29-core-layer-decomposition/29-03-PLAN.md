---
phase: 29-core-layer-decomposition
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/metadata/file/service.go
  - pkg/metadata/file/create.go
  - pkg/metadata/file/modify.go
  - pkg/metadata/file/remove.go
  - pkg/metadata/file/helpers.go
  - pkg/metadata/file/doc.go
  - pkg/metadata/auth/service.go
  - pkg/metadata/auth/identity.go
  - pkg/metadata/auth/permissions.go
  - pkg/metadata/auth/doc.go
  - pkg/metadata/service.go
  - pkg/metadata/file.go
  - pkg/metadata/authentication.go
autonomous: true
requirements:
  - REF-06.8
  - REF-06.9
must_haves:
  truths:
    - "file.go (1217 lines) is split into pkg/metadata/file/ sub-package with create.go, modify.go, remove.go, helpers.go"
    - "authentication.go (796 lines) is split into pkg/metadata/auth/ sub-package with identity.go, permissions.go"
    - "Each sub-package has its own Service type with interface"
    - "Composite MetadataService in parent package embeds file.Service and auth.Service"
    - "All existing tests pass after split"
  artifacts:
    - path: "pkg/metadata/file/service.go"
      provides: "FileService interface and constructor"
      contains: "type Service"
    - path: "pkg/metadata/file/create.go"
      provides: "CreateFile, CreateSymlink, CreateSpecialFile, CreateHardLink"
      contains: "func.*Service.*Create"
    - path: "pkg/metadata/file/modify.go"
      provides: "SetFileAttributes, Move, Lookup, ReadSymlink, MarkFileAsOrphaned"
      contains: "func.*Service.*SetFileAttributes"
    - path: "pkg/metadata/file/remove.go"
      provides: "RemoveFile, RemoveDirectory"
      contains: "func.*Service.*Remove"
    - path: "pkg/metadata/auth/identity.go"
      provides: "AuthContext, Identity, ApplyIdentityMapping"
      contains: "type AuthContext"
    - path: "pkg/metadata/auth/permissions.go"
      provides: "CheckShareAccess, checkFilePermissions, calculatePermissions"
      contains: "func.*Service.*Check"
  key_links:
    - from: "pkg/metadata/service.go"
      to: "pkg/metadata/file/"
      via: "composite embedding of file.Service"
      pattern: "file\\.Service"
    - from: "pkg/metadata/service.go"
      to: "pkg/metadata/auth/"
      via: "composite embedding of auth.Service"
      pattern: "auth\\.Service"
---

<objective>
Split the two largest files in the metadata package into focused sub-packages: file.go (1217 lines) into pkg/metadata/file/ and authentication.go (796 lines) into pkg/metadata/auth/.

Purpose: These two files contain the bulk of MetadataService business logic. Splitting them into sub-packages with their own Service types enables independent testing and clearer responsibility boundaries. The parent MetadataService becomes a thin composite that embeds both sub-services.

Output: Two new sub-packages (pkg/metadata/file/ and pkg/metadata/auth/), each with their own Service type and interface. The parent MetadataService embeds both. Original file.go and authentication.go are removed.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-core-layer-decomposition/29-CONTEXT.md
@.planning/phases/29-core-layer-decomposition/29-RESEARCH.md

<interfaces>
<!-- File split mapping from research -->

From pkg/metadata/file.go (1217 lines):

file/create.go: CreateFile (line 218), CreateSymlink (223), CreateSpecialFile (233),
  CreateHardLink (250), createEntry (865)

file/modify.go: SetFileAttributes (365), Move (596), MarkFileAsOrphaned (835),
  ReadSymlink (338), Lookup (168)

file/remove.go: RemoveFile (32) — the biggest single function (~130 lines)

file/helpers.go: buildPath (1057), buildPayloadID (1065),
  MakeRdev (1197), RdevMajor (1202), RdevMinor (1207), GetInitialLinkCount (1212)

From pkg/metadata/authentication.go (796 lines):

auth/identity.go: AuthContext struct (line 22), Identity struct (65),
  HasGID (127), ApplyIdentityMapping (371), IsAdministratorSID (434),
  MatchesIPPattern (450), CopyFileAttr (506)

auth/permissions.go: CheckShareAccess (207), checkFilePermissions (550),
  calculatePermissions (597), evaluateACLPermissions (664),
  evaluateWithACL (730), checkWritePermission (748), checkReadPermission (765),
  checkExecutePermission (782), CalculatePermissionsFromBits (475),
  CheckOtherPermissions (495)

Key constraint: Shared types (FileHandle, File, etc.) stay in parent pkg/metadata/
to avoid circular imports. Sub-packages define their own interfaces for any
metadata store methods they need.
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pkg/metadata/file/ sub-package from file.go</name>
  <files>
    pkg/metadata/file/service.go
    pkg/metadata/file/create.go
    pkg/metadata/file/modify.go
    pkg/metadata/file/remove.go
    pkg/metadata/file/helpers.go
    pkg/metadata/file/doc.go
    pkg/metadata/file.go
  </files>
  <action>
1. Create `pkg/metadata/file/` directory.

2. Create `service.go` — define the `Service` interface and struct:
   - The interface includes all public methods that were on MetadataService for file operations (CreateFile, CreateSymlink, CreateSpecialFile, CreateHardLink, SetFileAttributes, Move, RemoveFile, RemoveDirectory, Lookup, ReadSymlink, MarkFileAsOrphaned, plus helper exports like MakeRdev, RdevMajor, RdevMinor, GetInitialLinkCount).
   - The struct holds: metadata store reference (use a local interface for store methods this service needs — do NOT import the parent package), payload service reference (use interface), and lock manager reference (use interface).
   - Constructor: `New(store FileStore, ...) *ServiceImpl` that creates the concrete implementation.
   - **CRITICAL ANTI-PATTERN**: The sub-package must NOT import `pkg/metadata/` (would create circular import). Define any needed types/interfaces locally or accept them via constructor parameters.

3. Create `create.go` — move CreateFile, CreateSymlink, CreateSpecialFile, CreateHardLink, and the private createEntry function. These become methods on the ServiceImpl struct.

4. Create `modify.go` — move SetFileAttributes, Move, MarkFileAsOrphaned, ReadSymlink, Lookup. These become methods on ServiceImpl.

5. Create `remove.go` — move RemoveFile, RemoveDirectory. These become methods on ServiceImpl.

6. Create `helpers.go` — move buildPath, buildPayloadID (private helpers) and MakeRdev, RdevMajor, RdevMinor, GetInitialLinkCount (public helpers). Public helpers can be package-level functions (not methods).

7. Create `doc.go` with package documentation: "Package file implements file operation business logic for the metadata service. It handles file creation, modification, removal, and helper utilities."

8. Remove the original `pkg/metadata/file.go` entirely (all its code has moved to sub-package).

**Shared types stay in parent**: `FileHandle`, `File`, `FileType`, `AuthContext`, `ExportError`, etc. remain in `pkg/metadata/`. The sub-package imports them from the parent via `metadata.FileHandle` etc. Wait — this creates a circular import if the parent also imports the sub-package.

**Resolution for circular imports**:
- Types used by both parent and child (FileHandle, File, AuthContext, ExportError) should be defined in a shared types package or stay in the parent.
- The parent `service.go` will embed `*file.ServiceImpl` (concrete type) or hold the interface. The parent imports the child.
- The child imports the parent for types only — BUT the parent also imports the child → CYCLE.
- **Correct approach per CONTEXT.md**: Define shared types in the parent package. The child package defines its own interfaces for store operations it needs (like `FileStore`). Pass shared types as parameters (e.g., `*metadata.AuthContext`). The child DOES import the parent for type definitions — this is allowed as long as the parent does NOT import the child's types. The parent imports the child's Service for composition.
- If Go detects a cycle, extract shared types to `pkg/metadata/types/` or keep AuthContext in `pkg/metadata/auth/` and have the parent import it.

**Most pragmatic approach**: Keep AuthContext, FileHandle, File, ExportError in `pkg/metadata/` (parent). Child sub-packages import `pkg/metadata` for these types. The parent `service.go` imports `pkg/metadata/file` for the Service. This works because Go allows parent importing child AND child importing parent ONLY IF there is no circular dependency at the type level. Actually — Go does NOT allow circular imports at all.

**Actual resolution**: Move shared types (AuthContext, FileHandle, File, FileType, ExportError, etc.) into the sub-packages that own them, OR create a `pkg/metadata/types/` package for shared types. Per CONTEXT.md: "Types shared across sub-packages stay in the parent package" — so we need to break the cycle differently.

**Final approach** (break the cycle):
- Shared types stay in `pkg/metadata/` as decided.
- `pkg/metadata/file/` defines a local `MetadataStore` interface that includes only the store methods it needs (this is the "interfaces in sub-packages" pattern from CONTEXT.md).
- `pkg/metadata/file/` does NOT import `pkg/metadata/` — instead, shared types are passed as interface parameters or duplicated as type aliases.
- Actually, the cleanest Go pattern: have `pkg/metadata/file/` accept the store as an interface defined in its own package, and use the same concrete types from `pkg/metadata` by having the parent construct the child service and pass in the store. The child CAN import the parent for types as long as the parent only imports the child for the Service. Go will allow: parent → child AND child → parent ONLY if there's no initialization cycle... NO, Go flat-out forbids import cycles.

**Revised approach**: Define shared types in the parent `pkg/metadata/`. The sub-packages `file/` and `auth/` must NOT import the parent. Instead:
- Move `AuthContext` to `pkg/metadata/auth/` (it belongs there).
- Move `FileHandle`, `File`, `FileType`, `ExportError` to a separate `pkg/metadata/types.go` file — these are already there. The child packages import nothing from parent.
- The file sub-package defines its OWN interface for the metadata store methods it needs.
- The file sub-package uses primitive types or types from `pkg/metadata/auth/` for AuthContext.
- The parent `pkg/metadata/service.go` imports both `pkg/metadata/file` and `pkg/metadata/auth` for composition.
- `pkg/metadata/file/` imports `pkg/metadata/auth/` for AuthContext (no cycle: file → auth, parent → file, parent → auth).

This is the correct resolution. Implement accordingly.
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs && go build ./pkg/metadata/file/... && go build ./pkg/metadata/...</automated>
  </verify>
  <done>pkg/metadata/file/ sub-package exists with create.go, modify.go, remove.go, helpers.go; no circular imports; package compiles; original file.go removed.</done>
</task>

<task type="auto">
  <name>Task 2: Create pkg/metadata/auth/ sub-package, update parent composite, fix all importers</name>
  <files>
    pkg/metadata/auth/service.go
    pkg/metadata/auth/identity.go
    pkg/metadata/auth/permissions.go
    pkg/metadata/auth/doc.go
    pkg/metadata/service.go
    pkg/metadata/authentication.go
  </files>
  <action>
1. Create `pkg/metadata/auth/` directory.

2. Create `service.go` — define the `Service` interface and struct for auth operations:
   - Interface includes: CheckShareAccess, checkFilePermissions (private helper stays private), ApplyIdentityMapping, and related auth methods.
   - Struct holds references to any stores needed for identity resolution.
   - Constructor: `New(store AuthStore, ...) *ServiceImpl`.

3. Create `identity.go` — move AuthContext struct, Identity struct, HasGID, ApplyIdentityMapping, IsAdministratorSID, MatchesIPPattern, CopyFileAttr.
   - Note: AuthContext is the most widely used type from this file. Moving it here means all files that currently import `metadata.AuthContext` need updating to `metaauth.AuthContext` (or a type alias in the parent).

4. Create `permissions.go` — move CheckShareAccess, checkFilePermissions, calculatePermissions, evaluateACLPermissions, evaluateWithACL, checkWritePermission, checkReadPermission, checkExecutePermission, CalculatePermissionsFromBits, CheckOtherPermissions.

5. Create `doc.go` with package documentation.

6. Update `pkg/metadata/service.go` — the parent MetadataService becomes a composite:
   - Embed or hold references to `*file.ServiceImpl` and `*auth.ServiceImpl`.
   - The constructor creates both sub-services and wires them together.
   - Public methods on MetadataService that previously delegated to file.go or authentication.go now delegate to the embedded sub-services.
   - Alternatively, if the sub-services are embedded, the methods are automatically promoted.

7. Remove the original `pkg/metadata/authentication.go` (all code moved to auth/ sub-package).

8. **AuthContext type alias**: Since AuthContext is used throughout the codebase (50+ files), add a type alias in `pkg/metadata/`: `type AuthContext = auth.AuthContext` so existing importers don't need to change. This is a pragmatic decision to avoid a 50-file import update in this plan. The alias can be removed in a future cleanup pass.

9. Update all existing tests in `pkg/metadata/` that reference functions now in sub-packages. Move test files alongside their code where appropriate.

10. Run `go build ./...` to ensure no broken imports across the entire codebase.
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs && go build ./... && go test ./pkg/metadata/... -count=1 2>&1 | tail -20</automated>
  </verify>
  <done>pkg/metadata/auth/ exists with identity.go and permissions.go; parent MetadataService is a composite embedding file.Service and auth.Service; original authentication.go removed; type alias for AuthContext preserves backward compatibility; all tests pass; go build ./... succeeds.</done>
</task>

</tasks>

<verification>
```bash
# Full build succeeds
cd /Users/marmos91/Projects/dittofs && go build ./...

# All metadata tests pass
go test ./pkg/metadata/... -count=1

# No vet issues
go vet ./pkg/metadata/...

# Sub-packages exist with correct files
ls pkg/metadata/file/ pkg/metadata/auth/
```
</verification>

<success_criteria>
- file.go split into pkg/metadata/file/ with 4 operation files
- authentication.go split into pkg/metadata/auth/ with identity.go and permissions.go
- Each sub-package has its own Service type with interface
- No circular imports
- Composite MetadataService in parent embeds both sub-services
- AuthContext type alias preserves backward compatibility
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/29-core-layer-decomposition/29-03-SUMMARY.md`
</output>
