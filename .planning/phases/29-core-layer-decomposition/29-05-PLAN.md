---
phase: 29-core-layer-decomposition
plan: 05
type: execute
wave: 2
depends_on:
  - 29-02
  - 29-03
files_modified:
  - pkg/payload/io/read.go
  - pkg/payload/io/write.go
  - pkg/payload/io/doc.go
  - pkg/payload/service.go
  - pkg/payload/types.go
  - pkg/metadata/storetest/suite.go
  - pkg/metadata/storetest/file_ops.go
  - pkg/metadata/storetest/dir_ops.go
  - pkg/metadata/storetest/permissions.go
  - pkg/metadata/storetest/doc.go
  - pkg/metadata/store/memory/memory_conformance_test.go
  - pkg/metadata/store/badger/badger_conformance_test.go
  - pkg/metadata/store/postgres/postgres_conformance_test.go
autonomous: true
requirements:
  - REF-06.6
  - REF-06.7
must_haves:
  truths:
    - "PayloadService io operations extracted to pkg/payload/io/ sub-package"
    - "Composite PayloadService in parent embeds io.Service and references offloader"
    - "Metadata store conformance test suite exists in pkg/metadata/storetest/"
    - "All 3 metadata store implementations (memory, badger, postgres) can run conformance tests"
  artifacts:
    - path: "pkg/payload/io/read.go"
      provides: "ReadAt, ReadAtWithCOWSource operations"
      contains: "func.*Service.*ReadAt"
    - path: "pkg/payload/io/write.go"
      provides: "WriteAt, Truncate, Delete, writeBlockWithRetry"
      contains: "func.*Service.*WriteAt"
    - path: "pkg/metadata/storetest/suite.go"
      provides: "Conformance test suite runner"
      contains: "RunConformanceSuite"
    - path: "pkg/metadata/storetest/file_ops.go"
      provides: "File operation conformance tests"
      contains: "testCreateFile|testDeleteFile"
  key_links:
    - from: "pkg/payload/service.go"
      to: "pkg/payload/io/"
      via: "composite embedding of io.Service"
      pattern: "payloadio\\.Service"
    - from: "pkg/metadata/store/memory/memory_conformance_test.go"
      to: "pkg/metadata/storetest/"
      via: "runs conformance suite against memory store"
      pattern: "storetest\\.RunConformanceSuite"
---

<objective>
Extract PayloadService I/O operations to a sub-package and create a metadata store conformance test suite.

Purpose: PayloadService I/O extraction follows the same sub-package pattern used for MetadataService (Plan 03), making read/write operations independently testable. The metadata store conformance suite ensures all store implementations (memory, badger, postgres) satisfy the same behavioral contract, catching regressions when store code changes.

Output: New pkg/payload/io/ package with read/write operations, updated PayloadService composite, new pkg/metadata/storetest/ conformance suite with tests wired to all 3 store implementations.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-core-layer-decomposition/29-CONTEXT.md
@.planning/phases/29-core-layer-decomposition/29-RESEARCH.md
@.planning/phases/29-core-layer-decomposition/29-02-SUMMARY.md
@.planning/phases/29-core-layer-decomposition/29-03-SUMMARY.md

<interfaces>
<!-- PayloadService I/O split mapping -->

From pkg/payload/service.go (407 lines):

io/read.go: ReadAt(), ReadAtWithCOWSource()
  - These read from cache first, fall back to offloader download on cache miss
  - Accept payloadID, offset, length parameters
  - Return data bytes and error

io/write.go: WriteAt(), Truncate(), Delete(), writeBlockWithRetry()
  - WriteAt writes to cache layer
  - Truncate updates file size
  - Delete removes payload from cache and offloader
  - writeBlockWithRetry handles transient write failures

Remaining in service.go: Constructor, Flush(), FlushAll(), GetStats(),
  PayloadService struct definition, composition of sub-services

Note: Use import alias `payloadio` where stdlib `io` is also imported,
per CONTEXT.md decision.
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract PayloadService I/O to pkg/payload/io/ sub-package</name>
  <files>
    pkg/payload/io/read.go
    pkg/payload/io/write.go
    pkg/payload/io/doc.go
    pkg/payload/service.go
    pkg/payload/types.go
  </files>
  <action>
1. Create `pkg/payload/io/` directory.

2. Create `read.go` — move ReadAt and ReadAtWithCOWSource from service.go:
   - Define a `Service` interface with ReadAt and ReadAtWithCOWSource methods.
   - Define `ServiceImpl` struct that holds references to cache and offloader (as interfaces, not concrete types, to avoid circular imports).
   - Constructor: `New(cache CacheReader, offloader BlockDownloader) *ServiceImpl`.
   - The `CacheReader` and `BlockDownloader` interfaces are defined locally in this package — they describe only the methods the io package needs from cache and offloader.

3. Create `write.go` — move WriteAt, Truncate, Delete, writeBlockWithRetry:
   - These become methods on the same `ServiceImpl` (read and write share the same service instance since they both need cache and offloader access).
   - Define `CacheWriter` and `BlockUploader` local interfaces as needed.

4. Create `doc.go`: "Package io provides read and write operations for the payload service, coordinating between the cache layer and the offloader for persistent storage."

5. Update `pkg/payload/service.go`:
   - Import `payloadio "github.com/marmos91/dittofs/pkg/payload/io"` (alias to avoid stdlib io conflict).
   - PayloadService struct now holds `*payloadio.ServiceImpl` (or embeds `payloadio.Service` interface).
   - Constructor creates the io.Service and wires cache + offloader.
   - Remove ReadAt, ReadAtWithCOWSource, WriteAt, Truncate, Delete, writeBlockWithRetry from service.go.
   - Keep Flush, FlushAll, GetStats, Close in service.go (orchestration, not I/O).

6. Update `pkg/payload/types.go` if any type aliases reference removed methods.

7. Apply the same circular import avoidance strategy as Plan 03: the io sub-package defines its own local interfaces for cache and offloader dependencies.
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs && go build ./pkg/payload/... && go test ./pkg/payload/... -count=1 2>&1 | tail -20</automated>
  </verify>
  <done>pkg/payload/io/ exists with read.go and write.go; PayloadService is a composite; ReadAt/WriteAt operations work through the io sub-service; all payload tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Create metadata store conformance test suite</name>
  <files>
    pkg/metadata/storetest/suite.go
    pkg/metadata/storetest/file_ops.go
    pkg/metadata/storetest/dir_ops.go
    pkg/metadata/storetest/permissions.go
    pkg/metadata/storetest/doc.go
    pkg/metadata/store/memory/memory_conformance_test.go
    pkg/metadata/store/badger/badger_conformance_test.go
    pkg/metadata/store/postgres/postgres_conformance_test.go
  </files>
  <action>
1. Create `pkg/metadata/storetest/` directory.

2. Create `suite.go` — define the conformance test runner:
   - `RunConformanceSuite(t *testing.T, storeFactory func() metadata.MetadataStore)` — accepts a factory function that creates a fresh store instance for each test.
   - The suite runs all test categories as sub-tests: `t.Run("FileOps", ...)`, `t.Run("DirOps", ...)`, `t.Run("Permissions", ...)`.
   - Each category is defined in its own file.

3. Create `file_ops.go` — file operation conformance tests:
   - `testCreateFile`: create file, verify attributes, verify handle.
   - `testGetFile`: create then get, verify roundtrip.
   - `testDeleteFile`: create, delete, verify gone.
   - `testCreateHardLink`: create file, create hard link, verify link count.
   - `testSetFileAttributes`: create file, modify attrs, verify changes.
   - `testReadWrite`: create file, write data, read back, verify content.
   - `testRename`: create file, rename, verify old name gone, new name exists.
   - `testTruncate`: create file, write, truncate, verify size.

4. Create `dir_ops.go` — directory operation conformance tests:
   - `testCreateDirectory`: create dir, verify type, verify nlink.
   - `testListDirectory`: create dir with children, list, verify all present.
   - `testRemoveEmptyDirectory`: create dir, remove, verify gone.
   - `testRemoveNonEmptyDirectory`: create dir with children, attempt remove, verify error.
   - `testNestedDirectories`: create nested dirs, verify parent/child relationships.

5. Create `permissions.go` — permission conformance tests:
   - `testCheckAccess`: verify read/write/execute permission checks.
   - `testCheckAccessDenied`: verify permission denial for unauthorized users.
   - `testRootAccess`: verify root (UID 0) can access everything.

6. Create `doc.go`: "Package storetest provides a conformance test suite for metadata store implementations. All metadata store backends (memory, badger, postgres) should pass these tests."

7. Wire the suite to each store implementation:
   - `pkg/metadata/store/memory/memory_conformance_test.go`: call `storetest.RunConformanceSuite(t, func() { return memory.New() })`.
   - `pkg/metadata/store/badger/badger_conformance_test.go`: similar, with temp directory setup.
   - `pkg/metadata/store/postgres/postgres_conformance_test.go`: similar, with test DB setup (may need integration build tag).

8. Extract tests from EXISTING test files where they test the same behavior — don't duplicate. If existing tests already cover a conformance behavior, move the test logic to storetest and call it from the store-specific test file.
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs && go build ./pkg/metadata/storetest/... && go test ./pkg/metadata/store/memory/... -count=1 -run Conformance 2>&1 | tail -20</automated>
  </verify>
  <done>pkg/metadata/storetest/ exists with conformance suite; memory store passes all conformance tests; badger and postgres test files exist (may need integration build tag to run); suite covers file ops, dir ops, and permissions.</done>
</task>

</tasks>

<verification>
```bash
# Full build succeeds
cd /Users/marmos91/Projects/dittofs && go build ./...

# All tests pass
go test ./pkg/payload/... ./pkg/metadata/... -count=1

# Conformance suite runs for memory store
go test ./pkg/metadata/store/memory/... -count=1 -run Conformance -v

# No vet issues
go vet ./...
```
</verification>

<success_criteria>
- PayloadService I/O extracted to pkg/payload/io/ with read.go and write.go
- Composite PayloadService embeds io.Service
- Metadata store conformance suite exists in pkg/metadata/storetest/
- Memory store passes all conformance tests
- Badger and postgres conformance test files exist
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/29-core-layer-decomposition/29-05-SUMMARY.md`
</output>
