---
phase: 25-v3-integration-testing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/protocol/smb/v2/handlers/session_setup.go
  - internal/protocol/smb/v2/handlers/session_setup_test.go
  - test/e2e/smb_kerberos_test.go
  - test/e2e/cross_protocol_test.go
autonomous: true
requirements: [SMBKRB-01, SMBKRB-02]

must_haves:
  truths:
    - "SMB SESSION_SETUP handler detects Kerberos tokens in SPNEGO and validates them via gokrb5"
    - "Kerberos principal maps to control plane user identity (username extraction from principal)"
    - "SMB session established with correct user identity after Kerberos auth"
    - "Existing NTLM authentication continues to work unchanged"
    - "E2E test verifies SMB Kerberos mount and basic file operations"
    - "Cross-protocol identity consistency: NFS Kerberos user and SMB Kerberos user see same files with same permissions"
  artifacts:
    - path: "internal/protocol/smb/v2/handlers/session_setup.go"
      provides: "Kerberos authentication path in SessionSetup handler"
      contains: "handleKerberosAuth"
    - path: "internal/protocol/smb/v2/handlers/session_setup_test.go"
      provides: "Unit tests for Kerberos auth path"
      contains: "TestKerberos"
    - path: "test/e2e/smb_kerberos_test.go"
      provides: "E2E tests for SMB SPNEGO/Kerberos auth"
      min_lines: 100
  key_links:
    - from: "internal/protocol/smb/v2/handlers/session_setup.go"
      to: "internal/auth/spnego"
      via: "SPNEGO token parsing for Kerberos detection"
      pattern: "spnego\\.Parse|HasKerberos"
    - from: "internal/protocol/smb/v2/handlers/session_setup.go"
      to: "gokrb5/v8"
      via: "Kerberos ticket validation using service keytab"
      pattern: "gokrb5|service\\.NewSettings|VerifyAPREQ"
    - from: "test/e2e/smb_kerberos_test.go"
      to: "test/e2e/framework/kerberos.go"
      via: "KDC testcontainer for Kerberos environment"
      pattern: "NewKDCHelper"
---

<objective>
Implement SMB Kerberos authentication (SPNEGO/Kerberos path in SESSION_SETUP handler) and validate it end-to-end with tests covering auth, file ops, and cross-protocol identity mapping.

Purpose: SMB adapter currently only supports NTLM. Adding Kerberos auth enables enterprise SSO and shared identity between NFS and SMB protocols using the same Kerberos infrastructure.
Output: Kerberos auth path in SESSION_SETUP, unit tests, E2E SMB Kerberos tests, cross-protocol identity verification.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-v3-integration-testing/25-RESEARCH.md

@internal/protocol/smb/v2/handlers/session_setup.go
@internal/protocol/smb/v2/handlers/session_setup_test.go
@internal/auth/spnego/spnego.go
@test/e2e/framework/kerberos.go
@test/e2e/kerberos_test.go
@test/e2e/cross_protocol_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Kerberos auth path in SMB SESSION_SETUP handler</name>
  <files>
    internal/protocol/smb/v2/handlers/session_setup.go
    internal/protocol/smb/v2/handlers/session_setup_test.go
  </files>
  <action>
1. In `session_setup.go`, add a Kerberos authentication path alongside the existing NTLM path:

   **Detection:** After SPNEGO parsing (which already exists), check if the parsed SPNEGO token contains a Kerberos mechanism. The existing `internal/auth/spnego` package has `HasKerberos()` or similar OID detection. When a Kerberos OID is present with a non-empty MechToken, route to the new Kerberos path instead of NTLM.

   **Kerberos validation flow (`handleKerberosAuth` method):**
   a. Get the service keytab from the handler's registry/config. This should be the same keytab used by the NFS Kerberos layer (shared Kerberos infrastructure). The keytab is likely accessible via the handler's reference to the runtime or a config field. Look at how `internal/protocol/nfs/v4/handlers/` accesses the keytab and follow the same pattern.
   b. Use `gokrb5/v8/service` to validate the AP-REQ from the SPNEGO MechToken:
      - Create settings with `service.NewSettings(keytab)` (with optional logger)
      - Call the appropriate AcceptSecContext or VerifyAPREQ function to validate the ticket
   c. Extract the client principal name from the validated identity
   d. Map principal to control plane user: strip the realm part (e.g., `alice@REALM` -> `alice`), then look up the user in the UserStore. If user not found or disabled, return `STATUS_LOGON_FAILURE`.
   e. Create an authenticated SMB session with the resolved user identity (same as the NTLM success path)
   f. Build SPNEGO response token wrapping AP-REP for the success response

   **Error handling:** If Kerberos validation fails (invalid ticket, expired, wrong service), return `STATUS_LOGON_FAILURE`. Log at INFO level for auth failures, DEBUG for expected conditions.

   **Keytab access:** The SMB adapter needs access to the Kerberos keytab. Check how the NFS adapter accesses it (likely through config or runtime). If the SMB handler doesn't have keytab access yet, add it through the handler's registry or context. The keytab should be the same shared keytab, not a separate one.

   **SPNEGO response:** On successful Kerberos auth, the response should include an SPNEGO negTokenResp wrapping the AP-REP. On NTLM, the existing code already handles SPNEGO response wrapping. Follow the same pattern for Kerberos.

2. In `session_setup_test.go`, add unit tests:
   - Test that SPNEGO tokens with Kerberos OID are detected and routed correctly
   - Test that NTLM tokens continue to work (regression guard)
   - Test that Kerberos auth with invalid ticket returns STATUS_LOGON_FAILURE
   - Test principal-to-username mapping (strip realm, lookup user)

The implementation MUST NOT break existing NTLM authentication. The Kerberos path is an additional authentication mechanism detected by SPNEGO negotiation, not a replacement.
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs && go test ./internal/protocol/smb/...</automated>
    <manual>Verify session_setup.go has handleKerberosAuth method and tests pass</manual>
  </verify>
  <done>SESSION_SETUP handler routes Kerberos SPNEGO tokens to gokrb5 validation, maps principal to control plane user, creates authenticated session. NTLM continues working. Unit tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: SMB Kerberos E2E tests and cross-protocol identity verification</name>
  <files>
    test/e2e/smb_kerberos_test.go
    test/e2e/cross_protocol_test.go
  </files>
  <action>
1. Create `test/e2e/smb_kerberos_test.go` with build tag `//go:build e2e`:

   **Test setup pattern (reuse existing Kerberos infrastructure):**
   - Skip if Docker unavailable (KDC container required)
   - Start KDC via `framework.NewKDCHelper(t, framework.KDCConfig{Realm: "DITTOFS.LOCAL"})`
   - Add user principals: `kdc.AddPrincipal(t, "alice", "alice123")`
   - Add service principal for SMB: `kdc.AddServicePrincipal(t, "cifs", "localhost")` (SMB uses cifs/ SPN)
   - Create server config with Kerberos enabled (keytab from KDC), enable both NFS and SMB adapters
   - Create control plane user "alice" matching the Kerberos principal
   - Install system krb5.conf from KDC (same pattern as kerberos_test.go `installSystemKeytab`)
   - Run `kinit alice` to obtain a TGT before mounting

   **Platform strategy (per locked decision: "macOS: native SMB mount via mount_smbfs for basic ops; advanced features on Linux only (attempt first, skip on failure)"):**
   - **Linux (primary Kerberos validation):** Full Kerberos validation with `mount.cifs` using `sec=krb5`. Check for `cifs-utils` and `krb5-user`; skip if unavailable. Kerberos mount failures on Linux are treated as real test failures.
   - **macOS (best-effort only):** Attempt basic SMB mount via `mount_smbfs //alice@localhost:PORT/export /mnt/test`. Kerberos validation is NOT prioritized on macOS. If mount fails, skip with message "SMB Kerberos not reliably testable on macOS". Advanced features (identity mapping, NTLM coexistence) only run on Linux.

   **Test functions:**
   a. `TestSMBKerberosAuth` -- Linux: mount SMB with `mount -t cifs //localhost/export /mnt/test -o sec=krb5,port=PORT,vers=2.1,cache=none`, verify mount succeeds, perform basic CRUD (create file, read back, delete). macOS: attempt `mount_smbfs`, skip on failure. This proves SMBKRB-01.
   b. `TestSMBKerberosIdentityMapping` -- Linux only. After Kerberos auth, verify that the session user identity matches the control plane user "alice". Create a file via SMB, verify ownership/permissions reflect the mapped identity. Skip on macOS with message. This proves SMBKRB-02.
   c. `TestSMBKerberosAndNTLMCoexist` -- Linux only. Mount two SMB shares: one with Kerberos auth, one with NTLM auth. Both should work simultaneously. Skip on macOS with message.

   **SMB Kerberos mount on Linux (primary):**
   ```
   mount -t cifs //localhost/export /mnt/test -o sec=krb5,port=PORT,vers=2.1,cache=none
   ```
   Need to install cifs-utils and krb5-user on the system. The test should check for these and skip if unavailable.

   **SMB mount on macOS (best-effort, basic ops only):**
   ```
   mount_smbfs //alice@localhost:PORT/export /mnt/test
   ```
   macOS handles Kerberos via the system keychain. Attempt mount, skip on any failure. No advanced feature testing on macOS.

2. Extend `test/e2e/cross_protocol_test.go` (or create a new `test/e2e/cross_protocol_v41_test.go`):

   **Cross-protocol identity test:**
   - Start server with Kerberos enabled, NFS and SMB adapters
   - Mount NFS with Kerberos auth (same user "alice")
   - Mount SMB with Kerberos auth (same user "alice")
   - Create file from NFS mount, verify readable from SMB mount (bidirectional visibility)
   - Verify that file ownership is consistent across both mounts (same UID/identity)
   - Verify group membership resolution works consistently

This test validates that the shared Kerberos layer produces the same identity mapping regardless of whether the client comes through NFS or SMB.
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs && go build -tags=e2e ./test/e2e/...</automated>
    <manual>Verify smb_kerberos_test.go exists with Kerberos auth, identity mapping, and coexistence tests</manual>
  </verify>
  <done>SMB Kerberos E2E tests verify: mount with sec=krb5, identity mapping to control plane user, NTLM+Kerberos coexistence, and cross-protocol NFS+SMB Kerberos identity consistency.</done>
</task>

</tasks>

<verification>
1. `go test ./internal/protocol/smb/...` passes (unit tests for Kerberos auth path)
2. `go build -tags=e2e ./test/e2e/...` compiles without errors
3. `grep -r 'handleKerberosAuth' internal/protocol/smb/` confirms Kerberos handler exists
4. `grep -r 'TestSMBKerberos' test/e2e/` confirms E2E test functions exist
5. Existing NTLM-based SMB tests continue to compile and pass
</verification>

<success_criteria>
- SMB SESSION_SETUP handler detects Kerberos in SPNEGO and validates via gokrb5 shared keytab
- Kerberos principal (alice@REALM) maps to control plane user "alice"
- Existing NTLM authentication is unaffected (regression guard test)
- E2E tests cover: Kerberos mount, identity mapping, NTLM+Kerberos coexistence, cross-protocol identity
- All code compiles with e2e build tag
</success_criteria>

<output>
After completion, create `.planning/phases/25-v3-integration-testing/25-02-SUMMARY.md`
</output>
