---
phase: 01-operator-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - k8s/dittofs-operator/internal/controller/dittoserver_controller.go
  - k8s/dittofs-operator/api/v1alpha1/dittoserver_types.go
  - k8s/dittofs-operator/config/rbac/role.yaml
  - k8s/dittofs-operator/config/crd/bases/dittofs.dittofs.com_dittoservers.yaml
  - k8s/dittofs-operator/config/samples/dittofs_v1alpha1_dittofs_memory.yaml
autonomous: true

must_haves:
  truths:
    - "kubectl get dittofs works (shortName registered)"
    - "Operator can read Secrets without RBAC errors"
    - "Sample CR with memory stores is valid"
  artifacts:
    - path: "k8s/dittofs-operator/config/rbac/role.yaml"
      provides: "RBAC with secrets permission"
      contains: "secrets"
    - path: "k8s/dittofs-operator/config/crd/bases/dittofs.dittofs.com_dittoservers.yaml"
      provides: "CRD with dittofs shortName"
      contains: "dittofs"
    - path: "k8s/dittofs-operator/config/samples/dittofs_v1alpha1_dittofs_memory.yaml"
      provides: "Memory stores sample CR"
      contains: "type: memory"
  key_links:
    - from: "k8s/dittofs-operator/internal/controller/dittoserver_controller.go"
      to: "secrets"
      via: "RBAC marker"
      pattern: "\\+kubebuilder:rbac.*secrets"
---

<objective>
Fix RBAC permissions and CRD shortName, create memory stores sample CR for Phase 1 validation.

Purpose: The existing operator reads Secrets (for JWT, passwords, S3 credentials) but lacks RBAC permission. Also, requirements specify `kubectl get dittofs` should work - need to add `dittofs` shortName to CRD.

Output: RBAC with secrets permission, CRD with `dittofs` shortName, minimal sample CR using memory stores.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-operator-foundation/01-RESEARCH.md
@.planning/phases/01-operator-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add secrets RBAC permission</name>
  <files>k8s/dittofs-operator/internal/controller/dittoserver_controller.go</files>
  <action>
Add RBAC marker for secrets permission to the controller. The operator reads secrets for:
- JWT signing key (identity.jwt.secretRef)
- User password hashes (users.passwordSecretRef)
- S3 credentials (backends.secretRefs)
- Admin password (identity.admin.passwordSecretRef)

Open k8s/dittofs-operator/internal/controller/dittoserver_controller.go and add this RBAC marker with the other markers (around line 46-54):

```go
// +kubebuilder:rbac:groups="",resources=secrets,verbs=get;list;watch
```

The marker should be placed with the other RBAC markers, before the Reconcile function. The existing markers are:
- configmaps (create, delete, get, list, patch, update, watch)
- services (create, delete, get, list, patch, update, watch)
- etc.

For secrets, we only need read access (get, list, watch) - no create/update/delete.

After adding the marker, regenerate RBAC manifests:
```bash
cd k8s/dittofs-operator && make manifests
```

Verify role.yaml now includes secrets.
  </action>
  <verify>
Run: `grep -A5 "secrets" k8s/dittofs-operator/config/rbac/role.yaml` - should show secrets with get, list, watch verbs
Run: `grep "secrets" k8s/dittofs-operator/internal/controller/dittoserver_controller.go` - should show RBAC marker
  </verify>
  <done>RBAC role.yaml includes secrets permission with get;list;watch verbs</done>
</task>

<task type="auto">
  <name>Task 2: Add dittofs shortName to CRD</name>
  <files>k8s/dittofs-operator/api/v1alpha1/dittoserver_types.go</files>
  <action>
Add `dittofs` as an additional shortName to the CRD. Currently the CRD has `ditto` as shortName.

Open k8s/dittofs-operator/api/v1alpha1/dittoserver_types.go and find the kubebuilder:resource marker (around line 635):

```go
// +kubebuilder:resource:shortName=ditto
```

Change it to include both shortNames:

```go
// +kubebuilder:resource:shortName=ditto;dittofs
```

This allows both `kubectl get ditto` and `kubectl get dittofs` to work.

After changing the marker, regenerate CRD:
```bash
cd k8s/dittofs-operator && make manifests
```

Verify the CRD now includes both shortNames.
  </action>
  <verify>
Run: `grep "shortNames" k8s/dittofs-operator/config/crd/bases/dittofs.dittofs.com_dittoservers.yaml` - should show both ditto and dittofs
Run: `grep "shortName" k8s/dittofs-operator/api/v1alpha1/dittoserver_types.go` - should show shortName=ditto;dittofs
  </verify>
  <done>CRD includes both ditto and dittofs as shortNames</done>
</task>

<task type="auto">
  <name>Task 3: Create memory stores sample CR</name>
  <files>k8s/dittofs-operator/config/samples/dittofs_v1alpha1_dittofs_memory.yaml</files>
  <action>
Create a minimal sample CR that uses memory stores for both metadata and content. This is the simplest configuration for Phase 1 validation - no PVCs required, ephemeral storage only.

Create k8s/dittofs-operator/config/samples/dittofs_v1alpha1_dittofs_memory.yaml:

```yaml
# Minimal DittoFS configuration using memory stores
# This is the simplest setup for testing - all data is ephemeral
apiVersion: dittofs.dittofs.com/v1alpha1
kind: DittoServer
metadata:
  name: dittofs-memory
  labels:
    app.kubernetes.io/name: dittofs-operator
    app.kubernetes.io/managed-by: kustomize
spec:
  image: marmos91c/dittofs:latest
  replicas: 1

  # Minimal storage - only metadata PVC is required by operator
  # Content will use memory store (no PVC needed)
  storage:
    metadataSize: "1Gi"
    # contentSize omitted - using memory store

  # NFS configuration
  nfsPort: 2049

  # Service configuration
  service:
    type: ClusterIP

  config:
    # Memory-based backends - simplest setup, ephemeral storage
    backends:
      - name: "memory-metadata"
        type: "badger"  # BadgerDB with emptyDir is closest to "memory" for metadata
        config:
          path: "/data/metadata"

      - name: "memory-content"
        type: "local"  # Local filesystem - will use emptyDir since no contentSize
        config:
          path: "/tmp/content"  # Use /tmp for ephemeral content

    # Single share for testing
    shares:
      - name: "test"
        exportPath: "/export"
        metadataStore: "memory-metadata"
        contentStore: "memory-content"
        # Guest access enabled for easy testing
        defaultPermission: "read-write"
```

Note: The current DittoFS config format doesn't have a pure "memory" backend type. The closest for Phase 1 is:
- metadata: BadgerDB on /data/metadata (uses PVC)
- content: local filesystem on /tmp (ephemeral within pod)

This gives us a working deployment while keeping content ephemeral for testing.
  </action>
  <verify>
Run: `ls k8s/dittofs-operator/config/samples/dittofs_v1alpha1_dittofs_memory.yaml` - file exists
Run: `cat k8s/dittofs-operator/config/samples/dittofs_v1alpha1_dittofs_memory.yaml | head -5` - shows apiVersion
  </verify>
  <done>Memory stores sample CR exists and is valid YAML</done>
</task>

</tasks>

<verification>
From k8s/dittofs-operator/ directory:
1. `make manifests` - succeeds
2. `grep "secrets" config/rbac/role.yaml` - shows secrets permission
3. `grep -A2 "shortNames" config/crd/bases/dittofs.dittofs.com_dittoservers.yaml` - shows both shortNames
4. `ls config/samples/dittofs_v1alpha1_dittofs_memory.yaml` - file exists
</verification>

<success_criteria>
- RBAC role.yaml includes secrets permission (get, list, watch)
- CRD shortNames includes both "ditto" and "dittofs"
- Memory stores sample CR exists at config/samples/dittofs_v1alpha1_dittofs_memory.yaml
- `make manifests` regenerates cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/01-operator-foundation/01-02-SUMMARY.md`
</output>
