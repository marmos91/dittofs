---
phase: 10-nfsv4-locking
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - internal/protocol/nfs/v4/handlers/lock.go
  - internal/protocol/nfs/v4/handlers/handler.go
  - internal/protocol/nfs/v4/state/manager.go
  - internal/protocol/nfs/v4/handlers/lock_test.go
autonomous: true

must_haves:
  truths:
    - "LOCKT tests for lock conflicts without creating any state (no lock-owner, no stateid)"
    - "LOCKT returns NFS4_OK when no conflict exists"
    - "LOCKT returns NFS4ERR_DENIED with LOCK4denied when a conflicting lock is held"
    - "LOCKU releases a byte-range lock via the lock manager using POSIX split semantics"
    - "LOCKU increments the lock stateid seqid on success"
    - "LOCKU returns NFS4ERR_BAD_STATEID for unknown lock stateids"
  artifacts:
    - path: "internal/protocol/nfs/v4/handlers/lock.go"
      provides: "handleLockT and handleLockU handlers"
      contains: "func (h *Handler) handleLockT"
    - path: "internal/protocol/nfs/v4/state/manager.go"
      provides: "TestLock and UnlockFile methods on StateManager"
      contains: "func (sm *StateManager) TestLock"
    - path: "internal/protocol/nfs/v4/handlers/handler.go"
      provides: "OP_LOCKT and OP_LOCKU registered in dispatch table"
      contains: "OP_LOCKT"
  key_links:
    - from: "internal/protocol/nfs/v4/handlers/lock.go"
      to: "internal/protocol/nfs/v4/state/manager.go"
      via: "h.StateManager.TestLock / h.StateManager.UnlockFile"
      pattern: "StateManager\\.(TestLock|UnlockFile)"
    - from: "internal/protocol/nfs/v4/state/manager.go"
      to: "pkg/metadata/lock/manager.go"
      via: "sm.lockManager.ListEnhancedLocks for LOCKT, sm.lockManager.RemoveEnhancedLock for LOCKU"
      pattern: "lockManager\\.(ListEnhancedLocks|RemoveEnhancedLock)"
---

<objective>
Implement LOCKT (lock test) and LOCKU (unlock) operations for NFSv4 byte-range locking.

Purpose: LOCKT allows clients to test for lock conflicts before acquiring, and LOCKU releases held locks. Together with LOCK (Plan 10-01), these complete the core NFSv4 locking operations.

Output: Working LOCKT and LOCKU handlers, StateManager TestLock and UnlockFile methods, registered in dispatch table.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-nfsv4-locking/10-RESEARCH.md
@.planning/phases/10-nfsv4-locking/10-01-SUMMARY.md
@internal/protocol/nfs/v4/state/manager.go
@internal/protocol/nfs/v4/state/lockowner.go
@internal/protocol/nfs/v4/handlers/lock.go
@internal/protocol/nfs/v4/handlers/handler.go
@pkg/metadata/lock/manager.go
@pkg/metadata/lock/types.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: LOCKT handler and StateManager.TestLock</name>
  <files>
    internal/protocol/nfs/v4/state/manager.go
    internal/protocol/nfs/v4/handlers/lock.go
    internal/protocol/nfs/v4/handlers/handler.go
  </files>
  <action>
**1. Add `TestLock()` method to StateManager:**

```go
func (sm *StateManager) TestLock(
    clientID uint64, ownerData []byte,
    fileHandle []byte, lockType uint32, offset, length uint64,
) (*LOCK4denied, error)
```

IMPORTANT: LOCKT does NOT create state (Pitfall 3 from research). It only queries the lock manager for conflicts.

Implementation:
1. If sm.lockManager == nil, return nil, nil (no locks possible).
2. Build the owner ID string: `fmt.Sprintf("nfs4:%d:%s", clientID, hex.EncodeToString(ownerData))`.
3. Map lockType to lock.LockType: READ_LT/READW_LT -> LockTypeShared, WRITE_LT/WRITEW_LT -> LockTypeExclusive.
4. Call sm.lockManager.ListEnhancedLocks(string(fileHandle)) to get existing locks.
5. Create a temporary EnhancedLock for the test (don't add it):
   ```go
   testLock := &lock.EnhancedLock{
       Owner: lock.LockOwner{OwnerID: ownerID},
       Offset: offset, Length: length, Type: mappedType,
   }
   ```
6. Iterate existing locks, call lock.IsEnhancedLockConflicting(existing, testLock) for each.
7. If conflict found, build LOCK4denied from the conflicting lock's owner info. Parse the conflicting lock's OwnerID to extract clientID and ownerData (format "nfs4:{clientid}:{owner_hex}"). If parsing fails, use zero/empty values.
8. Return nil (no conflict) on no match.

No state modification. No lock-owner creation. No map updates.

**2. Create `handleLockT` in `handlers/lock.go`:**

```go
func (h *Handler) handleLockT(ctx *types.CompoundContext, reader io.Reader) *types.CompoundResult
```

Wire format (LOCKT4args per research):
- locktype (uint32) -- nfs_lock_type4
- offset (uint64)
- length (uint64)
- lock_owner4:
  - clientid (uint64)
  - owner (DecodeOpaque)

Note: LOCKT uses `lock_owner4` (NOT `locker4`). It does not have open stateid or seqid fields.

Implementation:
1. Require current filehandle (NFS4ERR_NOFILEHANDLE).
2. Reject pseudo-fs handles (NFS4ERR_INVAL).
3. Decode LOCKT4args: locktype, offset, length, clientid, owner.
4. Call h.StateManager.TestLock(clientid, owner, ctx.CurrentFH, locktype, offset, length).
5. On error: map and return error.
6. On denied != nil: encode NFS4ERR_DENIED + LOCK4denied (reuse encodeLOCK4denied from lockowner.go).
7. On nil denied: encode NFS4_OK (void response body -- status only).
8. Log at DEBUG level.

**3. Register OP_LOCKT in `handlers/handler.go`:**

Add `h.opDispatchTable[types.OP_LOCKT] = h.handleLockT` in the lock operations group created in Plan 10-01.
  </action>
  <verify>
Run `go build ./internal/protocol/nfs/v4/...` -- compiles. Run `go vet ./internal/protocol/nfs/v4/...` -- clean. Run existing tests: `go test -race ./internal/protocol/nfs/v4/...` -- all pass.
  </verify>
  <done>
LOCKT handler registered and compiles. TestLock method queries lock manager without creating state.
  </done>
</task>

<task type="auto">
  <name>Task 2: LOCKU handler, StateManager.UnlockFile, and comprehensive tests</name>
  <files>
    internal/protocol/nfs/v4/state/manager.go
    internal/protocol/nfs/v4/handlers/lock.go
    internal/protocol/nfs/v4/handlers/handler.go
    internal/protocol/nfs/v4/handlers/lock_test.go
  </files>
  <action>
**1. Add `UnlockFile()` method to StateManager:**

```go
func (sm *StateManager) UnlockFile(
    lockStateid *types.Stateid4, seqid uint32,
    lockType uint32, offset, length uint64,
) (*types.Stateid4, error)
```

Implementation:
1. Handle special stateids: if lockStateid.IsSpecialStateid(), return ErrBadStateid (can't unlock without a real lock stateid).
2. Lock sm.mu.
3. Look up LockState by lockStateid.Other in sm.lockStateByOther. Return ErrBadStateid if not found. Check boot epoch for ErrStaleStateid.
4. Compare seqid: < current -> ErrOldStateid, > current -> ErrBadStateid.
5. Validate seqid on lock-owner: lockState.LockOwner.ValidateSeqID(seqid). SeqIDBad -> ErrBadSeqid.
6. Call sm.lockManager.RemoveEnhancedLock(string(lockState.FileHandle), owner, offset, length) where owner has OwnerID = fmt.Sprintf("nfs4:%d:%s", ...). The lock manager handles POSIX split semantics (partial unlock = 0, 1, or 2 resulting locks).
7. If RemoveEnhancedLock returns lock-not-found error, that's OK for LOCKU (idempotent). Don't fail.
8. Increment lockState.Stateid.Seqid via nextSeqID.
9. Update lockState.LockOwner.LastSeqID = seqid.
10. Return &lockState.Stateid copy.

Note: LOCKU does NOT remove the LockState from tracking. The lock stateid persists even after all byte-ranges are unlocked. RELEASE_LOCKOWNER (Plan 10-03) handles cleanup.

**2. Create `handleLockU` in `handlers/lock.go`:**

```go
func (h *Handler) handleLockU(ctx *types.CompoundContext, reader io.Reader) *types.CompoundResult
```

Wire format (LOCKU4args per research):
- locktype (uint32)
- seqid (uint32)
- lock_stateid (DecodeStateid4 -- 16 bytes)
- offset (uint64)
- length (uint64)

Implementation:
1. Require current filehandle (NFS4ERR_NOFILEHANDLE).
2. Reject pseudo-fs handles (NFS4ERR_INVAL).
3. Decode LOCKU4args: locktype, seqid, lock_stateid, offset, length.
4. Call h.StateManager.UnlockFile(lock_stateid, seqid, locktype, offset, length).
5. On error: map via mapOpenStateError, return status-only.
6. On success: encode NFS4_OK + updated lock_stateid (EncodeStateid4).
7. Log at DEBUG level.

**3. Register OP_LOCKU in `handlers/handler.go`:**

Add `h.opDispatchTable[types.OP_LOCKU] = h.handleLockU` in the lock operations group.

**4. Add comprehensive tests to `handlers/lock_test.go`** (extending from Plan 10-01):

LOCKT tests:
- TestHandleLockT_NoConflict: LOCKT on unlocked file returns NFS4_OK
- TestHandleLockT_Conflict: LOCKT finds existing exclusive lock, returns NFS4ERR_DENIED with LOCK4denied
- TestHandleLockT_SharedNoConflict: LOCKT read lock against existing read lock returns NFS4_OK
- TestHandleLockT_NoCurrentFH: returns NFS4ERR_NOFILEHANDLE
- TestHandleLockT_PseudoFS: returns NFS4ERR_INVAL

LOCKU tests:
- TestHandleLockU_Success: LOCK then LOCKU succeeds, returns updated stateid with incremented seqid
- TestHandleLockU_BadStateid: unknown lock stateid returns NFS4ERR_BAD_STATEID
- TestHandleLockU_BadSeqid: wrong seqid returns NFS4ERR_BAD_SEQID
- TestHandleLockU_PartialUnlock: LOCK full file then LOCKU half -> remaining half still locked (verify via LOCKT)
- TestHandleLockU_NoCurrentFH: returns NFS4ERR_NOFILEHANDLE

For tests requiring full state setup: create StateManager with lock.Manager, run SETCLIENTID -> CONFIRM -> OPEN -> CONFIRM -> LOCK flow, then test LOCKT/LOCKU.

Each test should follow existing handler test patterns: create Handler, build compound context, encode XDR args, call handler, decode and verify response.
  </action>
  <verify>
Run `go test -race -v ./internal/protocol/nfs/v4/state/...` -- all tests pass. Run `go test -race -v ./internal/protocol/nfs/v4/handlers/...` -- all tests pass including LOCKT and LOCKU tests. Run `go vet ./internal/protocol/nfs/v4/...` -- clean.
  </verify>
  <done>
LOCKT tests for conflicts without creating state. LOCKU releases locks with POSIX split semantics and increments lock stateid seqid. Both handlers registered in dispatch table. All tests pass with -race.
  </done>
</task>

</tasks>

<verification>
```bash
# All NFSv4 tests pass with race detection
go test -race ./internal/protocol/nfs/v4/...

# OP_LOCKT and OP_LOCKU registered
grep -q "OP_LOCKT" internal/protocol/nfs/v4/handlers/handler.go
grep -q "OP_LOCKU" internal/protocol/nfs/v4/handlers/handler.go

# TestLock and UnlockFile methods exist
grep -q "func.*StateManager.*TestLock" internal/protocol/nfs/v4/state/manager.go
grep -q "func.*StateManager.*UnlockFile" internal/protocol/nfs/v4/state/manager.go

# Handlers exist
grep -q "func.*Handler.*handleLockT" internal/protocol/nfs/v4/handlers/lock.go
grep -q "func.*Handler.*handleLockU" internal/protocol/nfs/v4/handlers/lock.go
```
</verification>

<success_criteria>
- LOCKT checks for conflicts without creating lock-owners or stateids
- LOCKT returns NFS4_OK or NFS4ERR_DENIED with LOCK4denied
- LOCKU releases locks via unified lock manager (POSIX split semantics)
- LOCKU increments lock stateid seqid on success
- LOCKU returns appropriate errors for bad/stale/old stateids
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/10-nfsv4-locking/10-02-SUMMARY.md`
</output>
