---
phase: 10-nfsv4-locking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/protocol/nfs/v4/state/lockowner.go
  - internal/protocol/nfs/v4/state/manager.go
  - internal/protocol/nfs/v4/types/constants.go
  - internal/protocol/nfs/v4/handlers/lock.go
  - internal/protocol/nfs/v4/handlers/handler.go
autonomous: true

must_haves:
  truths:
    - "LOCK with new_lock_owner=true creates a lock-owner and lock stateid, acquires the byte-range lock, returns lock stateid"
    - "LOCK with new_lock_owner=false (existing lock-owner) uses existing lock stateid, acquires additional lock, increments seqid"
    - "LOCK returns NFS4ERR_DENIED with LOCK4denied on conflict (offset, length, lock type, conflicting owner)"
    - "LOCK returns NFS4ERR_OPENMODE when lock type incompatible with open share_access"
    - "LOCK returns NFS4ERR_GRACE for non-reclaim locks during grace period, allows reclaim=true"
    - "READW_LT/WRITEW_LT treated as non-blocking (return NFS4ERR_DENIED, not wait)"
  artifacts:
    - path: "internal/protocol/nfs/v4/state/lockowner.go"
      provides: "LockOwner, LockState, LockResult, LOCK4denied structs, lockOwnerKey, makeLockOwnerKey"
      min_lines: 80
    - path: "internal/protocol/nfs/v4/state/manager.go"
      provides: "lockOwners map, lockStateByOther map, lockManager field, LockNew, LockExisting, acquireLock methods"
      contains: "func (sm *StateManager) LockNew"
    - path: "internal/protocol/nfs/v4/types/constants.go"
      provides: "READ_LT, WRITE_LT, READW_LT, WRITEW_LT lock type constants"
      contains: "READ_LT"
    - path: "internal/protocol/nfs/v4/handlers/lock.go"
      provides: "handleLock handler with locker4 union decoding"
      contains: "func (h *Handler) handleLock"
    - path: "internal/protocol/nfs/v4/handlers/handler.go"
      provides: "OP_LOCK registered in dispatch table"
      contains: "OP_LOCK"
  key_links:
    - from: "internal/protocol/nfs/v4/handlers/lock.go"
      to: "internal/protocol/nfs/v4/state/manager.go"
      via: "h.StateManager.LockNew / h.StateManager.LockExisting"
      pattern: "StateManager\\.Lock(New|Existing)"
    - from: "internal/protocol/nfs/v4/state/manager.go"
      to: "pkg/metadata/lock/manager.go"
      via: "sm.lockManager.AddEnhancedLock"
      pattern: "lockManager\\.AddEnhancedLock"
    - from: "internal/protocol/nfs/v4/state/lockowner.go"
      to: "internal/protocol/nfs/v4/state/openowner.go"
      via: "LockState.OpenState references OpenState"
      pattern: "OpenState"
---

<objective>
Implement the NFSv4 LOCK operation with full state management: lock-owner data model, lock stateid generation, locker4 union decoding, and lock manager bridge.

Purpose: LOCK is the foundational locking operation that all other lock operations (LOCKT, LOCKU, RELEASE_LOCKOWNER) depend on. It creates lock-owner state, generates lock stateids, and bridges to the unified lock manager for cross-protocol conflict detection.

Output: Working LOCK handler, LockOwner/LockState structs, lock type constants, StateManager lock methods.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-nfsv4-locking/10-RESEARCH.md
@internal/protocol/nfs/v4/state/manager.go
@internal/protocol/nfs/v4/state/openowner.go
@internal/protocol/nfs/v4/state/stateid.go
@internal/protocol/nfs/v4/handlers/handler.go
@internal/protocol/nfs/v4/handlers/close.go
@internal/protocol/nfs/v4/types/constants.go
@pkg/metadata/lock/manager.go
@pkg/metadata/lock/types.go
@pkg/metadata/lock/errors.go
@pkg/metadata/errors/errors.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Lock-owner data model, lock type constants, and StateManager extensions</name>
  <files>
    internal/protocol/nfs/v4/state/lockowner.go
    internal/protocol/nfs/v4/state/manager.go
    internal/protocol/nfs/v4/types/constants.go
  </files>
  <action>
**1. Add lock type constants to `types/constants.go`:**

Add NFSv4 lock type constants per RFC 7531 (nfs_lock_type4 enum) in a new section after the existing constant groups:

```go
// Lock type constants (nfs_lock_type4) per RFC 7531
const (
    READ_LT  = 1 // Shared (read) lock
    WRITE_LT = 2 // Exclusive (write) lock
    READW_LT = 3 // Blocking read lock (hint; server does NOT block)
    WRITEW_LT = 4 // Blocking write lock (hint; server does NOT block)
)
```

**2. Create `state/lockowner.go`** with these types:

- `LockOwner` struct: ClientID uint64, OwnerData []byte, LastSeqID uint32, LastResult *CachedResult, ClientRecord *ClientRecord. Add `ValidateSeqID(seqid uint32) SeqIDValidation` method reusing the `nextSeqID()` helper from openowner.go (same algorithm: expected=LastSeqID+1 with wrap, replay=LastSeqID, else bad).

- `LockState` struct: Stateid types.Stateid4, LockOwner *LockOwner, OpenState *OpenState, FileHandle []byte.

- `lockOwnerKey` type (string) and `makeLockOwnerKey(clientID uint64, ownerData []byte) lockOwnerKey` using same pattern as `makeOwnerKey`: `fmt.Sprintf("%d:%s", clientID, hex.EncodeToString(ownerData))`.

- `LockResult` struct: Stateid types.Stateid4 (returned on success), Denied *LOCK4denied (returned on conflict, nil on success).

- `LOCK4denied` struct: Offset uint64, Length uint64, LockType uint32, Owner struct { ClientID uint64, OwnerData []byte }.

- `encodeLOCK4denied(buf *bytes.Buffer, denied *LOCK4denied)` helper: writes offset (uint64), length (uint64), locktype (uint32), owner.clientid (uint64), owner.ownerdata (XDR opaque via xdr.WriteXDROpaque).

- `validateOpenModeForLock(openState *OpenState, lockType uint32) error` helper: WRITE_LT/WRITEW_LT requires ShareAccess & OPEN4_SHARE_ACCESS_WRITE != 0, READ_LT/READW_LT requires ShareAccess & OPEN4_SHARE_ACCESS_READ != 0. Returns NFS4StateError with NFS4ERR_OPENMODE on mismatch.

**3. Extend `state/manager.go`:**

Add new fields to StateManager struct:
```go
lockOwners       map[lockOwnerKey]*LockOwner
lockStateByOther map[[types.NFS4_OTHER_SIZE]byte]*LockState
lockManager      *lock.Manager
```

Initialize these maps in `NewStateManager()`. Add a `lockManager` variadic parameter to `NewStateManager` as the third optional parameter (after graceDuration). If provided and non-nil, store it. If nil, tests work without a lock manager (lock operations will return error). Import `"github.com/marmos91/dittofs/pkg/metadata/lock"`.

Add `SetLockManager(lm *lock.Manager)` method so the NFS adapter can set it after construction (alternative to constructor injection).

Add `LockNew()` method per research Example 5:
```go
func (sm *StateManager) LockNew(
    lockClientID uint64, lockOwnerData []byte, lockSeqid uint32,
    openStateid *types.Stateid4, openSeqid uint32,
    fileHandle []byte, lockType uint32, offset, length uint64, reclaim bool,
) (*LockResult, error)
```

Implementation:
1. Grace period check: if !reclaim, call CheckGraceForNewState(); if reclaim and grace active, allow.
2. Lock sm.mu.
3. Validate open stateid: look up in openStateByOther. Return ErrBadStateid if not found.
4. Validate open-owner seqid: call openState.Owner.ValidateSeqID(openSeqid). SeqIDBad -> ErrBadSeqid. SeqIDReplay -> return cached result if available on lock owner, else ErrBadSeqid.
5. Validate open mode: validateOpenModeForLock(openState, lockType). Return error on mismatch.
6. Find or create lock-owner using makeLockOwnerKey(lockClientID, lockOwnerData). If new, create LockOwner with LastSeqID=0, register in sm.lockOwners and in client record (sm.clientsByID[lockClientID]).
7. Find or create LockState for (lock-owner, open-state) pair. Check if lock-owner already has a LockState referencing this open-state. If not, generate stateid using sm.generateStateidOther(StateTypeLock), create LockState with seqid=1, add to openState.LockStates, register in sm.lockStateByOther.
8. Validate lock seqid on lock-owner: lockOwner.ValidateSeqID(lockSeqid). SeqIDBad -> ErrBadSeqid.
9. Call sm.acquireLock(lockState, lockType, offset, length, reclaim).
10. If denied, return LockResult{Denied: denied}.
11. On success: increment lockState.Stateid.Seqid via nextSeqID, update lockOwner.LastSeqID = lockSeqid, update openState.Owner.LastSeqID = openSeqid.
12. Return LockResult{Stateid: lockState.Stateid}.

Add `LockExisting()` method:
```go
func (sm *StateManager) LockExisting(
    lockStateid *types.Stateid4, lockSeqid uint32,
    fileHandle []byte, lockType uint32, offset, length uint64, reclaim bool,
) (*LockResult, error)
```

Implementation:
1. Grace period check (same as LockNew).
2. Lock sm.mu.
3. Look up lock state by lockStateid.Other in sm.lockStateByOther. Return ErrBadStateid if not found. Validate boot epoch (stale). Validate seqid (old vs bad).
4. Validate open mode: validateOpenModeForLock(lockState.OpenState, lockType).
5. Validate lock seqid on lockState.LockOwner.
6. Call sm.acquireLock(lockState, lockType, offset, length, reclaim).
7. On success: increment lockState.Stateid.Seqid, update lockOwner.LastSeqID = lockSeqid.
8. Return LockResult.

Add private `acquireLock()` method:
```go
func (sm *StateManager) acquireLock(lockState *LockState, lockType uint32, offset, length uint64, reclaim bool) (*LOCK4denied, error)
```

Implementation:
1. If sm.lockManager == nil, return error (no lock manager configured).
2. Build lock.LockOwner: OwnerID = fmt.Sprintf("nfs4:%d:%s", lockState.LockOwner.ClientID, hex.EncodeToString(lockState.LockOwner.OwnerData)), ClientID = fmt.Sprintf("nfs4:%d", lockState.LockOwner.ClientID), ShareName = "" (extract from file handle if possible, but empty is safe for basic operation).
3. Map lockType: READ_LT/READW_LT -> lock.LockTypeShared, WRITE_LT/WRITEW_LT -> lock.LockTypeExclusive.
4. Create lock.NewEnhancedLock(owner, lock.FileHandle(lockState.FileHandle), offset, length, mappedType). Set enhLock.Reclaim = reclaim.
5. Call sm.lockManager.AddEnhancedLock(string(lockState.FileHandle), enhLock).
6. On error: check if it's a lock conflict error (errors.IsLockError from pkg/metadata/errors). If so, build LOCK4denied from the conflicting lock info. The conflict info is embedded in the StoreError but not easily extractable. Instead, before calling AddEnhancedLock, manually check for conflicts using lock.ListEnhancedLocks + lock.IsEnhancedLockConflicting to get the conflicting lock details for the LOCK4denied response. If no conflict found in pre-check, proceed with AddEnhancedLock (race is acceptable since the lock manager will reject on actual conflict).

  Alternative simpler approach: Call AddEnhancedLock first. If it returns an error, query ListEnhancedLocks to find the conflicting lock and build LOCK4denied from it. This is simpler and correct enough since the conflict still exists.

7. Return nil (no denied) on success.

Note: `OpenState.LockStates` is currently `[]interface{}`. For this plan, store `*LockState` in it as interface{} to avoid breaking the type until Plan 10-03 changes it to `[]*LockState`. This keeps the plan focused.
  </action>
  <verify>
Run `go build ./internal/protocol/nfs/v4/...` to verify compilation. Run `go vet ./internal/protocol/nfs/v4/...` for static analysis. Run existing tests: `go test -race ./internal/protocol/nfs/v4/state/... ./internal/protocol/nfs/v4/handlers/...` -- all must pass (no regressions).
  </verify>
  <done>
LockOwner and LockState types defined. Lock type constants added. StateManager has lockOwners, lockStateByOther, lockManager fields. LockNew() and LockExisting() methods compile and pass vet. Existing tests unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: LOCK handler with locker4 union decoding and tests</name>
  <files>
    internal/protocol/nfs/v4/handlers/lock.go
    internal/protocol/nfs/v4/handlers/handler.go
    internal/protocol/nfs/v4/state/lockowner_test.go
    internal/protocol/nfs/v4/handlers/lock_test.go
  </files>
  <action>
**1. Create `handlers/lock.go`** with the handleLock function:

```go
func (h *Handler) handleLock(ctx *types.CompoundContext, reader io.Reader) *types.CompoundResult
```

Implementation:
1. Require current filehandle (RequireCurrentFH). Return NFS4ERR_NOFILEHANDLE.
2. Reject pseudo-fs handles (IsPseudoFSHandle -> NFS4ERR_INVAL).
3. Decode LOCK4args per XDR wire format from research:
   - locktype (uint32) -- nfs_lock_type4
   - reclaim (uint32) -- bool
   - offset (uint64)
   - length (uint64)
   - new_lock_owner (uint32) -- locker4 discriminant
   - If new_lock_owner != 0 (open_to_lock_owner4):
     - open_seqid (uint32)
     - open_stateid (DecodeStateid4)
     - lock_seqid (uint32)
     - lock_owner_clientid (uint64)
     - lock_owner_data (DecodeOpaque)
     - Call h.StateManager.LockNew(...)
   - If new_lock_owner == 0 (exist_lock_owner4):
     - lock_stateid (DecodeStateid4)
     - lock_seqid (uint32)
     - Call h.StateManager.LockExisting(...)

4. Handle result:
   - On error: map via mapOpenStateError, return status-only response.
   - On LockResult.Denied != nil: encode NFS4ERR_DENIED + LOCK4denied response. Status is NFS4ERR_DENIED, response body is: status(uint32) + LOCK4denied (encodeLOCK4denied).
   - On success: encode NFS4_OK + lock_stateid (EncodeStateid4).

5. Log at DEBUG level: lock type, offset, length, new_lock_owner, reclaim, client.

**2. Register OP_LOCK in `handlers/handler.go`:**

Add `h.opDispatchTable[types.OP_LOCK] = h.handleLock` in the dispatch table section, in a new "Lock operations" group after the "Stub operations" group.

**3. Create `state/lockowner_test.go`** with tests:
- TestLockOwnerValidateSeqID: OK, Replay, Bad cases (matches OpenOwner pattern)
- TestMakeLockOwnerKey: deterministic key from clientID + ownerData
- TestValidateOpenModeForLock: WRITE_LT on read-only open -> NFS4ERR_OPENMODE, READ_LT on write-only open -> NFS4ERR_OPENMODE, WRITE_LT on RW open -> nil, READ_LT on RW open -> nil
- TestLockNew_CreatesLockOwnerAndState: new lock-owner creates LockOwner, LockState, returns stateid
- TestLockNew_ExistingLockOwner: calling LockNew twice for same owner reuses LockOwner
- TestLockNew_BadOpenStateid: returns ErrBadStateid for unknown open stateid
- TestLockNew_BadOpenSeqid: returns ErrBadSeqid for wrong open-owner seqid
- TestLockNew_OpenModeViolation: write lock on read-only open returns NFS4ERR_OPENMODE
- TestLockNew_GracePeriod: non-reclaim blocked during grace (NFS4ERR_GRACE), reclaim allowed
- TestLockExisting_Success: uses existing lock stateid
- TestLockExisting_BadStateid: returns ErrBadStateid for unknown lock stateid
- TestLockExisting_BadSeqid: returns ErrBadSeqid
- TestLockNew_Conflict: two different owners locking overlapping exclusive ranges returns LOCK4denied
- TestLockNew_SharedNoConflict: two shared locks on overlapping ranges succeed
- TestLockNew_BlockingType: READW_LT/WRITEW_LT return NFS4ERR_DENIED (not block)

For tests that use the lock manager bridge, create StateManager with a real lock.Manager:
```go
lm := lock.NewManager(lock.DefaultConfig())
sm := state.NewStateManager(90*time.Second)
sm.SetLockManager(lm)
```

Then set up client/open state via SetClientID -> ConfirmClientID -> OpenFile -> ConfirmOpen before testing locks.

**4. Create `handlers/lock_test.go`** with handler-level tests:
- TestHandleLock_NoCurrentFH: returns NFS4ERR_NOFILEHANDLE
- TestHandleLock_PseudoFS: returns NFS4ERR_INVAL
- TestHandleLock_BadXDR: truncated input returns NFS4ERR_BADXDR
- TestHandleLock_NewLockOwner_Success: full XDR encode -> decode roundtrip
- TestHandleLock_ExistingLockOwner_Success: full XDR encode -> decode roundtrip

Handler tests follow existing patterns in ops_test.go: create Handler with NewHandler, set up compound context, encode args into bytes.Buffer, call handleLock, decode response.
  </action>
  <verify>
Run `go test -race -v ./internal/protocol/nfs/v4/state/...` -- all tests pass including new lockowner tests. Run `go test -race -v ./internal/protocol/nfs/v4/handlers/...` -- all tests pass including new lock handler tests. Run `go vet ./internal/protocol/nfs/v4/...` -- no issues.
  </verify>
  <done>
LOCK handler registered and working. New lock-owner path creates LockOwner + LockState + returns stateid. Existing lock-owner path uses existing lock stateid. Conflicts return NFS4ERR_DENIED with LOCK4denied. Open-mode validation returns NFS4ERR_OPENMODE. Grace period checks work. All tests pass with -race.
  </done>
</task>

</tasks>

<verification>
```bash
# All NFSv4 tests pass with race detection
go test -race ./internal/protocol/nfs/v4/...

# Lock type constants exist
grep -q "READ_LT" internal/protocol/nfs/v4/types/constants.go

# OP_LOCK registered in handler dispatch table
grep -q "OP_LOCK" internal/protocol/nfs/v4/handlers/handler.go

# LockNew and LockExisting methods exist
grep -q "func.*StateManager.*LockNew" internal/protocol/nfs/v4/state/manager.go
grep -q "func.*StateManager.*LockExisting" internal/protocol/nfs/v4/state/manager.go

# Lock handler exists
grep -q "func.*Handler.*handleLock" internal/protocol/nfs/v4/handlers/lock.go
```
</verification>

<success_criteria>
- LOCK operation with new_lock_owner=true creates lock state and acquires lock
- LOCK operation with new_lock_owner=false uses existing lock state
- Lock conflicts return NFS4ERR_DENIED with LOCK4denied details
- Open-mode validation prevents incompatible lock types
- Grace period blocks non-reclaim locks, allows reclaim
- READW_LT/WRITEW_LT are non-blocking (return NFS4ERR_DENIED, don't wait)
- Lock manager bridge creates EnhancedLock with "nfs4:{clientid}:{owner}" OwnerID
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/10-nfsv4-locking/10-01-SUMMARY.md`
</output>
