---
phase: 10-nfsv4-locking
plan: 03
type: execute
wave: 3
depends_on: ["10-02"]
files_modified:
  - internal/protocol/nfs/v4/handlers/stubs.go
  - internal/protocol/nfs/v4/state/manager.go
  - internal/protocol/nfs/v4/state/openowner.go
  - internal/protocol/nfs/v4/handlers/lock_test.go
  - internal/protocol/nfs/v4/state/lockowner_test.go
autonomous: true

must_haves:
  truths:
    - "RELEASE_LOCKOWNER removes lock-owner state from StateManager and returns NFS4_OK"
    - "RELEASE_LOCKOWNER returns NFS4ERR_LOCKS_HELD if the lock-owner has active locks in the lock manager"
    - "CLOSE returns NFS4ERR_LOCKS_HELD if the open state has associated lock states"
    - "Lease expiry cleans up lock state from both StateManager maps and the lock manager"
    - "OpenState.LockStates is typed []*LockState (not []interface{})"
  artifacts:
    - path: "internal/protocol/nfs/v4/handlers/stubs.go"
      provides: "Real handleReleaseLockOwner implementation with state cleanup"
      contains: "ReleaseLockOwner"
    - path: "internal/protocol/nfs/v4/state/manager.go"
      provides: "ReleaseLockOwner method, CLOSE NFS4ERR_LOCKS_HELD check, lease expiry lock cleanup"
      contains: "func (sm *StateManager) ReleaseLockOwner"
    - path: "internal/protocol/nfs/v4/state/openowner.go"
      provides: "LockStates field typed as []*LockState"
      contains: "LockStates []*LockState"
  key_links:
    - from: "internal/protocol/nfs/v4/handlers/stubs.go"
      to: "internal/protocol/nfs/v4/state/manager.go"
      via: "h.StateManager.ReleaseLockOwner"
      pattern: "StateManager\\.ReleaseLockOwner"
    - from: "internal/protocol/nfs/v4/state/manager.go"
      to: "pkg/metadata/lock/manager.go"
      via: "sm.lockManager.RemoveEnhancedLock in onLeaseExpired"
      pattern: "lockManager\\.Remove"
    - from: "internal/protocol/nfs/v4/state/manager.go"
      to: "internal/protocol/nfs/v4/state/openowner.go"
      via: "CloseFile checks openState.LockStates length"
      pattern: "LockStates"
---

<objective>
Implement RELEASE_LOCKOWNER real state cleanup, add NFS4ERR_LOCKS_HELD enforcement to CLOSE, clean up lock state on lease expiry, and finalize LockStates typing.

Purpose: These are the integration and cleanup tasks that ensure lock state is properly managed across the full lifecycle: creation (LOCK), testing (LOCKT), release (LOCKU), owner cleanup (RELEASE_LOCKOWNER), file close (CLOSE), and client expiry (lease timeout). Without these, orphaned locks would persist and clients couldn't clean up properly.

Output: Real RELEASE_LOCKOWNER, CLOSE enforces lock cleanup, lease expiry removes locks from lock manager, LockStates properly typed.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-nfsv4-locking/10-RESEARCH.md
@.planning/phases/10-nfsv4-locking/10-01-SUMMARY.md
@.planning/phases/10-nfsv4-locking/10-02-SUMMARY.md
@internal/protocol/nfs/v4/state/manager.go
@internal/protocol/nfs/v4/state/openowner.go
@internal/protocol/nfs/v4/state/lockowner.go
@internal/protocol/nfs/v4/handlers/stubs.go
@internal/protocol/nfs/v4/handlers/close.go
@pkg/metadata/lock/manager.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: LockStates type change, CLOSE locks-held check, and RELEASE_LOCKOWNER</name>
  <files>
    internal/protocol/nfs/v4/state/openowner.go
    internal/protocol/nfs/v4/state/manager.go
    internal/protocol/nfs/v4/handlers/stubs.go
  </files>
  <action>
**1. Change OpenState.LockStates type in `state/openowner.go`:**

Change the LockStates field from `[]interface{}` to `[]*LockState`. Update the comment from "Empty for Phase 9; populated in Phase 10" to "Lock stateids derived from this open state."

This requires updating any code that appends to LockStates (in manager.go's LockNew method from Plan 10-01) to use `*LockState` directly instead of `interface{}`. Since Plan 10-01 should already be storing `*LockState`, this is a type declaration change only.

**2. Add NFS4ERR_LOCKS_HELD check to CloseFile in `state/manager.go`:**

Per Pitfall 7 from research: the check MUST come BEFORE removing any open state.

In `CloseFile()`, after looking up the open state and validating seqid (after the SeqIDOK case), add:

```go
// Phase 10: Check for held locks before closing
// Per RFC 7530, CLOSE MUST fail if byte-range locks are held.
// Client must LOCKU all locks before CLOSE.
if len(openState.LockStates) > 0 {
    return nil, &NFS4StateError{
        Status:  types.NFS4ERR_LOCKS_HELD,
        Message: "cannot close: byte-range locks still held, use LOCKU first",
    }
}
```

This goes BEFORE the `delete(sm.openStateByOther, stateid.Other)` line. The check uses the typed `[]*LockState` length.

**3. Add `ReleaseLockOwner()` method to StateManager in `state/manager.go`:**

```go
func (sm *StateManager) ReleaseLockOwner(clientID uint64, ownerData []byte) error
```

Implementation:
1. Lock sm.mu.
2. Build key: makeLockOwnerKey(clientID, ownerData).
3. Look up lock-owner in sm.lockOwners. If not found, return nil (NFS4_OK -- releasing unknown owner is a no-op per RFC).
4. Check if the lock-owner has any active locks. Iterate associated LockStates, and for each, check if there are locks in the lock manager for that file handle + owner. Use sm.lockManager.ListEnhancedLocks(string(lockState.FileHandle)) and check if any have matching OwnerID. If ANY locks are held, return NFS4StateError{Status: NFS4ERR_LOCKS_HELD}.
5. If no locks held: remove all LockStates from sm.lockStateByOther. For each LockState, also remove from its OpenState.LockStates slice. Remove the lock-owner from sm.lockOwners. Remove from client record if present.
6. Return nil.

**4. Upgrade `handleReleaseLockOwner` in `handlers/stubs.go`:**

Replace the no-op stub with real implementation:
1. Decode lock_owner4: clientid (uint64), owner (DecodeOpaque) -- same XDR as before.
2. Call h.StateManager.ReleaseLockOwner(clientid, owner).
3. On error: map via mapOpenStateError. NFS4ERR_LOCKS_HELD returns that status.
4. On success: return NFS4_OK.
5. Update the function comment to reflect it's now a real implementation.
6. Log at DEBUG level with "NFSv4 RELEASE_LOCKOWNER" message.

**5. Update `onLeaseExpired` in `state/manager.go`:**

Per Pitfall 6 from research: lease expiry must clean up locks from BOTH StateManager maps AND the lock manager.

In the existing `onLeaseExpired` method, after the loop that removes open states, add lock cleanup:

```go
// Phase 10: Clean up lock state for expired client
for lockKey, lockOwner := range sm.lockOwners {
    if lockOwner.ClientRecord == record || lockOwner.ClientID == clientID {
        // Remove locks from unified lock manager
        for _, lockState := range /* find associated lock states */ {
            if sm.lockManager != nil {
                ownerID := fmt.Sprintf("nfs4:%d:%s", lockOwner.ClientID,
                    hex.EncodeToString(lockOwner.OwnerData))
                // Remove all locks for this owner on this file
                locks := sm.lockManager.ListEnhancedLocks(string(lockState.FileHandle))
                for _, l := range locks {
                    if l.Owner.OwnerID == ownerID {
                        _ = sm.lockManager.RemoveEnhancedLock(
                            string(lockState.FileHandle),
                            l.Owner, l.Offset, l.Length,
                        )
                    }
                }
            }
            delete(sm.lockStateByOther, lockState.Stateid.Other)
        }
        delete(sm.lockOwners, lockKey)
    }
}
```

To find lock states for a lock-owner, iterate sm.lockStateByOther and match on LockOwner pointer. Or, better: iterate the lock-owner's associated open states' LockStates lists.

The approach: iterate all openOwners for the record (already done in existing code), then for each openState, iterate its LockStates. For each LockState, remove from lockStateByOther and remove locks from lock manager. Then delete the lock-owner.

Restructure the existing onLeaseExpired loop:

```go
// Remove all open states AND lock states for all owners
for _, owner := range record.OpenOwners {
    for _, openState := range owner.OpenStates {
        // Clean up lock states associated with this open
        for _, lockState := range openState.LockStates {
            // Remove from lockStateByOther map
            delete(sm.lockStateByOther, lockState.Stateid.Other)

            // Remove actual locks from unified lock manager
            if sm.lockManager != nil {
                ownerID := fmt.Sprintf("nfs4:%d:%s", lockState.LockOwner.ClientID,
                    hex.EncodeToString(lockState.LockOwner.OwnerData))
                locks := sm.lockManager.ListEnhancedLocks(string(lockState.FileHandle))
                for _, l := range locks {
                    if l.Owner.OwnerID == ownerID {
                        _ = sm.lockManager.RemoveEnhancedLock(
                            string(lockState.FileHandle),
                            l.Owner, l.Offset, l.Length,
                        )
                    }
                }
            }

            // Remove lock-owner from map
            lockKey := makeLockOwnerKey(lockState.LockOwner.ClientID, lockState.LockOwner.OwnerData)
            delete(sm.lockOwners, lockKey)
        }

        delete(sm.openStateByOther, openState.Stateid.Other)
    }
    ownerKey := makeOwnerKey(owner.ClientID, owner.OwnerData)
    delete(sm.openOwners, ownerKey)
}
```

IMPORTANT: The lock manager's own mutex is separate from StateManager.mu. Calling lockManager methods while holding sm.mu is safe because lock manager acquires its own lm.mu internally and there's no reverse dependency.
  </action>
  <verify>
Run `go build ./internal/protocol/nfs/v4/...` -- compiles (type change may require updating Plan 10-01's append code). Run `go vet ./internal/protocol/nfs/v4/...` -- clean. Run `go test -race ./internal/protocol/nfs/v4/...` -- all existing tests pass.
  </verify>
  <done>
OpenState.LockStates typed as []*LockState. CloseFile rejects CLOSE when locks held. ReleaseLockOwner cleans up lock-owner state. Lease expiry removes locks from lock manager. All compile and existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integration tests for RELEASE_LOCKOWNER, CLOSE, and lease expiry cleanup</name>
  <files>
    internal/protocol/nfs/v4/state/lockowner_test.go
    internal/protocol/nfs/v4/handlers/lock_test.go
  </files>
  <action>
**1. Add state-level integration tests to `state/lockowner_test.go`:**

- TestCloseFile_LocksHeld: OPEN -> LOCK -> CLOSE returns NFS4ERR_LOCKS_HELD. Then LOCKU -> CLOSE succeeds.
- TestReleaseLockOwner_NoLocks: create lock-owner via LockNew, LOCKU all locks, then ReleaseLockOwner succeeds. Lock-owner removed from maps.
- TestReleaseLockOwner_WithLocks: create lock-owner, hold a lock, ReleaseLockOwner returns NFS4ERR_LOCKS_HELD.
- TestReleaseLockOwner_Unknown: release unknown lock-owner returns nil (NFS4_OK).
- TestLeaseExpiry_CleansLockState: set up client -> open -> lock, let lease expire (use short lease like 50ms), verify:
  a. Lock-owner removed from sm.lockOwners (not directly accessible, but verify via LockExisting returning ErrBadStateid for the lock stateid).
  b. Locks removed from lock manager (verify via ListEnhancedLocks returning empty).
  c. Open state also removed (verify via ValidateStateid returning error).
- TestLeaseExpiry_CleansLockManager: verify that after expiry, another client can acquire a lock on the same file handle that was previously locked by the expired client.

For lease expiry tests, use `NewStateManager(50*time.Millisecond)` for fast expiry, then `time.Sleep(100*time.Millisecond)` to ensure expiry fires.

**2. Add handler-level integration tests to `handlers/lock_test.go`:**

- TestHandleReleaseLockOwner_NoLocks: encode RELEASE_LOCKOWNER args (clientid + owner), call handler, expect NFS4_OK.
- TestHandleReleaseLockOwner_LocksHeld: LOCK then RELEASE_LOCKOWNER returns NFS4ERR_LOCKS_HELD.
- TestHandleClose_LocksHeld: OPEN -> LOCK -> CLOSE returns NFS4ERR_LOCKS_HELD.
- TestHandleClose_AfterUnlock: OPEN -> LOCK -> LOCKU -> CLOSE returns NFS4_OK.
- TestFullLockLifecycle: SETCLIENTID -> CONFIRM -> OPEN -> CONFIRM -> LOCK (new owner) -> LOCKT (no conflict from same owner, conflict from different) -> LOCKU -> CLOSE -> integration end-to-end test.

For the full lifecycle test, this is the primary integration test validating the entire Phase 10 locking flow works end-to-end:
1. Set up client via SETCLIENTID/CONFIRM
2. OPEN a file
3. OPEN_CONFIRM
4. LOCK with new_lock_owner (get lock stateid)
5. LOCKT from same owner on same range (should succeed -- no conflict with self)
6. LOCK with same lock-owner (existing) on different range
7. LOCKU first range
8. LOCKT from different simulated owner (should show conflict for second range)
9. LOCKU second range
10. CLOSE (should succeed since no locks held)

Each step verifies the returned stateid seqids increment correctly.

All tests use real lock.Manager:
```go
lm := lock.NewManager(lock.DefaultConfig())
sm := state.NewStateManager(90*time.Second)
sm.SetLockManager(lm)
```
  </action>
  <verify>
Run `go test -race -v -count=1 ./internal/protocol/nfs/v4/state/...` -- all tests pass including new integration tests. Run `go test -race -v -count=1 ./internal/protocol/nfs/v4/handlers/...` -- all tests pass. Run full suite: `go test -race ./internal/protocol/nfs/v4/...` -- everything green.
  </verify>
  <done>
CLOSE properly rejects when locks held. RELEASE_LOCKOWNER cleans up or rejects appropriately. Lease expiry removes locks from both StateManager and lock manager. Full lock lifecycle test passes end-to-end. All tests pass with -race.
  </done>
</task>

</tasks>

<verification>
```bash
# All NFSv4 tests pass with race detection
go test -race ./internal/protocol/nfs/v4/...

# Full project compiles
go build ./...

# RELEASE_LOCKOWNER upgraded from stub
grep -q "ReleaseLockOwner" internal/protocol/nfs/v4/handlers/stubs.go

# CLOSE checks for locks
grep -q "NFS4ERR_LOCKS_HELD" internal/protocol/nfs/v4/state/manager.go

# LockStates properly typed
grep -q "LockStates \[\]\*LockState" internal/protocol/nfs/v4/state/openowner.go

# Lease expiry cleans lock state
grep -q "lockManager" internal/protocol/nfs/v4/state/manager.go
```
</verification>

<success_criteria>
- RELEASE_LOCKOWNER removes lock-owner state when no locks are held
- RELEASE_LOCKOWNER returns NFS4ERR_LOCKS_HELD when locks exist
- CLOSE returns NFS4ERR_LOCKS_HELD when lock states exist on the open
- Lease expiry removes lock-owners from StateManager maps AND locks from lock manager
- After lease expiry, other clients can acquire previously-held locks
- OpenState.LockStates is []*LockState (not []interface{})
- Full lock lifecycle test passes: OPEN -> LOCK -> LOCKT -> LOCKU -> CLOSE
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/10-nfsv4-locking/10-03-SUMMARY.md`
</output>
