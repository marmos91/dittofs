---
phase: 08-nfsv4-advanced-operations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/protocol/nfs/v4/handlers/link.go
  - internal/protocol/nfs/v4/handlers/rename.go
  - internal/protocol/nfs/v4/handlers/link_rename_test.go
  - internal/protocol/nfs/v4/handlers/handler.go
autonomous: true

must_haves:
  truths:
    - "LINK creates a hard link using SavedFH (source file) and CurrentFH (target dir)"
    - "LINK returns NFS4ERR_ISDIR when SavedFH is a directory"
    - "LINK returns NFS4ERR_XDEV when SavedFH and CurrentFH are from different shares"
    - "RENAME moves files using SavedFH (source dir) and CurrentFH (target dir)"
    - "RENAME returns change_info4 for both source and target directories"
    - "RENAME returns NFS4ERR_XDEV for cross-share rename"
    - "Both operations return NFS4ERR_ROFS on pseudo-fs handles"
  artifacts:
    - path: "internal/protocol/nfs/v4/handlers/link.go"
      provides: "LINK operation handler with two-filehandle pattern"
      contains: "handleLink"
    - path: "internal/protocol/nfs/v4/handlers/rename.go"
      provides: "RENAME operation handler with two-filehandle pattern"
      contains: "handleRename"
    - path: "internal/protocol/nfs/v4/handlers/link_rename_test.go"
      provides: "Tests for LINK and RENAME operations"
      min_lines: 200
  key_links:
    - from: "internal/protocol/nfs/v4/handlers/link.go"
      to: "pkg/metadata (MetadataService.CreateHardLink)"
      via: "getMetadataServiceForCtx + metaSvc.CreateHardLink"
      pattern: "CreateHardLink"
    - from: "internal/protocol/nfs/v4/handlers/rename.go"
      to: "pkg/metadata (MetadataService.Move)"
      via: "getMetadataServiceForCtx + metaSvc.Move"
      pattern: "Move"
    - from: "internal/protocol/nfs/v4/handlers/handler.go"
      to: "internal/protocol/nfs/v4/handlers/link.go"
      via: "opDispatchTable[OP_LINK]"
      pattern: "OP_LINK.*handleLink"
---

<objective>
Implement NFSv4 LINK and RENAME operations using the two-filehandle pattern (SavedFH + CurrentFH).

Purpose: These operations complete the filesystem manipulation set, enabling hard link creation and file/directory renaming within shares. Both use the same SavedFH/CurrentFH pattern and share error handling logic, making them a natural pair.

Output: Two handler files (link.go, rename.go), dispatch table registration, and comprehensive tests covering success paths, error conditions, cross-share detection, and compound sequences.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-nfsv4-advanced-operations/08-RESEARCH.md
@internal/protocol/nfs/v4/handlers/handler.go
@internal/protocol/nfs/v4/handlers/helpers.go
@internal/protocol/nfs/v4/handlers/realfs_test.go
@internal/protocol/nfs/v4/handlers/create.go
@internal/protocol/nfs/v4/handlers/remove.go
@internal/protocol/nfs/v4/types/constants.go
@internal/protocol/nfs/v4/types/types.go
@internal/protocol/nfs/v4/types/errors.go
@internal/protocol/nfs/v4/pseudofs/pseudofs.go
@pkg/metadata/service.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: LINK and RENAME handlers with dispatch registration and tests</name>
  <files>
    internal/protocol/nfs/v4/handlers/link.go
    internal/protocol/nfs/v4/handlers/rename.go
    internal/protocol/nfs/v4/handlers/link_rename_test.go
    internal/protocol/nfs/v4/handlers/handler.go
  </files>
  <action>
Create `link.go` implementing `handleLink`:
- Require CurrentFH via `types.RequireCurrentFH(ctx)` and SavedFH via `types.RequireSavedFH(ctx)`
- Check pseudo-fs: `pseudofs.IsPseudoFSHandle(ctx.CurrentFH)` -> NFS4ERR_ROFS
- Read the new link name (component4 XDR string) from the reader
- Validate the name with `types.ValidateUTF8Filename(name)`
- Build auth context from CurrentFH via `buildV4AuthContext`
- Cross-share check: decode both SavedFH and CurrentFH share names via `metadata.DecodeFileHandle()`. If share names differ, return NFS4ERR_XDEV
- Get MetadataService via `getMetadataServiceForCtx`
- Get pre-op ctime of target directory (CurrentFH) for change_info4 via `metaSvc.GetFile()`
- Call `metaSvc.CreateHardLink(authCtx, metadata.FileHandle(ctx.CurrentFH), name, metadata.FileHandle(ctx.SavedFH))`
- Get post-op ctime for change_info4
- Map any errors via `types.MapMetadataErrorToNFS4(err)`
- Encode response: status (NFS4_OK) + change_info4 (atomic=true, before, after ctimes as uint64 nanoseconds)
- Use `encodeChangeInfo4()` helper from helpers.go

Create `rename.go` implementing `handleRename`:
- Same FH requirements as LINK (CurrentFH + SavedFH)
- Check pseudo-fs on BOTH CurrentFH and SavedFH -> NFS4ERR_ROFS
- Read two component4 names: oldname (source) and newname (target) from the reader
- Validate both names with `types.ValidateUTF8Filename()`
- Build auth context from CurrentFH
- Cross-share check: compare share names from SavedFH and CurrentFH -> NFS4ERR_XDEV if different
- Get pre-op ctime for BOTH source dir (SavedFH) and target dir (CurrentFH)
- Call `metaSvc.Move(authCtx, metadata.FileHandle(ctx.SavedFH), oldname, metadata.FileHandle(ctx.CurrentFH), newname)`
- Get post-op ctime for both directories
- Map errors via `types.MapMetadataErrorToNFS4(err)`
- Encode response: status (NFS4_OK) + source_cinfo (change_info4) + target_cinfo (change_info4)
- Both change_info4 use atomic=true

Register in `handler.go` dispatch table:
```go
h.opDispatchTable[types.OP_LINK] = h.handleLink
h.opDispatchTable[types.OP_RENAME] = h.handleRename
```
Add a comment "// Link and rename operations" before the two lines.

Create `link_rename_test.go` with tests using `newRealFSTestFixture`:
LINK tests:
- TestHandleLink_Success: create a regular file, SAVEFH to save its handle, navigate to a dir, LINK creates new name, verify link count incremented
- TestHandleLink_NoCurrentFH: no FH set -> NFS4ERR_NOFILEHANDLE
- TestHandleLink_NoSavedFH: no SavedFH -> NFS4ERR_RESTOREFH
- TestHandleLink_PseudoFS: CurrentFH is pseudo-fs handle -> NFS4ERR_ROFS
- TestHandleLink_IsDirectory: SavedFH is a directory -> NFS4ERR_ISDIR
- TestHandleLink_CrossShare: SavedFH from different share -> NFS4ERR_XDEV
- TestHandleLink_InvalidName: empty name or name with "/" -> appropriate error
- TestHandleLink_TargetExists: name already exists -> NFS4ERR_EXIST

RENAME tests:
- TestHandleRename_Success: rename file from one name to another in same dir
- TestHandleRename_CrossDirectory: rename file from source dir to different target dir
- TestHandleRename_NoCurrentFH: -> NFS4ERR_NOFILEHANDLE
- TestHandleRename_NoSavedFH: -> NFS4ERR_RESTOREFH
- TestHandleRename_PseudoFS: -> NFS4ERR_ROFS
- TestHandleRename_CrossShare: different shares -> NFS4ERR_XDEV
- TestHandleRename_NotFound: source name doesn't exist -> NFS4ERR_NOENT
- TestHandleRename_InvalidName: invalid source or target name -> appropriate error

All tests: use `t.Run()` subtests, set up CompoundContext with proper UID/GID/AuthFlavor, build XDR reader for args, call handler directly, parse response status.
  </action>
  <verify>
Run `go test -race -v ./internal/protocol/nfs/v4/handlers/ -run "TestHandleLink|TestHandleRename"` -- all tests pass with no race conditions.
Run `go vet ./internal/protocol/nfs/v4/handlers/` -- no issues.
  </verify>
  <done>
LINK handler creates hard links using SavedFH/CurrentFH pattern with proper cross-share detection, pseudo-fs rejection, and change_info4 encoding. RENAME handler moves/renames files across directories within the same share with dual change_info4. Both registered in dispatch table. All tests pass with -race.
  </done>
</task>

</tasks>

<verification>
1. `go test -race -v ./internal/protocol/nfs/v4/handlers/ -run "TestHandleLink|TestHandleRename"` -- all new tests pass
2. `go test -race ./internal/protocol/nfs/v4/handlers/` -- all existing tests still pass (no regressions)
3. `go vet ./internal/protocol/nfs/v4/...` -- no static analysis issues
4. Verify LINK and RENAME are registered in handler.go dispatch table
</verification>

<success_criteria>
- LINK handler creates hard links via MetadataService.CreateHardLink with all error paths covered
- RENAME handler moves files/dirs via MetadataService.Move with dual change_info4 and cross-share detection
- Both operations registered in dispatch table and callable from COMPOUND
- 15+ tests covering success paths and all error conditions listed above
- All tests pass with -race flag
</success_criteria>

<output>
After completion, create `.planning/phases/08-nfsv4-advanced-operations/08-01-SUMMARY.md`
</output>
