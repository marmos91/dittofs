---
phase: 01-locking-infrastructure
plan: 04
type: execute
wave: 3
depends_on: ["01-01", "01-02", "01-03"]
files_modified:
  - pkg/metadata/errors.go (delete after move)
  - pkg/metadata/errors/errors.go (new)
  - pkg/metadata/lock/types.go (new)
  - pkg/metadata/lock/store.go (new)
  - pkg/metadata/lock/manager.go (new)
  - pkg/metadata/lock/deadlock.go (new)
  - pkg/metadata/lock/config.go (new)
  - pkg/metadata/lock/grace.go (new)
  - pkg/metadata/lock/connection.go (new)
  - pkg/metadata/lock/metrics.go (new)
  - pkg/metadata/lock/errors.go (new - lock-specific factories)
  - pkg/metadata/store.go (update Transaction)
  - pkg/metadata/store/memory/locks.go (update imports)
  - pkg/metadata/store/badger/locks.go (update imports)
  - pkg/metadata/store/postgres/locks.go (update imports)
autonomous: true

must_haves:
  truths:
    - "No circular imports between packages"
    - "All tests pass after refactoring"
    - "Import graph: errors <- lock <- metadata <- store implementations"
  artifacts:
    - path: "pkg/metadata/errors/errors.go"
      provides: "StoreError, ErrorCode, generic factory functions"
      exports: ["StoreError", "ErrorCode", "ErrNotFound", "ErrLocked", "..."]
    - path: "pkg/metadata/lock/store.go"
      provides: "LockStore interface, PersistedLock, LockQuery"
      exports: ["LockStore", "PersistedLock", "LockQuery"]
    - path: "pkg/metadata/lock/types.go"
      provides: "EnhancedLock, LockOwner, LockType"
      exports: ["EnhancedLock", "LockOwner", "LockType", "ShareReservation"]
---

<objective>
Refactor lock-related code into `pkg/metadata/lock/` package with shared errors in `pkg/metadata/errors/`.

Purpose: Clean separation of concerns, no circular dependencies, better code organization as lock subsystem grows.

Output:
- `pkg/metadata/errors/` - Leaf package with StoreError, ErrorCode, constants
- `pkg/metadata/lock/` - All lock-related code
- Updated imports throughout codebase
</objective>

<context>
## Current Structure (BEFORE)
```
pkg/metadata/
├── errors.go              # StoreError, ErrorCode, factory functions
├── lock_types.go          # EnhancedLock, LockOwner, LockType
├── lock_persistence.go    # LockStore, PersistedLock, LockQuery
├── lock_deadlock.go       # WaitForGraph
├── lock_config.go         # LockConfig, LockLimits
├── lock_grace.go          # GracePeriodManager
├── lock_connection.go     # ConnectionTracker
├── lock_metrics.go        # LockMetrics
├── locking.go             # LockManager, FileLock
├── locking_test.go
├── store.go               # Transaction embeds LockStore
└── store/
    ├── memory/locks.go
    ├── badger/locks.go
    └── postgres/locks.go
```

## Target Structure (AFTER)
```
pkg/metadata/
├── errors/
│   └── errors.go          # StoreError, ErrorCode, generic factories
├── lock/
│   ├── types.go           # EnhancedLock, LockOwner, LockType, ShareReservation
│   ├── store.go           # LockStore, PersistedLock, LockQuery
│   ├── manager.go         # LockManager, FileLock (was locking.go)
│   ├── manager_test.go
│   ├── deadlock.go        # WaitForGraph
│   ├── deadlock_test.go
│   ├── config.go          # LockConfig, LockLimits
│   ├── config_test.go
│   ├── grace.go           # GracePeriodManager
│   ├── grace_test.go
│   ├── connection.go      # ConnectionTracker
│   ├── connection_test.go
│   ├── metrics.go         # LockMetrics
│   ├── metrics_test.go
│   └── errors.go          # Lock-specific factory functions
├── store.go               # Transaction embeds lock.LockStore
└── store/
    ├── memory/locks.go    # imports errors, lock
    ├── badger/locks.go    # imports errors, lock
    └── postgres/locks.go  # imports errors, lock
```

## Import Graph (NO CYCLES)
```
errors  <--  lock  <--  metadata  <--  store/{memory,badger,postgres}
   ^                        ^                      |
   +------------------------+----------------------+
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create errors package</name>
  <files>
    pkg/metadata/errors/errors.go
  </files>
  <action>
Create `pkg/metadata/errors/errors.go` with:

1. Package declaration: `package errors`

2. Move from `pkg/metadata/errors.go`:
   - `StoreError` struct
   - `ErrorCode` type
   - All `Err*` constants (ErrNotFound through ErrConnectionLimitReached)
   - `Error()` method on StoreError
   - Generic factory functions that DON'T use lock types:
     - `NewNotFoundError`
     - `NewPermissionDeniedError`
     - `NewIsDirectoryError`
     - `NewNotDirectoryError`
     - `NewInvalidHandleError`
     - `NewNotEmptyError`
     - `NewAlreadyExistsError`
     - `NewInvalidArgumentError`
     - `NewAccessDeniedError`
     - `NewQuotaExceededError`
     - `NewPrivilegeRequiredError`
     - `NewNameTooLongError`
   - Helper functions:
     - `IsNotFoundError`
     - `IsLockConflictError`
     - `IsDeadlockError`

3. DO NOT include (will go to lock/errors.go):
   - `NewLockedError` (uses LockConflict)
   - `NewLockConflictError` (uses EnhancedLockConflict)
   - `NewDeadlockError` (lock-specific)
   - `NewGracePeriodError` (lock-specific)
   - `NewLockLimitExceededError` (lock-specific)
   - `NewLockNotFoundError` (lock-specific)

4. Import only `fmt` (leaf package)
  </action>
  <verify>
```bash
go build ./pkg/metadata/errors/...
```
  </verify>
</task>

<task type="auto">
  <name>Task 2: Create lock package - types and store</name>
  <files>
    pkg/metadata/lock/types.go
    pkg/metadata/lock/store.go
  </files>
  <action>
Create `pkg/metadata/lock/types.go`:
- Move from `lock_types.go`:
  - `LockType` (LockTypeShared, LockTypeExclusive)
  - `ShareReservation` constants
  - `LockOwner` struct
  - `EnhancedLock` struct
  - `EnhancedLockConflict` struct
  - `LockResult` struct
  - Any helper methods on these types

Create `pkg/metadata/lock/store.go`:
- Move from `lock_persistence.go`:
  - `PersistedLock` struct
  - `LockQuery` struct
  - `LockStore` interface
  - `ToPersistedLock` function
  - `FromPersistedLock` function
- Import: `context`, `time`, errors package
  </action>
  <verify>
```bash
go build ./pkg/metadata/lock/...
```
  </verify>
</task>

<task type="auto">
  <name>Task 3: Create lock package - manager and deadlock</name>
  <files>
    pkg/metadata/lock/manager.go
    pkg/metadata/lock/manager_test.go
    pkg/metadata/lock/deadlock.go
    pkg/metadata/lock/deadlock_test.go
  </files>
  <action>
Create `pkg/metadata/lock/manager.go`:
- Move from `locking.go`:
  - `FileLock` struct (legacy type)
  - `LockConflict` struct (legacy type)
  - `LockManager` struct
  - All LockManager methods
  - Helper functions (SplitLock, MergeLocks, etc.)
- Update package to `lock`
- Update imports to use `errors` package

Create `pkg/metadata/lock/deadlock.go`:
- Move from `lock_deadlock.go`:
  - `WaitForGraph` struct
  - All WaitForGraph methods
- Update package to `lock`

Move corresponding test files and update packages.
  </action>
  <verify>
```bash
go test ./pkg/metadata/lock/... -run "TestLockManager|TestWaitForGraph"
```
  </verify>
</task>

<task type="auto">
  <name>Task 4: Create lock package - config, grace, connection, metrics</name>
  <files>
    pkg/metadata/lock/config.go
    pkg/metadata/lock/config_test.go
    pkg/metadata/lock/grace.go
    pkg/metadata/lock/grace_test.go
    pkg/metadata/lock/connection.go
    pkg/metadata/lock/connection_test.go
    pkg/metadata/lock/metrics.go
    pkg/metadata/lock/metrics_test.go
  </files>
  <action>
Move each file to lock/ package:

1. `lock_config.go` -> `lock/config.go`
   - Update package to `lock`
   - Update imports to use `errors` package

2. `lock_grace.go` -> `lock/grace.go`
   - Update package to `lock`
   - Update imports

3. `lock_connection.go` -> `lock/connection.go`
   - Update package to `lock`
   - Update imports to use `errors` package

4. `lock_metrics.go` -> `lock/metrics.go`
   - Update package to `lock`

Move all corresponding test files.
  </action>
  <verify>
```bash
go test ./pkg/metadata/lock/...
```
  </verify>
</task>

<task type="auto">
  <name>Task 5: Create lock-specific error factories</name>
  <files>
    pkg/metadata/lock/errors.go
  </files>
  <action>
Create `pkg/metadata/lock/errors.go` with lock-specific factory functions:

```go
package lock

import (
    "fmt"
    "github.com/marmos91/dittofs/pkg/metadata/errors"
)

// NewLockedError creates error for lock conflicts (legacy FileLock).
func NewLockedError(path string, conflict *LockConflict) *errors.StoreError { ... }

// NewLockNotFoundError creates error for missing locks.
func NewLockNotFoundError(path string) *errors.StoreError { ... }

// NewDeadlockError creates error for deadlock detection.
func NewDeadlockError(waiter string, blockedBy []string) *errors.StoreError { ... }

// NewGracePeriodError creates error for grace period blocking.
func NewGracePeriodError(remainingSeconds int) *errors.StoreError { ... }

// NewLockLimitExceededError creates error for lock limit violations.
func NewLockLimitExceededError(limitType string, current, max int) *errors.StoreError { ... }

// NewLockConflictError creates error for enhanced lock conflicts.
func NewLockConflictError(path string, conflict *EnhancedLockConflict) *errors.StoreError { ... }
```

These functions use lock types (LockConflict, EnhancedLockConflict) so must be in lock package.
  </action>
  <verify>
```bash
go build ./pkg/metadata/lock/...
```
  </verify>
</task>

<task type="auto">
  <name>Task 6: Update metadata package</name>
  <files>
    pkg/metadata/store.go
    pkg/metadata/errors.go (delete)
    pkg/metadata/lock_*.go (delete all)
    pkg/metadata/locking.go (delete)
    pkg/metadata/locking_test.go (delete)
  </files>
  <action>
1. Update `pkg/metadata/store.go`:
   - Add import: `"github.com/marmos91/dittofs/pkg/metadata/lock"`
   - Change `Transaction` interface to embed `lock.LockStore` instead of `LockStore`

2. Delete old files (now in errors/ or lock/):
   - `pkg/metadata/errors.go`
   - `pkg/metadata/lock_types.go`
   - `pkg/metadata/lock_persistence.go`
   - `pkg/metadata/lock_deadlock.go`
   - `pkg/metadata/lock_deadlock_test.go`
   - `pkg/metadata/lock_config.go`
   - `pkg/metadata/lock_config_test.go`
   - `pkg/metadata/lock_grace.go`
   - `pkg/metadata/lock_grace_test.go`
   - `pkg/metadata/lock_connection.go`
   - `pkg/metadata/lock_connection_test.go`
   - `pkg/metadata/lock_metrics.go`
   - `pkg/metadata/lock_metrics_test.go`
   - `pkg/metadata/locking.go`
   - `pkg/metadata/locking_test.go`

3. Update remaining files in pkg/metadata/ to import from errors and lock packages
  </action>
  <verify>
```bash
go build ./pkg/metadata/...
```
  </verify>
</task>

<task type="auto">
  <name>Task 7: Update store implementations</name>
  <files>
    pkg/metadata/store/memory/locks.go
    pkg/metadata/store/memory/store.go
    pkg/metadata/store/badger/locks.go
    pkg/metadata/store/badger/store.go
    pkg/metadata/store/postgres/locks.go
    pkg/metadata/store/postgres/store.go
  </files>
  <action>
Update imports in all store implementations:

1. Replace `"github.com/marmos91/dittofs/pkg/metadata"` usage:
   - `metadata.StoreError` -> `errors.StoreError`
   - `metadata.ErrLockNotFound` -> `errors.ErrLockNotFound`
   - `metadata.PersistedLock` -> `lock.PersistedLock`
   - `metadata.LockQuery` -> `lock.LockQuery`
   - `metadata.LockStore` -> `lock.LockStore`

2. Add imports:
   - `"github.com/marmos91/dittofs/pkg/metadata/errors"`
   - `"github.com/marmos91/dittofs/pkg/metadata/lock"`

3. Update type assertions and interface implementations
  </action>
  <verify>
```bash
go build ./pkg/metadata/store/...
go test ./pkg/metadata/store/...
```
  </verify>
</task>

<task type="auto">
  <name>Task 8: Update rest of codebase</name>
  <files>
    internal/protocol/nfs/...
    pkg/controlplane/...
    cmd/...
    (any other files using metadata errors or lock types)
  </files>
  <action>
Search and update all files that import metadata package for error/lock types:

```bash
# Find files using metadata.StoreError
grep -r "metadata\.StoreError" --include="*.go" .
grep -r "metadata\.Err" --include="*.go" .
grep -r "metadata\.LockManager" --include="*.go" .
grep -r "metadata\.EnhancedLock" --include="*.go" .
```

Update imports:
- `metadata.StoreError` -> `metaerrors.StoreError` (import as metaerrors)
- `metadata.ErrNotFound` -> `metaerrors.ErrNotFound`
- `metadata.LockManager` -> `lock.Manager`
- etc.

Convention for import aliases:
```go
import (
    metaerrors "github.com/marmos91/dittofs/pkg/metadata/errors"
    "github.com/marmos91/dittofs/pkg/metadata/lock"
)
```
  </action>
  <verify>
```bash
go build ./...
go test ./...
```
  </verify>
</task>

</tasks>

<verification>
```bash
# Build entire project
go build ./...

# Run all tests
go test ./...

# Run with race detector
go test -race ./pkg/metadata/...

# Verify no circular imports
go list -f '{{.ImportPath}} -> {{.Imports}}' ./pkg/metadata/... | grep -E "(errors|lock)"
```
</verification>

<success_criteria>
1. No circular imports between packages
2. Import graph: errors <- lock <- metadata <- store implementations
3. All tests pass
4. No references to old file locations
5. Clean package boundaries
</success_criteria>

<output>
After completion, create `.planning/phases/01-locking-infrastructure/01-04-SUMMARY.md`
</output>
