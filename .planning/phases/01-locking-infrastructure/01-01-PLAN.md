---
phase: 01-locking-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/metadata/locking.go
  - pkg/metadata/locking_test.go
  - pkg/metadata/lock_types.go
  - pkg/metadata/lock_deadlock.go
  - pkg/metadata/lock_deadlock_test.go
  - pkg/metadata/lock_config.go
  - pkg/metadata/lock_config_test.go
  - pkg/metadata/errors.go
autonomous: true

must_haves:
  truths:
    - "Lock manager supports POSIX lock splitting (unlock middle of range creates two locks)"
    - "Lock manager detects deadlocks using Wait-For Graph before blocking"
    - "Lock manager enforces configurable limits (per-file, per-client, total)"
    - "Lock upgrade from shared to exclusive is atomic when no other readers"
    - "Lock manager treats protocol-specific owner IDs uniformly (LOCK-04)"
  artifacts:
    - path: "pkg/metadata/lock_types.go"
      provides: "Enhanced lock types with owner ID, client ID, share reservations"
      exports: ["EnhancedLock", "LockOwner", "LockType", "ShareReservation"]
    - path: "pkg/metadata/lock_deadlock.go"
      provides: "Wait-For Graph deadlock detection"
      exports: ["WaitForGraph", "WouldCauseCycle", "AddWaiter", "RemoveWaiter"]
    - path: "pkg/metadata/lock_config.go"
      provides: "Lock configuration and limits"
      exports: ["LockConfig", "DefaultLockConfig"]
  key_links:
    - from: "pkg/metadata/locking.go"
      to: "pkg/metadata/lock_types.go"
      via: "EnhancedLock type used in LockManager"
      pattern: "EnhancedLock"
    - from: "pkg/metadata/locking.go"
      to: "pkg/metadata/lock_deadlock.go"
      via: "WaitForGraph checked before blocking lock"
      pattern: "WouldCauseCycle"
---

<objective>
Enhance the existing LockManager with POSIX lock splitting, deadlock detection, atomic lock upgrades, and configurable limits.

Purpose: Build the foundation for a production-ready lock manager that supports byte-range locks with proper POSIX semantics. The existing LockManager has correct conflict detection but lacks splitting, deadlock prevention, atomic upgrades, and limits.

Output:
- Enhanced lock types supporting protocol-agnostic ownership
- Wait-For Graph for deadlock detection
- Lock configuration with limits
- POSIX-compliant lock splitting
- Atomic lock upgrade (shared to exclusive)
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-locking-infrastructure/01-CONTEXT.md
@.planning/phases/01-locking-infrastructure/01-RESEARCH.md

# Existing lock implementation to enhance
@pkg/metadata/locking.go
@pkg/metadata/locking_test.go
@pkg/metadata/errors.go
@pkg/metadata/service.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhanced lock types, POSIX lock splitting, and atomic upgrade</name>
  <files>
    pkg/metadata/lock_types.go
    pkg/metadata/locking.go
    pkg/metadata/locking_test.go
    pkg/metadata/errors.go
  </files>
  <action>
Create pkg/metadata/lock_types.go with enhanced lock types:

1. Define `LockType` enum: `LockTypeShared`, `LockTypeExclusive`

2. Define `ShareReservation` enum for SMB share modes:
   - `ShareReservationNone` (default)
   - `ShareReservationDenyRead`
   - `ShareReservationDenyWrite`
   - `ShareReservationDenyAll`

3. Define `LockOwner` struct to identify lock owners protocol-agnostically:
   - `OwnerID string` - Protocol-provided owner identifier. Format: "{protocol}:{details}"
     Examples: "nlm:client1:pid123", "smb:session456:pid789", "nfs4:clientid:stateid"
     The lock manager treats these as opaque strings - it does NOT parse the protocol prefix.
     This enables cross-protocol lock conflict detection (LOCK-04).
   - `ClientID string` - Connection tracker client ID
   - `ShareName string` - Share the lock belongs to

4. Define `EnhancedLock` struct extending the existing FileLock concept:
   - `ID string` - Unique lock identifier (UUID)
   - `Owner LockOwner` - Who owns the lock
   - `FileHandle FileHandle` - File this lock is on
   - `Offset uint64` - Starting byte offset
   - `Length uint64` - Bytes locked (0 = to EOF)
   - `Type LockType` - Shared or exclusive
   - `ShareReservation ShareReservation` - SMB share mode (NFS ignores)
   - `AcquiredAt time.Time` - When lock was acquired
   - `Blocking bool` - Whether this was a blocking request
   - `Reclaim bool` - Whether this is a reclaim during grace period

5. Update pkg/metadata/locking.go to add lock splitting function `SplitLock`:
   - Input: existing EnhancedLock, unlock offset, unlock length
   - Output: []EnhancedLock (0, 1, or 2 locks after split)
   - Handle cases: unlock at start, unlock at end, unlock in middle, exact match
   - Preserve all other lock properties (owner, type, etc.) in split locks

6. Add `MergeLocks` function to coalesce adjacent locks from same owner:
   - Used when upgrading/extending locks
   - Same owner + adjacent/overlapping ranges = merge into one

7. Implement `UpgradeLock(owner LockOwner, fileHandle FileHandle, offset, length uint64) (*EnhancedLock, error)`:
   - Atomically converts a shared lock to exclusive lock if no other readers exist on the range
   - Steps:
     a. Find existing shared lock owned by `owner` covering the range
     b. Check if any OTHER owners hold shared locks on overlapping range
     c. If other readers exist: return ErrLockConflict
     d. If no other readers: atomically change lock type to Exclusive, return upgraded lock
   - This implements the user decision: "Lock upgrade: Atomic upgrade supported (read â†’ write if no other readers)"

8. Add new error codes to errors.go:
   - `ErrDeadlock` for deadlock detection
   - `ErrGracePeriod` for operations blocked during grace period
   - `ErrLockLimitExceeded` for when limits are reached
   - `ErrLockConflict` for upgrade conflicts (if not already present)

9. Add comprehensive tests for lock splitting in locking_test.go:
   - Unlock at start of range
   - Unlock at end of range
   - Unlock in middle (creates two locks)
   - Unlock exact match (removes lock)
   - Unlock larger than lock (removes lock)
   - Unlock non-overlapping (no change)

10. Add tests for atomic lock upgrade (CRITICAL - implements user decision):
    - TestUpgradeLock_Atomic_NoOtherReaders: Owner A has shared lock, upgrades to exclusive - succeeds
    - TestUpgradeLock_Fails_WithOtherReaders: Owner A and B have shared locks, A tries upgrade - fails with ErrLockConflict
    - TestUpgradeLock_NoExistingLock: Owner tries to upgrade non-existent lock - fails
    - TestUpgradeLock_AlreadyExclusive: Owner already has exclusive lock - no-op success

11. Add tests for cross-protocol owner ID handling (LOCK-04):
    - TestLockConflict_CrossProtocol: NLM owner "nlm:client1:pid123" and SMB owner "smb:session456:pid789"
      both request exclusive lock on same range - second request correctly conflicts
    - TestOwnerID_TreatedAsOpaque: Lock manager does not parse protocol prefix, treats entire string as owner identity
  </action>
  <verify>
```bash
go test -v ./pkg/metadata/... -run "TestSplitLock|TestMergeLocks|TestEnhancedLock|TestUpgradeLock|TestLockConflict_CrossProtocol|TestOwnerID"
go build ./pkg/metadata/...
```
  </verify>
  <done>
- EnhancedLock type exists with all fields documented
- LockOwner, LockType, ShareReservation types exist
- SplitLock correctly handles all POSIX splitting cases
- MergeLocks coalesces adjacent locks
- UpgradeLock atomically upgrades shared to exclusive when no other readers
- UpgradeLock returns ErrLockConflict when other readers exist
- Cross-protocol owner IDs correctly conflict (LOCK-04 verified)
- New error codes defined
- All tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Wait-For Graph deadlock detection</name>
  <files>
    pkg/metadata/lock_deadlock.go
    pkg/metadata/lock_deadlock_test.go
  </files>
  <action>
Create pkg/metadata/lock_deadlock.go implementing Wait-For Graph (WFG) deadlock detection:

1. Define `WaitForGraph` struct:
   - `mu sync.RWMutex` - Thread safety
   - `edges map[string]map[string]struct{}` - waiter -> set of owners being waited on
   - Uses string keys (OwnerID) for flexibility

2. Implement `NewWaitForGraph() *WaitForGraph`

3. Implement `WouldCauseCycle(waiter string, owners []string) bool`:
   - Check if adding edges from waiter to owners would create a cycle
   - Use DFS from each owner to see if we can reach waiter
   - Return true if cycle would be created (deadlock)
   - Algorithm: For each owner, DFS through the graph checking if waiter is reachable

4. Implement `AddWaiter(waiter string, owners []string)`:
   - Add edges from waiter to all owners
   - Called when a blocking lock request starts waiting
   - MUST call WouldCauseCycle first (caller's responsibility)

5. Implement `RemoveWaiter(waiter string)`:
   - Remove all edges where waiter is the source
   - Called when: lock granted, request cancelled, timeout

6. Implement `RemoveOwner(owner string)`:
   - Remove all edges where owner is the target
   - Called when: lock released, client disconnects
   - Also removes owner as a waiter (if they were waiting)

7. Implement `GetWaitersFor(owner string) []string`:
   - Return all waiters waiting for this owner
   - Used to wake waiters when lock is released

8. Internal helper `canReach(from, to string, visited map[string]bool) bool`:
   - DFS traversal checking reachability
   - visited map prevents infinite loops

Create pkg/metadata/lock_deadlock_test.go with tests:
- Simple cycle: A waits for B, B waits for A
- Chain: A waits for B, B waits for C - no cycle
- Triangle: A->B->C->A cycle
- Multiple paths: Complex graph with and without cycles
- Remove waiter breaks cycle
- Remove owner breaks cycle
- Concurrent access (goroutine safety)
- Empty graph operations
  </action>
  <verify>
```bash
go test -v ./pkg/metadata/... -run "TestWaitForGraph"
go test -race ./pkg/metadata/... -run "TestWaitForGraph"
```
  </verify>
  <done>
- WaitForGraph struct and methods implemented
- WouldCauseCycle correctly detects A->B->A cycles
- WouldCauseCycle correctly detects larger cycles (A->B->C->A)
- AddWaiter/RemoveWaiter/RemoveOwner work correctly
- Thread-safe under concurrent access
- All tests pass including race detector
  </done>
</task>

<task type="auto">
  <name>Task 3: Lock configuration and limits</name>
  <files>
    pkg/metadata/lock_config.go
    pkg/metadata/lock_config_test.go
    pkg/config/config.go
  </files>
  <action>
Create pkg/metadata/lock_config.go with lock configuration:

1. Define `LockConfig` struct:
   - `MaxLocksPerFile int` - Maximum locks allowed on a single file (default: 1000)
   - `MaxLocksPerClient int` - Maximum locks a single client can hold (default: 10000)
   - `MaxTotalLocks int` - Maximum total locks across all files (default: 100000)
   - `BlockingTimeout time.Duration` - Server-side timeout for blocking locks (default: 60s)
   - `GracePeriodDuration time.Duration` - Grace period after restart (default: 90s)
   - `MandatoryLocking bool` - Whether locks are mandatory or advisory (default: false)

2. Define `DefaultLockConfig() LockConfig`:
   - Returns config with all defaults set

3. Define `LockLimits` struct for tracking current usage:
   - `mu sync.RWMutex`
   - `locksByFile map[string]int` - FileHandle -> count
   - `locksByClient map[string]int` - ClientID -> count
   - `totalLocks int`

4. Implement `NewLockLimits() *LockLimits`

5. Implement `CheckLimits(config LockConfig, fileHandle string, clientID string) error`:
   - Return ErrLockLimitExceeded if any limit would be exceeded
   - Check all three limits (file, client, total)

6. Implement `IncrementCounts(fileHandle, clientID string)`:
   - Increment all relevant counters
   - Called after successfully acquiring a lock

7. Implement `DecrementCounts(fileHandle, clientID string)`:
   - Decrement all relevant counters
   - Called after releasing a lock

8. Implement `GetStats() LockStats`:
   - Return current counts for monitoring
   - `LockStats` struct: TotalLocks, UniqueFiles, UniqueClients

9. Add lock configuration to pkg/config/config.go:
   - Add `Lock LockConfig` field to appropriate config section
   - This will be under server configuration

Create pkg/metadata/lock_config_test.go with tests:
- DefaultLockConfig returns valid defaults
- CheckLimits returns nil when under limits
- CheckLimits returns error when file limit exceeded
- CheckLimits returns error when client limit exceeded
- CheckLimits returns error when total limit exceeded
- IncrementCounts/DecrementCounts track correctly
- GetStats returns accurate counts
- Concurrent increment/decrement safety
  </action>
  <verify>
```bash
go test -v ./pkg/metadata/... -run "TestLockConfig|TestLockLimits"
go test -race ./pkg/metadata/... -run "TestLockLimits"
go build ./pkg/config/...
```
  </verify>
  <done>
- LockConfig struct defined with all fields and defaults
- LockLimits tracks per-file, per-client, and total lock counts
- CheckLimits correctly enforces all three limits
- Configuration integrated with pkg/config
- Thread-safe limit tracking
- All tests pass
  </done>
</task>

</tasks>

<verification>
```bash
# Run all tests for the metadata package
go test -v ./pkg/metadata/...

# Run with race detector
go test -race ./pkg/metadata/...

# Verify build
go build ./...

# Check for any lint issues
go vet ./pkg/metadata/...
```
</verification>

<success_criteria>
1. EnhancedLock type with protocol-agnostic ownership model
2. POSIX lock splitting produces correct results for all cases
3. Wait-For Graph detects cycles (deadlocks) before blocking
4. Lock limits are configurable and enforced
5. Atomic lock upgrade works when no other readers exist
6. Atomic lock upgrade fails with ErrLockConflict when other readers exist
7. Cross-protocol owner IDs correctly conflict (LOCK-04)
8. All new code has comprehensive test coverage
9. Race detector passes on all tests
10. Code builds successfully
</success_criteria>

<output>
After completion, create `.planning/phases/01-locking-infrastructure/01-01-SUMMARY.md`
</output>
