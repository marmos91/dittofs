---
phase: 01-locking-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - pkg/metadata/lock_grace.go
  - pkg/metadata/lock_grace_test.go
  - pkg/metadata/lock_connection.go
  - pkg/metadata/lock_connection_test.go
  - pkg/metadata/lock_metrics.go
  - pkg/metadata/lock_metrics_test.go
autonomous: true

must_haves:
  truths:
    - "Grace period blocks new locks while allowing reclaims after server restart"
    - "Grace period exits early when all expected clients have reclaimed"
    - "Connection tracker manages per-adapter client connections with configurable TTL"
    - "Prometheus metrics expose lock and connection statistics"
  artifacts:
    - path: "pkg/metadata/lock_grace.go"
      provides: "Grace period state machine"
      exports: ["GracePeriodManager", "GraceState", "IsAllowed", "MarkReclaimed"]
    - path: "pkg/metadata/lock_connection.go"
      provides: "Connection tracking with adapter-controlled TTL"
      exports: ["ConnectionTracker", "ClientRegistration", "RegisterClient", "UnregisterClient"]
    - path: "pkg/metadata/lock_metrics.go"
      provides: "Prometheus metrics for locks and connections"
      exports: ["LockMetrics", "NewLockMetrics"]
  key_links:
    - from: "pkg/metadata/lock_grace.go"
      to: "pkg/metadata/lock_connection.go"
      via: "Grace period checks expected clients from connection tracker"
      pattern: "expectedClients"
    - from: "pkg/metadata/lock_metrics.go"
      to: "pkg/metadata/lock_grace.go"
      via: "Metrics expose grace period status"
      pattern: "gracePeriodActive"
---

<objective>
Implement grace period handling and connection tracking for the lock manager.

Purpose: After server restart, clients need time to reclaim their locks. The grace period allows reclaims while blocking new lock requests. Connection tracking manages client lifecycle with protocol-specific TTLs.

Output:
- Grace period state machine with early exit
- Connection tracker with adapter-controlled TTL
- Prometheus metrics for observability
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-locking-infrastructure/01-CONTEXT.md
@.planning/phases/01-locking-infrastructure/01-RESEARCH.md

# Plan 01 creates the types and config we use
@.planning/phases/01-locking-infrastructure/01-01-SUMMARY.md

# Existing metrics patterns to follow
@pkg/controlplane/runtime/metrics.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Grace period state machine</name>
  <files>
    pkg/metadata/lock_grace.go
    pkg/metadata/lock_grace_test.go
  </files>
  <action>
Create pkg/metadata/lock_grace.go implementing grace period handling:

1. Define `GraceState` type:
   - `GraceStateNormal` - Normal operation, all lock operations allowed
   - `GraceStateActive` - Grace period active, only reclaims allowed

2. Define `GracePeriodManager` struct:
   - `mu sync.RWMutex` - Thread safety
   - `state GraceState` - Current state
   - `graceEnd time.Time` - When grace period expires
   - `duration time.Duration` - Configured grace duration
   - `expectedClients map[string]bool` - Clients expected to reclaim (from persisted locks)
   - `reclaimedClients map[string]bool` - Clients that have reclaimed
   - `timer *time.Timer` - Grace period timeout timer
   - `onGraceEnd func()` - Callback when grace ends (for cleanup)

3. Implement `NewGracePeriodManager(duration time.Duration, onGraceEnd func()) *GracePeriodManager`:
   - Initialize in Normal state
   - Store callback for grace end

4. Implement `EnterGracePeriod(expectedClients []string)`:
   - Set state to Active
   - Set graceEnd = now + duration
   - Store expected clients
   - Start timer for grace end
   - Called on server startup when persisted locks exist

5. Implement `ExitGracePeriod()`:
   - Set state to Normal
   - Cancel timer if running
   - Call onGraceEnd callback (releases unclaimed locks)
   - Called when: timer expires OR early exit triggered

6. Implement `IsOperationAllowed(op LockOperation) (bool, error)`:
   - LockOperation has: IsReclaim bool, IsTest bool, IsNew bool
   - During Normal: all operations allowed, return (true, nil)
   - During Active:
     - Reclaims: allowed (true, nil)
     - Tests: allowed (true, nil)
     - New locks: denied (false, ErrGracePeriod)

7. Implement `MarkReclaimed(clientID string)`:
   - Add clientID to reclaimedClients
   - Call checkEarlyExit()

8. Implement `checkEarlyExit()` (private):
   - If all expectedClients are in reclaimedClients, exit early
   - Log "Grace period ending early: all N clients reclaimed"

9. Implement `GetState() GraceState`:
   - Return current state (for metrics/logging)

10. Implement `GetRemainingTime() time.Duration`:
    - Return time until grace period ends (0 if Normal)

11. Implement `GetExpectedClients() []string`:
    - Return list of expected clients (for debugging)

12. Implement `GetReclaimedClients() []string`:
    - Return list of clients that have reclaimed

Create pkg/metadata/lock_grace_test.go:
- TestNewGracePeriodManager_StartsNormal
- TestEnterGracePeriod_BlocksNewLocks
- TestEnterGracePeriod_AllowsReclaims
- TestEnterGracePeriod_AllowsTests
- TestExitGracePeriod_AllowsAllOperations
- TestGracePeriod_ExpiresAfterDuration
- TestGracePeriod_EarlyExitWhenAllReclaimed
- TestGracePeriod_CallsOnGraceEndCallback
- TestGracePeriod_ThreadSafety
  </action>
  <verify>
```bash
go test -v ./pkg/metadata/... -run "TestGracePeriod"
go test -race ./pkg/metadata/... -run "TestGracePeriod"
```
  </verify>
  <done>
- GracePeriodManager implemented with Normal and Active states
- New locks blocked during grace period with ErrGracePeriod
- Reclaims and tests allowed during grace period
- Early exit when all expected clients reclaim
- Timer-based automatic exit after duration
- onGraceEnd callback invoked
- All tests pass including race detector
  </done>
</task>

<task type="auto">
  <name>Task 2: Connection tracker with adapter-controlled TTL</name>
  <files>
    pkg/metadata/lock_connection.go
    pkg/metadata/lock_connection_test.go
  </files>
  <action>
Create pkg/metadata/lock_connection.go implementing connection tracking:

1. Define `ClientRegistration` struct:
   - `ClientID string` - Unique client identifier
   - `AdapterType string` - Which adapter (e.g., "nfs", "smb")
   - `TTL time.Duration` - Time to keep locks after disconnect (0 = immediate release)
   - `RegisteredAt time.Time` - When client registered
   - `LastSeen time.Time` - Last activity timestamp
   - `RemoteAddr string` - Client IP address (for logging/metrics)
   - `LockCount int` - Number of locks held (for limits)

2. Define `ConnectionTrackerConfig` struct:
   - `MaxConnectionsPerAdapter map[string]int` - Per-adapter limits
   - `DefaultMaxConnections int` - Fallback limit (default: 10000)
   - `StaleCheckInterval time.Duration` - How often to check for stale clients (default: 30s)
   - `OnClientDisconnect func(clientID string)` - Callback for lock cleanup

3. Define `ConnectionTracker` struct:
   - `mu sync.RWMutex` - Thread safety
   - `clients map[string]*ClientRegistration` - ClientID -> registration
   - `config ConnectionTrackerConfig`
   - `disconnectTimers map[string]*time.Timer` - Pending disconnect timers (for TTL > 0)

4. Implement `NewConnectionTracker(config ConnectionTrackerConfig) *ConnectionTracker`

5. Implement `RegisterClient(clientID, adapterType, remoteAddr string, ttl time.Duration) error`:
   - Check connection limit for adapter
   - If limit exceeded, return ErrConnectionLimitReached (new error code)
   - Create registration with current timestamp
   - If client already registered, update LastSeen (idempotent)

6. Implement `UnregisterClient(clientID string)`:
   - Find client registration
   - If TTL == 0: immediately call OnClientDisconnect callback
   - If TTL > 0: schedule timer, after TTL call OnClientDisconnect
   - Store timer in disconnectTimers map
   - Remove from clients map

7. Implement `CancelDisconnect(clientID string)`:
   - If client reconnects before TTL expires, cancel the timer
   - Called when client re-registers

8. Implement `UpdateLastSeen(clientID string)`:
   - Update LastSeen timestamp
   - Used for keep-alive tracking

9. Implement `GetClient(clientID string) (*ClientRegistration, bool)`:
   - Return registration if exists

10. Implement `ListClients(adapterType string) []*ClientRegistration`:
    - Return all clients for adapter (empty string = all adapters)

11. Implement `GetClientCount(adapterType string) int`:
    - Return count for adapter (empty string = total)

12. Implement `IncrementLockCount(clientID string)`:
    - Increment client's LockCount

13. Implement `DecrementLockCount(clientID string)`:
    - Decrement client's LockCount

14. Implement `Close()`:
    - Cancel all pending disconnect timers
    - Clear all state

Create pkg/metadata/lock_connection_test.go:
- TestRegisterClient_Success
- TestRegisterClient_LimitExceeded
- TestRegisterClient_Idempotent
- TestUnregisterClient_ImmediateRelease_TTL0
- TestUnregisterClient_DeferredRelease_TTL_Positive
- TestCancelDisconnect_StopsTimer
- TestUpdateLastSeen
- TestListClients_FilterByAdapter
- TestGetClientCount
- TestConnectionTracker_ThreadSafety
  </action>
  <verify>
```bash
go test -v ./pkg/metadata/... -run "TestConnectionTracker|TestClientRegistration"
go test -race ./pkg/metadata/... -run "TestConnectionTracker"
```
  </verify>
  <done>
- ConnectionTracker manages per-adapter client connections
- Registration enforces per-adapter connection limits
- Unregister with TTL=0 immediately releases locks
- Unregister with TTL>0 defers lock release
- CancelDisconnect handles client reconnection
- Thread-safe under concurrent access
- All tests pass
  </done>
</task>

<task type="auto">
  <name>Task 3: Prometheus metrics for locks and connections</name>
  <files>
    pkg/metadata/lock_metrics.go
    pkg/metadata/lock_metrics_test.go
  </files>
  <action>
Create pkg/metadata/lock_metrics.go implementing Prometheus metrics:

1. Define `LockMetrics` struct containing all metric collectors:
```go
type LockMetrics struct {
    // Lock operation counters
    lockAcquireTotal    *prometheus.CounterVec   // labels: share, type, status
    lockReleaseTotal    *prometheus.CounterVec   // labels: share, reason

    // Lock state gauges
    lockActiveGauge     *prometheus.GaugeVec     // labels: share, type
    lockBlockedGauge    *prometheus.GaugeVec     // labels: share

    // Lock timing histograms
    lockBlockingDuration *prometheus.HistogramVec // labels: share
    lockHoldDuration     *prometheus.HistogramVec // labels: share, type

    // Connection metrics
    connectionActiveGauge *prometheus.GaugeVec   // labels: adapter
    connectionTotal       *prometheus.CounterVec // labels: adapter, event (connect/disconnect)

    // Grace period metrics
    gracePeriodActive     prometheus.Gauge
    gracePeriodRemaining  prometheus.Gauge        // seconds remaining
    reclaimTotal          *prometheus.CounterVec  // labels: status (success/failed)

    // Limit metrics
    lockLimitHits         *prometheus.CounterVec  // labels: limit_type (file/client/total)

    // Deadlock detection
    deadlockDetected      prometheus.Counter
}
```

2. Define metric options following Prometheus naming conventions:
   - Namespace: "dittofs"
   - Subsystem: "locks" or "connections"
   - Use snake_case names
   - Include Help strings

3. Implement `NewLockMetrics(registry prometheus.Registerer) *LockMetrics`:
   - Create all metric collectors
   - Register with provided registry (allows nil for testing)
   - Return initialized LockMetrics

4. Implement observation methods:
   - `ObserveLockAcquire(share string, lockType LockType, success bool)`
   - `ObserveLockRelease(share string, reason string)` // reasons: explicit, timeout, disconnect, grace_expired
   - `SetActiveLocks(share string, lockType LockType, count float64)`
   - `SetBlockedLocks(share string, count float64)`
   - `ObserveBlockingDuration(share string, duration time.Duration)`
   - `ObserveLockHoldDuration(share string, lockType LockType, duration time.Duration)`
   - `SetActiveConnections(adapter string, count float64)`
   - `ObserveConnection(adapter string, event string)` // events: connect, disconnect
   - `SetGracePeriodActive(active bool)`
   - `SetGracePeriodRemaining(seconds float64)`
   - `ObserveReclaim(success bool)`
   - `ObserveLockLimitHit(limitType string)` // limitTypes: file, client, total
   - `ObserveDeadlock()`

5. Implement `Describe(ch chan<- *prometheus.Desc)` and `Collect(ch chan<- prometheus.Metric)`:
   - Implement prometheus.Collector interface
   - Enables registration as a collector

6. Add label constants:
```go
const (
    LabelShare     = "share"
    LabelType      = "type"
    LabelStatus    = "status"
    LabelReason    = "reason"
    LabelAdapter   = "adapter"
    LabelEvent     = "event"
    LabelLimitType = "limit_type"
)
```

7. Add status/reason constants:
```go
const (
    StatusGranted  = "granted"
    StatusDenied   = "denied"
    StatusDeadlock = "deadlock"

    ReasonExplicit     = "explicit"
    ReasonTimeout      = "timeout"
    ReasonDisconnect   = "disconnect"
    ReasonGraceExpired = "grace_expired"
)
```

Create pkg/metadata/lock_metrics_test.go:
- TestNewLockMetrics_CreatesAllMetrics
- TestLockMetrics_ObserveLockAcquire_IncrementsCounter
- TestLockMetrics_ObserveBlockingDuration_RecordsHistogram
- TestLockMetrics_SetActiveLocks_UpdatesGauge
- TestLockMetrics_GracePeriodMetrics
- TestLockMetrics_NilRegistry_NoPanic (for disabled metrics)
  </action>
  <verify>
```bash
go test -v ./pkg/metadata/... -run "TestLockMetrics"
go build ./pkg/metadata/...
```
  </verify>
  <done>
- LockMetrics struct with all Prometheus collectors
- Proper namespace (dittofs) and subsystem (locks/connections)
- Lock acquire/release counters with useful labels
- Active locks and connections gauges
- Blocking duration histogram
- Grace period status exposed
- Deadlock detection counter
- All tests pass
  </done>
</task>

</tasks>

<verification>
```bash
# Run all tests for the metadata package
go test -v ./pkg/metadata/...

# Run with race detector
go test -race ./pkg/metadata/...

# Verify build
go build ./...

# Check for lint issues
go vet ./pkg/metadata/...
```
</verification>

<success_criteria>
1. Grace period blocks new locks, allows reclaims and tests
2. Grace period exits early when all clients reclaim
3. Connection tracker enforces per-adapter limits
4. Connection tracker supports immediate (TTL=0) and deferred (TTL>0) disconnect
5. Prometheus metrics expose lock operations, connections, and grace period
6. All new code has comprehensive test coverage
7. Race detector passes on all tests
</success_criteria>

<output>
After completion, create `.planning/phases/01-locking-infrastructure/01-03-SUMMARY.md`
</output>
