---
phase: 05-adapters-auxiliary
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - test/e2e/helpers/cli.go
  - test/e2e/context_test.go
autonomous: true

must_haves:
  truths:
    - "User can list all server contexts via CLI"
    - "User can add a new server context via login"
    - "User can remove a server context via CLI"
    - "User can switch between contexts via CLI"
    - "Context credentials don't leak between switches"
  artifacts:
    - path: "test/e2e/helpers/cli.go"
      provides: "Context management helper methods"
      contains: "func (r *CLIRunner) ListContexts"
    - path: "test/e2e/context_test.go"
      provides: "Multi-context E2E tests"
      contains: "TestContextManagement"
  key_links:
    - from: "test/e2e/context_test.go"
      to: "test/e2e/helpers/cli.go"
      via: "CLIRunner context methods"
      pattern: "runner\\.ListContexts|runner\\.UseContext|runner\\.DeleteContext"
---

<objective>
Implement E2E tests for multi-context server management in dittofsctl.

Purpose: Validates that users can manage multiple server connections with isolated credentials (CTX-01 through CTX-05).
Output: Context helper methods in cli.go and comprehensive context_test.go suite.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-adapters-auxiliary/05-CONTEXT.md
@.planning/phases/05-adapters-auxiliary/05-RESEARCH.md
@test/e2e/helpers/cli.go
@cmd/dittofsctl/commands/context/list.go
@cmd/dittofsctl/commands/context/use.go
@cmd/dittofsctl/commands/context/delete.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Context helper methods to CLIRunner</name>
  <files>test/e2e/helpers/cli.go</files>
  <action>
Add context management types and methods to cli.go following the established pattern.

1. Add ContextInfo type matching the CLI output:
```go
// ContextInfo represents context information from dittofsctl context list.
type ContextInfo struct {
    Name      string `json:"name"`
    Current   bool   `json:"current"`
    ServerURL string `json:"server_url"`
    Username  string `json:"username,omitempty"`
    LoggedIn  bool   `json:"logged_in"`
}
```

2. Add CLIRunner methods for context management:

```go
// ListContexts lists all saved server contexts via the CLI.
// Returns contexts with their names, server URLs, and current status.
func (r *CLIRunner) ListContexts() ([]*ContextInfo, error) {
    output, err := r.RunRaw("context", "list", "--output", "json")
    if err != nil {
        return nil, err
    }
    var contexts []*ContextInfo
    if err := ParseJSONResponse(output, &contexts); err != nil {
        return nil, err
    }
    return contexts, nil
}

// GetCurrentContext returns the name of the currently active context.
func (r *CLIRunner) GetCurrentContext() (string, error) {
    output, err := r.RunRaw("context", "current")
    if err != nil {
        return "", err
    }
    return strings.TrimSpace(string(output)), nil
}

// UseContext switches to the specified context.
func (r *CLIRunner) UseContext(name string) error {
    _, err := r.RunRaw("context", "use", name)
    return err
}

// DeleteContext removes a saved context.
func (r *CLIRunner) DeleteContext(name string) error {
    _, err := r.RunRaw("context", "delete", name)
    return err
}

// RenameContext renames a context.
func (r *CLIRunner) RenameContext(oldName, newName string) error {
    _, err := r.RunRaw("context", "rename", oldName, newName)
    return err
}
```

Note: Context commands use RunRaw because they don't use --server/--token flags (they manage the credentials store directly).

3. Add helper to get context by name:
```go
// GetContext retrieves a specific context by name.
func (r *CLIRunner) GetContext(name string) (*ContextInfo, error) {
    contexts, err := r.ListContexts()
    if err != nil {
        return nil, err
    }
    for _, ctx := range contexts {
        if ctx.Name == name {
            return ctx, nil
        }
    }
    return nil, fmt.Errorf("context not found: %s", name)
}
```
  </action>
  <verify>
Run `go build ./test/e2e/helpers/` to verify compilation. Run `go vet ./test/e2e/helpers/` for static analysis.
  </verify>
  <done>
ContextInfo type and all CLIRunner context methods compile successfully. Methods use RunRaw appropriately.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write multi-context E2E tests</name>
  <files>test/e2e/context_test.go</files>
  <action>
Create test/e2e/context_test.go with comprehensive context management tests covering requirements CTX-01 through CTX-05.

Test structure:
```go
//go:build e2e

package e2e

func TestContextManagement(t *testing.T) {
    // Important: Set XDG_CONFIG_HOME to isolate test credential storage
    // This prevents tests from affecting real user credentials
}
```

Subtests to implement:

1. **CTX-01 List server contexts**:
   - Start server
   - Login to create initial context
   - List contexts
   - Verify at least one context exists
   - Verify current context is marked

2. **CTX-02 Add new context via login**:
   - Start two servers (different ports)
   - Login to server 1 (creates context)
   - Login to server 2 (creates second context)
   - List contexts
   - Verify both contexts exist with correct server URLs

3. **CTX-03 Remove server context**:
   - Setup: Have two contexts
   - Delete one context
   - List contexts
   - Verify deleted context is gone
   - Verify other context still exists

4. **CTX-04 Switch active context**:
   - Setup: Have two contexts (ctx1, ctx2)
   - Verify current context is one of them
   - Switch to the other context
   - Verify current context changed
   - Verify API calls use correct server

5. **CTX-05 Credential isolation**:
   - Setup: server1 with user1, server2 with user2
   - Login to server1 as user1
   - Login to server2 as user2
   - Switch to server1 context
   - Make API call, verify it uses user1's permissions
   - Switch to server2 context
   - Make API call, verify it uses user2's permissions
   - Verify credentials didn't leak (user1 not accessible on server2)

Key implementation notes:
- Set XDG_CONFIG_HOME to t.TempDir() to isolate credential storage
- This prevents tests from modifying real user credentials
- Run tests sequentially - they share credential file state
- Clean up contexts at end of each test

Credential isolation setup:
```go
func setupIsolatedCredentials(t *testing.T) {
    t.Helper()
    tempConfig := t.TempDir()
    t.Setenv("XDG_CONFIG_HOME", tempConfig)
}
```
  </action>
  <verify>
Run `go test -tags=e2e -v ./test/e2e/ -run TestContextManagement -count=1` to verify tests pass.
  </verify>
  <done>
CTX-01 through CTX-05 requirements covered by tests. Tests use isolated credential storage. Test file has //go:build e2e tag.
  </done>
</task>

</tasks>

<verification>
1. `go build ./test/e2e/helpers/` compiles successfully
2. `go vet ./test/e2e/...` passes
3. `go test -tags=e2e -v ./test/e2e/ -run TestContextManagement` passes
4. Tests don't modify real user credentials (use XDG_CONFIG_HOME isolation)
5. Each CTX requirement (01-05) has at least one test covering it
</verification>

<success_criteria>
- ContextInfo type and CLIRunner context methods exist in cli.go
- context_test.go exists with TestContextManagement suite
- CTX-01 through CTX-05 requirements have test coverage
- Tests use credential isolation (XDG_CONFIG_HOME)
- Credential isolation test verifies no leakage between contexts
</success_criteria>

<output>
After completion, create `.planning/phases/05-adapters-auxiliary/05-03-SUMMARY.md`
</output>
