---
phase: 05-adapters-auxiliary
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - test/e2e/helpers/cli.go
  - test/e2e/backup_test.go
autonomous: true

must_haves:
  truths:
    - "Admin can backup control plane state to a file"
    - "Backup file contains all config data (users, groups, shares, permissions)"
    - "Backup round-trip preserves data integrity"
    - "Invalid backup file fails gracefully with clear error"
  artifacts:
    - path: "test/e2e/helpers/cli.go"
      provides: "Backup helper functions"
      contains: "RunDittofsBackup"
    - path: "test/e2e/backup_test.go"
      provides: "Backup/restore E2E tests"
      contains: "TestBackupRestore"
  key_links:
    - from: "test/e2e/backup_test.go"
      to: "test/e2e/helpers/cli.go"
      via: "RunDittofsBackup helper"
      pattern: "helpers\\.RunDittofsBackup|helpers\\.RunDittofs"
---

<objective>
Implement E2E tests for control plane backup and restore operations.

Purpose: Validates that control plane state can be backed up and data round-trips correctly (BAK-01 through BAK-04).
Output: Backup helper in cli.go and comprehensive backup_test.go suite.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-adapters-auxiliary/05-CONTEXT.md
@.planning/phases/05-adapters-auxiliary/05-RESEARCH.md
@test/e2e/helpers/cli.go
@test/e2e/helpers/server.go
@cmd/dittofs/commands/backup/controlplane.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add backup helper functions</name>
  <files>test/e2e/helpers/cli.go</files>
  <action>
Add backup-related helper functions to cli.go.

The backup command runs via `dittofs` (server binary), not `dittofsctl` (client).
Use the existing `RunDittofs` helper as the base.

Add dedicated backup helper:
```go
// RunDittofsBackup runs the dittofs backup controlplane command.
// outputPath: where to write the backup file
// configPath: path to server config (needed to locate the database)
// format: backup format - "native", "native-cli", or "json"
func RunDittofsBackup(t *testing.T, outputPath, configPath, format string) error {
    args := []string{"backup", "controlplane",
        "--output", outputPath,
        "--config", configPath,
    }
    if format != "" {
        args = append(args, "--format", format)
    }
    _, err := RunDittofs(t, args...)
    return err
}
```

Also add a helper to verify backup file contents (for JSON format):
```go
// ParseBackupFile reads and parses a JSON backup file.
// Returns the parsed ControlPlaneBackup structure for verification.
func ParseBackupFile(t *testing.T, path string) (*ControlPlaneBackup, error) {
    t.Helper()
    data, err := os.ReadFile(path)
    if err != nil {
        return nil, err
    }
    var backup ControlPlaneBackup
    if err := json.Unmarshal(data, &backup); err != nil {
        return nil, err
    }
    return &backup, nil
}

// ControlPlaneBackup matches the structure from backup/controlplane.go
type ControlPlaneBackup struct {
    Timestamp      string              `json:"timestamp"`
    Version        string              `json:"version"`
    DatabaseType   string              `json:"database_type"`
    Users          []BackupUser        `json:"users"`
    Groups         []BackupGroup       `json:"groups"`
    Shares         []json.RawMessage   `json:"shares"`          // Raw to avoid deep model dependency
    MetadataStores []json.RawMessage   `json:"metadata_stores"`
    PayloadStores  []json.RawMessage   `json:"payload_stores"`
    Adapters       []json.RawMessage   `json:"adapters"`
    Settings       []json.RawMessage   `json:"settings"`
}

type BackupUser struct {
    ID       string   `json:"id"`
    Username string   `json:"username"`
    Role     string   `json:"role"`
    Enabled  bool     `json:"enabled"`
    Groups   []string `json:"groups,omitempty"`
}

type BackupGroup struct {
    ID          string  `json:"id"`
    Name        string  `json:"name"`
    GID         *uint32 `json:"gid,omitempty"`
    Description string  `json:"description,omitempty"`
}
```
  </action>
  <verify>
Run `go build ./test/e2e/helpers/` to verify compilation.
  </verify>
  <done>
RunDittofsBackup, ParseBackupFile, and backup types compile successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write backup/restore E2E tests</name>
  <files>test/e2e/backup_test.go</files>
  <action>
Create test/e2e/backup_test.go with comprehensive backup/restore tests covering requirements BAK-01 through BAK-04.

Test structure:
```go
//go:build e2e

package e2e

func TestBackupRestore(t *testing.T) {
    // Sequential tests - each needs server control
}
```

Subtests to implement:

1. **BAK-01 Backup control plane state** (native format):
   - Start server
   - Create test data (user, group, share)
   - Run backup with native format
   - Verify backup file exists
   - Verify file size > 0

2. **BAK-01 Backup as JSON**:
   - Start server
   - Create test data (user, group)
   - Run backup with --format json
   - Parse backup file
   - Verify backup contains test user and group

3. **BAK-03 Round-trip data integrity**:
   - Start server 1
   - Create test data: user "backuptest" with group "backupgroup", share "/backupshare"
   - Run backup
   - Stop server 1
   - Create fresh server config pointing to new empty database
   - Start server 2 with fresh config
   - (Note: restore not implemented per RESEARCH.md - test backup content verification instead)
   - For now: Verify backup file contains all created resources

4. **BAK-04 Invalid backup file handling**:
   - Create a corrupted/invalid backup file
   - Attempt to use it (or verify error during creation with invalid config)
   - Verify clear error message

Note: Per RESEARCH.md, restore command may not be implemented yet. Tests focus on backup creation and content verification. The round-trip test verifies backup content includes all data; actual restore verification may be deferred if restore isn't implemented.

Key implementation notes:
- Use t.TempDir() for backup output files
- Use JSON format for content verification (easier to parse)
- Get configPath from ServerProcess helper
- Run tests sequentially - each needs server lifecycle control
  </action>
  <verify>
Run `go test -tags=e2e -v ./test/e2e/ -run TestBackupRestore -count=1` to verify tests pass.
  </verify>
  <done>
BAK-01 through BAK-04 requirements covered by tests. Tests verify backup creation and content. Test file has //go:build e2e tag.
  </done>
</task>

</tasks>

<verification>
1. `go build ./test/e2e/helpers/` compiles successfully
2. `go vet ./test/e2e/...` passes
3. `go test -tags=e2e -v ./test/e2e/ -run TestBackupRestore` passes
4. Backup file created contains expected data (users, groups)
</verification>

<success_criteria>
- RunDittofsBackup and ParseBackupFile helpers exist in cli.go
- backup_test.go exists with TestBackupRestore suite
- BAK-01 through BAK-04 requirements have test coverage
- Tests create valid backup files with expected content
</success_criteria>

<output>
After completion, create `.planning/phases/05-adapters-auxiliary/05-02-SUMMARY.md`
</output>
