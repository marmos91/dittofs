---
phase: 13-nfsv4-acls
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/identity/mapper.go
  - pkg/identity/mapper_test.go
  - pkg/identity/convention.go
  - pkg/identity/convention_test.go
  - pkg/identity/table.go
  - pkg/identity/table_test.go
  - pkg/identity/cache.go
  - pkg/identity/cache_test.go
  - pkg/identity/static.go
  - pkg/identity/static_test.go
  - pkg/identity/CLAUDE.md
  - pkg/auth/kerberos/identity.go
autonomous: true

must_haves:
  truths:
    - "ConventionMapper resolves user@REALM to control plane user when domain matches"
    - "Case-insensitive domain matching works (alice@EXAMPLE.COM = alice@example.com)"
    - "Unknown principals return Found=false but no error"
    - "Numeric UID@domain accepted for AUTH_SYS interop"
    - "CachedMapper returns cached results within TTL"
    - "CachedMapper queries inner mapper after TTL expiry"
    - "StaticMapper from Phase 12 works unchanged through new package"
    - "TableMapper resolves explicit mappings from a MappingStore"
    - "Group membership resolved via GroupResolver interface"
  artifacts:
    - path: "pkg/identity/mapper.go"
      provides: "IdentityMapper interface, ResolvedIdentity type, GroupResolver interface"
      exports: ["IdentityMapper", "ResolvedIdentity", "GroupResolver"]
    - path: "pkg/identity/convention.go"
      provides: "Convention-based mapper (user@REALM -> control plane user)"
      exports: ["ConventionMapper", "NewConventionMapper"]
    - path: "pkg/identity/table.go"
      provides: "Explicit mapping table mapper backed by MappingStore"
      exports: ["TableMapper", "NewTableMapper", "MappingStore"]
    - path: "pkg/identity/cache.go"
      provides: "TTL-based caching wrapper for any IdentityMapper"
      exports: ["CachedMapper", "NewCachedMapper"]
    - path: "pkg/identity/static.go"
      provides: "StaticMapper moved from pkg/auth/kerberos (backward compat)"
      exports: ["StaticMapper", "NewStaticMapper"]
  key_links:
    - from: "pkg/identity/cache.go"
      to: "pkg/identity/mapper.go"
      via: "wraps any IdentityMapper implementation"
      pattern: "IdentityMapper"
    - from: "pkg/identity/convention.go"
      to: "pkg/identity/mapper.go"
      via: "implements IdentityMapper interface"
      pattern: "func.*ConventionMapper.*Resolve"
    - from: "pkg/auth/kerberos/identity.go"
      to: "pkg/identity/static.go"
      via: "backward compatibility delegation"
      pattern: "identity\\.StaticMapper|identity\\.NewStaticMapper"
---

<objective>
Create the identity mapper package (`pkg/identity/`) with pluggable mappers for resolving NFSv4 user@domain principals to control plane identities. Refactor Phase 12 StaticMapper into this new package with backward compatibility.

Purpose: Identity mapping is required for ACL evaluation (resolving ACE principals), NFSv4 GETATTR owner encoding, and Kerberos principal mapping. A single pluggable interface serves all three use cases.
Output: Complete `pkg/identity/` package with ConventionMapper, TableMapper, CachedMapper, and migrated StaticMapper.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-nfsv4-acls/13-CONTEXT.md
@.planning/phases/13-nfsv4-acls/13-RESEARCH.md
@pkg/auth/kerberos/identity.go
@pkg/metadata/authentication.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Identity Mapper Interface, ConventionMapper, and StaticMapper Migration</name>
  <files>
    pkg/identity/mapper.go
    pkg/identity/mapper_test.go
    pkg/identity/convention.go
    pkg/identity/convention_test.go
    pkg/identity/static.go
    pkg/identity/static_test.go
    pkg/auth/kerberos/identity.go
  </files>
  <action>
**mapper.go** - Core interface:
- `IdentityMapper` interface with `Resolve(ctx context.Context, principal string) (*ResolvedIdentity, error)`. Takes full principal string (e.g., "alice@EXAMPLE.COM" or "OWNER@").
- `ResolvedIdentity` struct: Username (string), UID (uint32), GID (uint32), GIDs ([]uint32), Domain (string), Found (bool). Found=false means principal could not be resolved (not an error -- unknown principals are stored as-is in ACEs per locked decision).
- `GroupResolver` interface with `GetGroupMembers(ctx context.Context, groupName string) ([]string, error)` and `IsGroupMember(ctx context.Context, username string, groupName string) (bool, error)`. Used for group@domain ACE evaluation.
- `ParsePrincipal(principal string) (name, domain string)` helper: splits "user@domain" into parts. If no "@", returns (principal, ""). Handles special identifiers (OWNER@, GROUP@, EVERYONE@) by returning them as-is with empty domain.
- `NobodyIdentity()` helper: returns ResolvedIdentity with UID=65534, GID=65534, Username="nobody", Found=true.

**convention.go** - ConventionMapper:
- `ConventionMapper` struct with: configuredRealm (string), userLookup (func to query control plane user by username). The user lookup is a callback `func(ctx context.Context, username string) (*ResolvedIdentity, error)` to avoid importing controlplane package.
- `NewConventionMapper(realm string, userLookup func(ctx, username) (*ResolvedIdentity, error)) *ConventionMapper`
- `Resolve(ctx, principal)`:
  1. Parse principal into name@domain
  2. If domain is empty or doesn't match configuredRealm (case-insensitive via strings.EqualFold), return Found=false
  3. If name is numeric (strconv.Atoi succeeds), return ResolvedIdentity with UID=parsed int, Found=true, Username=name (AUTH_SYS interop per locked decision)
  4. Call userLookup(ctx, name) to resolve from control plane
  5. If not found, return Found=false
  6. Return the resolved identity

**static.go** - StaticMapper migrated from pkg/auth/kerberos:
- Move the StaticMapper code into `pkg/identity/` with the SAME behavior as the existing `pkg/auth/kerberos/StaticMapper`
- `StaticMapper` struct with staticMap, defaultUID, defaultGID
- `NewStaticMapper(cfg *StaticMapperConfig)` where `StaticMapperConfig` contains StaticMap (map[string]StaticIdentity), DefaultUID, DefaultGID. StaticIdentity has UID, GID, GIDs fields (replicate from config package to avoid circular import).
- Implements `IdentityMapper` interface via `Resolve(ctx, principal)`:
  1. Look up principal in staticMap
  2. If found, return ResolvedIdentity with mapped UID/GID/GIDs, Found=true
  3. If not found, return ResolvedIdentity with defaultUID/defaultGID, Found=true (static mapper always "finds" -- falls back to defaults)
- Also implement the old `MapPrincipal(principal, realm string) (*metadata.Identity, error)` method for backward compatibility with Kerberos code.

**pkg/auth/kerberos/identity.go** - Update to delegate to pkg/identity:
- Keep the existing `IdentityMapper` interface in kerberos package for backward compatibility
- Change `StaticMapper` to embed `*identity.StaticMapper` from the new package
- `NewStaticMapper(cfg *config.IdentityMappingConfig)` creates an `identity.StaticMapper` internally, converting the config
- `MapPrincipal(principal, realm)` delegates to the embedded mapper's `MapPrincipal`
- All existing callers of kerberos.StaticMapper continue to work without changes
- Add comment: "Deprecated: Use pkg/identity.StaticMapper directly for new code"

Tests:
- convention_test.go: Matching realm resolves, non-matching realm returns Found=false, case-insensitive domain, numeric UID resolution, empty domain returns Found=false, user lookup failure propagates error
- static_test.go: Known principal resolved, unknown principal gets defaults, JSON round-trip of StaticIdentity
- mapper_test.go: ParsePrincipal with various formats, NobodyIdentity values
  </action>
  <verify>
cd /Users/marmos91/Projects/dittofs && go test -race -v ./pkg/identity/... | tail -20
go test -race -v ./pkg/auth/kerberos/... | tail -20
go vet ./pkg/identity/... ./pkg/auth/kerberos/...
  </verify>
  <done>
IdentityMapper interface defined. ConventionMapper resolves user@REALM with case-insensitive domain matching and numeric UID support. StaticMapper migrated from pkg/auth/kerberos with backward compatibility wrapper. All tests pass including existing Kerberos tests.
  </done>
</task>

<task type="auto">
  <name>Task 2: TableMapper, CachedMapper, and Package Documentation</name>
  <files>
    pkg/identity/table.go
    pkg/identity/table_test.go
    pkg/identity/cache.go
    pkg/identity/cache_test.go
    pkg/identity/CLAUDE.md
  </files>
  <action>
**table.go** - TableMapper with explicit mapping store:
- `MappingStore` interface:
  - `GetMapping(ctx context.Context, principal string) (*IdentityMapping, error)` - lookup single mapping
  - `ListMappings(ctx context.Context) ([]*IdentityMapping, error)` - list all
  - `CreateMapping(ctx context.Context, mapping *IdentityMapping) error` - create new
  - `DeleteMapping(ctx context.Context, principal string) error` - delete by principal
- `IdentityMapping` struct: Principal (string), Username (string), CreatedAt (time.Time), UpdatedAt (time.Time).
- `TableMapper` struct with store MappingStore and a userLookup callback (same pattern as ConventionMapper).
- `NewTableMapper(store MappingStore, userLookup func(ctx, username) (*ResolvedIdentity, error)) *TableMapper`
- `Resolve(ctx, principal)`:
  1. Look up principal in MappingStore
  2. If not found (store returns nil/not-found error), return Found=false
  3. If found, call userLookup(ctx, mapping.Username) to get full identity
  4. Return the resolved identity

**cache.go** - TTL-based caching wrapper:
- `CachedMapper` struct with inner IdentityMapper, cache map[string]*cacheEntry, mu sync.RWMutex, ttl time.Duration.
- `cacheEntry` struct: result *ResolvedIdentity, err error, cachedAt time.Time.
- `NewCachedMapper(inner IdentityMapper, ttl time.Duration) *CachedMapper`. Default TTL: 5 minutes (per research recommendation).
- `Resolve(ctx, principal)`:
  1. RLock, check cache for principal
  2. If found and not expired (time.Since(entry.cachedAt) < ttl), return cached
  3. RUnlock, Lock (exclusive)
  4. Double-check (another goroutine may have populated)
  5. Call inner.Resolve(ctx, principal)
  6. Store result in cache (even errors, to avoid thundering herd)
  7. Unlock, return result
- `Invalidate(principal string)` - Remove single entry
- `InvalidateAll()` - Clear entire cache
- `Stats() CacheStats` - Return CacheStats{Hits, Misses, Size int64}

**CLAUDE.md** for pkg/identity/:
- Package purpose: Pluggable identity resolution for NFSv4 principals and Kerberos authentication
- IdentityMapper interface contract: ctx-aware, returns ResolvedIdentity with Found flag
- MapperChain pattern: TableMapper checked first (explicit overrides), then ConventionMapper (convention-based)
- CachedMapper wrapping: Always wrap the final mapper with CachedMapper for production
- GroupResolver usage: For ACL evaluation of group@domain principals
- MappingStore contract: Implementations provided by controlplane (Plan 05)
- Static mapper: For backward compat with Kerberos, also useful for testing
- Common gotchas: Found=false is not an error; cache stores errors too; domain matching is case-insensitive

Tests:
- table_test.go: Use mock MappingStore. Found mapping resolves to identity, missing mapping returns Found=false, store error propagated, userLookup failure propagated
- cache_test.go: First call is cache miss (calls inner), second call is cache hit (inner not called), expired entry triggers refresh, Invalidate removes entry, InvalidateAll clears all, concurrent access safety (parallel goroutines), Stats returns correct counts, error caching prevents thundering herd
  </action>
  <verify>
cd /Users/marmos91/Projects/dittofs && go test -race -v ./pkg/identity/... | tail -20
go vet ./pkg/identity/...
  </verify>
  <done>
TableMapper resolves explicit mappings from MappingStore. CachedMapper wraps any IdentityMapper with TTL-based caching, double-check locking, invalidation, and stats. CLAUDE.md documents the package. All tests pass with -race including concurrent cache access tests.
  </done>
</task>

</tasks>

<verification>
- `go test -race -count=1 ./pkg/identity/...` -- all tests pass
- `go test -race -count=1 ./pkg/auth/kerberos/...` -- existing Kerberos tests still pass (backward compat)
- `go vet ./pkg/identity/...` -- no issues
- `go build ./pkg/identity/` -- package compiles independently
- pkg/identity/ has NO imports from `internal/protocol/` or `pkg/controlplane/` (no circular deps)
- pkg/auth/kerberos/identity.go still exports same interface (no breaking changes)
</verification>

<success_criteria>
- IdentityMapper interface defined with Resolve(ctx, principal) method
- ConventionMapper resolves user@REALM with case-insensitive matching and numeric UID support
- TableMapper resolves explicit mappings from MappingStore interface
- CachedMapper provides TTL-based caching with invalidation and stats
- StaticMapper migrated from pkg/auth/kerberos with backward compatibility
- GroupResolver interface defined for group membership queries
- All tests pass with -race, existing Kerberos tests unbroken
</success_criteria>

<output>
After completion, create `.planning/phases/13-nfsv4-acls/13-02-SUMMARY.md`
</output>
