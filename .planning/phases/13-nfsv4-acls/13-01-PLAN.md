---
phase: 13-nfsv4-acls
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/metadata/acl/types.go
  - pkg/metadata/acl/types_test.go
  - pkg/metadata/acl/evaluate.go
  - pkg/metadata/acl/evaluate_test.go
  - pkg/metadata/acl/validate.go
  - pkg/metadata/acl/validate_test.go
  - pkg/metadata/acl/mode.go
  - pkg/metadata/acl/mode_test.go
  - pkg/metadata/acl/inherit.go
  - pkg/metadata/acl/inherit_test.go
  - pkg/metadata/acl/CLAUDE.md
autonomous: true

must_haves:
  truths:
    - "ACL evaluation correctly allows access when ALLOW ACEs match requested permissions"
    - "ACL evaluation correctly denies access when DENY ACEs precede ALLOW ACEs"
    - "INHERIT_ONLY ACEs are skipped during evaluation but inherited by children"
    - "OWNER@/GROUP@/EVERYONE@ resolve dynamically at evaluation time"
    - "Canonical ordering validation rejects mis-ordered ACLs"
    - "chmod adjusts only OWNER@/GROUP@/EVERYONE@ ACEs, preserves other ACEs"
    - "File inheritance produces ACEs without inheritance flags"
    - "Directory inheritance preserves propagation flags unless NO_PROPAGATE"
  artifacts:
    - path: "pkg/metadata/acl/types.go"
      provides: "ACE, ACL types, all constants (4 ACE types, 6 flags, 16 mask bits, 3 special identifiers)"
      contains: "ACE4_ACCESS_ALLOWED_ACE_TYPE"
    - path: "pkg/metadata/acl/evaluate.go"
      provides: "ACL evaluation engine with process-first-match algorithm"
      exports: ["Evaluate"]
    - path: "pkg/metadata/acl/validate.go"
      provides: "Canonical ordering validation and 128 ACE limit"
      exports: ["ValidateACL"]
    - path: "pkg/metadata/acl/mode.go"
      provides: "ACL to mode bits derivation and chmod ACL adjustment"
      exports: ["DeriveMode", "AdjustACLForMode"]
    - path: "pkg/metadata/acl/inherit.go"
      provides: "ACL inheritance computation for new files and directories"
      exports: ["ComputeInheritedACL"]
  key_links:
    - from: "pkg/metadata/acl/evaluate.go"
      to: "pkg/metadata/acl/types.go"
      via: "ACE type constants and special identifiers"
      pattern: "ACE4_ACCESS_ALLOWED_ACE_TYPE|ACE4_INHERIT_ONLY_ACE|SpecialOwner"
    - from: "pkg/metadata/acl/mode.go"
      to: "pkg/metadata/acl/types.go"
      via: "mask bit constants for OWNER@/GROUP@/EVERYONE@ adjustment"
      pattern: "ACE4_READ_DATA|ACE4_WRITE_DATA|ACE4_EXECUTE"
---

<objective>
Create the pure ACL package (`pkg/metadata/acl/`) implementing RFC 7530 Section 6 ACL types, evaluation engine, canonical ordering validation, mode-ACL synchronization, and inheritance computation.

Purpose: This is the foundation package for all ACL functionality. It is protocol-agnostic (no NFS/SMB/XDR dependencies) and fully unit-testable in isolation.
Output: Complete `pkg/metadata/acl/` package with comprehensive tests.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-nfsv4-acls/13-CONTEXT.md
@.planning/phases/13-nfsv4-acls/13-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: ACL Types, Evaluation Engine, and Validation</name>
  <files>
    pkg/metadata/acl/types.go
    pkg/metadata/acl/types_test.go
    pkg/metadata/acl/evaluate.go
    pkg/metadata/acl/evaluate_test.go
    pkg/metadata/acl/validate.go
    pkg/metadata/acl/validate_test.go
  </files>
  <action>
Create `pkg/metadata/acl/` package with three files:

**types.go:**
- ACE struct: Type (uint32), Flag (uint32), AccessMask (uint32), Who (string). JSON tags for serialization.
- ACL struct: ACEs []ACE with `json:"aces"` tag.
- All four ACE type constants: ACE4_ACCESS_ALLOWED_ACE_TYPE (0x0), ACE4_ACCESS_DENIED_ACE_TYPE (0x1), ACE4_SYSTEM_AUDIT_ACE_TYPE (0x2), ACE4_SYSTEM_ALARM_ACE_TYPE (0x3).
- All six ACE flag constants: FILE_INHERIT (0x01), DIRECTORY_INHERIT (0x02), NO_PROPAGATE_INHERIT (0x04), INHERIT_ONLY (0x08), SUCCESSFUL_ACCESS (0x10), FAILED_ACCESS (0x20), INHERITED_ACE (0x80).
- All 16 access mask bits per RFC 7530 Section 6.2.1: READ_DATA/LIST_DIRECTORY (0x01), WRITE_DATA/ADD_FILE (0x02), APPEND_DATA/ADD_SUBDIRECTORY (0x04), READ_NAMED_ATTRS (0x08), WRITE_NAMED_ATTRS (0x10), EXECUTE (0x20), DELETE_CHILD (0x40), READ_ATTRIBUTES (0x80), WRITE_ATTRIBUTES (0x100), WRITE_RETENTION (0x200), WRITE_RETENTION_HOLD (0x400), DELETE (0x10000), READ_ACL (0x20000), WRITE_ACL (0x40000), WRITE_OWNER (0x80000), SYNCHRONIZE (0x100000).
- ACL4_SUPPORT constants: ALLOW_ACL (0x01), DENY_ACL (0x02), AUDIT_ACL (0x04), ALARM_ACL (0x08). FullACLSupport = all four OR'd.
- FATTR4 bit numbers: FATTR4_ACL = 12, FATTR4_ACLSUPPORT = 13.
- Special identifiers: SpecialOwner = "OWNER@", SpecialGroup = "GROUP@", SpecialEveryone = "EVERYONE@".
- MaxACECount = 128.
- Helper: IsSpecialWho(who string) bool.
- Helper: ACE.IsInheritOnly() bool, ACE.IsInherited() bool.

**evaluate.go:**
- `EvaluateContext` struct: Who (string), UID (uint32), GID (uint32), GIDs ([]uint32), FileOwnerUID (uint32), FileOwnerGID (uint32). This carries the requestor's identity and the file's owner/group for dynamic OWNER@/GROUP@ resolution.
- `Evaluate(acl *ACL, evalCtx *EvaluateContext, requestedMask uint32) bool` - The core evaluation function per RFC 7530 Section 6.2.1:
  1. Process ACEs sequentially
  2. Skip ACEs with INHERIT_ONLY flag
  3. For each ACE, check if it matches the requestor via `aceMatchesWho()`
  4. ALLOW ACEs: set allowed bits that aren't yet decided (not in allowedBits or deniedBits)
  5. DENY ACEs: set denied bits that aren't yet decided
  6. AUDIT/ALARM ACEs: skip (store-only per locked decision)
  7. Early termination when all requested bits are decided
  8. Return true only if ALL requested bits are in allowedBits
- `aceMatchesWho(ace *ACE, evalCtx *EvaluateContext) bool`:
  - "OWNER@": matches when evalCtx.UID == evalCtx.FileOwnerUID
  - "GROUP@": matches when evalCtx.GID == evalCtx.FileOwnerGID OR evalCtx.FileOwnerGID is in evalCtx.GIDs
  - "EVERYONE@": always matches
  - Otherwise: matches when ace.Who == evalCtx.Who (exact string match for named principals)

**validate.go:**
- `ValidateACL(acl *ACL) error` - Validates an ACL:
  1. Check ACE count <= MaxACECount (128). Return descriptive error if exceeded.
  2. Validate canonical ordering (strict Windows canonical order per locked decision):
     - Bucket 1: Explicit DENY (no INHERITED_ACE flag, type == DENIED)
     - Bucket 2: Explicit ALLOW (no INHERITED_ACE flag, type == ALLOWED)
     - Bucket 3: Inherited DENY (INHERITED_ACE flag, type == DENIED)
     - Bucket 4: Inherited ALLOW (INHERITED_ACE flag, type == ALLOWED)
     - AUDIT/ALARM ACEs can appear anywhere (they don't affect access decisions)
     - If any ACE is in a lower bucket than the previous non-AUDIT/ALARM ACE, return error
  3. Validate each ACE has a valid type (0-3)
  4. Validate Who field is non-empty
- `ValidateACE(ace *ACE) error` - Validates individual ACE fields

Tests should cover:
- evaluate_test.go: ALLOW-only, DENY-before-ALLOW, INHERIT_ONLY skipping, OWNER@/GROUP@/EVERYONE@ dynamic resolution, empty ACL denies all, multiple mask bits, early termination, AUDIT/ALARM skipped, group membership via GIDs
- validate_test.go: Valid canonical ordering, out-of-order rejection, 128 ACE limit, empty ACL valid, AUDIT/ALARM placement flexibility, invalid ACE type, empty Who
- types_test.go: JSON round-trip serialization of ACL/ACE, IsSpecialWho helper, helper methods
  </action>
  <verify>
cd /Users/marmos91/Projects/dittofs && go test -race -v ./pkg/metadata/acl/... | tail -20
go vet ./pkg/metadata/acl/...
  </verify>
  <done>
All ACE types, flag constants, and mask bit constants defined per RFC 7530 Section 6.2.1. Evaluation engine correctly implements process-first-match with INHERIT_ONLY skipping and dynamic OWNER@/GROUP@/EVERYONE@ resolution. Validation enforces strict canonical ordering and 128 ACE limit. All tests pass with -race.
  </done>
</task>

<task type="auto">
  <name>Task 2: Mode-ACL Synchronization and Inheritance</name>
  <files>
    pkg/metadata/acl/mode.go
    pkg/metadata/acl/mode_test.go
    pkg/metadata/acl/inherit.go
    pkg/metadata/acl/inherit_test.go
    pkg/metadata/acl/CLAUDE.md
  </files>
  <action>
**mode.go** - ACL to/from Unix mode bits per RFC 7530 Section 6.4.1:
- `DeriveMode(acl *ACL) uint32` - Derive Unix mode bits from ACL for display. Scans OWNER@, GROUP@, EVERYONE@ ACEs and maps their ALLOW masks to rwx bits:
  - READ_DATA -> r (0x4)
  - WRITE_DATA|APPEND_DATA -> w (0x2)
  - EXECUTE -> x (0x1)
  - Owner bits from OWNER@ ACEs, group bits from GROUP@ ACEs, other bits from EVERYONE@ ACEs
  - Returns mode with owner, group, other triplets composed
- `AdjustACLForMode(acl *ACL, newMode uint32) *ACL` - Adjust ACL when mode bits change (chmod). Per RFC 7530 Section 6.4.1:
  - Deep copy the ACL
  - For each OWNER@/GROUP@/EVERYONE@ ACE that is ALLOW type:
    - Recompute the mask from the corresponding mode triplet
    - Owner: newMode>>6 & 0x7, Group: newMode>>3 & 0x7, Other: newMode & 0x7
    - Set ACE4_READ_DATA if r, ACE4_WRITE_DATA|ACE4_APPEND_DATA if w, ACE4_EXECUTE if x
    - Preserve non-rwx bits (READ_ACL, WRITE_ACL, DELETE, etc.) that were already in the mask
  - For DENY ACEs of OWNER@/GROUP@/EVERYONE@: adjust to deny bits NOT in the new mode
  - All other ACEs (explicit user/group ACEs) preserved unchanged
  - Return the new ACL

**inherit.go** - ACL inheritance per RFC 7530 Section 6.4.3:
- `ComputeInheritedACL(parentACL *ACL, isDirectory bool) *ACL`:
  - If parentACL is nil, return nil (no inheritance)
  - For each ACE in parentACL:
    - For directories:
      - If DIRECTORY_INHERIT flag set, include the ACE
      - Copy the ACE, add INHERITED_ACE flag
      - If NO_PROPAGATE_INHERIT set: clear all inheritance flags (FILE_INHERIT, DIRECTORY_INHERIT, NO_PROPAGATE_INHERIT, INHERIT_ONLY)
      - If INHERIT_ONLY was set on parent ACE and it has DIRECTORY_INHERIT: the inherited ACE should NOT have INHERIT_ONLY (it now applies to the directory itself)
    - For files:
      - If FILE_INHERIT flag set, include the ACE
      - Copy the ACE, add INHERITED_ACE flag
      - Clear ALL inheritance flags (FILE_INHERIT, DIRECTORY_INHERIT, NO_PROPAGATE_INHERIT, INHERIT_ONLY) since files don't propagate further
  - If no ACEs inherited, return nil
  - Return new ACL with inherited ACEs
- `PropagateACL(parentACL *ACL, existingACL *ACL, isDirectory bool) *ACL` - For recursive propagation:
  - Compute inherited ACEs from parentACL
  - If existingACL is nil, return just inherited
  - Otherwise: keep explicit ACEs from existingACL (those WITHOUT INHERITED_ACE flag), replace inherited ACEs with newly computed ones
  - Maintain canonical ordering in result

**CLAUDE.md** for the acl package:
- Package purpose and RFC reference
- Evaluation algorithm summary (process-first-match, INHERIT_ONLY skip, dynamic OWNER@/GROUP@)
- Canonical ordering rules
- nil ACL vs empty ACL semantics
- Mode sync behavior (only OWNER@/GROUP@/EVERYONE@ adjusted)
- Common gotchas

Tests should cover:
- mode_test.go: DeriveMode with various OWNER@/GROUP@/EVERYONE@ combinations, AdjustACLForMode preserving explicit user ACEs, AdjustACLForMode with mode 755/644/000/777, round-trip (set mode -> derive mode matches)
- inherit_test.go: FILE_INHERIT on parent produces ACE on child file, DIRECTORY_INHERIT on parent produces ACE on child dir, NO_PROPAGATE stops propagation, INHERIT_ONLY not applied to parent but inherited by child, nil parent returns nil, mixed inherit flags, PropagateACL replaces inherited but keeps explicit
  </action>
  <verify>
cd /Users/marmos91/Projects/dittofs && go test -race -v ./pkg/metadata/acl/... | tail -20
go vet ./pkg/metadata/acl/...
  </verify>
  <done>
DeriveMode correctly extracts rwx bits from OWNER@/GROUP@/EVERYONE@ ACEs. AdjustACLForMode modifies only special identifier ACEs and preserves all explicit user/group ACEs. ComputeInheritedACL correctly computes file and directory inheritance with all four inheritance flags. PropagateACL replaces inherited ACEs while preserving explicit ACEs. All tests pass with -race.
  </done>
</task>

</tasks>

<verification>
- `go test -race -count=1 ./pkg/metadata/acl/...` -- all tests pass
- `go vet ./pkg/metadata/acl/...` -- no issues
- `go build ./pkg/metadata/acl/` -- package compiles independently
- ACL package has NO imports from `internal/protocol/` (protocol-agnostic)
- ACL package has NO imports from `pkg/metadata` (no circular dependency)
</verification>

<success_criteria>
- pkg/metadata/acl/ package exists with types, evaluate, validate, mode, inherit files
- All 4 ACE types, 7 flag constants, 16 mask bits, 3 special identifiers defined
- Evaluation engine implements RFC 7530 process-first-match correctly
- Canonical ordering validation rejects mis-ordered ACLs
- Mode derivation and chmod adjustment work per RFC 7530 Section 6.4.1
- Inheritance computation handles all 4 inheritance flags
- All tests pass with -race
</success_criteria>

<output>
After completion, create `.planning/phases/13-nfsv4-acls/13-01-SUMMARY.md`
</output>
