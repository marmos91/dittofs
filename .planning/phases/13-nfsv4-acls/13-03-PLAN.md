---
phase: 13-nfsv4-acls
plan: 03
type: execute
wave: 2
depends_on: ["13-01", "13-02"]
files_modified:
  - pkg/metadata/file.go
  - pkg/metadata/authentication.go
  - pkg/metadata/store/postgres/migrations/000004_acl.up.sql
  - pkg/metadata/store/postgres/migrations/000004_acl.down.sql
  - pkg/metadata/store/postgres/files.go
  - pkg/controlplane/store/interface.go
  - pkg/controlplane/store/gorm.go
  - pkg/controlplane/models/identity_mapping.go
autonomous: true

must_haves:
  truths:
    - "FileAttr has ACL field that persists across all store backends"
    - "nil ACL on file uses classic Unix permission check"
    - "Non-nil ACL on file uses ACL evaluation for access decisions"
    - "Empty ACL (0 ACEs) denies all access"
    - "New files/directories inherit ACL from parent at creation time"
    - "chmod adjusts OWNER@/GROUP@/EVERYONE@ ACEs when ACL is present"
    - "SetAttrs supports setting ACL on files"
    - "CopyFileAttr includes ACL field"
    - "PostgreSQL stores ACL as JSONB column"
    - "Identity mapping CRUD available in controlplane store"
  artifacts:
    - path: "pkg/metadata/file.go"
      provides: "FileAttr with ACL field, SetAttrs with ACL, CopyFileAttr includes ACL"
      contains: "ACL.*acl\\.ACL"
    - path: "pkg/metadata/authentication.go"
      provides: "calculatePermissions with ACL evaluation branch"
      contains: "file\\.ACL != nil"
    - path: "pkg/metadata/store/postgres/migrations/000004_acl.up.sql"
      provides: "PostgreSQL ACL JSONB column + identity_mappings table"
      contains: "ALTER TABLE files ADD COLUMN acl"
    - path: "pkg/controlplane/store/interface.go"
      provides: "Identity mapping CRUD methods on Store interface"
      contains: "CreateIdentityMapping"
    - path: "pkg/controlplane/models/identity_mapping.go"
      provides: "IdentityMapping GORM model"
      contains: "type IdentityMapping struct"
  key_links:
    - from: "pkg/metadata/authentication.go"
      to: "pkg/metadata/acl/evaluate.go"
      via: "ACL evaluation in calculatePermissions"
      pattern: "acl\\.Evaluate"
    - from: "pkg/metadata/file.go"
      to: "pkg/metadata/acl/inherit.go"
      via: "inheritance in createEntry"
      pattern: "acl\\.ComputeInheritedACL"
    - from: "pkg/metadata/file.go"
      to: "pkg/metadata/acl/mode.go"
      via: "chmod adjusts ACL"
      pattern: "acl\\.AdjustACLForMode"
---

<objective>
Integrate ACL storage into the metadata layer (FileAttr extension, permission checking, inheritance at creation, chmod sync) and add identity mapping CRUD to the controlplane store.

Purpose: This is the core integration that makes ACLs functional -- files store ACLs, permission checks use ACL evaluation, new files inherit ACLs, and identity mappings are persistable.
Output: Modified metadata and controlplane packages with ACL storage and identity mapping support.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-nfsv4-acls/13-CONTEXT.md
@.planning/phases/13-nfsv4-acls/13-RESEARCH.md
@.planning/phases/13-nfsv4-acls/13-01-SUMMARY.md
@.planning/phases/13-nfsv4-acls/13-02-SUMMARY.md
@pkg/metadata/file.go
@pkg/metadata/authentication.go
@pkg/metadata/types.go
@pkg/controlplane/store/interface.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: FileAttr ACL Extension, Permission Check Integration, and Inheritance</name>
  <files>
    pkg/metadata/file.go
    pkg/metadata/authentication.go
  </files>
  <action>
**pkg/metadata/file.go changes:**

1. Add import for `"github.com/marmos91/dittofs/pkg/metadata/acl"`.

2. Add ACL field to `FileAttr` struct (after the Hidden field, before IdempotencyToken):
```go
// ACL is the NFSv4 Access Control List for this file.
// nil means no ACL is set -- use classic Unix permission check.
// Non-nil with empty ACEs means an explicit empty ACL (denies all access).
ACL *acl.ACL `json:"acl,omitempty"`
```

3. Update `CopyFileAttr` to include ACL:
```go
// Deep copy ACL if present
var aclCopy *acl.ACL
if attr.ACL != nil {
    aces := make([]acl.ACE, len(attr.ACL.ACEs))
    copy(aces, attr.ACL.ACEs)
    aclCopy = &acl.ACL{ACEs: aces}
}
```
Add `ACL: aclCopy` to the returned FileAttr.

4. Add ACL field to `SetAttrs` struct:
```go
// ACL sets the NFSv4 ACL on the file.
// When non-nil, the ACL is validated (canonical ordering, max ACEs) before applying.
ACL *acl.ACL
```

5. In `SetFileAttributes` method, after existing attribute processing, add ACL handling:
- If `attrs.ACL != nil`: validate using `acl.ValidateACL(attrs.ACL)`, return error if invalid. Set `file.ACL = attrs.ACL`.

6. In `SetFileAttributes`, when Mode is changed AND file has an ACL: call `acl.AdjustACLForMode(file.ACL, *attrs.Mode)` and update file.ACL with the result. This implements the locked decision "chmod adjusts OWNER@, GROUP@, EVERYONE@ ACEs to match new mode bits per RFC 7530 Section 6.4.1".

7. In `createEntry` method, after the new file is created but before saving, add ACL inheritance:
```go
// Inherit ACL from parent if parent has one
if parent.ACL != nil {
    isDir := fileType == FileTypeDirectory
    inherited := acl.ComputeInheritedACL(parent.ACL, isDir)
    newFile.ACL = inherited
}
```
This must happen AFTER the file is constructed but BEFORE it's saved to the store.

**pkg/metadata/authentication.go changes:**

1. Add import for `"github.com/marmos91/dittofs/pkg/metadata/acl"`.

2. Modify `calculatePermissions` function to add ACL evaluation branch at the START, before the existing Unix permission logic:
```go
func calculatePermissions(
    file *File,
    identity *Identity,
    shareOpts *ShareOptions,
    requested Permission,
) Permission {
    attr := &file.FileAttr

    // ACL evaluation takes precedence when ACL is present
    if attr.ACL != nil {
        return evaluateACLPermissions(file, identity, shareOpts, requested)
    }

    // No ACL = classic Unix permission check (existing code below)
    // ... existing code unchanged ...
}
```

3. Add `evaluateACLPermissions` function:
```go
func evaluateACLPermissions(
    file *File,
    identity *Identity,
    shareOpts *ShareOptions,
    requested Permission,
) Permission {
    // Handle anonymous/no identity
    if identity == nil || identity.UID == nil {
        // Evaluate as EVERYONE@ only
        evalCtx := &acl.EvaluateContext{
            FileOwnerUID: file.UID,
            FileOwnerGID: file.GID,
        }
        // Map requested Permission to ACL mask and evaluate
        return evaluateWithACL(file.ACL, evalCtx, requested, shareOpts)
    }

    uid := *identity.UID

    // Root bypass: UID 0 gets all permissions except write on read-only shares
    if uid == 0 {
        if shareOpts != nil && shareOpts.ReadOnly {
            return requested &^ (PermissionWrite | PermissionDelete)
        }
        return requested
    }

    // Build evaluation context
    evalCtx := &acl.EvaluateContext{
        UID:          uid,
        GID:          identity.GID != nil && *identity.GID || 0,  // use safe dereference
        GIDs:         identity.GIDs,
        FileOwnerUID: file.UID,
        FileOwnerGID: file.GID,
    }
    if identity.GID != nil {
        evalCtx.GID = *identity.GID
    }
    // Set Who to "username@domain" if available for named principal matching
    if identity.Username != "" {
        if identity.Domain != "" {
            evalCtx.Who = identity.Username + "@" + identity.Domain
        } else {
            evalCtx.Who = identity.Username
        }
    }

    return evaluateWithACL(file.ACL, evalCtx, requested, shareOpts)
}
```

4. Add `evaluateWithACL` helper that maps Permission flags to ACL mask bits:
```go
func evaluateWithACL(fileACL *acl.ACL, evalCtx *acl.EvaluateContext, requested Permission, shareOpts *ShareOptions) Permission {
    var granted Permission

    // Check each permission type individually
    permMasks := map[Permission]uint32{
        PermissionRead:              acl.ACE4_READ_DATA,
        PermissionWrite:             acl.ACE4_WRITE_DATA | acl.ACE4_APPEND_DATA,
        PermissionExecute:           acl.ACE4_EXECUTE,
        PermissionDelete:            acl.ACE4_DELETE,
        PermissionListDirectory:     acl.ACE4_LIST_DIRECTORY,
        PermissionTraverse:          acl.ACE4_EXECUTE,
        PermissionChangePermissions: acl.ACE4_WRITE_ACL,
        PermissionChangeOwnership:   acl.ACE4_WRITE_OWNER,
    }

    for perm, mask := range permMasks {
        if requested&perm != 0 {
            if acl.Evaluate(fileACL, evalCtx, mask) {
                granted |= perm
            }
        }
    }

    // Apply read-only share restriction
    if shareOpts != nil && shareOpts.ReadOnly {
        granted &= ^(PermissionWrite | PermissionDelete)
    }

    return granted & requested
}
```

NOTE: The evaluateWithACL function calls acl.Evaluate per permission type. This is correct because ACL evaluation is per-operation (e.g., READ and WRITE are separate access checks). The function maps DittoFS's internal Permission flags to NFSv4 ACE mask bits.
  </action>
  <verify>
cd /Users/marmos91/Projects/dittofs && go build ./pkg/metadata/...
go test -race -v ./pkg/metadata/... -run "TestPermission|TestCreate|TestSetFile" 2>&1 | tail -30
go vet ./pkg/metadata/...
  </verify>
  <done>
FileAttr has ACL field (nil = Unix mode, non-nil = ACL evaluation). SetAttrs supports ACL with validation. createEntry inherits ACL from parent. calculatePermissions has ACL evaluation branch. chmod adjusts ACL's OWNER@/GROUP@/EVERYONE@ ACEs. CopyFileAttr deep-copies ACL. All existing tests still pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: PostgreSQL Migration and Controlplane Identity Mapping CRUD</name>
  <files>
    pkg/metadata/store/postgres/migrations/000004_acl.up.sql
    pkg/metadata/store/postgres/migrations/000004_acl.down.sql
    pkg/metadata/store/postgres/files.go
    pkg/controlplane/store/interface.go
    pkg/controlplane/store/gorm.go
    pkg/controlplane/models/identity_mapping.go
  </files>
  <action>
**PostgreSQL Migration:**

Create `pkg/metadata/store/postgres/migrations/000004_acl.up.sql`:
```sql
-- Add ACL column to files table (JSONB for flexible ACL storage)
ALTER TABLE files ADD COLUMN IF NOT EXISTS acl JSONB DEFAULT NULL;

-- Partial index for files with ACLs (optimize queries that check ACL presence)
CREATE INDEX IF NOT EXISTS idx_files_has_acl ON files ((acl IS NOT NULL)) WHERE acl IS NOT NULL;
```

Create `pkg/metadata/store/postgres/migrations/000004_acl.down.sql`:
```sql
DROP INDEX IF EXISTS idx_files_has_acl;
ALTER TABLE files DROP COLUMN IF EXISTS acl;
```

**PostgreSQL files.go:**
- Review the existing file read/write methods. Since FileAttr is JSON-serialized, the ACL field with `json:"acl,omitempty"` should automatically serialize/deserialize. If PostgreSQL files.go uses GORM auto-migration or manual column mapping, ensure the `acl` JSONB column is included.
- If the store maps FileAttr fields individually (not as a single JSON blob), add explicit handling for the ACL field: marshal to JSON for writes, unmarshal from JSON for reads.
- Check how existing stores handle the FileAttr. Memory and BadgerDB use JSON encoding of the entire File struct, so they get ACL support automatically. PostgreSQL may need explicit column mapping.

**Controlplane Identity Mapping Model:**

Create `pkg/controlplane/models/identity_mapping.go`:
```go
package models

import "time"

// IdentityMapping maps an NFSv4 principal to a control plane username.
type IdentityMapping struct {
    ID        string    `gorm:"primaryKey;type:varchar(36)" json:"id"`
    Principal string    `gorm:"uniqueIndex;type:varchar(255);not null" json:"principal"`
    Username  string    `gorm:"type:varchar(255);not null" json:"username"`
    CreatedAt time.Time `json:"created_at"`
    UpdatedAt time.Time `json:"updated_at"`
}

// Error types
var (
    ErrMappingNotFound  = errors.New("identity mapping not found")
    ErrDuplicateMapping = errors.New("identity mapping already exists")
)
```

**Controlplane Store Interface Extension:**

Add to `pkg/controlplane/store/interface.go`, after the SETTINGS OPERATIONS section:
```go
// ============================================
// IDENTITY MAPPING OPERATIONS
// ============================================

// GetIdentityMapping returns an identity mapping by principal.
// Returns models.ErrMappingNotFound if the mapping doesn't exist.
GetIdentityMapping(ctx context.Context, principal string) (*models.IdentityMapping, error)

// ListIdentityMappings returns all identity mappings.
ListIdentityMappings(ctx context.Context) ([]*models.IdentityMapping, error)

// CreateIdentityMapping creates a new identity mapping.
// Returns models.ErrDuplicateMapping if a mapping for this principal already exists.
CreateIdentityMapping(ctx context.Context, mapping *models.IdentityMapping) error

// DeleteIdentityMapping deletes an identity mapping by principal.
// Returns models.ErrMappingNotFound if the mapping doesn't exist.
DeleteIdentityMapping(ctx context.Context, principal string) error
```

**Controlplane Store GORM Implementation:**

Add to `pkg/controlplane/store/gorm.go` (or a new file `identity_mappings.go` if gorm.go is large):
- Add `IdentityMapping` to AutoMigrate in the store initialization
- Implement `GetIdentityMapping`: `db.Where("principal = ?", principal).First(&mapping)` with ErrMappingNotFound on record not found
- Implement `ListIdentityMappings`: `db.Find(&mappings)`
- Implement `CreateIdentityMapping`: generate UUID for ID, `db.Create(&mapping)` with ErrDuplicateMapping on unique constraint violation
- Implement `DeleteIdentityMapping`: `db.Where("principal = ?", principal).Delete(&IdentityMapping{})` with ErrMappingNotFound if rows affected == 0
  </action>
  <verify>
cd /Users/marmos91/Projects/dittofs && go build ./pkg/metadata/store/postgres/...
go build ./pkg/controlplane/store/...
go build ./pkg/controlplane/models/...
go vet ./pkg/metadata/store/postgres/... ./pkg/controlplane/store/... ./pkg/controlplane/models/...
  </verify>
  <done>
PostgreSQL migration 000004 adds ACL JSONB column with partial index. Controlplane store interface extended with identity mapping CRUD. GORM implementation persists identity mappings. Memory and BadgerDB metadata stores automatically serialize/deserialize ACL via JSON. All packages build successfully.
  </done>
</task>

</tasks>

<verification>
- `go build ./...` -- entire project builds
- `go test -race ./pkg/metadata/...` -- all metadata tests pass (including ACL evaluation)
- `go test -race ./pkg/controlplane/...` -- controlplane tests pass
- `go vet ./...` -- no issues
- FileAttr struct has `ACL *acl.ACL` field
- calculatePermissions checks file.ACL before Unix mode bits
- createEntry computes inherited ACL from parent
- SetFileAttributes handles ACL in SetAttrs
- chmod (Mode change) calls AdjustACLForMode when ACL present
</verification>

<success_criteria>
- FileAttr has ACL field persisted across all three store backends
- nil ACL = Unix mode check, non-nil ACL = ACL evaluation, empty ACL = deny all
- New files/directories inherit ACL from parent at creation time
- chmod adjusts OWNER@/GROUP@/EVERYONE@ ACEs per RFC 7530 Section 6.4.1
- PostgreSQL migration adds ACL JSONB column
- Controlplane store has identity mapping CRUD (4 methods)
- All existing tests continue to pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/13-nfsv4-acls/13-03-SUMMARY.md`
</output>
