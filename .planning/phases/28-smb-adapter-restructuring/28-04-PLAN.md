---
phase: 28-smb-adapter-restructuring
plan: 04
type: execute
wave: 3
depends_on: [28-01]
files_modified:
  - pkg/adapter/auth.go
  - internal/adapter/smb/auth/authenticator.go
  - internal/adapter/nfs/auth/unix.go
autonomous: true
requirements: [REF-04]

must_haves:
  truths:
    - "Authenticator interface exists in pkg/adapter/auth.go"
    - "SMB Authenticator in internal/adapter/smb/auth/ implements the interface with SPNEGO/NTLM/Kerberos support"
    - "NFS AUTH_UNIX Authenticator in internal/adapter/nfs/auth/ implements the interface for symmetry"
    - "AuthResult struct provides User + SessionKey + IsGuest"
    - "ErrMoreProcessingRequired sentinel error exists for multi-round auth"
    - "All existing tests pass"
  artifacts:
    - path: "pkg/adapter/auth.go"
      provides: "Authenticator interface, AuthResult struct, ErrMoreProcessingRequired"
      contains: "type Authenticator interface"
    - path: "internal/adapter/smb/auth/authenticator.go"
      provides: "SMBAuthenticator wrapping NTLM + SPNEGO for the Authenticator interface"
      contains: "func.*Authenticate"
    - path: "internal/adapter/nfs/auth/unix.go"
      provides: "UnixAuthenticator for NFS AUTH_UNIX credential extraction"
      contains: "type UnixAuthenticator struct"
  key_links:
    - from: "internal/adapter/smb/auth/authenticator.go"
      to: "pkg/adapter/auth.go"
      via: "implements Authenticator interface"
      pattern: "adapter\\.Authenticator"
    - from: "internal/adapter/nfs/auth/unix.go"
      to: "pkg/adapter/auth.go"
      via: "implements Authenticator interface"
      pattern: "adapter\\.Authenticator"
---

<objective>
Define a unified Authenticator interface in pkg/adapter/auth.go that all protocol auth paths implement. Create SMB Authenticator wrapping NTLM/SPNEGO and NFS AUTH_UNIX Authenticator for symmetry.

Purpose: Clean authentication abstraction that bridges protocol-specific auth mechanisms to DittoFS's identity model. Same pattern as NFS where auth context extraction produces a ready-to-use identity.
Output: Interface definition + two implementations (SMB and NFS).
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-smb-adapter-restructuring/28-RESEARCH.md
@.planning/phases/28-smb-adapter-restructuring/28-01-SUMMARY.md

<interfaces>
<!-- Authenticator design from CONTEXT.md locked decisions -->

Per CONTEXT.md:
- Full bridge pattern: validates token, looks up DittoFS user in control plane, returns models.User + session key
- SPNEGO handled inside SMB Authenticator: receives raw SPNEGO tokens, internally detects mechanism (NTLM vs Kerberos), delegates
- ErrMoreProcessingRequired for multi-round auth (NTLM 2-round, Kerberos 1-round)

Interface design from RESEARCH.md:
```go
// pkg/adapter/auth.go
type AuthResult struct {
    User       *models.User
    SessionKey []byte   // For signing (NTLM/Kerberos session key)
    IsGuest    bool
}

type Authenticator interface {
    Authenticate(ctx context.Context, token []byte) (*AuthResult, []byte, error)
}

var ErrMoreProcessingRequired = errors.New("more processing required")
```

Current auth flow in SMB session_setup.go:
1. Receives security buffer (SPNEGO token)
2. Passes to spnego.ParseNegotiateToken() to detect mechanism
3. If NTLM: creates NTLMAuthenticator, calls Authenticate() in 2 rounds
4. Returns session with user info

Current NFS auth flow:
- dispatch.go:ExtractAuthContext() parses AUTH_UNIX credentials (UID, GID, GIDs)
- middleware/auth.go:ExtractHandlerContext() builds handler context with auth info
- No "User" lookup - NFS uses raw Unix credentials

For NFS AUTH_UNIX Authenticator:
- Input: serialized AUTH_UNIX bytes (uid, gid, gids, machinename)
- Output: AuthResult with User resolved from control plane (or synthetic user for unknown UIDs)
- This is a thin wrapper, primarily for architectural symmetry
- The full NFS auth refactoring may need Phase 29 (per deferred decisions)
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define Authenticator interface and SMB implementation</name>
  <files>
    pkg/adapter/auth.go
    internal/adapter/smb/auth/authenticator.go
  </files>
  <action>
    1. Create `pkg/adapter/auth.go` with:
       - `AuthResult` struct: User (*models.User), SessionKey ([]byte), IsGuest (bool)
       - `Authenticator` interface with single method:
         `Authenticate(ctx context.Context, token []byte) (result *AuthResult, challenge []byte, err error)`
         - Returns (result, nil, nil) on successful authentication
         - Returns (nil, challengeToken, ErrMoreProcessingRequired) for multi-round (NTLM Type 2 challenge)
         - Returns (nil, nil, error) on authentication failure
       - `ErrMoreProcessingRequired` sentinel error
       - Godoc explaining the three return patterns

    2. Create `internal/adapter/smb/auth/authenticator.go` with:
       - `SMBAuthenticator` struct that wraps the existing NTLM auth and SPNEGO parsing code
       - Fields: control plane store reference (for user lookup), Kerberos provider (optional, for future use)
       - `NewSMBAuthenticator(store, kerberosProvider)` constructor
       - `Authenticate(ctx, token)` method that:
         a. Uses SPNEGO parsing to detect mechanism (NTLM vs Kerberos)
         b. For NTLM: delegates to existing NTLMAuthenticator logic
         c. On successful NTLM auth: looks up user in control plane, returns AuthResult
         d. For multi-round: returns challenge + ErrMoreProcessingRequired
         e. For Kerberos: placeholder that returns error (Kerberos will be fully wired in Phase 39+)
       - The SMBAuthenticator must maintain state between rounds (NTLM challenge). Use a session-scoped approach (store challenge per session ID or connection).

    3. IMPORTANT: This plan does NOT wire the SMBAuthenticator into session_setup.go. That would require modifying the Handler and is a behavioral change. The authenticator.go is created and tested but session_setup.go continues using the existing direct NTLM calls. Wiring happens naturally in Phase 39 (SMB3) when the auth flow is upgraded.

    4. However, DO ensure the SMBAuthenticator interface is compatible with the existing auth flow by writing a unit test that verifies the authenticate round-trip.

    5. Verify with `go build ./... && go test ./internal/adapter/smb/auth/...`
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs && go build ./... && go test ./internal/adapter/smb/auth/...</automated>
  </verify>
  <done>Authenticator interface defined. SMBAuthenticator created wrapping NTLM+SPNEGO. Unit test validates the interface contract. Compiles and tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Create NFS AUTH_UNIX Authenticator</name>
  <files>
    internal/adapter/nfs/auth/unix.go
  </files>
  <action>
    1. Create `internal/adapter/nfs/auth/` directory.

    2. Create `internal/adapter/nfs/auth/unix.go` with:
       - `UnixAuthenticator` struct implementing the `adapter.Authenticator` interface
       - Fields: control plane store reference (for user lookup by UID)
       - `NewUnixAuthenticator(store)` constructor
       - `Authenticate(ctx, token)` method that:
         a. Parses AUTH_UNIX credential bytes (extract UID, GID, GIDs, machine name)
         b. Looks up user by UID in control plane (if available)
         c. Returns AuthResult with found User or synthetic user for unknown UIDs
         d. AUTH_UNIX is always single-round, never returns ErrMoreProcessingRequired
       - Extract the AUTH_UNIX parsing logic from `internal/adapter/nfs/middleware/auth.go` ExtractHandlerContext. Do NOT remove it from middleware (keep both, the Authenticator is the new clean interface, middleware is the existing wiring).

    3. This is primarily for architectural symmetry (per CONTEXT.md). The full NFS auth refactoring to use this Authenticator is deferred to Phase 29.

    4. Add a basic unit test `internal/adapter/nfs/auth/unix_test.go` verifying:
       - Valid AUTH_UNIX bytes produce correct AuthResult
       - Empty/invalid bytes return error

    5. Verify with `go build ./... && go test ./internal/adapter/nfs/auth/...`
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs && go build ./... && go test ./internal/adapter/nfs/auth/...</automated>
  </verify>
  <done>NFS UnixAuthenticator created implementing Authenticator interface. Unit tests pass. Architectural symmetry with SMB achieved.</done>
</task>

</tasks>

<verification>
1. `grep "type Authenticator interface" pkg/adapter/auth.go` confirms interface exists
2. `grep "type SMBAuthenticator struct" internal/adapter/smb/auth/authenticator.go` confirms SMB impl
3. `grep "type UnixAuthenticator struct" internal/adapter/nfs/auth/unix.go` confirms NFS impl
4. `go build ./...` succeeds
5. `go test ./internal/adapter/smb/auth/... ./internal/adapter/nfs/auth/...` passes
6. `go test ./...` passes (no regressions)
</verification>

<success_criteria>
- Clean Authenticator interface in pkg/adapter/auth.go
- SMB implementation wraps existing NTLM + SPNEGO auth
- NFS implementation provides AUTH_UNIX parsing
- Both implementations have unit tests
- Interface contract supports single-round and multi-round auth
- No behavioral changes to existing code paths
</success_criteria>

<output>
After completion, create `.planning/phases/28-smb-adapter-restructuring/28-04-SUMMARY.md`
</output>
