---
phase: 28-smb-adapter-restructuring
plan: 02
type: execute
wave: 2
depends_on: [28-01]
files_modified:
  - pkg/adapter/base.go
  - pkg/adapter/nfs/adapter.go
  - pkg/adapter/nfs/shutdown.go
  - pkg/adapter/smb/adapter.go
autonomous: true
requirements: [REF-04]

must_haves:
  truths:
    - "BaseAdapter struct exists in pkg/adapter/base.go with shared TCP lifecycle"
    - "NFS adapter embeds BaseAdapter and delegates lifecycle to it"
    - "SMB adapter embeds BaseAdapter and delegates lifecycle to it"
    - "ConnectionFactory interface enables per-protocol connection creation"
    - "Both adapters still pass all existing tests"
    - "TCP_NODELAY is set in BaseAdapter accept loop"
    - "Graceful shutdown, force-close, connection tracking all work through BaseAdapter"
  artifacts:
    - path: "pkg/adapter/base.go"
      provides: "BaseAdapter struct with shared lifecycle: accept loop, shutdown, connection tracking"
      contains: "type BaseAdapter struct"
    - path: "pkg/adapter/nfs/adapter.go"
      provides: "NFSAdapter embedding BaseAdapter"
      contains: "adapter.BaseAdapter"
    - path: "pkg/adapter/smb/adapter.go"
      provides: "Adapter embedding BaseAdapter"
      contains: "adapter.BaseAdapter"
  key_links:
    - from: "pkg/adapter/smb/adapter.go"
      to: "pkg/adapter/base.go"
      via: "struct embedding adapter.BaseAdapter"
      pattern: "adapter\\.BaseAdapter"
    - from: "pkg/adapter/nfs/adapter.go"
      to: "pkg/adapter/base.go"
      via: "struct embedding adapter.BaseAdapter"
      pattern: "adapter\\.BaseAdapter"
    - from: "pkg/adapter/base.go"
      to: "pkg/adapter/smb/adapter.go"
      via: "ConnectionFactory interface NewConnection callback"
      pattern: "ConnectionFactory"
---

<objective>
Extract shared TCP lifecycle code (accept loop, graceful shutdown, force-close, connection tracking, semaphore) from both NFS and SMB adapters into a BaseAdapter embedded struct.

Purpose: Eliminate ~600 lines of duplicated lifecycle code across adapters. Single place for shutdown bugs. Proves the abstraction works with both protocols.
Output: pkg/adapter/base.go with BaseAdapter. Both adapters refactored to embed it.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-smb-adapter-restructuring/28-RESEARCH.md
@.planning/phases/28-smb-adapter-restructuring/28-01-SUMMARY.md

<interfaces>
<!-- BaseAdapter design from RESEARCH.md and CONTEXT.md decisions -->

Pattern from both adapters (shared fields to extract):
```go
// Both NFS and SMB have these identical fields:
listener           net.Listener
activeConns        sync.WaitGroup
shutdownOnce       sync.Once
shutdown           chan struct{}
connCount          atomic.Int32
connSemaphore      chan struct{}
shutdownCtx        context.Context
cancelRequests     context.CancelFunc
activeConnections  sync.Map
listenerReady      chan struct{}
listenerMu         sync.RWMutex
registry           *runtime.Runtime
```

Shared methods to extract (found in both adapters):
- initiateShutdown() - close listener, cancel context
- interruptBlockingReads() - set read deadline on all tracked connections
- gracefulShutdown() error - wait with timeout, force close if needed
- forceCloseConnections() - close all tracked connections
- Stop(ctx) error - idempotent shutdown entry point
- logMetrics() - periodic connection count logging
- GetActiveConnections() int32
- GetListenerAddr() net.Addr

Protocol-specific overrides (stay per-adapter):
- NFS: portmapper cleanup, GSS cleanup, Kerberos close, NSM notifier stop
- SMB: live settings max_connections check in pre-accept

ConnectionFactory interface per CONTEXT.md:
```go
type ConnectionHandler interface {
    Serve(ctx context.Context)
}

type ConnectionFactory interface {
    NewConnection(conn net.Conn) ConnectionHandler
}
```

PreAccept hook per CONTEXT.md:
```go
// PreAccept returns true to accept the connection, false to reject
// SMB uses this for live settings max_connections
// NFS uses this for live settings checks
type PreAcceptFunc func(conn net.Conn) bool
```

NFS shutdown.go (262 lines) - Most of this moves to BaseAdapter.
NFS adapter.go Serve() method - Accept loop moves to BaseAdapter.ServeWithFactory().
SMB adapter.go Serve() method - Same accept loop pattern moves to BaseAdapter.ServeWithFactory().

After extraction:
- pkg/adapter/nfs/adapter.go: ~400 lines (down from 789, protocol-specific init + SetRuntime)
- pkg/adapter/nfs/shutdown.go: ~50 lines (NFS-specific cleanup only)
- pkg/adapter/smb/adapter.go: ~300 lines (down from 614, protocol-specific init + SetRuntime)
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BaseAdapter with shared lifecycle</name>
  <files>
    pkg/adapter/base.go
  </files>
  <action>
    1. Create `pkg/adapter/base.go` with:
       - `ConnectionHandler` interface: `Serve(ctx context.Context)`
       - `ConnectionFactory` interface: `NewConnection(conn net.Conn) ConnectionHandler`
       - `BaseConfig` struct: BindAddress, Port, MaxConnections, ShutdownTimeout, MetricsLogInterval
       - `BaseAdapter` struct with all shared fields listed in interfaces section above
       - `NewBaseAdapter(config BaseConfig) BaseAdapter` constructor (initializes shutdown chan, listenerReady chan, shutdownCtx/cancelRequests)

    2. Move shared methods to BaseAdapter receivers:
       - `(b *BaseAdapter) SetRuntime(rt *runtime.Runtime)` - stores runtime reference
       - `(b *BaseAdapter) ServeWithFactory(ctx context.Context, factory ConnectionFactory, preAccept func(net.Conn) bool) error` - the shared accept loop:
         * Creates TCP listener on config.BindAddress:config.Port
         * Signals listenerReady
         * Accept loop with semaphore gating
         * TCP_NODELAY on accepted connections
         * PreAccept callback (nil = accept all)
         * factory.NewConnection() for protocol-specific connection creation
         * Goroutine-per-connection with cleanup (activeConnections.Delete, activeConns.Done, connCount.Add(-1), semaphore release)
         * Metrics logging goroutine (if MetricsLogInterval > 0)
       - `(b *BaseAdapter) initiateShutdown()` - sync.Once close listener + cancel context
       - `(b *BaseAdapter) gracefulShutdown() error` - wait with timeout, force close
       - `(b *BaseAdapter) forceCloseConnections()` - range over activeConnections, close each
       - `(b *BaseAdapter) interruptBlockingReads()` - set read deadline to past time
       - `(b *BaseAdapter) Stop(ctx context.Context) error` - idempotent shutdown
       - `(b *BaseAdapter) GetActiveConnections() int32`
       - `(b *BaseAdapter) GetListenerAddr() net.Addr`
       - `(b *BaseAdapter) LogMetrics()` - periodic metrics logging helper
       - `(b *BaseAdapter) Port() int` - returns config.Port

    3. Extract the accept loop pattern from BOTH adapters. The research shows the exact shared pattern in the Code Examples section. Use it as the template.

    4. Verify with `go build ./pkg/adapter/...` (base.go should compile standalone).
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs && go build ./pkg/adapter/...</automated>
  </verify>
  <done>BaseAdapter struct exists in pkg/adapter/base.go with full shared lifecycle. Compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Refactor both adapters to embed BaseAdapter</name>
  <files>
    pkg/adapter/nfs/adapter.go
    pkg/adapter/nfs/shutdown.go
    pkg/adapter/smb/adapter.go
  </files>
  <action>
    1. Refactor SMB Adapter (pkg/adapter/smb/adapter.go):
       - Add `adapter.BaseAdapter` as embedded field
       - Remove all shared fields (listener, activeConns, shutdownOnce, shutdown, connCount, connSemaphore, shutdownCtx, cancelRequests, activeConnections, listenerReady, listenerMu, registry)
       - Keep SMB-specific fields: handler, sessionManager, and any SMB-specific state
       - Update `New(config Config) *Adapter` to call `adapter.NewBaseAdapter(baseConfig)` and embed result
       - Update `SetRuntime()`: call `a.BaseAdapter.SetRuntime(rt)` first, then SMB-specific setup (handler registry, settings application)
       - Update `Serve()`: call `a.ServeWithFactory(ctx, a, a.preAcceptCheck)` where preAcceptCheck handles live settings max_connections
       - Implement `ConnectionFactory`: `func (a *Adapter) NewConnection(conn net.Conn) adapter.ConnectionHandler` that wraps existing NewConnection call
       - Update `Stop()`: do SMB-specific cleanup, then call `a.BaseAdapter.Stop(ctx)`
       - Remove duplicated lifecycle methods (initiateShutdown, gracefulShutdown, forceCloseConnections, interruptBlockingReads)
       - Keep `Protocol() string` returning "SMB"

    2. Refactor NFS NFSAdapter (pkg/adapter/nfs/adapter.go):
       - Add `adapter.BaseAdapter` as embedded field
       - Remove all shared fields (same list as SMB above)
       - Keep NFS-specific fields: nfsHandler, v4Handler, pseudoFS, mountHandler, nlmHandler, nsmHandler, nsmNotifier, nsmMetrics, gssProcessor, kerberosProvider, kerberosConfig, portmapServer, portmapRegistry, nsmClientStore, blockingQueue, metrics, v3FirstUse, v4FirstUse
       - Update `NewNFSAdapter(...)` to call `adapter.NewBaseAdapter(baseConfig)` and embed result
       - Update `SetRuntime()`: call `a.BaseAdapter.SetRuntime(rt)` first, then NFS-specific setup (portmapper, share change callbacks)
       - Update `Serve()`: call `a.ServeWithFactory(ctx, a, a.preAcceptCheck)` where preAcceptCheck handles NFS-specific live settings
       - Implement `ConnectionFactory`: `func (a *NFSAdapter) NewConnection(conn net.Conn) adapter.ConnectionHandler`
       - Keep `Protocol() string` returning "NFS"

    3. Refactor NFS shutdown (pkg/adapter/nfs/shutdown.go):
       - Remove shared shutdown methods (initiateShutdown, gracefulShutdown, forceCloseConnections, interruptBlockingReads)
       - Keep ONLY NFS-specific cleanup: portmapper stop, GSS cleanup, Kerberos close, NSM notifier stop, blocking queue shutdown
       - Update `Stop()`: do NFS-specific cleanup, then call `a.BaseAdapter.Stop(ctx)`

    4. CRITICAL: Connection.Serve() in both adapters currently receives context from the shutdownCtx field. After extraction, BaseAdapter's ServeWithFactory passes shutdownCtx to the ConnectionHandler.Serve(ctx). Ensure the context is properly threaded.

    5. Verify with `go build ./...` and `go test ./pkg/adapter/... ./internal/adapter/...`

    6. Run full test suite: `go test ./...`
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs && go build ./... && go test ./...</automated>
  </verify>
  <done>Both NFS and SMB adapters embed BaseAdapter. Shared lifecycle code removed from both. Full test suite passes. ~600 lines of duplication eliminated.</done>
</task>

</tasks>

<verification>
1. `grep -r "type BaseAdapter struct" pkg/adapter/base.go` confirms BaseAdapter exists
2. `grep "adapter.BaseAdapter" pkg/adapter/nfs/adapter.go` confirms NFS embeds it
3. `grep "adapter.BaseAdapter" pkg/adapter/smb/adapter.go` confirms SMB embeds it
4. `grep -c "initiateShutdown\|gracefulShutdown\|forceCloseConnections" pkg/adapter/smb/adapter.go` returns 0 (removed)
5. `go build ./...` succeeds
6. `go test ./...` passes with zero failures
7. `go vet ./...` passes
</verification>

<success_criteria>
- BaseAdapter struct in pkg/adapter/base.go with complete shared lifecycle
- Both adapters embed BaseAdapter and delegate shared methods
- No duplicated lifecycle code remains in individual adapters
- ConnectionFactory pattern enables per-protocol connection creation
- Full test suite passes
</success_criteria>

<output>
After completion, create `.planning/phases/28-smb-adapter-restructuring/28-02-SUMMARY.md`
</output>
