---
phase: 28-smb-adapter-restructuring
plan: 03
type: execute
wave: 3
depends_on: [28-01, 28-02]
files_modified:
  - internal/adapter/smb/framing.go
  - internal/adapter/smb/compound.go
  - internal/adapter/smb/dispatch.go
  - pkg/adapter/smb/connection.go
autonomous: true
requirements: [REF-04]

must_haves:
  truths:
    - "pkg/adapter/smb/connection.go is ~150-200 lines (thin serve loop only)"
    - "NetBIOS framing logic lives in internal/adapter/smb/framing.go"
    - "Compound request handling lives in internal/adapter/smb/compound.go"
    - "Dispatch + response logic consolidated in internal/adapter/smb/dispatch.go"
    - "Signing verification delegated to internal/adapter/smb/signing/ package"
    - "All existing tests pass with zero failures"
  artifacts:
    - path: "internal/adapter/smb/framing.go"
      provides: "NetBIOS framing: ReadRequest, WriteNetBIOSFrame, SendRawMessage"
      contains: "func ReadRequest"
    - path: "internal/adapter/smb/compound.go"
      provides: "Compound request handling: ProcessCompoundRequest, ParseCompoundCommand, InjectFileID"
      contains: "func ProcessCompoundRequest"
    - path: "internal/adapter/smb/dispatch.go"
      provides: "Dispatch + response: ProcessRequest, SendResponse, SendErrorResponse, HandleSMB1Negotiate"
    - path: "pkg/adapter/smb/connection.go"
      provides: "Thin serve loop: Serve, handleConnectionClose, cleanupSessions, handleRequestPanic"
  key_links:
    - from: "pkg/adapter/smb/connection.go"
      to: "internal/adapter/smb/framing.go"
      via: "delegates read/write to framing functions"
      pattern: "smb\\.ReadRequest"
    - from: "pkg/adapter/smb/connection.go"
      to: "internal/adapter/smb/dispatch.go"
      via: "delegates request processing to dispatch"
      pattern: "smb\\.ProcessRequest"
    - from: "internal/adapter/smb/dispatch.go"
      to: "internal/adapter/smb/signing/"
      via: "signing verification delegated to signing package"
      pattern: "signing\\."
---

<objective>
Slim down pkg/adapter/smb/connection.go from ~1071 lines to ~150-200 lines by extracting NetBIOS framing, dispatch+response, and compound handling to internal/adapter/smb/ packages.

Purpose: Mirror the NFS connection pattern where pkg/ has a thin serve loop and internal/ has protocol-specific logic. Makes each concern independently testable and maintainable.
Output: Four focused files replacing one monolithic connection file.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-smb-adapter-restructuring/28-RESEARCH.md
@.planning/phases/28-smb-adapter-restructuring/28-01-SUMMARY.md
@.planning/phases/28-smb-adapter-restructuring/28-02-SUMMARY.md

<interfaces>
<!-- Functions to extract from connection.go, organized by target file -->

Target: internal/adapter/smb/framing.go (~210 lines)
Functions from connection.go:
- readRequest() -> ReadRequest(conn net.Conn, maxMsgSize uint32, readTimeout time.Duration, signingLookup func(uint64) []byte) (*header.SMB2Header, []byte, bool, error)
  Note: This accesses c.conn, c.server.config.MaxMessageSize, c.server.config.ReadTimeout.
  Convert private fields to explicit parameters. Signing verification happens via callback.
- writeNetBIOSFrame() -> WriteNetBIOSFrame(w io.Writer, data []byte) error
- sendRawMessage() -> SendRawMessage(w io.Writer, data []byte) error

Target: internal/adapter/smb/compound.go (~190 lines)
Functions from connection.go:
- processCompoundRequest() -> ProcessCompoundRequest(ctx, hdr, body, handler, conn) ([]*HandlerResult, error)
- parseCompoundCommand() -> ParseCompoundCommand(data []byte) (*header.SMB2Header, []byte, error)
- verifyCompoundCommandSignature() -> VerifyCompoundCommandSignature(hdr, body, signingKey []byte) error
- injectFileID() -> InjectFileID(nextBody []byte, fileID FileID) []byte

Target: internal/adapter/smb/dispatch.go (expand existing ~326 lines)
Functions from connection.go:
- processRequest() -> merge into dispatch or export as ProcessSingleRequest(ctx, hdr, body, handler, conn) (*HandlerResult, error)
- processRequestWithFileID() -> ProcessRequestWithFileID(ctx, hdr, body, handler, conn, fileID) (*HandlerResult, error)
- processRequestWithInheritedFileID() -> similar
- sendResponse() -> SendResponse(w io.Writer, writeMu *sync.Mutex, result *HandlerResult) error
- sendErrorResponse() -> SendErrorResponse(w io.Writer, writeMu *sync.Mutex, hdr, status) error
- sendMessage() -> SendMessage(w io.Writer, writeMu *sync.Mutex, hdr, body, signingKey) error
- handleSMB1Negotiate() -> HandleSMB1Negotiate(w io.Writer, writeMu *sync.Mutex) error
- SendAsyncChangeNotifyResponse() -> keep exported, move implementation
- trackSessionLifecycle() -> TrackSessionLifecycle(hdr, conn)
- makeErrorBody() -> MakeErrorBody(status) []byte

Signing verification to move:
- Inline signing verification in readRequest (lines 255-303 in connection.go) should delegate to signing.VerifyRequestSignature() in the existing internal/adapter/smb/signing/ package

Target: pkg/adapter/smb/connection.go (~150-200 lines, what remains)
- Connection struct definition
- NewConnection()
- Serve() - thin loop: read (via framing), check compound, dispatch (via dispatch), handle close
- handleConnectionClose() - session cleanup
- cleanupSessions()
- handleRequestPanic() - panic recovery
- TrackSession/UntrackSession
- Any small helper methods that access private Connection fields

CRITICAL: Functions moved to internal/ packages CANNOT access unexported Connection fields.
Two strategies per research:
1. Keep methods as Connection receivers in pkg/ that delegate to internal functions with explicit parameters
2. Pass net.Conn, config values, sync.Mutex pointer as parameters to internal functions

Prefer strategy (2) for framing and dispatch. The Connection struct stays in pkg/ with a thin Serve() loop that calls internal functions passing explicit parameters.
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract framing, compound, and dispatch to internal/</name>
  <files>
    internal/adapter/smb/framing.go
    internal/adapter/smb/compound.go
    internal/adapter/smb/dispatch.go
  </files>
  <action>
    1. Create `internal/adapter/smb/framing.go`:
       - Extract readRequest from connection.go as an exported function `ReadRequest(...)` that takes explicit parameters instead of Connection receiver fields:
         * conn net.Conn
         * maxMsgSize uint32
         * readTimeout time.Duration
         * signingLookup func(sessionID uint64) []byte (for signing verification, nil = skip)
       - Extract writeNetBIOSFrame as `WriteNetBIOSFrame(w io.Writer, data []byte) error`
       - Extract sendRawMessage as `SendRawMessage(w io.Writer, data []byte) error`
       - Move signing verification inline code to use the `signing` package's verify function. If the signing package does not have a verify function, add one there or keep the logic inline in ReadRequest with the signing key callback.

    2. Create `internal/adapter/smb/compound.go`:
       - Extract processCompoundRequest as `ProcessCompoundRequest(ctx context.Context, mainHdr *header.SMB2Header, fullBody []byte, handler *handlers.Handler, connInfo ConnInfo) ([]*handlers.HandlerResult, error)`
       - Define a `ConnInfo` struct or interface to pass connection metadata needed by handlers (session tracking, write capabilities, etc.)
       - Extract parseCompoundCommand as `ParseCompoundCommand(data []byte) (*header.SMB2Header, []byte, error)`
       - Extract verifyCompoundCommandSignature as `VerifyCompoundCommandSignature(hdr *header.SMB2Header, body []byte, signingKey []byte) error`
       - Extract injectFileID as `InjectFileID(nextBody []byte, fileID types.FileID) []byte`

    3. Expand `internal/adapter/smb/dispatch.go`:
       - Add exported functions for request processing and response building
       - Extract processRequest as `ProcessSingleRequest(ctx, hdr, body, handler, connInfo) (*handlers.HandlerResult, error)`
       - Extract processRequestWithFileID as `ProcessRequestWithFileID(ctx, hdr, body, handler, connInfo, fileID) (*handlers.HandlerResult, error)`
       - Extract sendResponse as `SendResponse(w io.Writer, writeMu *sync.Mutex, result *handlers.HandlerResult, signingKey []byte) error`
       - Extract sendErrorResponse as `SendErrorResponse(w io.Writer, writeMu *sync.Mutex, hdr *header.SMB2Header, status uint32, signingKey []byte) error`
       - Extract sendMessage as `SendMessage(w io.Writer, writeMu *sync.Mutex, hdr *header.SMB2Header, body []byte, signingKey []byte) error`
       - Extract handleSMB1Negotiate as `HandleSMB1Negotiate(w io.Writer, writeMu *sync.Mutex) error`
       - Extract SendAsyncChangeNotifyResponse
       - Extract trackSessionLifecycle, makeErrorBody

    4. IMPORTANT: Pay attention to the existing dispatch.go (326 lines) that already has DispatchTable and handler wrappers. The new dispatch functions should coexist with the existing code. Do NOT break the existing DispatchTable initialization.

    5. Verify with `go build ./internal/adapter/smb/...`
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs && go build ./internal/adapter/smb/...</automated>
  </verify>
  <done>framing.go, compound.go created. dispatch.go expanded with request processing and response functions. All compile cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Slim connection.go to thin serve loop</name>
  <files>
    pkg/adapter/smb/connection.go
    pkg/adapter/smb/connection_test.go
  </files>
  <action>
    1. Refactor `pkg/adapter/smb/connection.go` to delegate to internal/ functions:
       - Keep: Connection struct definition, NewConnection(), Serve() method, handleConnectionClose(), cleanupSessions(), handleRequestPanic(), TrackSession/UntrackSession
       - In Serve() method: replace inline readRequest call with `smb.ReadRequest(c.conn, c.server.Config().MaxMessageSize, c.server.Config().ReadTimeout, c.getSigningKey)`
       - Replace inline processCompoundRequest with `smb.ProcessCompoundRequest(ctx, hdr, body, c.handler, c.connInfo())`
       - Replace inline processRequest with `smb.ProcessSingleRequest(ctx, hdr, body, c.handler, c.connInfo())`
       - Replace inline sendResponse with `smb.SendResponse(c.conn, &c.writeMu, result, c.getSigningKeyForSession(...))`
       - Replace inline sendErrorResponse with `smb.SendErrorResponse(c.conn, &c.writeMu, hdr, status, signingKey)`
       - Replace inline handleSMB1Negotiate with `smb.HandleSMB1Negotiate(c.conn, &c.writeMu)`
       - Add `connInfo()` helper method that creates the ConnInfo struct from Connection fields
       - Add `getSigningKey(sessionID uint64) []byte` helper method for signing callback

    2. Remove all extracted function bodies from connection.go. The methods should now be thin delegation calls.

    3. The Connection struct may need minor field visibility changes (export some fields or add accessor methods) if internal/ code needs them via ConnInfo. Prefer accessor methods over exported fields.

    4. Update connection_test.go if it directly tests any extracted functions. Tests for extracted functions should work through the Connection.Serve() integration path or be moved to internal test files.

    5. Target: connection.go should be ~150-200 lines after extraction.

    6. Verify with `go build ./...` and `go test ./pkg/adapter/smb/... ./internal/adapter/smb/...`

    7. Run full test suite: `go test ./...`
  </action>
  <verify>
    <automated>cd /Users/marmos91/Projects/dittofs && go build ./... && go test ./...</automated>
  </verify>
  <done>connection.go is ~150-200 lines. All protocol logic delegated to internal/adapter/smb/. Full test suite passes.</done>
</task>

</tasks>

<verification>
1. `wc -l pkg/adapter/smb/connection.go` shows ~150-200 lines (was 1071)
2. `ls internal/adapter/smb/framing.go internal/adapter/smb/compound.go` both exist
3. `wc -l internal/adapter/smb/dispatch.go` shows expanded file with processing + response functions
4. `go build ./...` succeeds
5. `go test ./...` passes with zero failures
6. `go vet ./...` passes
</verification>

<success_criteria>
- connection.go reduced from 1071 to ~150-200 lines
- Four concerns cleanly separated: framing, dispatch, compound, serve loop
- Connection struct stays in pkg/ as the public interface
- Protocol logic lives in internal/ where it can be tested independently
- Mirror of NFS adapter pattern achieved
</success_criteria>

<output>
After completion, create `.planning/phases/28-smb-adapter-restructuring/28-03-SUMMARY.md`
</output>
