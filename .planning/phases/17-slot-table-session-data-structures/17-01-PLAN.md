---
phase: 17-slot-table-session-data-structures
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/protocol/nfs/v4/state/slot_table.go
  - internal/protocol/nfs/v4/state/slot_table_test.go
autonomous: true
requirements: [EOS-01, EOS-02, EOS-03]

must_haves:
  truths:
    - "SlotTable caches full COMPOUND response bytes for replay detection"
    - "Sequence ID validation correctly classifies new requests, retries, misordered, and in-use slots"
    - "Server can dynamically adjust slot count via target_highest_slotid"
    - "Per-SlotTable mutex provides concurrency without serializing on global StateManager RWMutex"
  artifacts:
    - path: "internal/protocol/nfs/v4/state/slot_table.go"
      provides: "SlotTable, Slot, SequenceValidation types and validation logic"
      exports: ["SlotTable", "Slot", "SequenceValidation", "SeqNew", "SeqRetry", "SeqMisordered", "NewSlotTable", "ValidateSequence", "CompleteSlotRequest", "MarkSlotInUse", "SetTargetHighestSlotID", "GetHighestSlotID", "GetTargetHighestSlotID"]
    - path: "internal/protocol/nfs/v4/state/slot_table_test.go"
      provides: "Comprehensive unit tests for slot table validation"
      min_lines: 200
  key_links:
    - from: "internal/protocol/nfs/v4/state/slot_table.go"
      to: "internal/protocol/nfs/v4/types/constants.go"
      via: "NFS4ERR_BADSLOT, NFS4ERR_SEQ_MISORDERED, NFS4ERR_RETRY_UNCACHED_REP, NFS4ERR_DELAY"
      pattern: "types\\.NFS4ERR_"
---

<objective>
Implement the SlotTable data structure with per-slot sequence ID tracking, cached reply storage, and the RFC 8881 Section 2.10.6.1 sequence validation algorithm.

Purpose: The slot table is the heart of NFSv4.1 exactly-once semantics (EOS). Every v4.1 COMPOUND request passes through SEQUENCE which validates against the slot table. This plan builds the data structure and validation logic that Phase 19 (CREATE_SESSION) will instantiate and Phase 20 (SEQUENCE handler) will call.

Output: `slot_table.go` with SlotTable struct, validation methods, and dynamic sizing; `slot_table_test.go` with comprehensive tests covering all validation paths.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-slot-table-session-data-structures/17-RESEARCH.md
@internal/protocol/nfs/v4/state/manager.go (StateManager pattern, NFS4StateError, error vars)
@internal/protocol/nfs/v4/state/stateid.go (NFS4StateError type, existing error vars)
@internal/protocol/nfs/v4/state/openowner.go (v4.0 SeqIDValidation pattern -- reference but DO NOT reuse)
@internal/protocol/nfs/v4/types/constants.go (NFS4ERR_BADSLOT, NFS4ERR_SEQ_MISORDERED, etc.)
@internal/protocol/nfs/v4/types/sequence.go (SequenceArgs, SequenceRes wire types)
@internal/protocol/nfs/v4/types/session_common.go (SessionId4, ChannelAttrs)
@internal/protocol/CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: SlotTable and Slot structs with validation logic</name>
  <files>internal/protocol/nfs/v4/state/slot_table.go</files>
  <action>
Create `internal/protocol/nfs/v4/state/slot_table.go` in package `state` with the following:

**Constants:**
- `DefaultMaxSlots uint32 = 64` -- default maximum slot count for DittoFS (server-imposed limit)
- `MinSlots uint32 = 1` -- minimum slot count per RFC

**SequenceValidation enum** (new, separate from the v4.0 SeqIDValidation in openowner.go):
- `SeqNew` -- new request (seqid == cached+1)
- `SeqRetry` -- retransmission (seqid == cached, slot not in-use, cached reply exists)
- `SeqMisordered` -- out of range (gap or behind)

NOTE: Do NOT reuse the v4.0 `SeqIDValidation` type from openowner.go. v4.1 slot-based seqid validation has different semantics (wraps through 0, initial seqid is 0, not 1).

**Slot struct:**
```go
type Slot struct {
    SeqID       uint32   // last completed seqid (starts at 0)
    InUse       bool     // request currently being processed
    CachedReply []byte   // full XDR-encoded COMPOUND4res (nil if not cached)
}
```

**SlotTable struct:**
```go
type SlotTable struct {
    mu                  sync.Mutex
    slots               []Slot
    highestSlotID       uint32  // highest slot ID ever used (for sr_highest_slotid)
    targetHighestSlotID uint32  // desired max (for sr_target_highest_slotid)
    maxSlots            uint32  // allocated slot count (len(slots))
}
```

**NewSlotTable(numSlots uint32) *SlotTable:**
- Clamp numSlots to [MinSlots, DefaultMaxSlots]
- Initialize all slots to SeqID=0, InUse=false, CachedReply=nil
- Set highestSlotID = numSlots - 1
- Set targetHighestSlotID = numSlots - 1
- Set maxSlots = numSlots

**ValidateSequence(slotID, seqID uint32) (SequenceValidation, *Slot, error):**
Implement RFC 8881 Section 2.10.6.1 exactly:
1. If slotID >= maxSlots -> return error with NFS4ERR_BADSLOT
2. Get slot reference: `slot := &st.slots[slotID]`
3. Compute expectedSeqID = slot.SeqID + 1 (uint32 natural overflow handles wrap; 0xFFFFFFFF+1 = 0 which is valid in v4.1)
4. If seqID == expectedSeqID:
   - If slot.InUse -> return error with NFS4ERR_SEQ_MISORDERED ("slot in use")
   - Else -> return SeqNew, slot, nil
5. If seqID == slot.SeqID:
   - If slot.InUse -> return error with NFS4ERR_DELAY ("retry in flight")
   - If slot.CachedReply == nil -> return error with NFS4ERR_RETRY_UNCACHED_REP
   - Else -> return SeqRetry, slot, nil
6. Otherwise -> return SeqMisordered, nil, error with NFS4ERR_SEQ_MISORDERED

IMPORTANT: Lock st.mu at entry, unlock at exit. This method validates and returns the slot pointer but does NOT mark InUse (caller does that via MarkSlotInUse).

**MarkSlotInUse(slotID uint32):**
- Lock, set slots[slotID].InUse = true, update highestSlotID if slotID > current, unlock

**CompleteSlotRequest(slotID, seqID uint32, cacheThis bool, reply []byte):**
- Lock, validate slotID in range, set slot.SeqID = seqID, slot.InUse = false
- If cacheThis: copy reply bytes into slot.CachedReply
- Else: set slot.CachedReply = nil
- Update highestSlotID if needed, unlock

**SetTargetHighestSlotID(target uint32):**
- Lock, clamp target to maxSlots-1, set targetHighestSlotID, unlock

**GetHighestSlotID() uint32:**
- Lock, return highestSlotID, unlock

**GetTargetHighestSlotID() uint32:**
- Lock, return targetHighestSlotID, unlock

**MaxSlots() uint32:**
- Return st.maxSlots (immutable after creation, no lock needed)

Use `NFS4StateError` from stateid.go for errors (same pattern as existing state package). Import types for NFS4ERR_* constants.
  </action>
  <verify>
`go build ./internal/protocol/nfs/v4/state/` compiles without errors.
`go vet ./internal/protocol/nfs/v4/state/` reports no issues.
  </verify>
  <done>
SlotTable struct exists with Slot, SequenceValidation enum, NewSlotTable constructor, ValidateSequence (RFC 8881 algorithm), MarkSlotInUse, CompleteSlotRequest, SetTargetHighestSlotID, and getter methods. Compiles and passes vet.
  </done>
</task>

<task type="auto">
  <name>Task 2: Comprehensive slot table unit tests</name>
  <files>internal/protocol/nfs/v4/state/slot_table_test.go</files>
  <action>
Create `internal/protocol/nfs/v4/state/slot_table_test.go` in package `state` with comprehensive tests:

**TestNewSlotTable:**
- Creates with 8 slots, verifies MaxSlots()=8, GetHighestSlotID()=7, GetTargetHighestSlotID()=7
- Creates with 0 slots, verifies clamped to MinSlots (1)
- Creates with > DefaultMaxSlots, verifies clamped to DefaultMaxSlots

**TestValidateSequence_NewRequest:**
- New slot table (4 slots), validate slotID=0, seqID=1 (expected: cached=0, next=1)
- Assert returns SeqNew, non-nil slot, nil error
- After CompleteSlotRequest(0, 1, true, []byte("reply")), validate seqID=2 returns SeqNew

**TestValidateSequence_Retry:**
- Set up slot: complete with seqID=5, cacheThis=true, reply=[]byte("cached-data")
- Validate seqID=5 -> SeqRetry, slot.CachedReply == "cached-data"

**TestValidateSequence_RetryUncached:**
- Set up slot: complete with seqID=5, cacheThis=false (no cached reply)
- Validate seqID=5 -> error with NFS4ERR_RETRY_UNCACHED_REP

**TestValidateSequence_Misordered:**
- Set up slot at seqID=5
- Validate seqID=3 (behind) -> error with NFS4ERR_SEQ_MISORDERED
- Validate seqID=7 (gap) -> error with NFS4ERR_SEQ_MISORDERED

**TestValidateSequence_BadSlot:**
- Slot table with 4 slots, validate slotID=4 -> NFS4ERR_BADSLOT
- Validate slotID=100 -> NFS4ERR_BADSLOT

**TestValidateSequence_SlotInUse:**
- Mark slot 0 in use, then validate expected next seqID -> NFS4ERR_SEQ_MISORDERED
- Mark slot 0 in use, then validate same seqID (retry while in-flight) -> NFS4ERR_DELAY

**TestValidateSequence_SeqIDWrap:**
- Set slot.SeqID = 0xFFFFFFFF via CompleteSlotRequest
- Validate seqID=0 -> SeqNew (uint32 overflow: 0xFFFFFFFF + 1 = 0, which IS valid in v4.1)
- This is the critical difference from v4.0 where seqid=0 is reserved

**TestCompleteSlotRequest:**
- Complete with cacheThis=true, verify CachedReply stored (copy, not reference)
- Complete with cacheThis=false, verify CachedReply is nil
- Complete with slotID out of range, verify no panic (silent return)

**TestSetTargetHighestSlotID:**
- Set target to value within range, verify GetTargetHighestSlotID returns it
- Set target to value >= maxSlots, verify clamped to maxSlots-1

**TestSlotTable_Concurrent:**
- Use sync.WaitGroup with 10 goroutines, each doing ValidateSequence + MarkSlotInUse + CompleteSlotRequest on different slot IDs
- Verify no panics, no data races (test should pass with -race flag)

Use `testing` package only. Use `types.NFS4ERR_*` constants for assertion. Check errors using type assertion to `*NFS4StateError` and comparing Status field.
  </action>
  <verify>
`go test -v -race ./internal/protocol/nfs/v4/state/ -run TestNewSlotTable` passes.
`go test -v -race ./internal/protocol/nfs/v4/state/ -run TestValidateSequence` passes.
`go test -v -race ./internal/protocol/nfs/v4/state/ -run TestSlotTable_Concurrent` passes.
`go test -race ./internal/protocol/nfs/v4/state/` passes (all existing + new tests).
  </verify>
  <done>
All slot table tests pass including: new request, retry, uncached retry, misordered, bad slot, in-use detection, uint32 seqid wraparound, complete with/without caching, dynamic target adjustment, and concurrent access. Tests pass with -race flag. Existing state package tests still pass.
  </done>
</task>

</tasks>

<verification>
```bash
# All tests pass (existing + new)
go test -race ./internal/protocol/nfs/v4/state/

# Package compiles cleanly
go build ./internal/protocol/nfs/v4/state/

# No static analysis issues
go vet ./internal/protocol/nfs/v4/state/
```
</verification>

<success_criteria>
- SlotTable with per-table mutex (not global StateManager.mu) provides EOS replay cache
- ValidateSequence implements RFC 8881 Section 2.10.6.1 with correct classification of new/retry/misordered/in-use
- CachedReply stores full XDR bytes (not just status code)
- SeqID wraparound works through 0 (v4.1 semantics, not v4.0 skip-zero)
- Dynamic slot adjustment via SetTargetHighestSlotID works correctly
- All tests pass with -race flag
- Existing state package tests unaffected
</success_criteria>

<output>
After completion, create `.planning/phases/17-slot-table-session-data-structures/17-01-SUMMARY.md`
</output>
