---
phase: 24-directory-delegations
plan: 03
type: execute
wave: 2
depends_on: [24-01]
files_modified:
  - internal/protocol/nfs/v4/handlers/create.go
  - internal/protocol/nfs/v4/handlers/remove.go
  - internal/protocol/nfs/v4/handlers/rename.go
  - internal/protocol/nfs/v4/handlers/link.go
  - internal/protocol/nfs/v4/handlers/open.go
  - internal/protocol/nfs/v4/handlers/setattr.go
  - internal/protocol/nfs/v4/state/delegation.go
  - internal/protocol/nfs/v4/state/dir_delegation_hooks_test.go
  - docs/NFS.md
autonomous: true
requirements: [DDELEG-02]

must_haves:
  truths:
    - "CREATE handler triggers NOTIFY4_ADD_ENTRY notification for parent directory"
    - "REMOVE handler triggers NOTIFY4_REMOVE_ENTRY notification for parent directory"
    - "RENAME handler triggers NOTIFY4_RENAME_ENTRY for both source and destination directories"
    - "LINK handler triggers NOTIFY4_ADD_ENTRY notification for target directory"
    - "OPEN with CREATE triggers NOTIFY4_ADD_ENTRY notification when new file is created"
    - "SETATTR on directory triggers NOTIFY4_CHANGE_DIR_ATTRS notification"
    - "Notifications only sent for subscribed types (filtered by notification mask)"
    - "Directory delegation recall triggered on conflicting modification from different client"
    - "Prometheus metrics shared with file delegations using type label"
  artifacts:
    - path: "internal/protocol/nfs/v4/handlers/create.go"
      provides: "NotifyDirChange hook after successful creation"
      contains: "NotifyDirChange"
    - path: "internal/protocol/nfs/v4/handlers/remove.go"
      provides: "NotifyDirChange hook after successful removal + recall for deleted directories"
      contains: "NotifyDirChange"
    - path: "internal/protocol/nfs/v4/handlers/rename.go"
      provides: "NotifyDirChange hooks for both source and destination directories"
      contains: "NotifyDirChange"
    - path: "internal/protocol/nfs/v4/handlers/link.go"
      provides: "NotifyDirChange hook after successful link"
      contains: "NotifyDirChange"
    - path: "internal/protocol/nfs/v4/state/dir_delegation_hooks_test.go"
      provides: "Integration tests verifying mutation hooks trigger correct notification types"
      min_lines: 150
    - path: "docs/NFS.md"
      provides: "Directory delegation documentation section"
      contains: "Directory Delegation"
  key_links:
    - from: "internal/protocol/nfs/v4/handlers/create.go"
      to: "internal/protocol/nfs/v4/state/dir_delegation.go"
      via: "h.StateManager.NotifyDirChange call"
      pattern: "NotifyDirChange"
    - from: "internal/protocol/nfs/v4/handlers/remove.go"
      to: "internal/protocol/nfs/v4/state/dir_delegation.go"
      via: "h.StateManager.NotifyDirChange + RecallDirDelegation for deleted dirs"
      pattern: "NotifyDirChange|RecallDirDelegation"
    - from: "internal/protocol/nfs/v4/handlers/rename.go"
      to: "internal/protocol/nfs/v4/state/dir_delegation.go"
      via: "Two NotifyDirChange calls (source + dest dir)"
      pattern: "NotifyDirChange"
---

<objective>
Add NotifyDirChange hooks to all directory-mutating NFSv4 handlers, implement conflict-based recall for directory delegations, add Prometheus metrics with type label, update NFS documentation, and write integration tests.

Purpose: Completes the directory delegation feature by wiring mutation handlers to the notification system. Without these hooks, clients holding directory delegations would never receive CB_NOTIFY callbacks about directory changes.

Output: Six handlers with notification hooks, conflict recall logic, Prometheus metrics, updated docs/NFS.md, integration tests.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-directory-delegations/24-CONTEXT.md
@.planning/phases/24-directory-delegations/24-RESEARCH.md
@.planning/phases/24-directory-delegations/24-01-SUMMARY.md
@internal/protocol/nfs/v4/handlers/create.go
@internal/protocol/nfs/v4/handlers/remove.go
@internal/protocol/nfs/v4/handlers/rename.go
@internal/protocol/nfs/v4/handlers/link.go
@internal/protocol/nfs/v4/handlers/open.go
@internal/protocol/nfs/v4/handlers/setattr.go
@internal/protocol/nfs/v4/state/delegation.go
@internal/protocol/nfs/v4/state/dir_delegation.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add NotifyDirChange hooks to mutation handlers and conflict recall</name>
  <files>
    internal/protocol/nfs/v4/handlers/create.go
    internal/protocol/nfs/v4/handlers/remove.go
    internal/protocol/nfs/v4/handlers/rename.go
    internal/protocol/nfs/v4/handlers/link.go
    internal/protocol/nfs/v4/handlers/open.go
    internal/protocol/nfs/v4/handlers/setattr.go
    internal/protocol/nfs/v4/state/delegation.go
  </files>
  <action>
**Hook Pattern:** After every successful directory mutation, add a non-blocking NotifyDirChange call. The pattern is identical for each handler -- add AFTER the success log line and BEFORE the response encoding. Guard with `if h.StateManager != nil` for safety.

**1. create.go** -- after successful CREATE (file or directory):
```go
if h.StateManager != nil {
    h.StateManager.NotifyDirChange(ctx.CurrentFH, state.DirNotification{
        Type:      types.NOTIFY4_ADD_ENTRY,
        EntryName: objName,
    })
}
```
Where `ctx.CurrentFH` is the parent directory handle and `objName` is the created entry name.

**2. remove.go** -- after successful REMOVE:
```go
if h.StateManager != nil {
    h.StateManager.NotifyDirChange(ctx.CurrentFH, state.DirNotification{
        Type:      types.NOTIFY4_REMOVE_ENTRY,
        EntryName: target,
    })
    // If the removed entry was a directory, revoke any directory delegations on it
    // Get the child handle (if available from the remove operation) and call
    // RecallDirDelegation with reason "directory_deleted" which triggers immediate revocation
}
```
For directory deletion recall: if the remove handler has access to the child file handle of the removed directory (from the lookup before remove), check if any directory delegations exist on that child handle via `sm.GetDelegationsForFile(childFH)` and revoke any directory delegations immediately.

**3. rename.go** -- after successful RENAME:
```go
if h.StateManager != nil {
    // Notify source directory (RENAME = single event per user decision)
    h.StateManager.NotifyDirChange(ctx.SavedFH, state.DirNotification{
        Type:      types.NOTIFY4_RENAME_ENTRY,
        EntryName: oldName,
        NewName:   newName,
    })
    // For cross-directory renames, also notify destination directory
    if !bytes.Equal(ctx.SavedFH, ctx.CurrentFH) {
        h.StateManager.NotifyDirChange(ctx.CurrentFH, state.DirNotification{
            Type:      types.NOTIFY4_ADD_ENTRY,
            EntryName: newName,
        })
    }
}
```
Per user decision: cross-directory renames notify both source and destination delegation holders. Source gets RENAME, destination gets ADD.

**4. link.go** -- after successful LINK:
```go
if h.StateManager != nil {
    h.StateManager.NotifyDirChange(ctx.CurrentFH, state.DirNotification{
        Type:      types.NOTIFY4_ADD_ENTRY,
        EntryName: newName,
    })
}
```

**5. open.go** -- after successful OPEN with CREATE (when a new file is actually created):
```go
// Only notify if OPEN4_CREATE was used and the file was actually created (not just opened)
if h.StateManager != nil && claim.OpenType == types.OPEN4_CREATE && fileWasCreated {
    h.StateManager.NotifyDirChange(ctx.CurrentFH, state.DirNotification{
        Type:      types.NOTIFY4_ADD_ENTRY,
        EntryName: fileName,
    })
}
```
Determine `fileWasCreated` from the handler's existing logic (check if create mode was used and the file didn't already exist, or if GUARDED4/EXCLUSIVE4 mode was used).

**6. setattr.go** -- after successful SETATTR on a directory (for CHANGE_DIR_ATTRS):
```go
if h.StateManager != nil {
    // Only for significant attribute changes: mode, uid, gid, size
    // Per discretion: ignore atime-only and ctime-only changes (too noisy)
    if isSignificantAttrChange(setAttrMask) {
        h.StateManager.NotifyDirChange(ctx.CurrentFH, state.DirNotification{
            Type:      types.NOTIFY4_CHANGE_DIR_ATTRS,
            EntryName: "", // directory itself, not an entry
        })
    }
}
```
Add a helper `isSignificantAttrChange(mask)` that returns true if mode, uid, gid, or size bits are set in the attribute mask.

**7. Conflict-based recall in delegation.go:**

Add a `ShouldRecallDirDelegation(dirFH []byte, clientID uint64) bool` method that checks if any directory delegation holders exist for the given directory handle from a DIFFERENT client. If so, send recall to those holders (CB_RECALL for the directory delegation) and proceed immediately (do not block, per discretion). This enables the pattern: "client B modifies directory -> server recalls delegation from client A -> client A gets CB_RECALL -> client B's operation proceeds immediately".

Call this from NotifyDirChange: if the notification comes from a different client than the delegation holder, recall the delegation. Use the non-blocking recall pattern (sendRecall starts a timer, revokes after lease timeout if not returned).

**8. Prometheus metrics:**

In delegation.go, update existing delegation metrics (if any) to include a `type` label with values "file" and "directory". If no delegation metrics exist yet, add:
- `nfsv4_delegations_granted_total` counter with labels: `type` (file/directory)
- `nfsv4_delegations_recalled_total` counter with labels: `type` (file/directory), `reason` (conflict/resource_pressure/admin/directory_deleted)
- `nfsv4_delegations_active` gauge with labels: `type` (file/directory)
- `nfsv4_dir_notifications_sent_total` counter

Follow the nil-safe receiver + registerOrReuse pattern from SessionMetrics/ConnectionMetrics/BackchannelMetrics.
  </action>
  <verify>
```bash
cd /Users/marmos91/Projects/dittofs && go build ./internal/protocol/nfs/v4/... && go vet ./internal/protocol/nfs/v4/... && go test -race -count=1 ./internal/protocol/nfs/v4/handlers/... -v 2>&1 | tail -5
```
  </verify>
  <done>All six mutation handlers (CREATE, REMOVE, RENAME, LINK, OPEN, SETATTR) have NotifyDirChange hooks, conflict recall triggers delegation recall from different clients, directory delegation metrics use shared counters with type label, existing tests still pass.</done>
</task>

<task type="auto">
  <name>Task 2: Integration tests for notification hooks and NFS documentation</name>
  <files>
    internal/protocol/nfs/v4/state/dir_delegation_hooks_test.go
    docs/NFS.md
  </files>
  <action>
**1. Create dir_delegation_hooks_test.go** in the state package:

These tests verify the full notification flow: grant delegation -> mutate directory -> verify notification batched/flushed. Use a mock or spy BackchannelSender to capture enqueued callbacks.

Tests:
- TestNotifyHook_Create: Grant dir deleg on directory, simulate CREATE by calling NotifyDirChange with ADD_ENTRY, verify notification appears in PendingNotifs
- TestNotifyHook_Remove: Grant dir deleg, call NotifyDirChange with REMOVE_ENTRY, verify notification batched
- TestNotifyHook_Rename_SameDir: Grant dir deleg, call NotifyDirChange with RENAME_ENTRY (oldName+newName), verify single notification
- TestNotifyHook_Rename_CrossDir: Grant dir deleg on both source and dest dirs, simulate cross-dir rename with NotifyDirChange on both, verify both get notifications
- TestNotifyHook_Link: Grant dir deleg, call NotifyDirChange with ADD_ENTRY for link target
- TestNotifyHook_AttrChange: Grant dir deleg with CHANGE_DIR_ATTRS in mask, call NotifyDirChange, verify notification
- TestNotifyHook_MaskFiltering: Grant dir deleg with only ADD_ENTRY in mask, call NotifyDirChange with REMOVE_ENTRY, verify NO notification (filtered by mask)
- TestNotifyHook_MultipleClients: Two clients hold dir deleg on same directory, mutation notifies both
- TestNotifyHook_ConflictRecall: Client A holds dir deleg, client B mutates -> verify recall sent to client A
- TestNotifyHook_BatchFlush_Integration: Grant dir deleg, send multiple notifications, wait for batch timer, verify single CB_NOTIFY with all notifications flushed via BackchannelSender
- TestNotifyHook_DirectoryDeleted: Grant dir deleg, remove the directory, verify immediate revocation (not just recall)

All tests with `-race` flag.

**2. Update docs/NFS.md** with a "Directory Delegations" section:

Add after the existing Delegations section. Include:
- What directory delegations provide (client caching of directory listings, notification of changes)
- How to request: GET_DIR_DELEGATION with notification bitmask
- Notification types supported: ADD_ENTRY, REMOVE_ENTRY, RENAME_ENTRY, CHANGE_DIR_ATTRS, CHANGE_CHILD_ATTRS
- How notifications are delivered: CB_NOTIFY over backchannel (batched, configurable window)
- Recall behavior: delegation recalled on conflicting client modification, revoked on directory deletion
- Configuration: MaxDelegations, DirDelegBatchWindowMs, DelegationsEnabled
- Limitations: ephemeral state (lost on restart), Linux NFS client support varies
  </action>
  <verify>
```bash
cd /Users/marmos91/Projects/dittofs && go test -race -count=1 ./internal/protocol/nfs/v4/state/... -run "NotifyHook" -v
```
  </verify>
  <done>Integration tests verify all notification hooks trigger correct notification types with mask filtering, conflict recall works across clients, batch flush sends single CB_NOTIFY, directory deletion causes immediate revocation. docs/NFS.md has comprehensive directory delegation section.</done>
</task>

</tasks>

<verification>
- `go build ./...` compiles without errors
- `go test -race ./internal/protocol/nfs/v4/...` passes (all existing + new tests)
- `go vet ./...` passes
- grep confirms NotifyDirChange present in create.go, remove.go, rename.go, link.go, open.go, setattr.go
- docs/NFS.md contains "Directory Delegation" section
- Prometheus metrics include `nfsv4_delegations_granted_total`, `nfsv4_delegations_recalled_total` with type label
</verification>

<success_criteria>
- All six mutation handlers trigger correct notification types
- Cross-directory renames notify both source and destination delegation holders
- Conflict recall triggers on modification by different client
- Directory deletion causes immediate revocation
- Notification mask filtering prevents unwanted notifications
- Multiple clients receive notifications simultaneously
- Prometheus metrics track delegation lifecycle with file/directory type label
- docs/NFS.md documents the feature completely
- All tests pass with race detection
</success_criteria>

<output>
After completion, create `.planning/phases/24-directory-delegations/24-03-SUMMARY.md`
</output>
