---
phase: 23-client-lifecycle-and-cleanup
plan: 03
type: execute
wave: 3
depends_on: ["23-01"]
files_modified:
  - internal/controlplane/api/handlers/grace.go
  - internal/controlplane/api/handlers/health.go
  - internal/controlplane/api/router.go
  - cmd/dfs/commands/status.go
  - cmd/dfsctl/commands/grace/grace.go
  - cmd/dfsctl/commands/grace/status.go
  - cmd/dfsctl/commands/grace/end.go
  - cmd/dfsctl/commands/root.go
  - pkg/apiclient/grace.go
autonomous: true
requirements:
  - LIFE-02

must_haves:
  truths:
    - "GET /api/v1/grace returns grace period status with active, remaining_seconds, client counts"
    - "POST /api/v1/grace/end force-ends the grace period (admin only)"
    - "Health endpoint includes grace period info when active"
    - "`dfs status` shows grace countdown when active: 'Grace period: 47s remaining (3/5 clients reclaimed)'"
    - "`dfsctl grace status` displays grace period information"
    - "`dfsctl grace end` force-ends the grace period"
  artifacts:
    - path: "internal/controlplane/api/handlers/grace.go"
      provides: "Grace period REST API handlers"
      contains: "GraceHandler"
    - path: "cmd/dfsctl/commands/grace/grace.go"
      provides: "Parent grace command for dfsctl"
      contains: "graceCmd"
    - path: "pkg/apiclient/grace.go"
      provides: "API client methods for grace period"
      contains: "GraceStatus"
  key_links:
    - from: "internal/controlplane/api/handlers/grace.go"
      to: "internal/protocol/nfs/v4/state/grace.go"
      via: "StateManager.GraceStatus() and StateManager.ForceEndGrace()"
      pattern: "GraceStatus|ForceEndGrace"
    - from: "cmd/dfsctl/commands/grace/status.go"
      to: "pkg/apiclient/grace.go"
      via: "API client GraceStatus method"
      pattern: "client\\.GraceStatus"
    - from: "cmd/dfs/commands/status.go"
      to: "health endpoint"
      via: "HTTP health response with grace fields"
      pattern: "grace_period"
---

<objective>
Implement grace period REST API (GET /api/v1/grace, POST /api/v1/grace/end), enrich health endpoint and `dfs status` with grace period information, and add `dfsctl grace status` and `dfsctl grace end` CLI commands.

Purpose: Provides operational visibility and control over the NFSv4 grace period. Admin users can monitor grace progress and force-end it for fast recovery in dev/test environments.
Output: Grace API handlers, enriched health/status outputs, and `dfsctl grace` CLI commands.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-client-lifecycle-and-cleanup/23-RESEARCH.md
@.planning/phases/23-client-lifecycle-and-cleanup/23-01-SUMMARY.md

# Key source files to read:
@internal/controlplane/api/handlers/health.go
@internal/controlplane/api/handlers/clients.go
@internal/controlplane/api/router.go
@cmd/dfs/commands/status.go
@cmd/dfsctl/commands/client/client.go
@cmd/dfsctl/commands/client/list.go
@cmd/dfsctl/commands/root.go
@pkg/apiclient/client.go
@pkg/apiclient/clients.go
@internal/cli/health/response.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Grace period REST API endpoints and health endpoint enrichment</name>
  <files>
    internal/controlplane/api/handlers/grace.go
    internal/controlplane/api/handlers/health.go
    internal/controlplane/api/router.go
    pkg/apiclient/grace.go
  </files>
  <action>
**Read first:** `handlers/health.go`, `handlers/clients.go` for handler patterns. Read `router.go` for route registration. Read `pkg/apiclient/client.go` and `pkg/apiclient/clients.go` for API client patterns. Read `internal/cli/health/response.go` for health response structure.

**1. Create grace.go API handler:**

Create `internal/controlplane/api/handlers/grace.go` following the health handler pattern:

```go
type GraceHandler struct {
    registry *runtime.Runtime
}
```

The `GraceHandler` needs access to the NFS adapter's StateManager to call `GraceStatus()` and `ForceEndGrace()`. Follow the pattern used in `clients.go` where the handler accesses the NFS state via `registry.NFSClientProvider()`. The `NFSClientProvider` returns an `any` type that should be type-asserted to access state methods. Check how `clients.go` does this and follow the same pattern.

Add `Status(w http.ResponseWriter, r *http.Request)` handler for `GET /api/v1/grace`:
- Get grace status from StateManager via the NFSClientProvider chain.
- Return JSON response with structure:
  ```json
  {
    "active": true,
    "remaining_seconds": 47.5,
    "total_duration": "1m30s",
    "expected_clients": 5,
    "reclaimed_clients": 3,
    "started_at": "2026-02-22T10:00:00Z",
    "message": "Grace period active: 47s remaining (3/5 clients reclaimed)"
  }
  ```
- If not active, return `{"active": false, "message": "No active grace period"}`.
- This is an unauthenticated endpoint (like health).

Add `ForceEnd(w http.ResponseWriter, r *http.Request)` handler for `POST /api/v1/grace/end`:
- This is an admin-only endpoint (locked decision: admin API to force-end).
- Call `ForceEndGrace()` on StateManager.
- Return 200 with `{"message": "Grace period ended"}` on success.
- If no active grace period, return 200 with `{"message": "No active grace period"}`.

**2. Register grace routes in router.go:**

Read `router.go` to find where routes are registered. Add:
- `GET /api/v1/grace` -> `graceHandler.Status` (unauthenticated, like health)
- `POST /api/v1/grace/end` -> `graceHandler.ForceEnd` (authenticated, admin only)

Follow the existing route group pattern. The grace status endpoint should be unauthenticated (similar to health probes) so K8s and monitoring tools can access it. The force-end endpoint requires admin auth.

**3. Enrich health endpoint in health.go:**

Modify the `Readiness` handler to include grace period info when active:
- After the existing readiness checks, get grace status.
- Add a `"grace_period"` field to the response data:
  ```json
  {
    "grace_period": {
      "active": true,
      "remaining_seconds": 47,
      "expected_clients": 5,
      "reclaimed_clients": 3
    }
  }
  ```
- During grace period, the server is still "healthy" but include the grace info for visibility (Claude's discretion: healthy during grace, since the server is functioning correctly -- it's just in a recovery phase).

**4. Create API client methods in pkg/apiclient/grace.go:**

Create `pkg/apiclient/grace.go` following the pattern in `clients.go`:

Add `GraceStatusResponse` struct matching the API response.
Add `GraceStatus() (*GraceStatusResponse, error)` method on `*Client`:
- `GET /api/v1/grace` (no auth required).

Add `ForceEndGrace() error` method on `*Client`:
- `POST /api/v1/grace/end` (requires auth token).
  </action>
  <verify>
Run `go build ./internal/controlplane/api/...` -- must compile.
Run `go build ./pkg/apiclient/...` -- must compile.
Run `go vet ./internal/controlplane/api/... ./pkg/apiclient/...` -- must pass clean.
  </verify>
  <done>
Grace REST API endpoints created and registered. GET /api/v1/grace returns grace status (unauthenticated). POST /api/v1/grace/end force-ends grace period (admin auth). Health readiness enriched with grace_period info. API client methods created for both endpoints.
  </done>
</task>

<task type="auto">
  <name>Task 2: `dfs status` grace countdown and `dfsctl grace` CLI commands</name>
  <files>
    cmd/dfs/commands/status.go
    cmd/dfsctl/commands/grace/grace.go
    cmd/dfsctl/commands/grace/status.go
    cmd/dfsctl/commands/grace/end.go
    cmd/dfsctl/commands/root.go
  </files>
  <action>
**Read first:** `cmd/dfs/commands/status.go` for status command pattern. Read `cmd/dfsctl/commands/client/client.go`, `cmd/dfsctl/commands/client/list.go`, `cmd/dfsctl/commands/client/evict.go` for the parent+subcommand pattern. Read `cmd/dfsctl/commands/root.go` for command registration.

**1. Enrich `dfs status` with grace countdown:**

Modify `cmd/dfs/commands/status.go`:
- Add grace period info to the `ServerStatus` struct:
  ```go
  GracePeriod *GracePeriodInfo `json:"grace_period,omitempty" yaml:"grace_period,omitempty"`
  ```
  where `GracePeriodInfo` has `Active bool`, `RemainingSeconds float64`, `ExpectedClients int`, `ReclaimedClients int`.

- In `runStatus()`, after the health check succeeds, make an additional HTTP request to `GET /api/v1/grace` to fetch grace period status. Parse the response and populate `status.GracePeriod`.

- In `printStatusTable()`, if `status.GracePeriod` is non-nil and active, add a line:
  ```
    Grace:      ‚è≥ 47s remaining (3/5 clients reclaimed)
  ```
  (locked decision: "Grace period: 47s remaining (3/5 clients reclaimed)" format -- adapt to fit the status table styling). Use the existing terminal color codes if appropriate (yellow for grace active).

  If grace period is not active, don't show it (keep output clean).

**2. Create `dfsctl grace` parent command:**

Create `cmd/dfsctl/commands/grace/grace.go`:
- Follow the `client/client.go` parent command pattern.
- Define `graceCmd` with `Use: "grace"`, `Short: "Manage NFSv4 grace period"`.
- Add `status` and `end` subcommands in `init()`.
- Export `Cmd()` function returning the parent command (or export the var directly per the existing pattern).

**3. Create `dfsctl grace status` command:**

Create `cmd/dfsctl/commands/grace/status.go`:
- Follow the `client/list.go` pattern.
- Create API client using `cmdutil.NewAuthClient()` (or unauthenticated client since grace status is public).
- Call `client.GraceStatus()`.
- Table output format:
  ```
  Grace Period Status
  ===================

    Active:     true
    Remaining:  47s
    Expected:   5 clients
    Reclaimed:  3 clients
    Started:    2026-02-22 10:00:00 UTC
  ```
- JSON/YAML output: direct marshal of the response.
- If not active, show: `No active grace period`

Support `-o json`, `-o yaml`, `-o table` flags following the `cmdutil` output pattern.

**4. Create `dfsctl grace end` command:**

Create `cmd/dfsctl/commands/grace/end.go`:
- Follow the `client/evict.go` pattern.
- Create authenticated API client.
- Call `client.ForceEndGrace()`.
- On success, print: `Grace period ended successfully`.
- If no active grace period, print: `No active grace period`.
- Add `--force` or similar flag is NOT needed -- the command itself is the force action (locked decision: admin API for fast recovery).

**5. Register grace command in root.go:**

In `cmd/dfsctl/commands/root.go`, add:
```go
import "github.com/marmos91/dittofs/cmd/dfsctl/commands/grace"
```
And register: `rootCmd.AddCommand(grace.Cmd())` (or follow the existing registration pattern).
  </action>
  <verify>
Run `go build ./cmd/dfs/...` -- must compile.
Run `go build ./cmd/dfsctl/...` -- must compile.
Run `go vet ./cmd/dfs/... ./cmd/dfsctl/...` -- must pass clean.
Run `./dfs status --help` -- help text shows.
Run `./dfsctl grace --help` -- shows status and end subcommands.
Run `./dfsctl grace status --help` -- shows output format flags.
Run `./dfsctl grace end --help` -- shows description.
  </verify>
  <done>
`dfs status` shows grace period countdown when active ("Grace period: 47s remaining (3/5 clients reclaimed)" format). `dfsctl grace status` displays grace period information with table/JSON/YAML output. `dfsctl grace end` force-ends grace period via admin API. Grace command registered in dfsctl root. All CLI binaries compile and show correct help text.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` -- entire project compiles
2. `go vet ./...` -- entire project passes vet
3. `go test ./internal/controlplane/api/...` -- API handler tests pass
4. `go test ./pkg/apiclient/...` -- API client tests pass
5. Both `dfs` and `dfsctl` binaries build successfully
6. `dfsctl grace status --help` and `dfsctl grace end --help` display correct usage
7. `dfs status --help` still works correctly
</verification>

<success_criteria>
- GET /api/v1/grace returns structured grace period status (unauthenticated)
- POST /api/v1/grace/end force-ends grace period (admin auth required)
- Health readiness endpoint includes grace_period field when active
- `dfs status` shows grace countdown in locked format: "47s remaining (3/5 clients reclaimed)"
- `dfsctl grace status` works with table/JSON/YAML output formats
- `dfsctl grace end` force-ends grace period and prints confirmation
- All existing tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/23-client-lifecycle-and-cleanup/23-03-SUMMARY.md`
</output>
