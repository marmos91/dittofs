---
phase: 18-exchange-id-and-client-registration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/protocol/nfs/v4/state/v41_client.go
  - internal/protocol/nfs/v4/state/v41_client_test.go
  - internal/protocol/nfs/v4/state/manager.go
  - internal/protocol/nfs/v4/handlers/exchange_id_handler.go
  - internal/protocol/nfs/v4/handlers/exchange_id_handler_test.go
  - internal/protocol/nfs/v4/handlers/handler.go
autonomous: true
requirements: [SESS-01, TRUNK-02]

must_haves:
  truths:
    - "EXCHANGE_ID from a new client returns a unique clientid and sequenceid=1"
    - "EXCHANGE_ID from the same owner+verifier returns the same clientid (idempotent)"
    - "EXCHANGE_ID from the same owner but different verifier replaces the client record (reboot)"
    - "Server reports consistent server_owner across all EXCHANGE_ID calls"
    - "SP4_MACH_CRED and SP4_SSV are rejected before any client record allocation"
    - "Client implementation ID is logged at INFO level"
  artifacts:
    - path: "internal/protocol/nfs/v4/state/v41_client.go"
      provides: "V41ClientRecord, ServerIdentity, ExchangeIDResult types; ExchangeID method on StateManager"
      min_lines: 100
    - path: "internal/protocol/nfs/v4/state/v41_client_test.go"
      provides: "Unit tests for ExchangeID multi-case algorithm"
      min_lines: 80
    - path: "internal/protocol/nfs/v4/handlers/exchange_id_handler.go"
      provides: "handleExchangeID V41OpHandler"
      min_lines: 50
    - path: "internal/protocol/nfs/v4/handlers/exchange_id_handler_test.go"
      provides: "Integration tests through dispatch path"
      min_lines: 40
  key_links:
    - from: "internal/protocol/nfs/v4/handlers/exchange_id_handler.go"
      to: "internal/protocol/nfs/v4/state/manager.go"
      via: "h.StateManager.ExchangeID()"
      pattern: "StateManager\\.ExchangeID"
    - from: "internal/protocol/nfs/v4/handlers/handler.go"
      to: "internal/protocol/nfs/v4/handlers/exchange_id_handler.go"
      via: "v41DispatchTable[OP_EXCHANGE_ID] = h.handleExchangeID"
      pattern: "OP_EXCHANGE_ID.*handleExchangeID"
    - from: "internal/protocol/nfs/v4/state/v41_client.go"
      to: "internal/protocol/nfs/v4/types/exchange_id.go"
      via: "ServerOwner4, NfsImplId4 types in ExchangeIDResult"
      pattern: "types\\.ServerOwner4|types\\.NfsImplId4"
---

<objective>
Implement the NFSv4.1 EXCHANGE_ID operation (op 42) per RFC 8881 Section 18.35 so v4.1 clients can register with the server and receive a client ID for session creation. This includes the V41ClientRecord struct, ServerIdentity singleton, ExchangeID algorithm on StateManager, and the NFS handler wired into the v4.1 dispatch table.

Purpose: EXCHANGE_ID is the first operation a v4.1 client sends. Without it, no session can be created (Phase 19). The server_owner response enables trunking detection (TRUNK-02).
Output: Working EXCHANGE_ID handler that registers v4.1 clients with proper multi-case algorithm, tests covering all RFC 8881 cases.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-exchange-id-and-client-registration/18-CONTEXT.md
@.planning/phases/18-exchange-id-and-client-registration/18-RESEARCH.md
@.planning/phases/17-slot-table-session-data-structures/17-02-SUMMARY.md

Key source files:
@internal/protocol/nfs/v4/state/manager.go (StateManager, generateClientID, bootEpoch pattern)
@internal/protocol/nfs/v4/state/client.go (v4.0 ClientRecord, LeaseState pattern)
@internal/protocol/nfs/v4/state/session.go (Session struct from Phase 17)
@internal/protocol/nfs/v4/types/exchange_id.go (ExchangeIdArgs, ExchangeIdRes -- complete XDR)
@internal/protocol/nfs/v4/types/session_common.go (ClientOwner4, ServerOwner4, NfsImplId4, StateProtect4A/R)
@internal/protocol/nfs/v4/types/constants.go (EXCHGID4_FLAG_*, SP4_* constants)
@internal/protocol/nfs/v4/handlers/handler.go (Handler struct, v41DispatchTable, NewHandler, V41OpHandler signature)
@internal/protocol/nfs/v4/handlers/compound.go (dispatchV41 -- how v4.1 handlers are called)
@internal/protocol/CLAUDE.md (v4.1 handler conventions, adding-handler guide)
</context>

<tasks>

<task type="auto">
  <name>Task 1: V41ClientRecord, ServerIdentity, and ExchangeID on StateManager</name>
  <files>
    internal/protocol/nfs/v4/state/v41_client.go
    internal/protocol/nfs/v4/state/v41_client_test.go
    internal/protocol/nfs/v4/state/manager.go
  </files>
  <action>
Create `internal/protocol/nfs/v4/state/v41_client.go` with:

1. **V41ClientRecord struct** (separate from v4.0 ClientRecord, per locked decision):
   - ClientID uint64 (server-assigned)
   - OwnerID []byte (co_ownerid from client_owner4, stored as bytes, byte-exact comparison)
   - Verifier [8]byte (co_verifier)
   - ImplDomain, ImplName string (from eia_client_impl_id)
   - ImplDate time.Time (from nfs_impl_id4.nii_date)
   - SequenceID uint32 (eir_sequenceid -- starts at 1 for new clients, used by CREATE_SESSION Phase 19)
   - Confirmed bool (becomes true after CREATE_SESSION -- always false in Phase 18)
   - ClientAddr string
   - CreatedAt, LastRenewal time.Time
   - Lease *LeaseState (shared lease behavior via pointer, same as v4.0 pattern)

2. **ServerIdentity struct** (immutable singleton created at StateManager init):
   - ServerOwner types.ServerOwner4 (major_id=hostname via os.Hostname() with "dittofs-unknown" fallback, minor_id=bootEpoch as 4-byte big-endian)
   - ServerScope []byte (same hostname bytes as major_id)
   - ImplID types.NfsImplId4 (Name="dittofs", Domain="dittofs.io", Date=build date via ldflags with fallback to zero time)
   - Build date variables: `var BuildDate string` set via `-ldflags "-X ...state.BuildDate=..."` at compile time

3. **ExchangeIDResult struct**:
   - ClientID uint64, SequenceID uint32, Flags uint32
   - ServerOwner types.ServerOwner4, ServerScope []byte, ServerImplId []types.NfsImplId4

4. **StateManager modifications** (in manager.go):
   - Add fields: `v41ClientsByID map[uint64]*V41ClientRecord`, `v41ClientsByOwner map[string]*V41ClientRecord`, `serverIdentity *ServerIdentity`
   - Initialize these maps and serverIdentity in `NewStateManager()`
   - Add `newServerIdentity()` function that creates the singleton (called once in constructor)

5. **ExchangeID method on StateManager** implementing RFC 8881 Section 18.35 multi-case algorithm:
   - Signature: `ExchangeID(ownerID []byte, verifier [8]byte, flags uint32, clientImplId []types.NfsImplId4, clientAddr string) (*ExchangeIDResult, error)`
   - Use `sm.mu.Lock()` (full write lock since it may create records)
   - Owner key: `string(ownerID)` for byte-exact map comparison (NOT string comparison)
   - **Case 1 (new client):** No existing record for owner -> generate new clientID via generateClientID(), create V41ClientRecord with SequenceID=1, Confirmed=false, store in both maps, return flags=EXCHGID4_FLAG_USE_NON_PNFS without CONFIRMED_R
   - **Case 2 (same owner+verifier):** Existing record with matching verifier -> update ImplDomain/ImplName/ClientAddr/LastRenewal, return existing clientID+sequenceID, set CONFIRMED_R flag only if record.Confirmed==true
   - **Case 3 (same owner, different verifier -- client reboot):** Delete old record from v41ClientsByID, create new V41ClientRecord with fresh clientID and SequenceID=1, Confirmed=false, return without CONFIRMED_R
   - **Case 4 (unconfirmed record exists -- supersede):** If existing record is unconfirmed, replace it (same as Case 3 flow)
   - Always set EXCHGID4_FLAG_USE_NON_PNFS (per locked decision)
   - Return ServerOwner, ServerScope, ServerImplId from the singleton

6. **Helper methods:**
   - `createV41Client(ownerID, verifier, clientImplId, clientAddr)` -> creates and stores V41ClientRecord
   - `purgeV41Client(record)` -> removes from both maps (cleanup for Case 3)
   - `ListV41Clients()` -> returns slice of V41ClientRecord copies (for REST API in Plan 02)
   - `ListV40Clients()` -> returns slice of ClientRecord copies (for unified REST API in Plan 02)
   - `EvictV41Client(clientID)` -> removes client record (for REST API eviction in Plan 02; add TODO comment about extending to sessions in Phase 19)
   - `ServerInfo()` -> returns the ServerIdentity (for REST API /health status in Plan 02)

Create `internal/protocol/nfs/v4/state/v41_client_test.go` with comprehensive tests:
- TestExchangeID_NewClient: New owner gets unique clientID, sequenceID=1, no CONFIRMED_R
- TestExchangeID_SameOwnerSameVerifier: Same call returns same clientID (idempotent)
- TestExchangeID_SameOwnerDifferentVerifier: Client reboot gets new clientID
- TestExchangeID_UnconfirmedReplace: Second EXCHANGE_ID from same owner with different verifier replaces unconfirmed
- TestExchangeID_MultipleClients: Different owners get different clientIDs
- TestExchangeID_ServerIdentityConsistent: server_owner identical across multiple calls
- TestExchangeID_ImplInfoUpdate: Same owner+verifier updates implementation info
- TestExchangeID_ConcurrentAccess: Parallel EXCHANGE_ID calls are thread-safe (use goroutines + race flag)
- TestListV41Clients: Returns copies of all registered v4.1 clients
- TestEvictV41Client: Removes client from both maps
  </action>
  <verify>
Run `go test -race -v ./internal/protocol/nfs/v4/state/... 2>&1 | tail -30` -- all new tests pass, no race conditions.
Run `go vet ./internal/protocol/nfs/v4/state/...` -- clean.
  </verify>
  <done>
StateManager.ExchangeID() implements the RFC 8881 multi-case algorithm. V41ClientRecord is separate from v4.0 ClientRecord. ServerIdentity returns consistent server_owner across calls. All unit tests pass with -race flag.
  </done>
</task>

<task type="auto">
  <name>Task 2: EXCHANGE_ID handler and dispatch table wiring</name>
  <files>
    internal/protocol/nfs/v4/handlers/exchange_id_handler.go
    internal/protocol/nfs/v4/handlers/exchange_id_handler_test.go
    internal/protocol/nfs/v4/handlers/handler.go
  </files>
  <action>
Create `internal/protocol/nfs/v4/handlers/exchange_id_handler.go` with `handleExchangeID` method on Handler:

1. **Signature**: `func (h *Handler) handleExchangeID(ctx *types.CompoundContext, v41ctx *types.V41RequestContext, reader io.Reader) *types.CompoundResult`

2. **Flow** (per research code example, following the handler pattern from setclientid.go):
   a. Decode args: `var args types.ExchangeIdArgs; args.Decode(reader)` -> return NFS4ERR_BADXDR on failure
   b. **Validate SP4 BEFORE any state allocation** (per locked decision): Check `args.StateProtect.How != types.SP4_NONE`. If SP4_SSV -> return NFS4ERR_ENCR_ALG_UNSUPP. If SP4_MACH_CRED -> return NFS4ERR_ENCR_ALG_UNSUPP (per research recommendation, same as Linux nfsd).
   c. **Log client implementation ID at INFO level** (per locked decision): If len(args.ClientImplId) > 0, log impl name, domain, and client address
   d. Call `h.StateManager.ExchangeID(args.ClientOwner.OwnerID, args.ClientOwner.Verifier, args.Flags, args.ClientImplId, ctx.ClientAddr)`
   e. On error, map state error to NFS4 status code and return error result
   f. Encode response: Build ExchangeIdRes{Status: NFS4_OK, ClientID, SequenceID, Flags, StateProtect: {How: SP4_NONE}, ServerOwner, ServerScope, ServerImplId}, encode to bytes.Buffer, return CompoundResult

3. **Error encoding helper**: Use the existing `encodeStatusOnly` pattern from other handlers (write just the status uint32) for error responses. If this helper doesn't exist, create a local one following the pattern in setclientid.go.

4. **Wire into dispatch table** (in handler.go NewHandler):
   - Replace the existing v41StubHandler for OP_EXCHANGE_ID with: `h.v41DispatchTable[types.OP_EXCHANGE_ID] = h.handleExchangeID`
   - Do NOT remove the v41StubHandler function itself -- other stubs still use it
   - Place the replacement AFTER the stub registrations block (or replace the specific line in-place)

Create `internal/protocol/nfs/v4/handlers/exchange_id_handler_test.go` with integration tests:
- TestHandleExchangeID_Success: Build a COMPOUND with minorversion=1 containing EXCHANGE_ID, verify NFS4_OK response with valid clientID
- TestHandleExchangeID_SP4Rejected: Send EXCHANGE_ID with SP4_SSV, verify NFS4ERR_ENCR_ALG_UNSUPP
- TestHandleExchangeID_BadXDR: Send truncated args, verify NFS4ERR_BADXDR
- TestHandleExchangeID_Idempotent: Two identical EXCHANGE_ID calls return same clientID
- Follow the existing compound_test.go pattern: create a Handler with test StateManager, build raw XDR compound bytes, call ProcessCompound, decode the response
  </action>
  <verify>
Run `go test -race -v ./internal/protocol/nfs/v4/handlers/... -run Exchange 2>&1 | tail -20` -- all new tests pass.
Run `go test -race ./internal/protocol/nfs/v4/handlers/...` -- all existing tests still pass (no regressions).
Run `go vet ./internal/protocol/nfs/v4/handlers/...` -- clean.
Run `go test -race ./... 2>&1 | tail -5` -- full test suite passes.
  </verify>
  <done>
handleExchangeID is wired into v41DispatchTable replacing the stub. SP4 validation happens before state allocation. Client implementation ID is logged at INFO level. All handler tests and existing compound tests pass. Full test suite green.
  </done>
</task>

</tasks>

<verification>
1. `go test -race ./internal/protocol/nfs/v4/state/...` -- all state tests pass
2. `go test -race ./internal/protocol/nfs/v4/handlers/...` -- all handler tests pass (including existing v4.0/v4.1 compound tests)
3. `go vet ./...` -- clean across entire codebase
4. `go build ./cmd/dfs/` -- server binary builds
5. Verify EXCHANGE_ID is no longer a stub: grep the v41DispatchTable for OP_EXCHANGE_ID and confirm it points to handleExchangeID
</verification>

<success_criteria>
- EXCHANGE_ID from new client returns unique clientid + sequenceid=1 + EXCHGID4_FLAG_USE_NON_PNFS
- Same owner+verifier returns same clientid (idempotent)
- Same owner + different verifier replaces record (client reboot)
- Server_owner is identical across all EXCHANGE_ID responses (TRUNK-02)
- SP4_MACH_CRED/SP4_SSV rejected with NFS4ERR_ENCR_ALG_UNSUPP before any allocation
- All tests pass with -race, no regressions in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/18-exchange-id-and-client-registration/18-01-SUMMARY.md`
</output>
