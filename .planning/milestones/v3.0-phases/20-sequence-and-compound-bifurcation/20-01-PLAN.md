---
phase: 20-sequence-and-compound-bifurcation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/protocol/nfs/v4/handlers/sequence_handler.go
  - internal/protocol/nfs/v4/handlers/sequence_handler_test.go
  - internal/protocol/nfs/v4/handlers/compound.go
  - internal/protocol/nfs/v4/handlers/handler.go
  - internal/protocol/nfs/v4/types/types.go
  - internal/protocol/nfs/v4/state/manager.go
  - internal/protocol/nfs/v4/state/v41_client.go
autonomous: true
requirements: [SESS-04, COEX-01, COEX-03]

must_haves:
  truths:
    - "v4.1 COMPOUND with SEQUENCE as first op validates session/slot/seqid and dispatches remaining ops"
    - "v4.1 COMPOUND without SEQUENCE as first op returns NFS4ERR_OP_NOT_IN_SESSION (unless exempt op)"
    - "Exempt ops (EXCHANGE_ID, CREATE_SESSION, DESTROY_SESSION, BIND_CONN_TO_SESSION) work without SEQUENCE"
    - "Duplicate v4.1 request (same slot+seqid) returns cached COMPOUND response without re-execution"
    - "Per-owner seqid validation is skipped for v4.1 operations (slot table provides replay protection)"
    - "SEQUENCE implicitly renews v4.1 client lease"
  artifacts:
    - path: "internal/protocol/nfs/v4/handlers/sequence_handler.go"
      provides: "SEQUENCE handler implementation with session lookup, slot validation, lease renewal, status flags"
      min_lines: 80
    - path: "internal/protocol/nfs/v4/handlers/compound.go"
      provides: "dispatchV41 with SEQUENCE gating, exempt op detection, replay cache at COMPOUND level"
      contains: "isSessionExemptOp"
    - path: "internal/protocol/nfs/v4/types/types.go"
      provides: "SkipOwnerSeqid flag on CompoundContext for v4.1 seqid bypass"
      contains: "SkipOwnerSeqid"
    - path: "internal/protocol/nfs/v4/state/manager.go"
      provides: "RenewV41Lease and GetStatusFlags methods on StateManager"
      contains: "RenewV41Lease"
    - path: "internal/protocol/nfs/v4/handlers/sequence_handler_test.go"
      provides: "Table-driven SEQUENCE validation edge case tests"
      min_lines: 100
  key_links:
    - from: "internal/protocol/nfs/v4/handlers/compound.go"
      to: "internal/protocol/nfs/v4/handlers/sequence_handler.go"
      via: "handleSequenceOp called as first op in dispatchV41"
      pattern: "handleSequenceOp"
    - from: "internal/protocol/nfs/v4/handlers/sequence_handler.go"
      to: "internal/protocol/nfs/v4/state/manager.go"
      via: "GetSession, RenewV41Lease, GetStatusFlags"
      pattern: "StateManager\\.GetSession|RenewV41Lease|GetStatusFlags"
    - from: "internal/protocol/nfs/v4/handlers/sequence_handler.go"
      to: "internal/protocol/nfs/v4/state/slot_table.go"
      via: "ValidateSequence and CompleteSlotRequest"
      pattern: "ValidateSequence|CompleteSlotRequest"
    - from: "internal/protocol/nfs/v4/handlers/compound.go"
      to: "internal/protocol/nfs/v4/types/types.go"
      via: "SkipOwnerSeqid set on CompoundContext in v4.1 dispatch path"
      pattern: "SkipOwnerSeqid"
---

<objective>
Implement the SEQUENCE handler and COMPOUND bifurcation for NFSv4.1, providing exactly-once semantics via slot table validation while maintaining full v4.0 compatibility.

Purpose: This is the critical integration point where all v4.1 session infrastructure (Phases 16-19) becomes functional. Every v4.1 COMPOUND is gated by SEQUENCE validation, cached responses enable replay detection, and per-owner seqid validation is bypassed for v4.1 operations.
Output: Working SEQUENCE handler, COMPOUND dispatcher with SEQUENCE enforcement, replay cache at COMPOUND level, seqid bypass for v4.1, lease renewal, status flags reporting.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-sequence-and-compound-bifurcation/20-CONTEXT.md
@.planning/phases/20-sequence-and-compound-bifurcation/20-RESEARCH.md
@.planning/phases/19-session-lifecycle/19-01-SUMMARY.md

@internal/protocol/nfs/v4/handlers/compound.go
@internal/protocol/nfs/v4/handlers/handler.go
@internal/protocol/nfs/v4/types/types.go
@internal/protocol/nfs/v4/types/sequence.go
@internal/protocol/nfs/v4/state/slot_table.go
@internal/protocol/nfs/v4/state/manager.go
@internal/protocol/nfs/v4/state/session.go
@internal/protocol/nfs/v4/state/v41_client.go
@internal/protocol/nfs/v4/state/openowner.go
@internal/protocol/CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: SEQUENCE handler, StateManager lease/status methods, and seqid bypass flag</name>
  <files>
    internal/protocol/nfs/v4/handlers/sequence_handler.go
    internal/protocol/nfs/v4/types/types.go
    internal/protocol/nfs/v4/state/manager.go
    internal/protocol/nfs/v4/state/v41_client.go
    internal/protocol/nfs/v4/handlers/handler.go
  </files>
  <action>
    **1. Add SkipOwnerSeqid to CompoundContext** (types/types.go):
    Add a `SkipOwnerSeqid bool` field to the `CompoundContext` struct. This flag is set by the v4.1 dispatch path and checked by StateManager methods that validate per-owner seqid (OpenFile, ConfirmOpen, CloseFile, OpenDowngrade, Lock, Unlock). When true, the seqid validation is skipped and the operation proceeds with seqid=0 semantics.

    **2. Add RenewV41Lease method** (state/manager.go):
    Add `RenewV41Lease(clientID uint64)` that acquires sm.mu.Lock(), looks up V41ClientRecord by clientID in v41ClientsByID, updates `LastRenewal` to time.Now(). This is called by SEQUENCE on every successful validation per RFC 8881 Section 8.1.3 (implicit lease renewal). Log at DEBUG level.

    **3. Add GetStatusFlags method** (state/manager.go or v41_client.go):
    Add `GetStatusFlags(session *Session) uint32` that computes the SEQ4_STATUS_* bitmask. For this phase, report:
    - SEQ4_STATUS_CB_PATH_DOWN: set if no backchannel bound (always true for now, Phase 22 will clear it)
    - SEQ4_STATUS_BACKCHANNEL_FAULT: same as above
    - SEQ4_STATUS_EXPIRED_ALL_STATE_REVOKED: check if client lease has expired (compare LastRenewal + leaseDuration to now)
    - SEQ4_STATUS_RECALLABLE_STATE_REVOKED: check delegByOther for any revoked delegations for this client
    - Other flags: 0 for now (devid notifications, etc.)
    Use the existing SEQ4_STATUS_* constants from types/constants.go.

    **4. Wire seqid bypass in StateManager** (state/manager.go):
    In the methods that call `ValidateSeqID` (OpenFile, ConfirmOpen, CloseFile, OpenDowngrade, Lock, Unlock), add a check: if the operation is flagged for v4.1 bypass, skip the seqid validation and proceed as if SeqIDOK. The approach: add a `skipSeqidValidation bool` parameter to these methods. However, to avoid breaking the existing API, use the simpler approach from CONTEXT: pass a sentinel seqid value (0 means "skip validation" for v4.1) OR add `SkipOwnerSeqid` as a context-threaded flag. The cleanest approach per CONTEXT locked decision "handler wrapper pattern for seqid bypass": In the v4.1 dispatch path in compound.go, set `compCtx.SkipOwnerSeqid = true` before calling v4.0 handlers. Then in StateManager methods that call ValidateSeqID, check a new parameter. Actually, since CompoundContext is not passed to StateManager, the simplest correct approach is: the v4.0 handlers called from v4.1 dispatch should pass `seqid=0` to StateManager, and StateManager should treat seqid=0 as "skip validation" (return SeqIDOK). This is safe because v4.0 seqids start at 1 and wrap from 0xFFFFFFFF to 1 (never 0). Add this check at the top of the ValidateSeqID methods: `if seqid == 0 { /* v4.1 bypass, skip validation */ }`. However, the v4.0 handlers extract seqid from XDR args, not from CompoundContext. So the simplest correct approach is: add `SkipOwnerSeqid bool` to CompoundContext, set it to true in dispatchV41's operation loop (after SEQUENCE succeeds), and check it in StateManager methods by passing it through. Actually the StateManager methods don't receive CompoundContext either. Let me be precise:

    The actual implementation: The v4.0 handlers (handleOpen, handleClose, handleLock, etc.) extract seqid from XDR args and pass it to StateManager methods. For v4.1 bypass, the simplest approach is to modify the v4.0 handlers to check `compCtx.SkipOwnerSeqid` and pass seqid=0 to StateManager when true, AND modify StateManager's ValidateSeqID callers to treat seqid=0 as skip. This is a 2-line change per handler + 1-line per StateManager method.

    Specifically in state/manager.go, at the top of each block that calls `owner.ValidateSeqID(seqid)` or `lockOwner.ValidateSeqID(seqid)`, add:
    ```go
    if seqid == 0 {
        // v4.1 bypass: slot table provides replay protection
    } else {
        validation := owner.ValidateSeqID(seqid)
        // ... existing switch
    }
    ```
    The seqid=0 convention is safe because v4.0 seqids never use 0 (they start at 1 and wrap from 0xFFFFFFFF to 1, skipping 0).

    **5. Create sequence_handler.go** (handlers/sequence_handler.go):
    Create `handleSequenceOp` method on Handler that:
    a) Decodes SequenceArgs from reader using the existing SequenceArgs.Decode()
    b) Looks up session via h.StateManager.GetSession(args.SessionID) -- returns NFS4ERR_BADSESSION if nil
    c) Calls session.ForeChannelSlots.ValidateSequence(args.SlotID, args.SequenceID)
    d) Handles each SequenceValidation case:
       - SeqRetry: log at INFO ("SEQUENCE replay hit"), return the slot's CachedReply directly (this is the full COMPOUND response bytes, not just SEQUENCE result)
       - SeqMisordered: log at DEBUG with expected vs actual seqid, return appropriate NFS4ERR_* from the error
       - SeqNew: build V41RequestContext, call h.StateManager.RenewV41Lease(session.ClientID), build SequenceRes with status flags
    e) Build SequenceRes with: Status=NFS4_OK, SessionID, SequenceID, SlotID, HighestSlotID from session.ForeChannelSlots.GetHighestSlotID(), TargetHighestSlotID from session.ForeChannelSlots.GetTargetHighestSlotID(), StatusFlags from GetStatusFlags()
    f) Return: (CompoundResult with SEQUENCE response, *V41RequestContext, *Session, error)

    Also create `isSessionExemptOp(opCode uint32) bool` helper that returns true for OP_EXCHANGE_ID, OP_CREATE_SESSION, OP_DESTROY_SESSION, OP_BIND_CONN_TO_SESSION per RFC 8881.

    **6. Replace SEQUENCE stub** (handlers/handler.go):
    Replace the SEQUENCE stub in v41DispatchTable with: `h.v41DispatchTable[types.OP_SEQUENCE] = h.handleSequence` where handleSequence is a thin V41OpHandler wrapper that delegates to handleSequenceOp. Note: SEQUENCE should NOT be dispatched as a regular v4.1 op -- it's handled specially in dispatchV41 before the op loop. So actually, REMOVE the OP_SEQUENCE entry from v41DispatchTable entirely (it will be handled by the special first-op check in dispatchV41). If it remains in the table, it would be dispatched as a normal op which is wrong.

    Actually, per RFC 8881, SEQUENCE appearing in any position OTHER than first should return NFS4ERR_SEQUENCE_POS. So keep OP_SEQUENCE in v41DispatchTable but make it return NFS4ERR_SEQUENCE_POS (it's only reached if SEQUENCE appears after position 0):
    ```go
    h.v41DispatchTable[types.OP_SEQUENCE] = func(ctx *types.CompoundContext, v41ctx *types.V41RequestContext, reader io.Reader) *types.CompoundResult {
        var args types.SequenceArgs
        if err := args.Decode(reader); err != nil {
            return &types.CompoundResult{Status: types.NFS4ERR_BADXDR, OpCode: types.OP_SEQUENCE, Data: encodeStatusOnly(types.NFS4ERR_BADXDR)}
        }
        return &types.CompoundResult{Status: types.NFS4ERR_SEQUENCE_POS, OpCode: types.OP_SEQUENCE, Data: encodeStatusOnly(types.NFS4ERR_SEQUENCE_POS)}
    }
    ```

    **Logging per CONTEXT decisions:**
    - Successful SEQUENCE: DEBUG level
    - Replay cache hits: INFO level
    - SEQUENCE errors: log with session ID, expected vs actual seqid, slot state at DEBUG level
  </action>
  <verify>
    `cd /Users/marmos91/Projects/dittofs && go build ./...` compiles without errors.
    `cd /Users/marmos91/Projects/dittofs && go vet ./internal/protocol/nfs/v4/...` passes.
  </verify>
  <done>
    SEQUENCE handler decodes args, validates session/slot/seqid, builds V41RequestContext, renews lease, computes status flags. SkipOwnerSeqid bypass mechanism is in place. isSessionExemptOp helper identifies SEQUENCE-exempt operations. All existing tests still pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: dispatchV41 SEQUENCE gating with replay cache and exempt op handling</name>
  <files>
    internal/protocol/nfs/v4/handlers/compound.go
    internal/protocol/nfs/v4/handlers/sequence_handler_test.go
  </files>
  <action>
    **1. Rewrite dispatchV41** (compound.go):
    Replace the current dispatchV41 with SEQUENCE-gated dispatch per RFC 8881. The new flow:

    a) Keep existing op count validation (MaxCompoundOps check).

    b) Read the first operation opcode from reader.

    c) Check if it's an exempt op via isSessionExemptOp(firstOpCode). If exempt:
       - Dispatch through v41DispatchTable with v41ctx=nil (existing pattern works)
       - Continue dispatching remaining ops (if any) through the existing v4.1 dispatch loop with v41ctx=nil
       - Return encoded response
       - Log "NFSv4.1 COMPOUND exempt op" at DEBUG with op name

    d) If not exempt, verify firstOpCode == OP_SEQUENCE. If not:
       - Return NFS4ERR_OP_NOT_IN_SESSION as COMPOUND status with zero results
       - Log at DEBUG

    e) If SEQUENCE: call handleSequenceOp(compCtx, reader). This returns:
       - On replay (SeqRetry with CachedReply): return CachedReply bytes directly, bypassing entire dispatch. Log at INFO.
       - On error (bad session, misordered, etc.): encode COMPOUND response with just SEQUENCE error result. Log at DEBUG.
       - On success (SeqNew): get v41ctx, session, slot back. Continue to step f.

    f) Set `compCtx.SkipOwnerSeqid = true` for v4.1 seqid bypass.

    g) Use defer to ensure slot release: `defer func() { ... CompleteSlotRequest ... }()`. The deferred function captures a `responseBytes *[]byte` pointer. If the real response is built, cache it. If panic/error, cache an empty response to release the slot.

    h) Log the full operation list at DEBUG: collect all op names as [SEQUENCE, PUTFH, OPEN, GETATTR] format.

    i) Dispatch remaining ops (numOps - 1) through the existing v4.1 dispatch loop (v41DispatchTable first, then opDispatchTable fallback). Pass v41ctx to v4.1 handlers. For v4.0 handlers called via fallback, compCtx.SkipOwnerSeqid is already true.

    j) After all ops or on first error, encode the COMPOUND response via encodeCompoundResponse(). The SEQUENCE result is the first entry in results.

    k) Cache the encoded response bytes in the slot via session.ForeChannelSlots.CompleteSlotRequest(v41ctx.SlotID, v41ctx.SequenceID, v41ctx.CacheThis, responseBytes).

    l) Return the response bytes.

    **2. Log bifurcation routing** (compound.go):
    In ProcessCompound, add DEBUG logging for which path each COMPOUND takes (v4.0 or v4.1) per CONTEXT decision.

    **3. Create comprehensive tests** (sequence_handler_test.go):
    Table-driven unit tests using real in-memory components (per CONTEXT: no mocks):

    Test cases for SEQUENCE validation:
    - Valid SEQUENCE (new request): returns NFS4_OK with correct SEQUENCE response fields
    - Bad session ID: returns NFS4ERR_BADSESSION
    - Bad slot ID (out of range): returns NFS4ERR_BADSLOT
    - Misordered seqid (gap): returns NFS4ERR_SEQ_MISORDERED
    - Replay (same seqid, cached reply exists): returns cached COMPOUND response byte-identical
    - Replay (same seqid, no cached reply -- uncached retry): returns NFS4ERR_RETRY_UNCACHED_REP
    - Slot in use (NFS4ERR_DELAY): returns NFS4ERR_DELAY immediately, no queuing
    - Bad XDR args: returns NFS4ERR_BADXDR

    Test cases for COMPOUND dispatch:
    - v4.1 COMPOUND with SEQUENCE + PUTFH + GETATTR: full dispatch succeeds
    - v4.1 COMPOUND with exempt op (EXCHANGE_ID) as first op: works without SEQUENCE
    - v4.1 COMPOUND with non-exempt, non-SEQUENCE first op: returns NFS4ERR_OP_NOT_IN_SESSION
    - v4.1 COMPOUND with SEQUENCE at position > 0: returns NFS4ERR_SEQUENCE_POS
    - Replay detection: send same slot+seqid twice, second returns cached response
    - Slot released on error: after a failing op, the slot is available for next request

    Test for seqid bypass:
    - v4.1 COMPOUND with SEQUENCE + OPEN: open-owner seqid validation is skipped (seqid=0 passed)

    Use the test setup pattern from existing compound_test.go and create_session_handler_test.go: create real StateManager, register v4.1 client via ExchangeID, create session via CreateSession, then test SEQUENCE.

    Helper: create `encodeSequenceArgs(sessionID types.SessionId4, slotID, seqID, highestSlotID uint32, cacheThis bool) []byte` for encoding test SEQUENCE args.
  </action>
  <verify>
    `cd /Users/marmos91/Projects/dittofs && go test -race -count=1 ./internal/protocol/nfs/v4/handlers/... -run "Sequence|Compound"` passes all new and existing tests.
    `cd /Users/marmos91/Projects/dittofs && go test -race -count=1 ./internal/protocol/nfs/v4/state/...` passes all existing state tests (no regressions from seqid bypass).
    `cd /Users/marmos91/Projects/dittofs && go test -race -count=1 ./...` passes (full test suite, no regressions).
  </verify>
  <done>
    dispatchV41 enforces SEQUENCE as first operation for non-exempt v4.1 COMPOUNDs. Replay cache returns byte-identical cached COMPOUND responses on duplicate slot+seqid. Exempt ops (EXCHANGE_ID, CREATE_SESSION, DESTROY_SESSION, BIND_CONN_TO_SESSION) work without SEQUENCE. Slot lifecycle management via defer ensures slots are always released. v4.0 dispatch path is unchanged. All tests pass with -race.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` -- entire project compiles
2. `go test -race -count=1 ./internal/protocol/nfs/v4/...` -- all v4 tests pass with race detection
3. `go test -race -count=1 ./...` -- full test suite passes (no regressions)
4. `go vet ./...` -- no static analysis issues
</verification>

<success_criteria>
- SEQUENCE validates session, slot, and seqid before any v4.1 operation executes
- Duplicate requests return cached COMPOUND response without re-execution
- Exempt operations (EXCHANGE_ID, CREATE_SESSION, etc.) work without SEQUENCE
- Per-owner seqid bypass works for v4.1 operations via seqid=0 convention
- SEQUENCE implicitly renews v4.1 client lease
- v4.0 dispatch path is completely unchanged
- All existing tests pass (zero regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/20-sequence-and-compound-bifurcation/20-01-SUMMARY.md`
</output>
