---
phase: 17-slot-table-session-data-structures
plan: 02
type: execute
wave: 2
depends_on: [17-01]
files_modified:
  - internal/protocol/nfs/v4/state/session.go
  - internal/protocol/nfs/v4/state/session_test.go
autonomous: true
requirements: [EOS-01, EOS-02, EOS-03]

must_haves:
  truths:
    - "Session record ties a session ID to a client, fore/back channel slot tables, and channel attributes"
    - "NewSession generates a crypto/rand session ID and creates slot tables from negotiated channel attributes"
    - "Session is ready for use by CREATE_SESSION (Phase 19) and SEQUENCE (Phase 20) handlers"
  artifacts:
    - path: "internal/protocol/nfs/v4/state/session.go"
      provides: "Session struct, NewSession constructor, session ID generation"
      exports: ["Session", "NewSession"]
    - path: "internal/protocol/nfs/v4/state/session_test.go"
      provides: "Unit tests for session creation and slot table allocation"
      min_lines: 80
  key_links:
    - from: "internal/protocol/nfs/v4/state/session.go"
      to: "internal/protocol/nfs/v4/state/slot_table.go"
      via: "NewSlotTable() in NewSession"
      pattern: "NewSlotTable"
    - from: "internal/protocol/nfs/v4/state/session.go"
      to: "internal/protocol/nfs/v4/types/session_common.go"
      via: "SessionId4, ChannelAttrs, CREATE_SESSION4_FLAG_CONN_BACK_CHAN"
      pattern: "types\\.SessionId4|types\\.ChannelAttrs|CREATE_SESSION4_FLAG"
---

<objective>
Implement the Session record struct and constructor that ties together a session ID, client ID, fore/back channel slot tables, and negotiated channel attributes.

Purpose: The Session is the container that holds slot tables and channel parameters for an NFSv4.1 session. Phase 19 (CREATE_SESSION) will instantiate sessions via NewSession, and Phase 20 (SEQUENCE) will look up sessions by ID to access their slot tables. This plan builds the Session struct and verifies it correctly creates and wires slot tables.

Output: `session.go` with Session struct and NewSession constructor; `session_test.go` with tests for session creation, slot table wiring, and back channel allocation.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-slot-table-session-data-structures/17-RESEARCH.md
@.planning/phases/17-slot-table-session-data-structures/17-01-SUMMARY.md
@internal/protocol/nfs/v4/state/slot_table.go (SlotTable from Plan 01)
@internal/protocol/nfs/v4/state/manager.go (StateManager pattern)
@internal/protocol/nfs/v4/types/session_common.go (SessionId4, ChannelAttrs)
@internal/protocol/nfs/v4/types/constants.go (CREATE_SESSION4_FLAG_CONN_BACK_CHAN)
@internal/protocol/CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Session struct and NewSession constructor</name>
  <files>internal/protocol/nfs/v4/state/session.go</files>
  <action>
Create `internal/protocol/nfs/v4/state/session.go` in package `state` with:

**Session struct:**
```go
type Session struct {
    // SessionID is the unique 16-byte session identifier (crypto/rand generated).
    SessionID types.SessionId4

    // ClientID is the server-assigned client ID that owns this session.
    ClientID uint64

    // ForeChannelSlots is the slot table for fore channel (client -> server).
    ForeChannelSlots *SlotTable

    // BackChannelSlots is the slot table for back channel (server -> client).
    // nil if no back channel was requested.
    BackChannelSlots *SlotTable

    // ForeChannelAttrs holds the negotiated fore channel attributes.
    ForeChannelAttrs types.ChannelAttrs

    // BackChannelAttrs holds the negotiated back channel attributes.
    BackChannelAttrs types.ChannelAttrs

    // Flags holds the CREATE_SESSION flags (e.g., CREATE_SESSION4_FLAG_CONN_BACK_CHAN).
    Flags uint32

    // CbProgram is the callback RPC program number from CREATE_SESSION.
    CbProgram uint32

    // CreatedAt is when this session was created.
    CreatedAt time.Time
}
```

**NewSession(clientID uint64, foreAttrs, backAttrs types.ChannelAttrs, flags, cbProgram uint32) (*Session, error):**
1. Generate a random 16-byte session ID using `crypto/rand.Read(sid[:])`. If crypto/rand fails, fallback to encoding clientID (8 bytes) + time.Now().UnixNano() (8 bytes) in big-endian, and log a warning.
2. Create the Session struct with all fields populated.
3. Create fore channel slot table: `ForeChannelSlots = NewSlotTable(foreAttrs.MaxRequests)` -- NewSlotTable already clamps to [MinSlots, DefaultMaxSlots].
4. If flags & types.CREATE_SESSION4_FLAG_CONN_BACK_CHAN != 0, create back channel slot table: `BackChannelSlots = NewSlotTable(backAttrs.MaxRequests)`. Otherwise BackChannelSlots = nil.
5. Set CreatedAt = time.Now()
6. Return the session and nil error.

NOTE: This constructor does NOT register the session with StateManager. That will be Phase 19's job (CREATE_SESSION handler calls NewSession then registers). This keeps the Session struct independent and testable.

Import: `crypto/rand`, `encoding/binary`, `time`, types package, logger package.
  </action>
  <verify>
`go build ./internal/protocol/nfs/v4/state/` compiles without errors.
`go vet ./internal/protocol/nfs/v4/state/` reports no issues.
  </verify>
  <done>
Session struct exists with all fields. NewSession generates crypto/rand session IDs, creates fore channel slot table from MaxRequests, conditionally creates back channel slot table based on CONN_BACK_CHAN flag. Compiles and passes vet.
  </done>
</task>

<task type="auto">
  <name>Task 2: Session unit tests</name>
  <files>internal/protocol/nfs/v4/state/session_test.go</files>
  <action>
Create `internal/protocol/nfs/v4/state/session_test.go` in package `state` with:

**TestNewSession_Basic:**
- Create session with clientID=42, foreAttrs.MaxRequests=16, backAttrs.MaxRequests=8, flags=CREATE_SESSION4_FLAG_CONN_BACK_CHAN, cbProgram=0x40000000
- Assert SessionID is not all zeros (crypto/rand generated)
- Assert ClientID == 42
- Assert ForeChannelSlots != nil and ForeChannelSlots.MaxSlots() == 16
- Assert BackChannelSlots != nil and BackChannelSlots.MaxSlots() == 8
- Assert Flags == CREATE_SESSION4_FLAG_CONN_BACK_CHAN
- Assert CbProgram == 0x40000000
- Assert CreatedAt is within last second

**TestNewSession_NoBackChannel:**
- Create session with flags=0 (no CONN_BACK_CHAN)
- Assert ForeChannelSlots != nil
- Assert BackChannelSlots == nil

**TestNewSession_UniqueSessionIDs:**
- Create 100 sessions, collect all session IDs into a map
- Assert all 100 are unique (no collisions)

**TestNewSession_ForeChannelSlotTableWorks:**
- Create session with foreAttrs.MaxRequests=4
- Use ForeChannelSlots.ValidateSequence(0, 1) -> SeqNew
- Call ForeChannelSlots.MarkSlotInUse(0)
- Call ForeChannelSlots.CompleteSlotRequest(0, 1, true, []byte("test-reply"))
- ValidateSequence(0, 1) -> SeqRetry with CachedReply == "test-reply"
- ValidateSequence(0, 2) -> SeqNew
- This proves the slot table is correctly wired and functional within the session

**TestNewSession_SlotCountClamping:**
- Create session with foreAttrs.MaxRequests=0 -> slot table has MinSlots (1)
- Create session with foreAttrs.MaxRequests=1000 -> slot table has DefaultMaxSlots (64)
  </action>
  <verify>
`go test -v -race ./internal/protocol/nfs/v4/state/ -run TestNewSession` passes.
`go test -race ./internal/protocol/nfs/v4/state/` passes (all existing + new tests).
  </verify>
  <done>
All session tests pass: basic creation with back channel, no-back-channel variant, unique session ID generation, slot table functionality through session, and slot count clamping. Tests pass with -race flag. All existing state package tests still pass.
  </done>
</task>

</tasks>

<verification>
```bash
# All tests pass (existing + new from both plans)
go test -race ./internal/protocol/nfs/v4/state/

# Package compiles cleanly
go build ./internal/protocol/nfs/v4/state/

# No static analysis issues
go vet ./internal/protocol/nfs/v4/state/
```
</verification>

<success_criteria>
- Session struct holds SessionID, ClientID, fore/back SlotTables, ChannelAttrs, Flags, CbProgram, CreatedAt
- NewSession generates unique 16-byte session IDs via crypto/rand
- Fore channel slot table always created from foreAttrs.MaxRequests
- Back channel slot table only created when CONN_BACK_CHAN flag is set
- Session's slot tables are fully functional (ValidateSequence + CompleteSlotRequest work through Session)
- All tests pass with -race flag
- Existing state package tests unaffected
</success_criteria>

<output>
After completion, create `.planning/phases/17-slot-table-session-data-structures/17-02-SUMMARY.md`
</output>
