---
phase: 19-session-lifecycle
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/protocol/nfs/v4/state/v41_client.go
  - internal/protocol/nfs/v4/state/manager.go
  - internal/protocol/nfs/v4/state/session.go
  - internal/protocol/nfs/v4/state/session_metrics.go
  - internal/protocol/nfs/v4/state/v41_client_test.go
  - internal/protocol/nfs/v4/state/session_test.go
  - internal/protocol/nfs/v4/handlers/handler.go
  - internal/protocol/nfs/v4/handlers/create_session_handler.go
  - internal/protocol/nfs/v4/handlers/create_session_handler_test.go
  - internal/protocol/nfs/v4/handlers/destroy_session_handler.go
  - internal/protocol/nfs/v4/handlers/destroy_session_handler_test.go
  - internal/protocol/nfs/v4/handlers/compound_test.go
  - internal/controlplane/api/handlers/clients.go
  - pkg/apiclient/clients.go
  - cmd/dfsctl/commands/client/client.go
  - cmd/dfsctl/commands/client/sessions_list.go
  - cmd/dfsctl/commands/client/sessions_destroy.go
  - pkg/controlplane/api/router.go
  - pkg/controlplane/models/adapter_settings.go
  - internal/protocol/CLAUDE.md
autonomous: true
requirements: [SESS-02, SESS-03]

must_haves:
  truths:
    - "CREATE_SESSION allocates a session with fore/back channel slot tables using negotiated attributes"
    - "Session ID returned to client is usable for subsequent SEQUENCE operations"
    - "DESTROY_SESSION tears down session, releases slot table memory, and unbinds connections"
    - "Channel attribute negotiation respects server-imposed limits (max slots, max request/response size)"
    - "CREATE_SESSION replay detection returns cached response for same sequence ID"
    - "Background session reaper destroys sessions for lease-expired clients"
    - "REST API lists sessions per client and force-destroys sessions"
    - "dfsctl client sessions list/destroy commands work"
  artifacts:
    - path: "internal/protocol/nfs/v4/state/manager.go"
      provides: "CreateSession, DestroySession, GetSession, ListSessionsForClient methods with session maps"
      contains: "sessionsByID"
    - path: "internal/protocol/nfs/v4/state/v41_client.go"
      provides: "CachedCreateSessionRes field, negotiateChannelAttrs, ChannelLimits"
      contains: "CachedCreateSessionRes"
    - path: "internal/protocol/nfs/v4/state/session_metrics.go"
      provides: "Prometheus session metrics (create/destroy counters, active gauge, duration histogram)"
      contains: "dittofs_nfs_sessions"
    - path: "internal/protocol/nfs/v4/handlers/create_session_handler.go"
      provides: "handleCreateSession handler wired into v41DispatchTable"
      contains: "handleCreateSession"
    - path: "internal/protocol/nfs/v4/handlers/destroy_session_handler.go"
      provides: "handleDestroySession handler wired into v41DispatchTable"
      contains: "handleDestroySession"
    - path: "internal/controlplane/api/handlers/clients.go"
      provides: "ListSessions and ForceDestroySession REST handlers"
      contains: "ListSessions"
    - path: "cmd/dfsctl/commands/client/sessions_list.go"
      provides: "dfsctl client sessions list command"
      contains: "sessionsListCmd"
    - path: "cmd/dfsctl/commands/client/sessions_destroy.go"
      provides: "dfsctl client sessions destroy command"
      contains: "sessionsDestroyCmd"
  key_links:
    - from: "internal/protocol/nfs/v4/handlers/create_session_handler.go"
      to: "internal/protocol/nfs/v4/state/manager.go"
      via: "h.StateManager.CreateSession()"
      pattern: "StateManager\\.CreateSession"
    - from: "internal/protocol/nfs/v4/handlers/destroy_session_handler.go"
      to: "internal/protocol/nfs/v4/state/manager.go"
      via: "h.StateManager.DestroySession()"
      pattern: "StateManager\\.DestroySession"
    - from: "internal/protocol/nfs/v4/handlers/handler.go"
      to: "internal/protocol/nfs/v4/handlers/create_session_handler.go"
      via: "v41DispatchTable[OP_CREATE_SESSION] = h.handleCreateSession"
      pattern: "OP_CREATE_SESSION.*handleCreateSession"
    - from: "internal/controlplane/api/handlers/clients.go"
      to: "internal/protocol/nfs/v4/state/manager.go"
      via: "sm.ListSessionsForClient() and sm.ForceDestroySession()"
      pattern: "ListSessionsForClient|ForceDestroySession"
    - from: "pkg/controlplane/api/router.go"
      to: "internal/controlplane/api/handlers/clients.go"
      via: "r.Route(\"/{id}/sessions\")"
      pattern: "sessions"
---

<objective>
Implement NFSv4.1 session lifecycle: CREATE_SESSION and DESTROY_SESSION handlers with full RFC 8881 compliance, session management on StateManager, channel attribute negotiation, CREATE_SESSION replay detection, background session reaper, Prometheus metrics, REST API endpoints, and dfsctl CLI commands.

Purpose: Enable NFSv4.1 clients to create and destroy sessions with negotiated channel attributes, which is the prerequisite for SEQUENCE validation (Phase 20) and all subsequent v4.1 operations.

Output: Working CREATE_SESSION/DESTROY_SESSION handlers, session state management, REST API session endpoints, dfsctl session commands, Prometheus session metrics, updated protocol CLAUDE.md.
</objective>

<execution_context>
@/Users/marmos91/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marmos91/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-session-lifecycle/19-CONTEXT.md
@.planning/phases/19-session-lifecycle/19-RESEARCH.md
@.planning/phases/17-slot-table-session-data-structures/17-01-SUMMARY.md
@.planning/phases/17-slot-table-session-data-structures/17-02-SUMMARY.md
@.planning/phases/18-exchange-id-and-client-registration/18-01-SUMMARY.md
@.planning/phases/18-exchange-id-and-client-registration/18-02-SUMMARY.md
@internal/protocol/nfs/v4/state/manager.go
@internal/protocol/nfs/v4/state/v41_client.go
@internal/protocol/nfs/v4/state/session.go
@internal/protocol/nfs/v4/state/slot_table.go
@internal/protocol/nfs/v4/handlers/handler.go
@internal/protocol/nfs/v4/handlers/exchange_id_handler.go
@internal/protocol/nfs/v4/types/create_session.go
@internal/protocol/nfs/v4/types/destroy_session.go
@internal/protocol/nfs/v4/types/constants.go
@internal/controlplane/api/handlers/clients.go
@pkg/apiclient/clients.go
@pkg/controlplane/api/router.go
@pkg/controlplane/models/adapter_settings.go
@cmd/dfsctl/commands/client/client.go
@cmd/dfsctl/commands/client/list.go
@cmd/dfsctl/commands/client/evict.go
@internal/protocol/CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: StateManager session methods, channel negotiation, metrics, and reaper</name>
  <files>
    internal/protocol/nfs/v4/state/v41_client.go
    internal/protocol/nfs/v4/state/manager.go
    internal/protocol/nfs/v4/state/session.go
    internal/protocol/nfs/v4/state/session_metrics.go
    internal/protocol/nfs/v4/state/v41_client_test.go
    internal/protocol/nfs/v4/state/session_test.go
  </files>
  <action>
    **1. Extend V41ClientRecord** (v41_client.go):
    - Add `CachedCreateSessionRes []byte` field for CREATE_SESSION replay detection (stores full XDR-encoded response bytes)
    - Add `negotiateChannelAttrs(requested types.ChannelAttrs, limits ChannelLimits, isBackChannel bool) types.ChannelAttrs` function:
      - `ChannelLimits` struct with `MaxSlots uint32` (64), `MaxRequestSize uint32` (1MB = 1048576), `MaxResponseSize uint32` (1MB), `MaxResponseSizeCached uint32` (64KB = 65536), `MinRequestSize uint32` (8KB = 8192), `MinResponseSize uint32` (8KB)
      - Clamp MaxRequests to [1, limits.MaxSlots]; for back channel use 8 as MaxSlots
      - Clamp MaxRequestSize to [MinRequestSize, limits.MaxRequestSize]; for back channel cap at 64KB
      - Clamp MaxResponseSize same pattern; for back channel cap at 64KB
      - Clamp MaxResponseSizeCached to min(requested, limits.MaxResponseSizeCached)
      - Set HeaderPadSize = 0 always (no RDMA per locked decision)
      - Set RdmaIrd = nil always (no RDMA)
      - MaxOperations = 0 (unlimited per locked decision)
    - Add `DefaultForeLimits()` and `DefaultBackLimits()` helpers returning appropriate ChannelLimits
    - Add `hasAcceptableCallbackSecurity(secParms []types.CallbackSecParms4) bool` that accepts AUTH_NONE (flavor 0) and AUTH_SYS (flavor 1), rejects RPCSEC_GSS (flavor 6). Return true if at least one acceptable flavor found, or if the slice is empty (no callback security = ok).

    **2. Extend StateManager** (manager.go):
    - Add `sessionsByID map[types.SessionId4]*Session` and `sessionsByClientID map[uint64][]*Session` to struct
    - Initialize both maps in `NewStateManager()`
    - Add `maxSessionsPerClient int` field (default 16) -- set in constructor
    - Add `CreateSession(clientID uint64, sequenceID uint32, flags uint32, foreAttrs, backAttrs types.ChannelAttrs, cbProgram uint32, cbSecParms []types.CallbackSecParms4) (*CreateSessionResult, []byte, error)`:
      - Case 1: `clientID` not found -> return `ErrStaleClientID` (use existing `types.NFS4ERR_STALE_CLIENTID` mapped via `NFS4StateError`)
      - Case 2: `sequenceID == record.SequenceID` (replay) -> return `nil, record.CachedCreateSessionRes, nil`. If `CachedCreateSessionRes` is nil, return `ErrSeqMisordered`
      - Case 3: `sequenceID == record.SequenceID + 1` (new request) -> create session, cache response, increment SequenceID
      - Case 4: any other sequenceID -> return `ErrSeqMisordered`
      - For Case 3: check per-client session limit (`len(sm.sessionsByClientID[clientID]) >= sm.maxSessionsPerClient`) -> return resource error (NFS4ERR_RESOURCE via a new `ErrTooManySessions`)
      - Negotiate channel attrs using `negotiateChannelAttrs()` for both fore and back channels
      - Call `NewSession(clientID, negotiatedFore, negotiatedBack, responseFlags, cbProgram)` (existing constructor)
      - Response flags: clear PERSIST flag, set CONN_BACK_CHAN if client requested it AND back channel slot table was allocated
      - Store session in `sessionsByID[session.SessionID]` and append to `sessionsByClientID[clientID]`
      - If `!record.Confirmed`: set `record.Confirmed = true`, create lease timer via `NewLeaseState(sm.leaseDuration, nil)` (use nil callback -- v4.1 uses reaper, not callback), set `record.LastRenewal = time.Now()`
      - Increment `record.SequenceID`
      - Record metrics: sessionCreatedTotal.Inc(), sessionActiveGauge.Inc()
      - Log at INFO level: "CREATE_SESSION: session created" with client_id, session_id hex, fore_slots
    - `CreateSessionResult` struct: `SessionID types.SessionId4, SequenceID uint32, Flags uint32, ForeChannelAttrs types.ChannelAttrs, BackChannelAttrs types.ChannelAttrs`
    - Add `CacheCreateSessionResponse(clientID uint64, responseBytes []byte)`:
      - Lookup v41ClientsByID, set record.CachedCreateSessionRes = responseBytes (copy the bytes)
      - Caller must hold no lock (this method acquires sm.mu.Lock)
    - Add `DestroySession(sessionID types.SessionId4) error`:
      - Lookup session in sessionsByID. Not found -> return error (NFS4ERR_BADSESSION via `ErrBadSession`)
      - Check if any fore channel slot has InUse=true -> return `ErrDelay` (NFS4ERR_DELAY) to let client retry
      - Remove from sessionsByID
      - Remove from sessionsByClientID[session.ClientID] (filter the slice)
      - Record metrics: sessionDestroyedTotal.WithLabelValues("client_request").Inc(), sessionActiveGauge.Dec(), sessionDurationHistogram.Observe(time.Since(session.CreatedAt).Seconds())
      - Log at INFO: "DESTROY_SESSION: session destroyed" with session_id, client_id, duration
    - Add `GetSession(sessionID types.SessionId4) *Session`:
      - RLock, lookup in sessionsByID, return pointer (or nil)
    - Add `ListSessionsForClient(clientID uint64) []*Session`:
      - RLock, return a copy of the session slice for the client
    - Add `ForceDestroySession(sessionID types.SessionId4) error`:
      - Same as DestroySession but skips the InUse check (for admin force-destroy)
      - Uses "admin_evict" reason label for metrics
    - Add `StartSessionReaper(ctx context.Context)`:
      - Goroutine with `time.NewTicker(30 * time.Second)` sweep
      - On each tick: acquire sm.mu.Lock, iterate v41ClientsByID:
        - If `record.Lease != nil && record.Lease.IsExpired()`: destroy all sessions for that client (remove from sessionsByID and sessionsByClientID), call `sm.purgeV41Client(record)`, record metrics with "lease_expired" reason, log at INFO
        - Also sweep unconfirmed clients: if `!record.Confirmed && time.Since(record.CreatedAt) > 2*sm.leaseDuration`: purge with log at INFO "Session reaper: unconfirmed client timed out"
    - **Update `purgeV41Client`** to also clean up sessions: before deleting client maps, iterate `sm.sessionsByClientID[record.ClientID]`, delete each from `sm.sessionsByID`, record destroy metrics with "admin_evict" reason, then `delete(sm.sessionsByClientID, record.ClientID)`. This fixes the existing EvictV41Client session cleanup gap.

    **3. Add NFS4StateError types** (v41_client.go or a separate errors section):
    - `ErrBadSession = &NFS4StateError{Code: types.NFS4ERR_BADSESSION, Message: "session not found"}`
    - `ErrDelay = &NFS4StateError{Code: types.NFS4ERR_DELAY, Message: "operation in progress, retry later"}`
    - `ErrTooManySessions = &NFS4StateError{Code: types.NFS4ERR_RESOURCE, Message: "per-client session limit exceeded"}`
    - Ensure `mapStateError()` in handlers/helpers.go already handles NFS4StateError -> nfsstat4 mapping (it does, using the Code field)

    **4. Add Session.HasInFlightRequests() bool** (session.go):
    - Check ForeChannelSlots: iterate slots 0..maxSlotID, return true if any slot.InUse is true
    - Add a method on SlotTable: `HasInFlightRequests() bool` that does this (thread-safe with its own mu)

    **5. Create session_metrics.go**:
    - Define Prometheus metrics using the existing nil-check pattern from lock/metrics.go:
      - `SessionMetrics` struct with: `CreatedTotal prometheus.Counter`, `DestroyedTotal *prometheus.CounterVec` (label: "reason" with values "client_request", "admin_evict", "lease_expired"), `ActiveGauge prometheus.Gauge`, `DurationHistogram prometheus.Histogram` (buckets: ExponentialBuckets(1, 2, 20) covering 1s to ~145 hours)
    - `NewSessionMetrics(reg prometheus.Registerer) *SessionMetrics` constructor that creates and registers all metrics with `dittofs_nfs_sessions_` prefix
    - `NilSessionMetrics()` returns nil-safe no-op (or the StateManager checks for nil before recording)
    - Add `sessionMetrics *SessionMetrics` field to StateManager, set in constructor or via `SetSessionMetrics()`
    - All metric calls in StateManager methods check `sm.sessionMetrics != nil` before calling

    **6. Unit Tests** (v41_client_test.go and session_test.go):
    - Table-driven tests for `CreateSession`:
      - Unknown client -> NFS4ERR_STALE_CLIENTID
      - Replay (same seqid) with cached response -> returns cached bytes
      - Replay (same seqid) with no cached response -> NFS4ERR_SEQ_MISORDERED
      - New request (seqid+1) -> creates session, returns result
      - Misordered seqid -> NFS4ERR_SEQ_MISORDERED
      - Per-client session limit exceeded -> NFS4ERR_RESOURCE
      - First CREATE_SESSION confirms client (Confirmed=true, Lease non-nil)
      - Channel attribute negotiation clamps values correctly
      - PERSIST flag cleared from response
      - CONN_BACK_CHAN flag set when client requests back channel
    - Tests for `DestroySession`:
      - Session not found -> NFS4ERR_BADSESSION
      - Session destroyed successfully -> removed from maps
      - Session with in-flight request -> NFS4ERR_DELAY
      - ForceDestroySession bypasses in-flight check
    - Tests for `negotiateChannelAttrs`:
      - Values clamped to server limits
      - Values below floor raised to floor
      - HeaderPadSize always 0
      - RdmaIrd always nil
      - Back channel uses smaller limits
    - Tests for `HasInFlightRequests` on SlotTable
    - Tests for `StartSessionReaper`:
      - Expired lease client cleaned up
      - Unconfirmed client timed out after 2x lease duration
      - Active lease client NOT cleaned up
    - Tests for `purgeV41Client` session cleanup
    - Test for `hasAcceptableCallbackSecurity`: AUTH_NONE accepted, AUTH_SYS accepted, RPCSEC_GSS only -> rejected, mixed -> accepted
    - Run all with `-race`
  </action>
  <verify>
    cd /Users/marmos91/Projects/dittofs && go test -race -count=1 ./internal/protocol/nfs/v4/state/... && go vet ./internal/protocol/nfs/v4/state/...
  </verify>
  <done>
    StateManager has CreateSession/DestroySession/GetSession/ListSessionsForClient/ForceDestroySession methods with full RFC 8881 Section 18.36 multi-case replay detection, channel attribute negotiation, per-client session limit (16), background reaper, Prometheus metrics, and EvictV41Client session cleanup. All tests pass with -race.
  </done>
</task>

<task type="auto">
  <name>Task 2: CREATE_SESSION and DESTROY_SESSION handlers with dispatch wiring</name>
  <files>
    internal/protocol/nfs/v4/handlers/create_session_handler.go
    internal/protocol/nfs/v4/handlers/create_session_handler_test.go
    internal/protocol/nfs/v4/handlers/destroy_session_handler.go
    internal/protocol/nfs/v4/handlers/destroy_session_handler_test.go
    internal/protocol/nfs/v4/handlers/handler.go
    internal/protocol/nfs/v4/handlers/compound_test.go
  </files>
  <action>
    **1. Create create_session_handler.go** following the exchange_id_handler.go pattern exactly:
    - `func (h *Handler) handleCreateSession(ctx *types.CompoundContext, _ *types.V41RequestContext, reader io.Reader) *types.CompoundResult`
    - Decode `types.CreateSessionArgs` from reader. On decode error -> NFS4ERR_BADXDR.
    - Validate callback security: call `hasAcceptableCallbackSecurity(args.CbSecParms)` (from state package, or define locally if needed). If no acceptable security -> NFS4ERR_ENCR_ALG_UNSUPP.
    - Call `h.StateManager.CreateSession(args.ClientID, args.SequenceID, args.Flags, args.ForeChannelAttrs, args.BackChannelAttrs, args.CbProgram, args.CbSecParms)`.
    - If `cachedReply` is non-nil (replay case) -> return CompoundResult with NFS4_OK status and cachedReply as Data.
    - If err != nil -> map error via `mapStateError(err)` and return status-only response.
    - On success: encode `types.CreateSessionRes` with NFS4_OK, result.SessionID, result.SequenceID, result.Flags, result.ForeChannelAttrs, result.BackChannelAttrs.
    - Cache the encoded response bytes: call `h.StateManager.CacheCreateSessionResponse(args.ClientID, buf.Bytes())`.
    - Log at INFO: "CREATE_SESSION: session created" with client_id (hex), session_id (hex), fore_slots, client addr.
    - Return CompoundResult with NFS4_OK and encoded bytes.

    **2. Create destroy_session_handler.go**:
    - `func (h *Handler) handleDestroySession(ctx *types.CompoundContext, _ *types.V41RequestContext, reader io.Reader) *types.CompoundResult`
    - Decode `types.DestroySessionArgs`. On error -> NFS4ERR_BADXDR.
    - Call `h.StateManager.DestroySession(args.SessionID)`.
    - If err -> map via `mapStateError(err)`, return status-only.
    - On success: encode status-only NFS4_OK response (DestroySessionRes only has status).
    - Log at INFO: "DESTROY_SESSION: session destroyed" with session_id (hex), client addr.

    **3. Wire into dispatch table** (handler.go):
    - Replace `v41StubHandler(types.OP_CREATE_SESSION, ...)` with `h.handleCreateSession`
    - Replace `v41StubHandler(types.OP_DESTROY_SESSION, ...)` with `h.handleDestroySession`

    **4. Update compound_test.go**:
    - Two existing tests may reference CREATE_SESSION as a stub op (updated in Phase 18 to use CREATE_SESSION as representative stub). Since CREATE_SESSION is now a real handler, update those tests to use a different stub op (SEQUENCE is still a stub, or DESTROY_CLIENTID). Add `encodeDestroyClientIdArgs` or use another available stub.
    - Verify the two tests that were changed in Phase 18 (they reference `encodeCreateSessionArgs`) and update them to use a different operation that is still a stub.

    **5. Handler unit tests** (create_session_handler_test.go):
    - Test successful CREATE_SESSION: register client via ExchangeID, call CREATE_SESSION with seqid=1, expect NFS4_OK with session ID and negotiated attrs
    - Test CREATE_SESSION replay: call same seqid twice, expect same response
    - Test CREATE_SESSION with bad XDR -> NFS4ERR_BADXDR
    - Test CREATE_SESSION with RPCSEC_GSS-only callback security -> NFS4ERR_ENCR_ALG_UNSUPP
    - Test CREATE_SESSION with unknown client -> NFS4ERR_STALE_CLIENTID
    - Test CREATE_SESSION + DESTROY_SESSION round trip: create then destroy, verify session gone
    - Test multi-op compound: EXCHANGE_ID + CREATE_SESSION in single compound
    - Follow the existing exchange_id_handler_test.go fixture pattern (NewHandlerFixture, encodeArgs helpers)

    **6. Handler unit tests** (destroy_session_handler_test.go):
    - Test DESTROY_SESSION on non-existent session -> NFS4ERR_BADSESSION
    - Test DESTROY_SESSION on valid session -> NFS4_OK
    - Test DESTROY_SESSION with bad XDR -> NFS4ERR_BADXDR
  </action>
  <verify>
    cd /Users/marmos91/Projects/dittofs && go test -race -count=1 ./internal/protocol/nfs/v4/handlers/... && go vet ./internal/protocol/nfs/v4/handlers/...
  </verify>
  <done>
    CREATE_SESSION and DESTROY_SESSION handlers are wired into v41DispatchTable, replacing stubs. Handlers decode XDR, validate callback security, delegate to StateManager, encode responses, cache replay bytes. All handler tests pass with -race. Compound tests updated to use a different stub op.
  </done>
</task>

<task type="auto">
  <name>Task 3: REST API session endpoints, dfsctl CLI, NFS config, and protocol docs</name>
  <files>
    internal/controlplane/api/handlers/clients.go
    pkg/apiclient/clients.go
    cmd/dfsctl/commands/client/client.go
    cmd/dfsctl/commands/client/sessions_list.go
    cmd/dfsctl/commands/client/sessions_destroy.go
    pkg/controlplane/api/router.go
    pkg/controlplane/models/adapter_settings.go
    internal/protocol/CLAUDE.md
  </files>
  <action>
    **1. Extend ClientHandler** (clients.go):
    - Add `SessionInfo` response struct: `SessionID string, ClientID string, CreatedAt time.Time, ForeSlots uint32, BackSlots uint32, Flags uint32, BackChannel bool`
    - Add `ListSessions(w, r)` handler for GET /clients/{id}/sessions:
      - Parse `{id}` as hex uint64 (same pattern as Evict)
      - Call `sm.ListSessionsForClient(clientID)` to get sessions
      - Map each *Session to SessionInfo (session_id as hex string of 16 bytes, fore_slots = ForeChannelAttrs.MaxRequests, back_slots = BackChannelAttrs.MaxRequests if BackChannelSlots != nil else 0, back_channel = BackChannelSlots != nil)
      - WriteJSONOK with the list
    - Add `ForceDestroySession(w, r)` handler for DELETE /clients/{id}/sessions/{sid}:
      - Parse `{sid}` as hex bytes -> types.SessionId4 (16 bytes)
      - Call `sm.ForceDestroySession(sessionID)`
      - On error -> NotFound(w, "session not found")
      - On success -> WriteNoContent(w)

    **2. Wire routes** (router.go):
    - Inside the existing `/clients` route block, add nested session routes:
      ```
      r.Route("/{id}/sessions", func(r chi.Router) {
          r.Get("/", clientHandler.ListSessions)
          r.Delete("/{sid}", clientHandler.ForceDestroySession)
      })
      ```
    - Update the router doc comment to mention session endpoints

    **3. Extend apiclient** (clients.go):
    - Add `SessionInfo` struct matching the API response
    - Add `ListSessions(ctx, clientID string) ([]SessionInfo, error)` method on Client: GET /api/v1/clients/{clientID}/sessions
    - Add `ForceDestroySession(ctx, clientID, sessionID string) error` method: DELETE /api/v1/clients/{clientID}/sessions/{sessionID}

    **4. Create dfsctl client sessions list** (sessions_list.go):
    - `sessionsListCmd` cobra command: `dfsctl client sessions list CLIENT_ID`
    - Takes client ID as positional arg (hex string)
    - Calls `client.ListSessions(ctx, clientID)`
    - Renders table with columns: SESSION_ID, FORE_SLOTS, BACK_SLOTS, BACK_CHANNEL, CREATED_AT
    - Supports -o json/yaml via existing cmdutil output helpers

    **5. Create dfsctl client sessions destroy** (sessions_destroy.go):
    - `sessionsDestroyCmd` cobra command: `dfsctl client sessions destroy CLIENT_ID SESSION_ID`
    - Takes client ID and session ID as positional args
    - Prompts for confirmation unless --force flag set (use existing prompt.Confirm pattern from evict.go)
    - Calls `client.ForceDestroySession(ctx, clientID, sessionID)`

    **6. Wire CLI commands** (client.go):
    - Create `sessionsCmd` parent command: Use "sessions", Short "Manage client sessions"
    - Add sessionsListCmd and sessionsDestroyCmd as subcommands
    - Add sessionsCmd as subcommand of Cmd (the parent client command)

    **7. Add V4 session config to NFSAdapterSettings** (adapter_settings.go):
    - Add fields to NFSAdapterSettings struct:
      - `V4MaxSessionSlots int \`gorm:"default:64" json:"v4_max_session_slots"\`` -- fore channel max slots
      - `V4MaxSessionsPerClient int \`gorm:"default:16" json:"v4_max_sessions_per_client"\``
    - These fields make the session limits configurable via the existing adapter settings API. Per locked decision, configurability is via NFS adapter config. The existing NFSAdapterSettings already serves this role (it has LeaseTime, MaxCompoundOps, etc.).
    - NOTE: The StateManager uses hardcoded defaults for now (64 slots, 16 sessions). Wiring these config values to StateManager is a future concern (settings watcher already exists for other fields like delegationsEnabled). Document this in the CLAUDE.md update.

    **8. Update protocol CLAUDE.md** (internal/protocol/CLAUDE.md):
    - Add "### NFSv4.1 Session Handler Conventions" subsection under the existing v4.1 section
    - Document: CREATE_SESSION/DESTROY_SESSION handler file naming pattern, CacheCreateSessionResponse pattern (handler caches response bytes after encoding, not StateManager), session maps on StateManager, reaper goroutine pattern, INFO-level logging for session events
    - Document: V4MaxSessionSlots and V4MaxSessionsPerClient config fields exist in NFSAdapterSettings but are not yet wired to StateManager (future: settings watcher)
  </action>
  <verify>
    cd /Users/marmos91/Projects/dittofs && go build ./cmd/dfs/... && go build ./cmd/dfsctl/... && go test -race -count=1 ./internal/controlplane/api/handlers/... && go test -race -count=1 ./pkg/apiclient/... && go vet ./...
  </verify>
  <done>
    REST API exposes GET /clients/{id}/sessions and DELETE /clients/{id}/sessions/{sid} for session listing and force-destroy. dfsctl client sessions list/destroy commands work. NFSAdapterSettings has V4MaxSessionSlots and V4MaxSessionsPerClient fields. Protocol CLAUDE.md updated with session handler conventions. All builds and tests pass.
  </done>
</task>

</tasks>

<verification>
1. `go test -race -count=1 ./internal/protocol/nfs/v4/state/...` -- all state layer tests pass
2. `go test -race -count=1 ./internal/protocol/nfs/v4/handlers/...` -- all handler tests pass including CREATE_SESSION and DESTROY_SESSION
3. `go test -race -count=1 ./internal/controlplane/api/handlers/...` -- API handler tests pass
4. `go build ./cmd/dfs/... && go build ./cmd/dfsctl/...` -- both binaries compile
5. `go vet ./...` -- no vet issues
6. `go test -race -count=1 ./...` -- full test suite passes (no regressions)
</verification>

<success_criteria>
- CREATE_SESSION with valid client ID and correct sequence ID returns NFS4_OK with session ID and negotiated channel attributes
- CREATE_SESSION replay (same sequence ID) returns cached response without creating a new session
- CREATE_SESSION with unknown client returns NFS4ERR_STALE_CLIENTID
- CREATE_SESSION with misordered sequence ID returns NFS4ERR_SEQ_MISORDERED
- CREATE_SESSION per-client limit (16) enforced with NFS4ERR_RESOURCE
- First CREATE_SESSION confirms the client (Confirmed=true, lease timer started)
- Channel attributes clamped to server limits (64 slots, 1MB request/response, no RDMA)
- DESTROY_SESSION removes session from all maps and releases slot table memory
- DESTROY_SESSION with in-flight requests returns NFS4ERR_DELAY
- Background reaper cleans up lease-expired client sessions and unconfirmed clients
- REST API GET /clients/{id}/sessions returns session list
- REST API DELETE /clients/{id}/sessions/{sid} force-destroys session
- dfsctl client sessions list renders sessions table
- dfsctl client sessions destroy prompts and destroys session
- Prometheus metrics: session create/destroy counters, active gauge, duration histogram
- EvictV41Client properly cleans up all sessions for the evicted client
</success_criteria>

<output>
After completion, create `.planning/phases/19-session-lifecycle/19-01-SUMMARY.md`
</output>
