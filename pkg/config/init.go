package config

import (
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// InitConfig creates a sample configuration file at the default location.
//
// This function:
//  1. Creates the config directory if it doesn't exist
//  2. Generates a config file with defaults and helpful comments
//  3. Returns an error if the file already exists (won't overwrite)
//
// Parameters:
//   - force: If true, overwrite existing config file
//
// Returns:
//   - string: Path to the created config file
//   - error: File creation error or file already exists
func InitConfig(force bool) (string, error) {
	configPath := GetDefaultConfigPath()
	configDir := filepath.Dir(configPath)

	// Create config directory if it doesn't exist
	if err := os.MkdirAll(configDir, 0755); err != nil {
		return "", fmt.Errorf("failed to create config directory: %w", err)
	}

	// Check if config already exists
	if !force && DefaultConfigExists() {
		return "", fmt.Errorf("config file already exists at %s (use --force to overwrite)", configPath)
	}

	// Generate sample config
	cfg := GetDefaultConfig()

	// Marshal to YAML with comments
	yamlData, err := generateYAMLWithComments(cfg)
	if err != nil {
		return "", fmt.Errorf("failed to generate YAML: %w", err)
	}

	// Write to file
	if err := os.WriteFile(configPath, []byte(yamlData), 0600); err != nil {
		return "", fmt.Errorf("failed to write config file: %w", err)
	}

	return configPath, nil
}

// yamlSafeCachePath converts a filesystem path to a YAML-safe representation.
// On Windows, backslashes in double-quoted YAML strings are interpreted as
// escape sequences (e.g. \U -> Unicode escape), causing parse errors.
func yamlSafeCachePath(p string) string {
	return strings.ReplaceAll(p, `\`, `/`)
}

// generateJWTSecret generates a cryptographically secure random JWT secret.
// Returns a 32-byte (256-bit) hex-encoded string (64 characters).
func generateJWTSecret() string {
	bytes := make([]byte, 32)
	if _, err := rand.Read(bytes); err != nil {
		// Fallback to a placeholder if crypto/rand fails (extremely unlikely)
		return "REPLACE-ME-WITH-SECURE-SECRET-MIN-32-CHARS"
	}
	return hex.EncodeToString(bytes)
}

// generateYAMLWithComments generates a YAML config file with helpful comments.
func generateYAMLWithComments(cfg *Config) (string, error) {
	yaml := `# DittoFS Configuration File
# This file is automatically generated with default values.
# Modify as needed for your environment.

# Logging configuration
logging:
  # Log level: DEBUG, INFO, WARN, ERROR
  level: "` + cfg.Logging.Level + `"
  # Log format: text, json
  format: "` + cfg.Logging.Format + `"
  # Log output: stdout, stderr, or file path
  output: "` + cfg.Logging.Output + `"

# OpenTelemetry distributed tracing configuration
telemetry:
  # Enable distributed tracing (default: false)
  enabled: ` + fmt.Sprintf("%t", cfg.Telemetry.Enabled) + `
  # OTLP collector endpoint (host:port)
  endpoint: "` + cfg.Telemetry.Endpoint + `"
  # Use insecure (non-TLS) connection (default: false)
  insecure: ` + fmt.Sprintf("%t", cfg.Telemetry.Insecure) + `
  # Trace sampling rate (0.0 to 1.0)
  sample_rate: ` + fmt.Sprintf("%.1f", cfg.Telemetry.SampleRate) + `
  profiling:
    enabled: false
    endpoint: "http://localhost:4040"

# Maximum time to wait for graceful shutdown
shutdown_timeout: ` + cfg.ShutdownTimeout.String() + `

# Control plane database configuration
# Stores users, groups, shares, and permissions
database:
  # Database type: sqlite (single-node) or postgres (HA)
  type: sqlite
  # SQLite configuration (used when type: sqlite)
  sqlite:
    # Path to SQLite database file
    # Default: $XDG_CONFIG_HOME/dittofs/controlplane.db
    path: ""

# Prometheus metrics configuration
metrics:
  # Enable Prometheus metrics endpoint
  enabled: false
  # Port for metrics HTTP server
  port: 9090

# Control plane API server configuration (always enabled)
controlplane:
  # Port for control plane HTTP server
  port: 8080
  # Request timeouts
  read_timeout: 10s
  write_timeout: 10s
  idle_timeout: 60s
  # JWT authentication configuration
  jwt:
    # JWT signing secret (minimum 32 characters)
    # IMPORTANT: This is auto-generated for development. For production:
    #   1. Generate a secure secret: openssl rand -hex 32
    #   2. Use environment variable: export DITTOFS_CONTROLPLANE_SECRET="your-secret"
    #   3. The environment variable takes precedence over this config value
    secret: "` + generateJWTSecret() + `"
    # Access token lifetime
    access_token_duration: 15m
    # Refresh token lifetime
    refresh_token_duration: 168h  # 7 days

# Cache configuration (WAL-backed, mandatory for crash recovery)
# All writes go through the WAL cache for durability
cache:
  # Directory path for the cache WAL file (required)
  path: "` + yamlSafeCachePath(cfg.Cache.Path) + `"
  # Maximum cache size (supports human-readable formats: "1GB", "512MB", "10Gi")
  size: 1Gi

# Initial admin user configuration
# This is used to bootstrap the first admin user
admin:
  # Admin username
  username: "` + cfg.Admin.Username + `"
  # Admin email (optional)
  email: ""
  # Admin password hash (bcrypt)
  # Set during 'dittofs init --admin' or leave empty for auto-generated password on first start
  # To generate manually: htpasswd -nbB "" "your-password" | cut -d: -f2
  password_hash: ""
`

	return yaml, nil
}

// InitConfigToPath creates a sample configuration file at the specified path.
//
// Similar to InitConfig but allows specifying a custom path.
//
// Parameters:
//   - path: Full path to the config file to create
//   - force: If true, overwrite existing config file
//
// Returns:
//   - error: File creation error or file already exists
func InitConfigToPath(path string, force bool) error {
	configDir := filepath.Dir(path)

	// Create config directory if it doesn't exist
	if err := os.MkdirAll(configDir, 0755); err != nil {
		return fmt.Errorf("failed to create config directory: %w", err)
	}

	// Check if config already exists
	if !force {
		if _, err := os.Stat(path); err == nil {
			return fmt.Errorf("config file already exists at %s (use --force to overwrite)", path)
		}
	}

	// Generate sample config with comments
	cfg := GetDefaultConfig()

	// Generate YAML with helpful comments
	yamlData, err := generateYAMLWithComments(cfg)
	if err != nil {
		return fmt.Errorf("failed to generate config: %w", err)
	}

	// Write to file
	if err := os.WriteFile(path, []byte(yamlData), 0600); err != nil {
		return fmt.Errorf("failed to write config file: %w", err)
	}

	return nil
}
