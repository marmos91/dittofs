package metadata

import (
	"crypto/sha256"
	"encoding/binary"
	"fmt"
	"strings"

	"github.com/google/uuid"
)

// FileHandle is an opaque identifier for a file or directory.
//
// File handles are generated by the repository and used by protocol handlers
// to reference files and directories. Format: "shareName:uuid"
//
// Maximum size: 64 bytes (NFS RFC 1813 compliant)
type FileHandle []byte

// EncodeFileHandle encodes a File into a FileHandle.
//
// Format: "<shareName>:<uuid>"
// Example: "/export:550e8400-e29b-41d4-a716-446655440000"
func EncodeFileHandle(file *File) (FileHandle, error) {
	encoded := file.ShareName + ":" + file.ID.String()
	if len(encoded) > 64 {
		return nil, fmt.Errorf("file handle too long: %d bytes (max 64)", len(encoded))
	}
	return FileHandle([]byte(encoded)), nil
}

// EncodeShareHandle encodes a share name and UUID into a FileHandle.
func EncodeShareHandle(shareName string, id uuid.UUID) (FileHandle, error) {
	encoded := shareName + ":" + id.String()
	if len(encoded) > 64 {
		return nil, fmt.Errorf("file handle too long: %d bytes (max 64)", len(encoded))
	}
	return FileHandle([]byte(encoded)), nil
}

// DecodeFileHandle decodes a FileHandle into its share name and UUID components.
func DecodeFileHandle(handle FileHandle) (shareName string, id uuid.UUID, err error) {
	handleStr := string(handle)

	idx := strings.Index(handleStr, ":")
	if idx == -1 {
		return "", uuid.Nil, fmt.Errorf("invalid file handle format: missing ':' separator")
	}

	shareName = handleStr[:idx]
	uuidStr := handleStr[idx+1:]

	if shareName == "" {
		return "", uuid.Nil, fmt.Errorf("invalid file handle: empty share name")
	}

	id, err = uuid.Parse(uuidStr)
	if err != nil {
		return "", uuid.Nil, fmt.Errorf("invalid file handle: malformed UUID: %w", err)
	}

	return shareName, id, nil
}

// GenerateNewHandle creates a new unique file handle with a fresh UUID.
func GenerateNewHandle(shareName string) (FileHandle, error) {
	return EncodeShareHandle(shareName, uuid.New())
}

// HandleToINode converts a FileHandle to a uint64 file ID (inode number).
//
// Uses SHA-256 hash of the entire handle, taking the first 8 bytes as a
// uint64 in big-endian format.
func HandleToINode(handle FileHandle) uint64 {
	if len(handle) == 0 {
		return 0
	}
	hash := sha256.Sum256(handle)
	return binary.BigEndian.Uint64(hash[:8])
}
