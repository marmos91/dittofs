// Package metadata provides the core metadata types and operations for DittoFS.
//
// This package contains:
//   - Core types: File, FileAttr, FileHandle, PayloadID
//   - Store interface: MetadataStore, Transaction, Transactor
//   - Business logic: RemoveFile, Move, Create, Lookup operations
//   - Permissions: Unix-style permission checking
//
// Store implementations are in subpackages:
//   - pkg/metadata/store/memory - In-memory store (for testing)
//   - pkg/metadata/store/badger - BadgerDB persistent store
//   - pkg/metadata/store/postgres - PostgreSQL distributed store
package metadata

import (
	"crypto/sha256"
	"encoding/binary"
	"fmt"
	"strings"
	"time"

	"github.com/google/uuid"
)

// ============================================================================
// File Handle
// ============================================================================

// FileHandle is an opaque identifier for a file or directory.
//
// File handles are generated by the repository and used by protocol handlers
// to reference files and directories. Format: "shareName:uuid"
//
// Maximum size: 64 bytes (NFS RFC 1813 compliant)
type FileHandle []byte

// EncodeFileHandle encodes a File into a FileHandle.
//
// Format: "<shareName>:<uuid>"
// Example: "/export:550e8400-e29b-41d4-a716-446655440000"
func EncodeFileHandle(file *File) (FileHandle, error) {
	encoded := file.ShareName + ":" + file.ID.String()
	if len(encoded) > 64 {
		return nil, fmt.Errorf("file handle too long: %d bytes (max 64)", len(encoded))
	}
	return FileHandle([]byte(encoded)), nil
}

// EncodeShareHandle encodes a share name and UUID into a FileHandle.
func EncodeShareHandle(shareName string, id uuid.UUID) (FileHandle, error) {
	encoded := shareName + ":" + id.String()
	if len(encoded) > 64 {
		return nil, fmt.Errorf("file handle too long: %d bytes (max 64)", len(encoded))
	}
	return FileHandle([]byte(encoded)), nil
}

// DecodeFileHandle decodes a FileHandle into its share name and UUID components.
func DecodeFileHandle(handle FileHandle) (shareName string, id uuid.UUID, err error) {
	handleStr := string(handle)

	idx := strings.Index(handleStr, ":")
	if idx == -1 {
		return "", uuid.Nil, fmt.Errorf("invalid file handle format: missing ':' separator")
	}

	shareName = handleStr[:idx]
	uuidStr := handleStr[idx+1:]

	if shareName == "" {
		return "", uuid.Nil, fmt.Errorf("invalid file handle: empty share name")
	}

	id, err = uuid.Parse(uuidStr)
	if err != nil {
		return "", uuid.Nil, fmt.Errorf("invalid file handle: malformed UUID: %w", err)
	}

	return shareName, id, nil
}

// GenerateNewHandle creates a new unique file handle with a fresh UUID.
func GenerateNewHandle(shareName string) (FileHandle, error) {
	return EncodeShareHandle(shareName, uuid.New())
}

// HandleToINode converts a FileHandle to a uint64 file ID (inode number).
//
// Uses SHA-256 hash of the entire handle, taking the first 8 bytes as a
// uint64 in big-endian format.
func HandleToINode(handle FileHandle) uint64 {
	if len(handle) == 0 {
		return 0
	}
	hash := sha256.Sum256(handle)
	return binary.BigEndian.Uint64(hash[:8])
}

// ============================================================================
// Share Types
// ============================================================================

// Share represents a filesystem path made available to clients with specific access rules.
//
// A share is the root point that clients connect to. It contains the name being
// shared and the access control rules that apply to all files within the share.
type Share struct {
	// Name is the unique identifier for the share
	// Format is implementation-specific (e.g., "/export/data", "projects")
	Name string

	// Options contains access control and authentication settings for the share
	Options ShareOptions
}

// ShareOptions defines access control and authentication settings for a share.
//
// These options apply to all files and directories within the share and are
// checked before any file-level permission checks.
type ShareOptions struct {
	// ReadOnly makes the share read-only
	// All write operations are denied regardless of file permissions
	ReadOnly bool

	// Async allows asynchronous write operations
	// When true, write operations may return success before data is fully persisted
	// When false, write operations are synchronous (data committed before success)
	Async bool

	// AllowedClients is a list of IP addresses or CIDR ranges allowed to access the share
	// Empty list means all clients are allowed (unless in DeniedClients)
	// Examples: ["192.168.1.0/24", "10.0.0.100"]
	AllowedClients []string

	// DeniedClients is a list of IP addresses or CIDR ranges explicitly denied access
	// Denial takes precedence over AllowedClients
	// Examples: ["192.168.1.50", "10.0.0.0/8"]
	DeniedClients []string

	// RequireAuth requires clients to authenticate
	// When true, anonymous access is not allowed
	RequireAuth bool

	// AllowedAuthMethods is a list of allowed authentication methods
	// Empty list means all methods are allowed
	// Examples: ["unix", "kerberos", "ntlm"]
	AllowedAuthMethods []string

	// IdentityMapping defines how client identities are mapped
	// Used for squashing (mapping users to anonymous) and other transformations
	IdentityMapping *IdentityMapping
}

// ShareSession represents an active client session on a share.
type ShareSession struct {
	// ShareName is the name of the mounted share
	ShareName string

	// ClientAddr is the network address of the client
	ClientAddr string

	// MountedAt is the time when the share was mounted
	MountedAt time.Time
}

// ============================================================================
// Server Configuration
// ============================================================================

// MetadataServerConfig contains metadata repository server-wide configuration settings.
//
// This includes settings that apply across all shares and operations at the
// metadata repository level. This is distinct from pkg/config.ServerConfig which
// contains application-level server settings.
//
// The structure is intentionally flexible to accommodate protocol-specific
// settings without coupling the repository to specific protocols.
type MetadataServerConfig struct {
	// CustomSettings allows protocol-specific configurations
	// Examples:
	//   - "nfs.mount.allowed_clients": []string{"192.168.1.0/24"}
	//   - "nfs.mount.denied_clients": []string{"192.168.1.50"}
	//   - "smb.signing_required": true
	//   - "ftp.passive_ports": "10000-10100"
	CustomSettings map[string]any
}

// ============================================================================
// Filesystem Capabilities and Statistics
// ============================================================================

// FilesystemCapabilities contains static filesystem capabilities and limits.
//
// This information is relatively stable (changes only on configuration updates)
// and describes what the filesystem supports and its limits.
type FilesystemCapabilities struct {
	// Transfer Sizes
	// These guide clients on optimal I/O sizes

	// MaxReadSize is the maximum size in bytes of a single read operation
	MaxReadSize uint32

	// PreferredReadSize is the preferred size in bytes for read operations
	// Optimal performance is typically achieved using this size
	PreferredReadSize uint32

	// MaxWriteSize is the maximum size in bytes of a single write operation
	MaxWriteSize uint32

	// PreferredWriteSize is the preferred size in bytes for write operations
	// Optimal performance is typically achieved using this size
	PreferredWriteSize uint32

	// Limits
	// These define hard limits on filesystem objects

	// MaxFileSize is the maximum file size in bytes supported
	// Example: 2^63-1 for practically unlimited
	MaxFileSize uint64

	// MaxFilenameLen is the maximum filename length in bytes
	// Typical value: 255 bytes (common Unix limit)
	MaxFilenameLen uint32

	// MaxPathLen is the maximum full path length in bytes
	// Typical value: 4096 bytes (common Unix limit)
	MaxPathLen uint32

	// MaxHardLinkCount is the maximum number of hard links to a file
	// Typical values: 32767 (ext4), 65000 (XFS)
	MaxHardLinkCount uint32

	// Features
	// These indicate what features the filesystem supports

	// SupportsHardLinks indicates whether hard links are supported
	SupportsHardLinks bool

	// SupportsSymlinks indicates whether symbolic links are supported
	SupportsSymlinks bool

	// CaseSensitive indicates whether filenames are case-sensitive
	// true: "File.txt" and "file.txt" are different (Unix)
	// false: "File.txt" and "file.txt" are the same (Windows)
	CaseSensitive bool

	// CasePreserving indicates whether filename case is preserved
	// true: Filename maintains its original case
	// false: Case information may be lost
	CasePreserving bool

	// ChownRestricted indicates if chown is restricted to the superuser
	// true: Only root/superuser can change file ownership (POSIX-compliant)
	// false: File owner can give away ownership
	// Most POSIX-compliant systems set this to true for security
	ChownRestricted bool

	// SupportsACLs indicates whether the filesystem supports Access Control Lists
	// beyond basic Unix permissions
	SupportsACLs bool

	// SupportsExtendedAttrs indicates whether extended attributes (xattrs) are supported
	SupportsExtendedAttrs bool

	// TruncatesLongNames indicates how the filesystem handles long filenames
	// true: Names longer than MaxFilenameLen are rejected with an error
	// false: Names are silently truncated to MaxFilenameLen
	TruncatesLongNames bool

	// Time Resolution
	// Indicates the granularity of timestamps

	// TimestampResolution is the resolution of file timestamps
	// Examples:
	//   - 1 nanosecond (high-resolution filesystems)
	//   - 1 microsecond (many modern filesystems)
	//   - 1 second (older filesystems)
	TimestampResolution time.Duration
}

// FilesystemStatistics contains dynamic filesystem usage statistics.
//
// This information changes frequently as files are created, modified, and deleted.
// It provides current state information about available space and capacity.
type FilesystemStatistics struct {
	// Space Statistics (in bytes)

	// TotalBytes is the total size of the filesystem in bytes
	TotalBytes uint64

	// UsedBytes is the amount of space currently in use
	UsedBytes uint64

	// AvailableBytes is the space available to the user
	// May be less than (TotalBytes - UsedBytes) if space is reserved for root
	// or if quotas are in effect
	AvailableBytes uint64

	// File Statistics (inodes)

	// TotalFiles is the total number of file slots (inodes) in the filesystem
	TotalFiles uint64

	// UsedFiles is the number of file slots currently in use
	UsedFiles uint64

	// AvailableFiles is the number of file slots available to the user
	// May be less than (TotalFiles - UsedFiles) if reserved for root
	AvailableFiles uint64

	// Stability

	// ValidFor indicates how long these statistics remain valid
	// 0 = statistics may change at any time (real-time)
	// >0 = statistics are stable for at least this duration
	ValidFor time.Duration
}
